(function() {
  const fn = function() {
    'use strict';
    (function(root) {
      function now() {
        return new Date();
      }
    
      const force = false;
    
      if (typeof root._bokeh_onload_callbacks === "undefined" || force === true) {
        root._bokeh_onload_callbacks = [];
        root._bokeh_is_loading = undefined;
      }
    
    
    const element = document.getElementById("bcb6210c-96b1-4820-9942-3a1f9e740213");
        if (element == null) {
          console.warn("Bokeh: autoload.js configured with elementid 'bcb6210c-96b1-4820-9942-3a1f9e740213' but no matching script tag was found.")
        }
      function run_callbacks() {
        try {
          root._bokeh_onload_callbacks.forEach(function(callback) {
            if (callback != null)
              callback();
          });
        } finally {
          delete root._bokeh_onload_callbacks
        }
        console.debug("Bokeh: all callbacks have finished");
      }
    
      function load_libs(css_urls, js_urls, callback) {
        if (css_urls == null) css_urls = [];
        if (js_urls == null) js_urls = [];
    
        root._bokeh_onload_callbacks.push(callback);
        if (root._bokeh_is_loading > 0) {
          console.debug("Bokeh: BokehJS is being loaded, scheduling callback at", now());
          return null;
        }
        if (js_urls == null || js_urls.length === 0) {
          run_callbacks();
          return null;
        }
        console.debug("Bokeh: BokehJS not loaded, scheduling load and callback at", now());
        root._bokeh_is_loading = css_urls.length + js_urls.length;
    
        function on_load() {
          root._bokeh_is_loading--;
          if (root._bokeh_is_loading === 0) {
            console.debug("Bokeh: all BokehJS libraries/stylesheets loaded");
            run_callbacks()
          }
        }
    
        function on_error(url) {
          console.error("failed to load " + url);
        }
    
        for (let i = 0; i < css_urls.length; i++) {
          const url = css_urls[i];
          const element = document.createElement("link");
          element.onload = on_load;
          element.onerror = on_error.bind(null, url);
          element.rel = "stylesheet";
          element.type = "text/css";
          element.href = url;
          console.debug("Bokeh: injecting link tag for BokehJS stylesheet: ", url);
          document.body.appendChild(element);
        }
    
        for (let i = 0; i < js_urls.length; i++) {
          const url = js_urls[i];
          const element = document.createElement('script');
          element.onload = on_load;
          element.onerror = on_error.bind(null, url);
          element.async = false;
          element.src = url;
          console.debug("Bokeh: injecting script tag for BokehJS library: ", url);
          document.head.appendChild(element);
        }
      };
    
      function inject_raw_css(css) {
        const element = document.createElement("style");
        element.appendChild(document.createTextNode(css));
        document.body.appendChild(element);
      }
    
      const js_urls = ["https://cdn.bokeh.org/bokeh/release/bokeh-3.4.1.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-gl-3.4.1.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-widgets-3.4.1.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-tables-3.4.1.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-mathjax-3.4.1.min.js"];
      const css_urls = [];
    
      const inline_js = [    function(Bokeh) {
          Bokeh.set_log_level("info");
        },
        function(Bokeh) {
          (function() {
            const fn = function() {
              Bokeh.safely(function() {
                (function(root) {
                  function embed_document(root) {
                  const docs_json = '{"3ce22bdc-8842-40a6-9d43-f3fc4ba45989":{"version":"3.4.1","title":"Bokeh Application","roots":[{"type":"object","name":"Column","id":"p1450","attributes":{"children":[{"type":"object","name":"Row","id":"p1445","attributes":{"children":[{"type":"object","name":"Spacer","id":"p1443","attributes":{"width":409}},{"type":"object","name":"Row","id":"p1403","attributes":{"children":[{"type":"object","name":"Div","id":"p1401","attributes":{"text":"&lt;p&gt;&lt;b&gt;Quantile setter mode&lt;/b&gt;&lt;/p&gt;"}},{"type":"object","name":"Spacer","id":"p1402","attributes":{"width":2}},{"type":"object","name":"Switch","id":"p1390","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:active",[{"type":"object","name":"CustomJS","id":"p1394","attributes":{"args":{"type":"map","entries":[["p_p",{"type":"object","name":"Figure","id":"p1287","attributes":{"x_range":{"type":"object","name":"Range1d","id":"p1351","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:start",[{"type":"object","name":"CustomJS","id":"p1393","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p1287"}],["p_c",{"type":"object","name":"Figure","id":"p1319","attributes":{"js_event_callbacks":{"type":"map","entries":[["reset",[{"type":"object","name":"CustomJS","id":"p1396","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p1287"}],["p_c",{"id":"p1319"}],["source_p",{"type":"object","name":"ColumnDataSource","id":"p1353","attributes":{"selected":{"type":"object","name":"Selection","id":"p1354","attributes":{"indices":[],"line_indices":[]}},"selection_policy":{"type":"object","name":"UnionRenderers","id":"p1355"},"data":{"type":"map","entries":[["x",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}],["y_p",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}]]}}}],["source_c",{"type":"object","name":"ColumnDataSource","id":"p1356","attributes":{"selected":{"type":"object","name":"Selection","id":"p1357","attributes":{"indices":[],"line_indices":[]}},"selection_policy":{"type":"object","name":"UnionRenderers","id":"p1358"},"data":{"type":"map","entries":[["x",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}],["y_c",{"type":"ndarray","array":{"type":"bytes","data":"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///vPym8/////+8/fdD/////7z/P3v/////vP97o/////+8/6+//////7z/Z9P/////vP0n4/////+8/rfr/////7z9W/P/////vP3z9/////+8/R/7/////7z/T/v/////vPzP//////+8/dP//////7z+h///////vP8D//////+8/1f//////7z/j///////vP+z//////+8/8///////7z/3///////vP/r//////+8//P//////7z/9///////vP/7//////+8/////////7z/////////vPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8="},"shape":[400],"dtype":"float64","order":"little"}]]}}}],["discrete",false],["n",400],["sliders",[{"type":"object","name":"Slider","id":"p1378","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p1392","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p1287"}],["p_c",{"id":"p1319"}],["source_p",{"id":"p1353"}],["source_c",{"id":"p1356"}],["discrete",false],["n",400],["sliders",[{"id":"p1378"},{"type":"object","name":"Slider","id":"p1380","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p1392"}]]]},"width":200,"title":"\\u03c3","format":{"type":"object","name":"CustomJSTickFormatter","id":"p1379","attributes":{"code":"return tick.toPrecision(4)"}},"start":0,"end":1,"value":0.2,"step":0.01}}]],["xBoxes",[{"type":"object","name":"TextInput","id":"p1385","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p1395","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p1287"}],["p_c",{"id":"p1319"}],["source_p",{"id":"p1353"}],["source_c",{"id":"p1356"}],["discrete",false],["n",400],["sliders",[{"id":"p1378"},{"id":"p1380"}]],["xBoxes",[{"id":"p1385"},{"type":"object","name":"TextInput","id":"p1386","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p1395"}]]]},"disabled":true,"width":80,"value":"0.3920"}}]],["pBoxes",[{"type":"object","name":"TextInput","id":"p1387","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p1395"}]]]},"disabled":true,"width":80,"value":"0.0250"}},{"type":"object","name":"TextInput","id":"p1388","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p1395"}]]]},"disabled":true,"width":80,"value":"0.9750"}}]],["quantileSetterSwitch",{"id":"p1390"}],["quantileSetterDiv",{"type":"object","name":"Div","id":"p1389"}],["triggerCallbacks",{"type":"object","name":"Switch","id":"p1391","attributes":{"active":true}}],["startBoxes",[{"type":"object","name":"TextInput","id":"p1381","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p1397","attributes":{"args":{"type":"map","entries":[["minValue","-Infinity"],["maxValue","Infinity"],["slider",{"id":"p1378"}]]},"code":"\\n\\nslider.start = Math.max(minValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"-0.5"}},{"type":"object","name":"TextInput","id":"p1382","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p1399","attributes":{"args":{"type":"map","entries":[["minValue","0"],["maxValue","Infinity"],["slider",{"id":"p1380"}]]},"code":"\\n\\nslider.start = Math.max(minValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"0"}}]],["endBoxes",[{"type":"object","name":"TextInput","id":"p1383","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p1398","attributes":{"args":{"type":"map","entries":[["minValue","-Infinity"],["maxValue","Infinity"],["slider",{"id":"p1378"}]]},"code":"\\n\\nslider.end = Math.min(maxValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"0.5"}},{"type":"object","name":"TextInput","id":"p1384","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p1400","attributes":{"args":{"type":"map","entries":[["minValue","0"],["maxValue","Infinity"],["slider",{"id":"p1380"}]]},"code":"\\n\\nslider.end = Math.min(maxValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"1"}}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nfunction erf(x) {\\n  \\n  var a = [1.00002368,\\n           0.37409196,\\n           0.09678418,\\n           -0.18628806,\\n           0.27886807,\\n           -1.13520398,\\n           1.48851587,\\n           -0.82215223,\\n           0.17087277];\\n\\n  var t = 1 / (1 + Math.abs(x)/2);\\n  var expSum = -Math.pow(x, 2) - 1.26551223;\\n\\n  for (var i = 0; i &lt; a.length; i++) {\\n      expSum += a[i] * Math.pow(t, i+1);\\n  }\\n\\n  var result = 1 - t * Math.exp(expSum);\\n\\n  if (x &lt; 0) return -result;\\n  return result;\\n}\\n\\n\\nfunction erfinv(x) {\\n  \\n  let p = (x + 1.0) / 2.0;\\n\\n  \\n  if (p == 0.0) return -Infinity;\\n  if (p == 1.0) return Infinity;\\n  if (p &gt; 1.0 || p &lt; 0.0) return undefined;\\n\\n  let split1 = 0.425;\\n  let split2 = 5.0;\\n  let const1 = 0.180625;\\n  let const2 = 1.6;\\n\\n  \\n  let a0 = 3.3871327179;\\n  let a1 = 5.0434271938e1;\\n  let a2 = 1.5929113202e2;\\n  let a3 = 5.9109374720e1;\\n  let b1 = 1.7895169469e1;\\n  let b2 = 7.8757757664e1;\\n  let b3 = 6.7187563600e1;\\n\\n  \\n  let c0 = 1.4234372777;\\n  let c1 = 2.7568153900;\\n  let c2 = 1.3067284816;\\n  let c3 = 1.7023821103e-1;\\n  let d1 = 7.3700164250e-1;\\n  let d2 = 1.2021132975e-1;\\n\\n  \\n  let e0 = 6.6579051150;\\n  let e1 = 3.0812263860;\\n  let e2 = 4.2868294337e-1;\\n  let e3 = 1.7337203997e-2;\\n  let f1 = 2.4197894225e-1;\\n  let f2 = 1.2258202635e-2;\\n\\n  let r;\\n  let res;\\n  let q = p - 0.5;\\n\\n  if (Math.abs(q) &lt;= split1) {\\n    r = const1 - q * q;\\n    res = q * (((a3 * r + a2) * r + a1) * r + a0) /\\n              (((b3 * r + b2) * r + b1) * r + 1.0);\\n  } else {\\n    r = q &lt; 0 ? p : 1.0 - p;\\n\\n    r = Math.sqrt(-Math.log(r));\\n\\n    if (r &lt;= split2) {\\n      r -= const2;\\n      res = (((c3 * r + c2) * r + c1) * r + c0) /\\n             ((d2 * r + d1) * r + 1.0);\\n    } else {\\n      r -= split2;\\n      res = (((e3 * r + e2) * r + e1) * r + e0) /\\n             ((f2 * r + f1) * r + 1.0);\\n    }\\n  \\n    if (q &lt; 0) {\\n      res = -res;\\n    }\\n  }\\n\\n  \\n  return 0.7071067811865475 * res;\\n\\n}\\n\\n\\nclass NormalDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Normal&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.locationParam = &#x27;\\u03bc&#x27;;\\n\\n    \\n    this.paramMin = [-Infinity, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds();\\n\\n    \\n    super.generateLocationParamIndex();\\n}\\n\\n  xMin(params) {\\n    return -Infinity;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x === -Infinity || x === Infinity) return 0.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    let expTerm = (Math.pow(x - mu, 2) / 2.0 / Math.pow(sigma, 2));\\n    return Math.exp(-expTerm) / sigma / Math.sqrt(2 * Math.PI);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x === -Infinity) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    return (1 + erf((x - mu) / sigma / Math.sqrt(2))) / 2;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return -Infinity;\\n    if (p === 1) return Infinity;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return mu + sqrt2 * sigma * erfinv(2 * p - 1);\\n  }\\n\\n  defaultXRange(params) {\\n    return this.ppf([0.001, 0.999], params);\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    let sqrt2 = 1.4142135623730951;\\n\\n    let sigmaCoeff1 = sqrt2 * erfinv(2 * p1 - 1);\\n    let sigmaCoeff2 = sqrt2 * erfinv(2 * p2 - 1);\\n\\n    let sigma = (x2 - x1) / (sigmaCoeff2 - sigmaCoeff1);\\n    let mu = x2 - sigmaCoeff2 * sigma;\\n\\n    return [[mu, sigma], true];\\n  }\\n}\\n\\n\\n\\nvar dist = new NormalDistribution();\\n\\n\\n\\nif (quantileSetterSwitch.active) {\\n  quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p);\\n}"}}]]]},"disabled":true,"width":80,"value":"-0.3920"}},{"id":"p1386"}]],["pBoxes",[{"id":"p1387"},{"id":"p1388"}]],["quantileSetterSwitch",{"id":"p1390"}],["quantileSetterDiv",{"id":"p1389"}],["triggerCallbacks",{"id":"p1391"}],["startBoxes",[{"id":"p1381"},{"id":"p1382"}]],["endBoxes",[{"id":"p1383"},{"id":"p1384"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nfunction erf(x) {\\n  \\n  var a = [1.00002368,\\n           0.37409196,\\n           0.09678418,\\n           -0.18628806,\\n           0.27886807,\\n           -1.13520398,\\n           1.48851587,\\n           -0.82215223,\\n           0.17087277];\\n\\n  var t = 1 / (1 + Math.abs(x)/2);\\n  var expSum = -Math.pow(x, 2) - 1.26551223;\\n\\n  for (var i = 0; i &lt; a.length; i++) {\\n      expSum += a[i] * Math.pow(t, i+1);\\n  }\\n\\n  var result = 1 - t * Math.exp(expSum);\\n\\n  if (x &lt; 0) return -result;\\n  return result;\\n}\\n\\n\\nfunction erfinv(x) {\\n  \\n  let p = (x + 1.0) / 2.0;\\n\\n  \\n  if (p == 0.0) return -Infinity;\\n  if (p == 1.0) return Infinity;\\n  if (p &gt; 1.0 || p &lt; 0.0) return undefined;\\n\\n  let split1 = 0.425;\\n  let split2 = 5.0;\\n  let const1 = 0.180625;\\n  let const2 = 1.6;\\n\\n  \\n  let a0 = 3.3871327179;\\n  let a1 = 5.0434271938e1;\\n  let a2 = 1.5929113202e2;\\n  let a3 = 5.9109374720e1;\\n  let b1 = 1.7895169469e1;\\n  let b2 = 7.8757757664e1;\\n  let b3 = 6.7187563600e1;\\n\\n  \\n  let c0 = 1.4234372777;\\n  let c1 = 2.7568153900;\\n  let c2 = 1.3067284816;\\n  let c3 = 1.7023821103e-1;\\n  let d1 = 7.3700164250e-1;\\n  let d2 = 1.2021132975e-1;\\n\\n  \\n  let e0 = 6.6579051150;\\n  let e1 = 3.0812263860;\\n  let e2 = 4.2868294337e-1;\\n  let e3 = 1.7337203997e-2;\\n  let f1 = 2.4197894225e-1;\\n  let f2 = 1.2258202635e-2;\\n\\n  let r;\\n  let res;\\n  let q = p - 0.5;\\n\\n  if (Math.abs(q) &lt;= split1) {\\n    r = const1 - q * q;\\n    res = q * (((a3 * r + a2) * r + a1) * r + a0) /\\n              (((b3 * r + b2) * r + b1) * r + 1.0);\\n  } else {\\n    r = q &lt; 0 ? p : 1.0 - p;\\n\\n    r = Math.sqrt(-Math.log(r));\\n\\n    if (r &lt;= split2) {\\n      r -= const2;\\n      res = (((c3 * r + c2) * r + c1) * r + c0) /\\n             ((d2 * r + d1) * r + 1.0);\\n    } else {\\n      r -= split2;\\n      res = (((e3 * r + e2) * r + e1) * r + e0) /\\n             ((f2 * r + f1) * r + 1.0);\\n    }\\n  \\n    if (q &lt; 0) {\\n      res = -res;\\n    }\\n  }\\n\\n  \\n  return 0.7071067811865475 * res;\\n\\n}\\n\\n\\nclass NormalDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Normal&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.locationParam = &#x27;\\u03bc&#x27;;\\n\\n    \\n    this.paramMin = [-Infinity, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds();\\n\\n    \\n    super.generateLocationParamIndex();\\n}\\n\\n  xMin(params) {\\n    return -Infinity;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x === -Infinity || x === Infinity) return 0.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    let expTerm = (Math.pow(x - mu, 2) / 2.0 / Math.pow(sigma, 2));\\n    return Math.exp(-expTerm) / sigma / Math.sqrt(2 * Math.PI);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x === -Infinity) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    return (1 + erf((x - mu) / sigma / Math.sqrt(2))) / 2;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return -Infinity;\\n    if (p === 1) return Infinity;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return mu + sqrt2 * sigma * erfinv(2 * p - 1);\\n  }\\n\\n  defaultXRange(params) {\\n    return this.ppf([0.001, 0.999], params);\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    let sqrt2 = 1.4142135623730951;\\n\\n    let sigmaCoeff1 = sqrt2 * erfinv(2 * p1 - 1);\\n    let sigmaCoeff2 = sqrt2 * erfinv(2 * p2 - 1);\\n\\n    let sigma = (x2 - x1) / (sigmaCoeff2 - sigmaCoeff1);\\n    let mu = x2 - sigmaCoeff2 * sigma;\\n\\n    return [[mu, sigma], true];\\n  }\\n}\\n\\n\\n\\nvar dist = new NormalDistribution();\\n\\n\\n\\nif (triggerCallbacks.active &amp;&amp; !cb_obj.disabled) {\\n\\tif (quantileSetterSwitch.active) {\\n\\t\\tquantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p);\\n\\t}\\n\\telse {\\n\\t\\tupdateData(source_p, source_c, p_p, sliders, discrete);\\n\\t\\tupdateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes);\\n\\t}\\n}"}}]]]},"width":200,"title":"\\u00b5","format":{"type":"object","name":"CustomJSTickFormatter","id":"p1377","attributes":{"code":"return tick.toPrecision(4)"}},"start":-0.5,"end":0.5,"value":0,"step":0.01}},{"id":"p1380"}]],["xBoxes",[{"id":"p1385"},{"id":"p1386"}]],["pBoxes",[{"id":"p1387"},{"id":"p1388"}]],["quantileSetterSwitch",{"id":"p1390"}],["quantileSetterDiv",{"id":"p1389"}],["triggerCallbacks",{"id":"p1391"}],["startBoxes",[{"id":"p1381"},{"id":"p1382"}]],["endBoxes",[{"id":"p1383"},{"id":"p1384"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nfunction erf(x) {\\n  \\n  var a = [1.00002368,\\n           0.37409196,\\n           0.09678418,\\n           -0.18628806,\\n           0.27886807,\\n           -1.13520398,\\n           1.48851587,\\n           -0.82215223,\\n           0.17087277];\\n\\n  var t = 1 / (1 + Math.abs(x)/2);\\n  var expSum = -Math.pow(x, 2) - 1.26551223;\\n\\n  for (var i = 0; i &lt; a.length; i++) {\\n      expSum += a[i] * Math.pow(t, i+1);\\n  }\\n\\n  var result = 1 - t * Math.exp(expSum);\\n\\n  if (x &lt; 0) return -result;\\n  return result;\\n}\\n\\n\\nfunction erfinv(x) {\\n  \\n  let p = (x + 1.0) / 2.0;\\n\\n  \\n  if (p == 0.0) return -Infinity;\\n  if (p == 1.0) return Infinity;\\n  if (p &gt; 1.0 || p &lt; 0.0) return undefined;\\n\\n  let split1 = 0.425;\\n  let split2 = 5.0;\\n  let const1 = 0.180625;\\n  let const2 = 1.6;\\n\\n  \\n  let a0 = 3.3871327179;\\n  let a1 = 5.0434271938e1;\\n  let a2 = 1.5929113202e2;\\n  let a3 = 5.9109374720e1;\\n  let b1 = 1.7895169469e1;\\n  let b2 = 7.8757757664e1;\\n  let b3 = 6.7187563600e1;\\n\\n  \\n  let c0 = 1.4234372777;\\n  let c1 = 2.7568153900;\\n  let c2 = 1.3067284816;\\n  let c3 = 1.7023821103e-1;\\n  let d1 = 7.3700164250e-1;\\n  let d2 = 1.2021132975e-1;\\n\\n  \\n  let e0 = 6.6579051150;\\n  let e1 = 3.0812263860;\\n  let e2 = 4.2868294337e-1;\\n  let e3 = 1.7337203997e-2;\\n  let f1 = 2.4197894225e-1;\\n  let f2 = 1.2258202635e-2;\\n\\n  let r;\\n  let res;\\n  let q = p - 0.5;\\n\\n  if (Math.abs(q) &lt;= split1) {\\n    r = const1 - q * q;\\n    res = q * (((a3 * r + a2) * r + a1) * r + a0) /\\n              (((b3 * r + b2) * r + b1) * r + 1.0);\\n  } else {\\n    r = q &lt; 0 ? p : 1.0 - p;\\n\\n    r = Math.sqrt(-Math.log(r));\\n\\n    if (r &lt;= split2) {\\n      r -= const2;\\n      res = (((c3 * r + c2) * r + c1) * r + c0) /\\n             ((d2 * r + d1) * r + 1.0);\\n    } else {\\n      r -= split2;\\n      res = (((e3 * r + e2) * r + e1) * r + e0) /\\n             ((f2 * r + f1) * r + 1.0);\\n    }\\n  \\n    if (q &lt; 0) {\\n      res = -res;\\n    }\\n  }\\n\\n  \\n  return 0.7071067811865475 * res;\\n\\n}\\n\\n\\nclass NormalDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Normal&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.locationParam = &#x27;\\u03bc&#x27;;\\n\\n    \\n    this.paramMin = [-Infinity, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds();\\n\\n    \\n    super.generateLocationParamIndex();\\n}\\n\\n  xMin(params) {\\n    return -Infinity;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x === -Infinity || x === Infinity) return 0.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    let expTerm = (Math.pow(x - mu, 2) / 2.0 / Math.pow(sigma, 2));\\n    return Math.exp(-expTerm) / sigma / Math.sqrt(2 * Math.PI);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x === -Infinity) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    return (1 + erf((x - mu) / sigma / Math.sqrt(2))) / 2;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return -Infinity;\\n    if (p === 1) return Infinity;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return mu + sqrt2 * sigma * erfinv(2 * p - 1);\\n  }\\n\\n  defaultXRange(params) {\\n    return this.ppf([0.001, 0.999], params);\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    let sqrt2 = 1.4142135623730951;\\n\\n    let sigmaCoeff1 = sqrt2 * erfinv(2 * p1 - 1);\\n    let sigmaCoeff2 = sqrt2 * erfinv(2 * p2 - 1);\\n\\n    let sigma = (x2 - x1) / (sigmaCoeff2 - sigmaCoeff1);\\n    let mu = x2 - sigmaCoeff2 * sigma;\\n\\n    return [[mu, sigma], true];\\n  }\\n}\\n\\n\\n\\nvar dist = new NormalDistribution();\\n\\n\\n\\nlet params = paramsFromSliders(sliders); \\n\\n\\nlet [x1, x2] = dist.defaultXRange(params);\\n\\n\\ntriggerCallbacks.active = false;\\n\\n\\np_p.x_range.start = x1;\\np_p.x_range.end = x2;\\n\\nupdateData(source_p, source_c, p_p, sliders, discrete);\\n\\n\\nsetYRanges(p_p, p_c, source_p);  \\n\\ntriggerCallbacks.active = true;\\n"}}]]]},"x_range":{"id":"p1351"},"y_range":{"type":"object","name":"Range1d","id":"p1352"},"x_scale":{"type":"object","name":"LinearScale","id":"p1329"},"y_scale":{"type":"object","name":"LinearScale","id":"p1330"},"title":{"type":"object","name":"Title","id":"p1322","attributes":{"text":" "}},"renderers":[{"type":"object","name":"GlyphRenderer","id":"p1365","attributes":{"data_source":{"id":"p1356"},"view":{"type":"object","name":"CDSView","id":"p1366","attributes":{"filter":{"type":"object","name":"AllIndices","id":"p1367"}}},"glyph":{"type":"object","name":"Line","id":"p1362","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_width":2}},"nonselection_glyph":{"type":"object","name":"Line","id":"p1363","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_alpha":0.1,"line_width":2}},"muted_glyph":{"type":"object","name":"Line","id":"p1364","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_alpha":0.2,"line_width":2}}}}],"toolbar":{"type":"object","name":"Toolbar","id":"p1328","attributes":{"tools":[{"type":"object","name":"PanTool","id":"p1341"},{"type":"object","name":"BoxZoomTool","id":"p1342","attributes":{"overlay":{"type":"object","name":"BoxAnnotation","id":"p1343","attributes":{"syncable":false,"level":"overlay","visible":false,"left":{"type":"number","value":"nan"},"right":{"type":"number","value":"nan"},"top":{"type":"number","value":"nan"},"bottom":{"type":"number","value":"nan"},"left_units":"canvas","right_units":"canvas","top_units":"canvas","bottom_units":"canvas","line_color":"black","line_alpha":1.0,"line_width":2,"line_dash":[4,4],"fill_color":"lightgrey","fill_alpha":0.5}}}},{"type":"object","name":"WheelZoomTool","id":"p1348","attributes":{"renderers":"auto"}},{"type":"object","name":"SaveTool","id":"p1349"},{"type":"object","name":"ResetTool","id":"p1350"}]}},"toolbar_location":null,"left":[{"type":"object","name":"LinearAxis","id":"p1336","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p1337","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p1338"},"axis_label":"CDF","axis_label_text_font_style":"normal","major_label_policy":{"type":"object","name":"AllLabels","id":"p1339"}}}],"below":[{"type":"object","name":"LinearAxis","id":"p1331","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p1332","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p1333"},"axis_label":"y","major_label_policy":{"type":"object","name":"AllLabels","id":"p1334"}}}],"center":[{"type":"object","name":"Grid","id":"p1335","attributes":{"axis":{"id":"p1331"}}},{"type":"object","name":"Grid","id":"p1340","attributes":{"dimension":1,"axis":{"id":"p1336"}}}],"frame_width":300,"frame_height":175,"background_fill_alpha":0,"border_fill_alpha":0}}],["source_p",{"id":"p1353"}],["source_c",{"id":"p1356"}],["discrete",false],["n",400],["sliders",[{"id":"p1378"},{"id":"p1380"}]],["xBoxes",[{"id":"p1385"},{"id":"p1386"}]],["pBoxes",[{"id":"p1387"},{"id":"p1388"}]],["quantileSetterSwitch",{"id":"p1390"}],["quantileSetterDiv",{"id":"p1389"}],["triggerCallbacks",{"id":"p1391"}],["startBoxes",[{"id":"p1381"},{"id":"p1382"}]],["endBoxes",[{"id":"p1383"},{"id":"p1384"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nfunction erf(x) {\\n  \\n  var a = [1.00002368,\\n           0.37409196,\\n           0.09678418,\\n           -0.18628806,\\n           0.27886807,\\n           -1.13520398,\\n           1.48851587,\\n           -0.82215223,\\n           0.17087277];\\n\\n  var t = 1 / (1 + Math.abs(x)/2);\\n  var expSum = -Math.pow(x, 2) - 1.26551223;\\n\\n  for (var i = 0; i &lt; a.length; i++) {\\n      expSum += a[i] * Math.pow(t, i+1);\\n  }\\n\\n  var result = 1 - t * Math.exp(expSum);\\n\\n  if (x &lt; 0) return -result;\\n  return result;\\n}\\n\\n\\nfunction erfinv(x) {\\n  \\n  let p = (x + 1.0) / 2.0;\\n\\n  \\n  if (p == 0.0) return -Infinity;\\n  if (p == 1.0) return Infinity;\\n  if (p &gt; 1.0 || p &lt; 0.0) return undefined;\\n\\n  let split1 = 0.425;\\n  let split2 = 5.0;\\n  let const1 = 0.180625;\\n  let const2 = 1.6;\\n\\n  \\n  let a0 = 3.3871327179;\\n  let a1 = 5.0434271938e1;\\n  let a2 = 1.5929113202e2;\\n  let a3 = 5.9109374720e1;\\n  let b1 = 1.7895169469e1;\\n  let b2 = 7.8757757664e1;\\n  let b3 = 6.7187563600e1;\\n\\n  \\n  let c0 = 1.4234372777;\\n  let c1 = 2.7568153900;\\n  let c2 = 1.3067284816;\\n  let c3 = 1.7023821103e-1;\\n  let d1 = 7.3700164250e-1;\\n  let d2 = 1.2021132975e-1;\\n\\n  \\n  let e0 = 6.6579051150;\\n  let e1 = 3.0812263860;\\n  let e2 = 4.2868294337e-1;\\n  let e3 = 1.7337203997e-2;\\n  let f1 = 2.4197894225e-1;\\n  let f2 = 1.2258202635e-2;\\n\\n  let r;\\n  let res;\\n  let q = p - 0.5;\\n\\n  if (Math.abs(q) &lt;= split1) {\\n    r = const1 - q * q;\\n    res = q * (((a3 * r + a2) * r + a1) * r + a0) /\\n              (((b3 * r + b2) * r + b1) * r + 1.0);\\n  } else {\\n    r = q &lt; 0 ? p : 1.0 - p;\\n\\n    r = Math.sqrt(-Math.log(r));\\n\\n    if (r &lt;= split2) {\\n      r -= const2;\\n      res = (((c3 * r + c2) * r + c1) * r + c0) /\\n             ((d2 * r + d1) * r + 1.0);\\n    } else {\\n      r -= split2;\\n      res = (((e3 * r + e2) * r + e1) * r + e0) /\\n             ((f2 * r + f1) * r + 1.0);\\n    }\\n  \\n    if (q &lt; 0) {\\n      res = -res;\\n    }\\n  }\\n\\n  \\n  return 0.7071067811865475 * res;\\n\\n}\\n\\n\\nclass NormalDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Normal&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.locationParam = &#x27;\\u03bc&#x27;;\\n\\n    \\n    this.paramMin = [-Infinity, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds();\\n\\n    \\n    super.generateLocationParamIndex();\\n}\\n\\n  xMin(params) {\\n    return -Infinity;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x === -Infinity || x === Infinity) return 0.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    let expTerm = (Math.pow(x - mu, 2) / 2.0 / Math.pow(sigma, 2));\\n    return Math.exp(-expTerm) / sigma / Math.sqrt(2 * Math.PI);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x === -Infinity) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    return (1 + erf((x - mu) / sigma / Math.sqrt(2))) / 2;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return -Infinity;\\n    if (p === 1) return Infinity;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return mu + sqrt2 * sigma * erfinv(2 * p - 1);\\n  }\\n\\n  defaultXRange(params) {\\n    return this.ppf([0.001, 0.999], params);\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    let sqrt2 = 1.4142135623730951;\\n\\n    let sigmaCoeff1 = sqrt2 * erfinv(2 * p1 - 1);\\n    let sigmaCoeff2 = sqrt2 * erfinv(2 * p2 - 1);\\n\\n    let sigma = (x2 - x1) / (sigmaCoeff2 - sigmaCoeff1);\\n    let mu = x2 - sigmaCoeff2 * sigma;\\n\\n    return [[mu, sigma], true];\\n  }\\n}\\n\\n\\n\\nvar dist = new NormalDistribution();\\n\\n\\nif (triggerCallbacks.active) {\\n  updateData(source_p, source_c, p_p, sliders, discrete);\\n}"}}]],["change:end",[{"id":"p1393"}]]]},"start":-2,"end":2}},"y_range":{"type":"object","name":"DataRange1d","id":"p1289","attributes":{"start":0.0}},"x_scale":{"type":"object","name":"LinearScale","id":"p1297"},"y_scale":{"type":"object","name":"LinearScale","id":"p1298"},"title":{"type":"object","name":"Title","id":"p1290","attributes":{"text":"Normal"}},"renderers":[{"type":"object","name":"GlyphRenderer","id":"p1374","attributes":{"data_source":{"id":"p1353"},"view":{"type":"object","name":"CDSView","id":"p1375","attributes":{"filter":{"type":"object","name":"AllIndices","id":"p1376"}}},"glyph":{"type":"object","name":"Line","id":"p1371","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"line_color":"#1f77b4","line_width":2}},"nonselection_glyph":{"type":"object","name":"Line","id":"p1372","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"line_color":"#1f77b4","line_alpha":0.1,"line_width":2}},"muted_glyph":{"type":"object","name":"Line","id":"p1373","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"line_color":"#1f77b4","line_alpha":0.2,"line_width":2}}}}],"toolbar":{"type":"object","name":"Toolbar","id":"p1296","attributes":{"tools":[{"type":"object","name":"PanTool","id":"p1309"},{"type":"object","name":"BoxZoomTool","id":"p1310","attributes":{"overlay":{"type":"object","name":"BoxAnnotation","id":"p1311","attributes":{"syncable":false,"level":"overlay","visible":false,"left":{"type":"number","value":"nan"},"right":{"type":"number","value":"nan"},"top":{"type":"number","value":"nan"},"bottom":{"type":"number","value":"nan"},"left_units":"canvas","right_units":"canvas","top_units":"canvas","bottom_units":"canvas","line_color":"black","line_alpha":1.0,"line_width":2,"line_dash":[4,4],"fill_color":"lightgrey","fill_alpha":0.5}}}},{"type":"object","name":"WheelZoomTool","id":"p1316","attributes":{"renderers":"auto"}},{"type":"object","name":"SaveTool","id":"p1317"},{"type":"object","name":"ResetTool","id":"p1318"}]}},"toolbar_location":null,"left":[{"type":"object","name":"LinearAxis","id":"p1304","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p1305","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p1306"},"axis_label":"PDF","axis_label_text_font_style":"normal","major_label_policy":{"type":"object","name":"AllLabels","id":"p1307"}}}],"below":[{"type":"object","name":"LinearAxis","id":"p1299","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p1300","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p1301"},"axis_label":"y","major_label_policy":{"type":"object","name":"AllLabels","id":"p1302"}}}],"center":[{"type":"object","name":"Grid","id":"p1303","attributes":{"axis":{"id":"p1299"}}},{"type":"object","name":"Grid","id":"p1308","attributes":{"dimension":1,"axis":{"id":"p1304"}}}],"frame_width":300,"frame_height":175,"background_fill_alpha":0,"border_fill_alpha":0}}],["p_c",{"id":"p1319"}],["source_p",{"id":"p1353"}],["source_c",{"id":"p1356"}],["discrete",false],["n",400],["sliders",[{"id":"p1378"},{"id":"p1380"}]],["xBoxes",[{"id":"p1385"},{"id":"p1386"}]],["pBoxes",[{"id":"p1387"},{"id":"p1388"}]],["quantileSetterSwitch",{"id":"p1390"}],["quantileSetterDiv",{"id":"p1389"}],["triggerCallbacks",{"id":"p1391"}],["startBoxes",[{"id":"p1381"},{"id":"p1382"}]],["endBoxes",[{"id":"p1383"},{"id":"p1384"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nfunction erf(x) {\\n  \\n  var a = [1.00002368,\\n           0.37409196,\\n           0.09678418,\\n           -0.18628806,\\n           0.27886807,\\n           -1.13520398,\\n           1.48851587,\\n           -0.82215223,\\n           0.17087277];\\n\\n  var t = 1 / (1 + Math.abs(x)/2);\\n  var expSum = -Math.pow(x, 2) - 1.26551223;\\n\\n  for (var i = 0; i &lt; a.length; i++) {\\n      expSum += a[i] * Math.pow(t, i+1);\\n  }\\n\\n  var result = 1 - t * Math.exp(expSum);\\n\\n  if (x &lt; 0) return -result;\\n  return result;\\n}\\n\\n\\nfunction erfinv(x) {\\n  \\n  let p = (x + 1.0) / 2.0;\\n\\n  \\n  if (p == 0.0) return -Infinity;\\n  if (p == 1.0) return Infinity;\\n  if (p &gt; 1.0 || p &lt; 0.0) return undefined;\\n\\n  let split1 = 0.425;\\n  let split2 = 5.0;\\n  let const1 = 0.180625;\\n  let const2 = 1.6;\\n\\n  \\n  let a0 = 3.3871327179;\\n  let a1 = 5.0434271938e1;\\n  let a2 = 1.5929113202e2;\\n  let a3 = 5.9109374720e1;\\n  let b1 = 1.7895169469e1;\\n  let b2 = 7.8757757664e1;\\n  let b3 = 6.7187563600e1;\\n\\n  \\n  let c0 = 1.4234372777;\\n  let c1 = 2.7568153900;\\n  let c2 = 1.3067284816;\\n  let c3 = 1.7023821103e-1;\\n  let d1 = 7.3700164250e-1;\\n  let d2 = 1.2021132975e-1;\\n\\n  \\n  let e0 = 6.6579051150;\\n  let e1 = 3.0812263860;\\n  let e2 = 4.2868294337e-1;\\n  let e3 = 1.7337203997e-2;\\n  let f1 = 2.4197894225e-1;\\n  let f2 = 1.2258202635e-2;\\n\\n  let r;\\n  let res;\\n  let q = p - 0.5;\\n\\n  if (Math.abs(q) &lt;= split1) {\\n    r = const1 - q * q;\\n    res = q * (((a3 * r + a2) * r + a1) * r + a0) /\\n              (((b3 * r + b2) * r + b1) * r + 1.0);\\n  } else {\\n    r = q &lt; 0 ? p : 1.0 - p;\\n\\n    r = Math.sqrt(-Math.log(r));\\n\\n    if (r &lt;= split2) {\\n      r -= const2;\\n      res = (((c3 * r + c2) * r + c1) * r + c0) /\\n             ((d2 * r + d1) * r + 1.0);\\n    } else {\\n      r -= split2;\\n      res = (((e3 * r + e2) * r + e1) * r + e0) /\\n             ((f2 * r + f1) * r + 1.0);\\n    }\\n  \\n    if (q &lt; 0) {\\n      res = -res;\\n    }\\n  }\\n\\n  \\n  return 0.7071067811865475 * res;\\n\\n}\\n\\n\\nclass NormalDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Normal&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.locationParam = &#x27;\\u03bc&#x27;;\\n\\n    \\n    this.paramMin = [-Infinity, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds();\\n\\n    \\n    super.generateLocationParamIndex();\\n}\\n\\n  xMin(params) {\\n    return -Infinity;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x === -Infinity || x === Infinity) return 0.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    let expTerm = (Math.pow(x - mu, 2) / 2.0 / Math.pow(sigma, 2));\\n    return Math.exp(-expTerm) / sigma / Math.sqrt(2 * Math.PI);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x === -Infinity) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    return (1 + erf((x - mu) / sigma / Math.sqrt(2))) / 2;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return -Infinity;\\n    if (p === 1) return Infinity;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return mu + sqrt2 * sigma * erfinv(2 * p - 1);\\n  }\\n\\n  defaultXRange(params) {\\n    return this.ppf([0.001, 0.999], params);\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    let sqrt2 = 1.4142135623730951;\\n\\n    let sigmaCoeff1 = sqrt2 * erfinv(2 * p1 - 1);\\n    let sigmaCoeff2 = sqrt2 * erfinv(2 * p2 - 1);\\n\\n    let sigma = (x2 - x1) / (sigmaCoeff2 - sigmaCoeff1);\\n    let mu = x2 - sigmaCoeff2 * sigma;\\n\\n    return [[mu, sigma], true];\\n  }\\n}\\n\\n\\n\\nvar dist = new NormalDistribution();\\n\\n\\n\\nif (cb_obj.active) {\\n  for (let i = 0; i &lt; sliders.length; i++) {\\n    if (!dist.fixedParamsInds.includes(i)) {\\n      sliders[i].title = dist.paramNames[i] + &#x27; (computed)&#x27;;\\n      sliders[i].disabled = true;\\n    }\\n  }\\n  for (let xBox of xBoxes) {\\n    xBox.disabled = false;\\n  }\\n  for (let pBox of pBoxes) {\\n    pBox.disabled = false;\\n  }\\n} else {\\n  for (let i = 0; i &lt; sliders.length; i++) {\\n    if (!dist.fixedParamsInds.includes(i)) {\\n      sliders[i].title = dist.paramNames[i];\\n      sliders[i].disabled = false;\\n    }\\n  }\\n  for (let xBox of xBoxes) {\\n    xBox.disabled = true;\\n  }\\n  for (let pBox of pBoxes) {\\n    pBox.disabled = true;\\n  }\\n  quantileSetterDiv.text = &#x27;&#x27;;\\n}"}}]]]}}}]}},{"type":"object","name":"Spacer","id":"p1444","attributes":{"width":10}},{"id":"p1389"}]}},{"type":"object","name":"Spacer","id":"p1446","attributes":{"height":10}},{"type":"object","name":"Row","id":"p1448","attributes":{"children":[{"type":"object","name":"Column","id":"p1433","attributes":{"children":[{"type":"object","name":"Row","id":"p1431","attributes":{"children":[{"type":"object","name":"Column","id":"p1424","attributes":{"children":[{"type":"object","name":"Spacer","id":"p1423","attributes":{"height":4}},{"id":"p1381"}]}},{"id":"p1378"},{"type":"object","name":"Column","id":"p1426","attributes":{"children":[{"type":"object","name":"Spacer","id":"p1425","attributes":{"height":4}},{"id":"p1383"}]}}]}},{"type":"object","name":"Row","id":"p1432","attributes":{"children":[{"type":"object","name":"Column","id":"p1428","attributes":{"children":[{"type":"object","name":"Spacer","id":"p1427","attributes":{"height":4}},{"id":"p1382"}]}},{"id":"p1380"},{"type":"object","name":"Column","id":"p1430","attributes":{"children":[{"type":"object","name":"Spacer","id":"p1429","attributes":{"height":4}},{"id":"p1384"}]}}]}}]}},{"type":"object","name":"Spacer","id":"p1447","attributes":{"width":20}},{"type":"object","name":"Column","id":"p1422","attributes":{"children":[{"type":"object","name":"Row","id":"p1420","attributes":{"children":[{"type":"object","name":"Spacer","id":"p1404","attributes":{"width":20}},{"type":"object","name":"Column","id":"p1407","attributes":{"children":[{"type":"object","name":"Spacer","id":"p1405","attributes":{"height":7}},{"type":"object","name":"Div","id":"p1406","attributes":{"text":"&lt;p&gt;&lt;b&gt;lower y: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p1385"},{"type":"object","name":"Spacer","id":"p1408","attributes":{"width":34}},{"type":"object","name":"Column","id":"p1411","attributes":{"children":[{"type":"object","name":"Spacer","id":"p1409","attributes":{"height":7}},{"type":"object","name":"Div","id":"p1410","attributes":{"text":"&lt;p&gt;&lt;b&gt;upper y: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p1386"}]}},{"type":"object","name":"Row","id":"p1421","attributes":{"children":[{"type":"object","name":"Spacer","id":"p1412","attributes":{"width":16}},{"type":"object","name":"Column","id":"p1415","attributes":{"children":[{"type":"object","name":"Spacer","id":"p1413","attributes":{"height":7}},{"type":"object","name":"Div","id":"p1414","attributes":{"text":"&lt;p&gt;&lt;b&gt;quantile: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p1387"},{"type":"object","name":"Spacer","id":"p1416","attributes":{"width":30}},{"type":"object","name":"Column","id":"p1419","attributes":{"children":[{"type":"object","name":"Spacer","id":"p1417","attributes":{"height":7}},{"type":"object","name":"Div","id":"p1418","attributes":{"text":"&lt;p&gt;&lt;b&gt;quantile: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p1388"}]}}]}}]}},{"type":"object","name":"Spacer","id":"p1449","attributes":{"height":10}},{"type":"object","name":"GridPlot","id":"p1441","attributes":{"rows":null,"cols":null,"toolbar":{"type":"object","name":"Toolbar","id":"p1440","attributes":{"tools":[{"type":"object","name":"ToolProxy","id":"p1435","attributes":{"tools":[{"id":"p1309"},{"id":"p1341"},{"id":"p1309"},{"id":"p1341"}]}},{"type":"object","name":"ToolProxy","id":"p1436","attributes":{"tools":[{"id":"p1310"},{"id":"p1342"},{"id":"p1310"},{"id":"p1342"}]}},{"type":"object","name":"ToolProxy","id":"p1437","attributes":{"tools":[{"id":"p1316"},{"id":"p1348"},{"id":"p1316"},{"id":"p1348"}]}},{"type":"object","name":"SaveTool","id":"p1438"},{"type":"object","name":"ToolProxy","id":"p1439","attributes":{"tools":[{"id":"p1318"},{"id":"p1350"},{"id":"p1318"},{"id":"p1350"}]}}]}},"toolbar_location":"right","children":[[{"id":"p1287"},0,0],[{"type":"object","name":"Spacer","id":"p1434","attributes":{"width":30}},0,1],[{"id":"p1319"},0,2]]}}]}}]}}';
                  const render_items = [{"docid":"3ce22bdc-8842-40a6-9d43-f3fc4ba45989","roots":{"p1450":"bcb6210c-96b1-4820-9942-3a1f9e740213"},"root_ids":["p1450"]}];
                  root.Bokeh.embed.embed_items(docs_json, render_items);
                  }
                  if (root.Bokeh !== undefined) {
                    embed_document(root);
                  } else {
                    let attempts = 0;
                    const timer = setInterval(function(root) {
                      if (root.Bokeh !== undefined) {
                        clearInterval(timer);
                        embed_document(root);
                      } else {
                        attempts++;
                        if (attempts > 100) {
                          clearInterval(timer);
                          console.log("Bokeh: ERROR: Unable to run BokehJS code because BokehJS library is missing");
                        }
                      }
                    }, 10, root)
                  }
                })(window);
              });
            };
            if (document.readyState != "loading") fn();
            else document.addEventListener("DOMContentLoaded", fn);
          })();
        },
    function(Bokeh) {
        }
      ];
    
      function run_inline_js() {
        for (let i = 0; i < inline_js.length; i++) {
          inline_js[i].call(root, root.Bokeh);
        }
      }
    
      if (root._bokeh_is_loading === 0) {
        console.debug("Bokeh: BokehJS loaded, going straight to plotting");
        run_inline_js();
      } else {
        load_libs(css_urls, js_urls, function() {
          console.debug("Bokeh: BokehJS plotting callback run at", now());
          run_inline_js();
        });
      }
    }(window));
  };
  if (document.readyState != "loading") fn();
  else document.addEventListener("DOMContentLoaded", fn);
})();