(function() {
  const fn = function() {
    (function(root) {
      function now() {
        return new Date();
      }
    
      const force = false;
    
      if (typeof root._bokeh_onload_callbacks === "undefined" || force === true) {
        root._bokeh_onload_callbacks = [];
        root._bokeh_is_loading = undefined;
      }
    
    
    const element = document.getElementById("bf32a522-bb8c-4bd1-8a92-34883f1c74b8");
        if (element == null) {
          console.warn("Bokeh: autoload.js configured with elementid 'bf32a522-bb8c-4bd1-8a92-34883f1c74b8' but no matching script tag was found.")
        }
      function run_callbacks() {
        try {
          root._bokeh_onload_callbacks.forEach(function(callback) {
            if (callback != null)
              callback();
          });
        } finally {
          delete root._bokeh_onload_callbacks
        }
        console.debug("Bokeh: all callbacks have finished");
      }
    
      function load_libs(css_urls, js_urls, callback) {
        if (css_urls == null) css_urls = [];
        if (js_urls == null) js_urls = [];
    
        root._bokeh_onload_callbacks.push(callback);
        if (root._bokeh_is_loading > 0) {
          console.debug("Bokeh: BokehJS is being loaded, scheduling callback at", now());
          return null;
        }
        if (js_urls == null || js_urls.length === 0) {
          run_callbacks();
          return null;
        }
        console.debug("Bokeh: BokehJS not loaded, scheduling load and callback at", now());
        root._bokeh_is_loading = css_urls.length + js_urls.length;
    
        function on_load() {
          root._bokeh_is_loading--;
          if (root._bokeh_is_loading === 0) {
            console.debug("Bokeh: all BokehJS libraries/stylesheets loaded");
            run_callbacks()
          }
        }
    
        function on_error(url) {
          console.error("failed to load " + url);
        }
    
        for (let i = 0; i < css_urls.length; i++) {
          const url = css_urls[i];
          const element = document.createElement("link");
          element.onload = on_load;
          element.onerror = on_error.bind(null, url);
          element.rel = "stylesheet";
          element.type = "text/css";
          element.href = url;
          console.debug("Bokeh: injecting link tag for BokehJS stylesheet: ", url);
          document.body.appendChild(element);
        }
    
        for (let i = 0; i < js_urls.length; i++) {
          const url = js_urls[i];
          const element = document.createElement('script');
          element.onload = on_load;
          element.onerror = on_error.bind(null, url);
          element.async = false;
          element.src = url;
          console.debug("Bokeh: injecting script tag for BokehJS library: ", url);
          document.head.appendChild(element);
        }
      };
    
      function inject_raw_css(css) {
        const element = document.createElement("style");
        element.appendChild(document.createTextNode(css));
        document.body.appendChild(element);
      }
    
      const js_urls = ["https://cdn.bokeh.org/bokeh/release/bokeh-3.3.0.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-gl-3.3.0.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-widgets-3.3.0.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-tables-3.3.0.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-mathjax-3.3.0.min.js"];
      const css_urls = [];
    
      const inline_js = [    function(Bokeh) {
          Bokeh.set_log_level("info");
        },
        function(Bokeh) {
          (function() {
            const fn = function() {
              Bokeh.safely(function() {
                (function(root) {
                  function embed_document(root) {
                  const docs_json = '{"d1674beb-572a-4990-8a59-0f9ae68dd20f":{"version":"3.3.0","title":"Bokeh Application","roots":[{"type":"object","name":"Column","id":"p3667","attributes":{"children":[{"type":"object","name":"Row","id":"p3662","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3660","attributes":{"width":409}},{"type":"object","name":"Row","id":"p3623","attributes":{"children":[{"type":"object","name":"Div","id":"p3621","attributes":{"text":"&lt;p&gt;&lt;b&gt;Quantile setter mode&lt;/b&gt;&lt;/p&gt;"}},{"type":"object","name":"Spacer","id":"p3622","attributes":{"width":2}},{"type":"object","name":"Switch","id":"p3610","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:active",[{"type":"object","name":"CustomJS","id":"p3614","attributes":{"args":{"type":"map","entries":[["p_p",{"type":"object","name":"Figure","id":"p3523","attributes":{"x_range":{"type":"object","name":"Range1d","id":"p3571","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:start",[{"type":"object","name":"CustomJS","id":"p3613","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p3523"}],["p_c",{"type":"object","name":"Figure","id":"p3547","attributes":{"js_event_callbacks":{"type":"map","entries":[["reset",[{"type":"object","name":"CustomJS","id":"p3616","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p3523"}],["p_c",{"id":"p3547"}],["source_p",{"type":"object","name":"ColumnDataSource","id":"p3573","attributes":{"selected":{"type":"object","name":"Selection","id":"p3574","attributes":{"indices":[],"line_indices":[]}},"selection_policy":{"type":"object","name":"UnionRenderers","id":"p3575"},"data":{"type":"map","entries":[["x",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}],["y_p",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}]]}}}],["source_c",{"type":"object","name":"ColumnDataSource","id":"p3576","attributes":{"selected":{"type":"object","name":"Selection","id":"p3577","attributes":{"indices":[],"line_indices":[]}},"selection_policy":{"type":"object","name":"UnionRenderers","id":"p3578"},"data":{"type":"map","entries":[["x",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}],["y_c",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}]]}}}],["discrete",false],["n",400],["sliders",[{"type":"object","name":"Slider","id":"p3598","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p3612","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p3523"}],["p_c",{"id":"p3547"}],["source_p",{"id":"p3573"}],["source_c",{"id":"p3576"}],["discrete",false],["n",400],["sliders",[{"id":"p3598"},{"type":"object","name":"Slider","id":"p3600","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p3612"}]]]},"width":200,"title":"\\u03ba","format":{"type":"object","name":"CustomJSTickFormatter","id":"p3599","attributes":{"code":"return tick.toPrecision(4)"}},"start":0.01,"end":10,"value":1,"step":0.01}}]],["xBoxes",[{"type":"object","name":"TextInput","id":"p3605","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p3615","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p3523"}],["p_c",{"id":"p3547"}],["source_p",{"id":"p3573"}],["source_c",{"id":"p3576"}],["discrete",false],["n",400],["sliders",[{"id":"p3598"},{"id":"p3600"}]],["xBoxes",[{"id":"p3605"},{"type":"object","name":"TextInput","id":"p3606","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p3615"}]]]},"disabled":true,"width":80,"value":"2.6246"}}]],["pBoxes",[{"type":"object","name":"TextInput","id":"p3607","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p3615"}]]]},"disabled":true,"width":80,"value":"0.0250"}},{"type":"object","name":"TextInput","id":"p3608","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p3615"}]]]},"disabled":true,"width":80,"value":"0.9750"}}]],["quantileSetterSwitch",{"id":"p3610"}],["quantileSetterDiv",{"type":"object","name":"Div","id":"p3609"}],["triggerCallbacks",{"type":"object","name":"Switch","id":"p3611","attributes":{"active":true}}],["startBoxes",[{"type":"object","name":"TextInput","id":"p3601","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p3617","attributes":{"args":{"type":"map","entries":[["minValue","-3.1416"],["maxValue","3.1416"],["slider",{"id":"p3598"}]]},"code":"\\n\\nslider.start = Math.max(minValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"-3.1416"}},{"type":"object","name":"TextInput","id":"p3602","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p3619","attributes":{"args":{"type":"map","entries":[["minValue","0"],["maxValue","Infinity"],["slider",{"id":"p3600"}]]},"code":"\\n\\nslider.start = Math.max(minValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"0.01"}}]],["endBoxes",[{"type":"object","name":"TextInput","id":"p3603","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p3618","attributes":{"args":{"type":"map","entries":[["minValue","-3.1416"],["maxValue","3.1416"],["slider",{"id":"p3598"}]]},"code":"\\n\\nslider.end = Math.min(maxValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"3.1416"}},{"type":"object","name":"TextInput","id":"p3604","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p3620","attributes":{"args":{"type":"map","entries":[["minValue","0"],["maxValue","Infinity"],["slider",{"id":"p3600"}]]},"code":"\\n\\nslider.end = Math.min(maxValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"10"}}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.floor(xRange.start);\\n  let xRangeMax = Math.ceil(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c = [xRangeMin - 1, ...x_p.flatMap(x =&gt; [x, x]), xRangeMax + 1];\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = -0.04;\\n    p_c.y_range.end = 1.04;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = -pdfMax * 0.04;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264&#x27; + xMax.toString() + &#x27;.&lt;/p\\\\&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nclass NormalDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Normal&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.locationParam = &#x27;\\u03bc&#x27;;\\n\\n    \\n    this.paramMin = [-Infinity, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds();\\n\\n    \\n    super.generateLocationParamIndex();\\n}\\n\\n  xMin(params) {\\n    return -Infinity;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x === -Infinity || x === Infinity) return 0.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    let expTerm = (Math.pow(x - mu, 2) / 2.0 / Math.pow(sigma, 2));\\n    return Math.exp(-expTerm) / sigma / Math.sqrt(2 * Math.PI);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x === -Infinity) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    return (1 + erf((x - mu) / sigma / Math.sqrt(2))) / 2;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return -Infinity;\\n    if (p === 1) return Infinity;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return mu + sqrt2 * sigma * erfinv(2 * p - 1);\\n  }\\n\\n  defaultXRange(params) {\\n    return this.ppf([0.001, 0.999], params);\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    let sqrt2 = 1.4142135623730951;\\n\\n    let sigmaCoeff1 = sqrt2 * erfinv(2 * p1 - 1);\\n    let sigmaCoeff2 = sqrt2 * erfinv(2 * p2 - 1);\\n\\n    let sigma = (x2 - x1) / (sigmaCoeff2 - sigmaCoeff1);\\n    let mu = x2 - sigmaCoeff2 * sigma;\\n\\n    return [[mu, sigma], true];\\n  }\\n}\\n\\nfunction isclose(x, y, rtol = 1.0e-7, atol = 1.0e-8) {\\n  return Math.abs(x - y) &lt;= (atol + rtol * Math.abs(y));\\n}\\n\\n\\nfunction erf(x) {\\n  \\n  var a = [1.00002368,\\n           0.37409196,\\n           0.09678418,\\n           -0.18628806,\\n           0.27886807,\\n           -1.13520398,\\n           1.48851587,\\n           -0.82215223,\\n           0.17087277];\\n\\n  var t = 1 / (1 + Math.abs(x)/2);\\n  var expSum = -Math.pow(x, 2) - 1.26551223;\\n\\n  for (var i = 0; i &lt; a.length; i++) {\\n      expSum += a[i] * Math.pow(t, i+1);\\n  }\\n\\n  var result = 1 - t * Math.exp(expSum);\\n\\n  if (x &lt; 0) return -result;\\n  return result;\\n}\\n\\n\\nfunction besseli0(x, expWeighted = false) {\\n\\n  let A = [\\n    -4.41534164647933937950e-18,\\n     3.33079451882223809783e-17,\\n    -2.43127984654795469359e-16,\\n     1.71539128555513303061e-15,\\n    -1.16853328779934516808e-14,\\n     7.67618549860493561688e-14,\\n    -4.85644678311192946090e-13,\\n     2.95505266312963983461e-12,\\n    -1.72682629144155570723e-11,\\n     9.67580903537323691224e-11,\\n    -5.18979560163526290666e-10,\\n     2.65982372468238665035e-9,\\n    -1.30002500998624804212e-8,\\n     6.04699502254191894932e-8,\\n    -2.67079385394061173391e-7,\\n     1.11738753912010371815e-6,\\n    -4.41673835845875056359e-6,\\n     1.64484480707288970893e-5,\\n    -5.75419501008210370398e-5,\\n     1.88502885095841655729e-4,\\n    -5.76375574538582365885e-4,\\n     1.63947561694133579842e-3,\\n    -4.32430999505057594430e-3,\\n     1.05464603945949983183e-2,\\n    -2.37374148058994688156e-2,\\n     4.93052842396707084878e-2,\\n    -9.49010970480476444210e-2,\\n     1.71620901522208775349e-1,\\n    -3.04682672343198398683e-1,\\n     6.76795274409476084995e-1\\n  ];\\n\\n  let B = [\\n    -7.23318048787475395456e-18,\\n    -4.83050448594418207126e-18,\\n     4.46562142029675999901e-17,\\n     3.46122286769746109310e-17,\\n    -2.82762398051658348494e-16,\\n    -3.42548561967721913462e-16,\\n     1.77256013305652638360e-15,\\n     3.81168066935262242075e-15,\\n    -9.55484669882830764870e-15,\\n    -4.15056934728722208663e-14,\\n     1.54008621752140982691e-14,\\n     3.85277838274214270114e-13,\\n     7.18012445138366623367e-13,\\n    -1.79417853150680611778e-12,\\n    -1.32158118404477131188e-11,\\n    -3.14991652796324136454e-11,\\n     1.18891471078464383424e-11,\\n     4.94060238822496958910e-10,\\n     3.39623202570838634515e-9,\\n     2.26666899049817806459e-8,\\n     2.04891858946906374183e-7,\\n     2.89137052083475648297e-6,\\n     6.88975834691682398426e-5,\\n     3.36911647825569408990e-3,\\n     8.04490411014108831608e-1\\n  ];\\n\\n  if ( x &lt; 0 ) x = -x;\\n\\n  let result;\\n  if (x &lt;= 8.0) {\\n    let y = x / 2.0 - 2.0;\\n    result = chbevl(y, A);\\n  } else {\\n    result = chbevl(32.0 / x - 2.0, B) / Math.sqrt(x)\\n  }\\n\\n  if (expWeighted) return result;\\n  else return Math.exp(x) * result;\\n}\\n\\n\\nfunction cosm1(x) {\\n\\n  let coeffs = [\\n     4.7377507964246204691685E-14,\\n    -1.1470284843425359765671E-11,\\n     2.0876754287081521758361E-9,\\n    -2.7557319214999787979814E-7,\\n     2.4801587301570552304991E-5,\\n    -1.3888888888888872993737E-3,\\n     4.1666666666666666609054E-2\\n   ];\\n\\n  let quarterPi = Math.PI / 4;\\n\\n  if (x &lt; quarterPi || x &gt; quarterPi) return Math.cos(x) - 1.0;\\n\\n  let x2 = x * x;\\n  return -0.5 * x2 + x2 * x2 * polevl(x2, coeffs);\\n}\\n\\n\\nfunction clenshawCurtisIntegrate(f, a, b, n = 100, args = [], weights = undefined) {\\n\\n  if (weights === undefined) {\\n    \\n    let ccWeights = clenshawCurtisWeights(n);\\n\\n    \\n    weights = ccWeights.map((x) =&gt; (b - a) / 2.0 * x);\\n  }\\n\\n  \\n  let x = chebPoints(n);\\n\\n  \\n  x = x.map((x) =&gt; (b - a) / 2.0 * x + (b + a) / 2.0);\\n\\n  \\n  let fVals = x.map((x) =&gt; f(x, ...args));\\n\\n  \\n  return dot(weights, fVals);\\n}\\n\\n\\nfunction findRootTrustRegion(\\n\\t\\tf, \\n\\t\\tx0, \\n\\t\\targs=[],\\n\\t\\tjac=jacCentralDiff,\\n\\t\\ttol=0.000000001, \\n\\t\\tmaxIters=10000, \\n\\t\\tdeltaBar=1000.0, \\n\\t\\teta=0.125, \\n\\t\\tminDelta=1e-12\\n  ) {\\n\\t\\n\\tlet x = deepCopy(x0);\\n\\n\\t\\n\\tlet delta = 0.99 * deltaBar;\\n\\n\\t\\n\\tlet r = f(x, ...args);\\n\\n\\t\\n\\tlet J = jac(f, x, args);\\n\\n\\t\\n\\tlet JTJ = mmMult(transpose(J), J);\\n\\n\\t\\n\\tlet JTr = mvMult(transpose(J), r);\\n\\n\\t\\n\\tlet normJTr = norm(JTr);\\n\\n\\tlet iters = 0;\\n\\twhile (iters &lt; maxIters &amp;&amp; checkTol(r, tol) &amp;&amp; delta &gt;= minDelta) {\\n\\t\\t\\n\\t\\tlet p = doglegStep(JTJ, JTr, normJTr, delta);\\n\\n\\t\\t\\n\\t\\tlet newr = f(vectorAdd(x, p), ...args);\\n\\t\\tlet rho = computeRho(r, newr, J, p);\\n\\n\\t\\t\\n\\t\\tif  (rho &lt; 0.25) {\\n\\t\\t\\tdelta = norm(p) / 4.0;\\n\\t\\t} else if (rho &gt; 0.75 &amp;&amp; Math.abs(norm(p) - delta) &lt; 1e-12) {\\n\\t\\t\\t\\tdelta = Math.min(2 * delta, deltaBar);\\n\\t\\t}\\n\\n\\t\\t\\n\\t\\tif (rho &gt; eta) {\\n\\t\\t\\tx = vectorAdd(x, p);\\n\\n\\t\\t\\tr = newr;\\n\\t\\t\\tJ = jac(f, x, args);\\n\\t\\t\\tJTJ = mmMult(transpose(J), J);\\n\\t\\t\\tJTr = mvMult(transpose(J), r);\\n\\t\\t\\tnormJTr = norm(JTr);\\n\\t\\t}\\n\\n\\t\\titers += 1;\\n\\t}\\n\\n\\tlet success = !checkTol(r, tol);\\n\\n\\treturn [x, success];\\n\\n}\\n\\n\\nfunction brentSolve(f, lower, upper, args=[], tol=1e-8, maxIter=1000) {\\n\\tlet a = lower;\\n\\tlet b = upper;\\n  let fa = f(a, ...args);\\n  let fb = f(b, ...args);\\n\\n  \\n  if (Math.abs(fa) &lt; tol) return a;\\n  if (Math.abs(fb) &lt; tol) return b;\\n\\n  \\n  if (fa * fb &gt;= 0) {\\n  \\treturn null;\\n\\t}\\n\\n  \\n  let c = a;\\n  let fc = fa;\\n\\n\\tlet iter = 0;\\n  while (iter++ &lt; maxIter) {\\n  \\tlet prevStep = b - a;\\n\\n    \\n    if (Math.abs(fc) &lt; Math.abs(fb)) {      \\n    \\t[a, b, c] = [b, c, b];\\n    \\t[fa, fb, fc] = [fb, fc, fb];\\n    }\\n\\n    \\n    let newStep = (c - b) / 2.0;\\n\\n    \\n    let tolAdj = 1e-15 * Math.abs(b) + tol / 2;\\n\\n    \\n  \\tif (Math.abs(newStep) &lt;= tolAdj || fb === 0 ) {\\n    \\t\\treturn b;\\n  \\t}\\n\\n    \\n    if (Math.abs(prevStep) &gt; tolAdj &amp;&amp; Math.abs(fa) &gt; Math.abs(fb)) {\\n    \\tlet p;\\n    \\tlet q;\\n    \\tlet t1;\\n    \\tlet t2;\\n    \\tlet cb = c - b;\\n    \\tif (a === c) { \\n    \\t\\tt1 = fb / fa;\\n    \\t\\tp = cb * t1;\\n    \\t\\tq = 1.0 - t1;\\n    \\t}\\n    \\telse { \\n    \\t\\tq = fa / fc;\\n    \\t\\tt1 = fb / fc;\\n    \\t\\tt2 = fb / fa;\\n    \\t\\tp = t2 * (cb * q * (q - t1) - (b - a) * (t1 - 1.0));\\n    \\t\\tq = (q - 1.0) * (t1 - 1.0) * (t2 - 1.0);\\n    \\t}\\n\\n    \\t\\n    \\tif (p &gt; 0) q = -q;\\n    \\telse p = -p;\\n\\n    \\t\\n    \\tif (p &lt; (0.75 * cb * q - Math.abs(tolAdj * q) / 2.0) \\n    \\t\\t&amp;&amp; p &lt; Math.abs(prevStep * q / 2.0)) { \\n\\t        newStep = p / q;\\n      \\t}\\n    }\\n\\n    if (Math.abs(newStep) &lt; tolAdj) {\\n      newStep = (newStep &gt; 0) ? tolAdj : -tolAdj;\\n    }\\n\\n    \\n    a = b;\\n    fa = fb;\\n\\n    \\n    b += newStep;\\n    fb = f(b, ...args);\\n\\n\\t\\n    if ((fb &gt; 0 &amp;&amp; fc &gt; 0) || (fb &lt; 0 &amp;&amp; fc &lt; 0)) {\\n      c = a; \\n      fc = fa;\\n    }\\n  }\\n\\n  \\n  return null;\\n}\\n\\n\\nfunction erfinv(x) {\\n  \\n  let p = (x + 1.0) / 2.0;\\n\\n  \\n  if (p == 0.0) return -Infinity;\\n  if (p == 1.0) return Infinity;\\n  if (p &gt; 1.0 || p &lt; 0.0) return undefined;\\n\\n  let split1 = 0.425;\\n  let split2 = 5.0;\\n  let const1 = 0.180625;\\n  let const2 = 1.6;\\n\\n  \\n  let a0 = 3.3871327179;\\n  let a1 = 5.0434271938e1;\\n  let a2 = 1.5929113202e2;\\n  let a3 = 5.9109374720e1;\\n  let b1 = 1.7895169469e1;\\n  let b2 = 7.8757757664e1;\\n  let b3 = 6.7187563600e1;\\n\\n  \\n  let c0 = 1.4234372777;\\n  let c1 = 2.7568153900;\\n  let c2 = 1.3067284816;\\n  let c3 = 1.7023821103e-1;\\n  let d1 = 7.3700164250e-1;\\n  let d2 = 1.2021132975e-1;\\n\\n  \\n  let e0 = 6.6579051150;\\n  let e1 = 3.0812263860;\\n  let e2 = 4.2868294337e-1;\\n  let e3 = 1.7337203997e-2;\\n  let f1 = 2.4197894225e-1;\\n  let f2 = 1.2258202635e-2;\\n\\n  let r;\\n  let res;\\n  let q = p - 0.5;\\n\\n  if (Math.abs(q) &lt;= split1) {\\n    r = const1 - q * q;\\n    res = q * (((a3 * r + a2) * r + a1) * r + a0) /\\n              (((b3 * r + b2) * r + b1) * r + 1.0);\\n  } else {\\n    r = q &lt; 0 ? p : 1.0 - p;\\n\\n    r = Math.sqrt(-Math.log(r));\\n\\n    if (r &lt;= split2) {\\n      r -= const2;\\n      res = (((c3 * r + c2) * r + c1) * r + c0) /\\n             ((d2 * r + d1) * r + 1.0);\\n    } else {\\n      r -= split2;\\n      res = (((e3 * r + e2) * r + e1) * r + e0) /\\n             ((f2 * r + f1) * r + 1.0);\\n    }\\n  \\n    if (q &lt; 0) {\\n      res = -res;\\n    }\\n  }\\n\\n  \\n  return 0.7071067811865475 * res;\\n\\n}\\n\\n\\nfunction chbevl(x, A) {\\n\\n  let b0, b1, b2;\\n  let n = A.length;\\n  let i = n - 1;\\n\\n  b0 = A[0];\\n  b1 = 0.0;\\n\\n  for (let j = 1; j &lt;= i; j++) {\\n    b2 = b1;\\n    b1 = b0;\\n    b0 = x * b1 - b2 + A[j];\\n  }\\n\\n  return 0.5 * (b0 - b2);\\n}\\n\\n\\nfunction polevl(x, coef) {\\n\\n    let result;\\n    let n = coef.length;\\n\\n    let i = n;\\n\\n    result = coef[0];\\n\\n    for (let j = 1; j &lt;= n; j++) {\\n        result = result * x + coef[j];\\n    }\\n\\n    return result;\\n}\\n\\n\\nfunction chebPoints(n, low = -1, high = 1) {\\n  \\n  let points = Array.from({ length: n }, (_, i) =&gt; Math.cos(Math.PI * i / (n - 1)));\\n\\n  \\n  let m = (high - low) / 2.0;\\n  let b = (high + low) / 2.0;\\n\\n  points = points.map((x) =&gt; m * x + b);\\n\\n  return points;\\n}\\n\\n\\nfunction clenshawCurtisWeights(n) {\\n    n -= 1; \\n\\n    const theta = Array.from({ length: n + 1 }, (_, i) =&gt; Math.PI * i / n);\\n    let w = new Array(n + 1).fill(0);\\n    let v = new Array(n - 1).fill(1);\\n\\n    if (n % 2 === 0) {\\n        w[0] = 1.0 / (n ** 2 - 1);\\n        w[n] = w[0];\\n        for (let k = 1; k &lt; n / 2; k++) {\\n            for (let j = 1; j &lt; n; j++) {\\n                v[j - 1] -= 2.0 * Math.cos(2.0 * k * theta[j]) / (4.0 * k ** 2 - 1);\\n            }\\n        }\\n        for (let j = 1; j &lt; n; j++) {\\n            v[j - 1] -= Math.cos(n * theta[j]) / (n ** 2 - 1);\\n        }\\n    } else {\\n        w[0] = 1.0 / n ** 2;\\n        w[n] = w[0];\\n        for (let k = 1; k &lt;= (n - 1) / 2; k++) {\\n            for (let j = 1; j &lt; n; j++) {\\n                v[j - 1] -= 2.0 * Math.cos(2.0 * k * theta[j]) / (4.0 * k ** 2 - 1);\\n            }\\n        }\\n    }\\n\\n    for (let j = 1; j &lt; n; j++) {\\n        w[j] = 2.0 * v[j - 1] / n;\\n    }\\n\\n    return w;\\n}\\n\\n\\nfunction dot(v1, v2) {\\n  const n = v1.length;\\n  let result = 0.0;\\n  for (let i = 0; i &lt; n; i++) result += v1[i] * v2[i];\\n\\n  return result;\\n}\\n\\n\\nfunction transpose(A) {\\n    return A[0].map((_, colIndex) =&gt; A.map(row =&gt; row[colIndex]));\\n}\\n\\n\\nfunction mvMult(A, v) {\\n  return A.map(Arow =&gt; dot(Arow, v));\\n}\\n\\n\\nfunction mmMult(A, B) {\\n  let mA = A.length;\\n  let nA = A[0].length;\\n  let mB = B.length;\\n  let nB = B[0].length;\\n\\n  if (nA !== mB) {\\n      throw new Error(&#x27;Matrix dimension mismatch.&#x27;);\\n  }\\n\\n  let result = zeros(mA, nB);\\n\\n  for (let i = 0; i &lt; mA; i++) {\\n    for (let j = 0; j &lt; nB; j++) {\\n      for (let k = 0; k &lt; nA; k++) {\\n        result[i][j] += A[i][k] * B[k][j];\\n      }\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction vectorAdd() {\\n  let m = arguments.length;\\n  let n = arguments[0].length;\\n \\n  let result = new Array(n).fill(0.0);\\n \\n  for (let i = 0; i &lt; n; i++) {\\n    for (let j = 0; j &lt; m; j++) {\\n        result[i] += arguments[j][i];\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction norm(v) {\\n  return Math.sqrt(dot(v, v));\\n}\\n\\n\\nfunction deepCopy(x) {\\n  return JSON.parse(JSON.stringify(x));\\n}\\n\\n\\nfunction computeRho(r, newr, J, p) {\\n\\tlet r2 = norm(r) ** 2;\\n\\tlet num = r2 - norm(newr)**2;\\n\\tlet denom = r2 - norm(vectorAdd(r, mvMult(J, p))) ** 2;\\n\\n\\treturn num / denom;\\n}\\n\\n\\nfunction checkTol(r, tol) {\\n\\t\\n\\tconst n = r.length;\\n\\tfor (let i = 0; i &lt; n; i++) {\\n\\t\\tif (tol &lt; Math.abs(r[i])) return true;\\n\\t}\\n\\n\\treturn false;\\n}\\n\\n\\nfunction doglegStep(JTJ, JTr, normJTr, delta) {\\n\\t\\n\\tlet [pJ, posDef] = solvePosDef(JTJ, JTr);\\n\\tpJ = svMult(-1.0, pJ);\\n\\n\\t\\n\\tif (posDef &amp;&amp; norm(pJ) &lt;= delta) {\\n\\t\\treturn pJ;\\n\\t}\\n\\n\\t\\n\\tlet tau = Math.min(1, normJTr**3 / delta / quadForm(JTJ, JTr));\\n\\tlet pC = svMult(-tau * delta / normJTr, JTr);\\n\\n\\tlet pCnorm = norm(pC);\\n\\tif (!posDef || Math.abs(pCnorm - delta) &lt;= 1e-12) {\\n\\t\\treturn pC;\\n\\t}\\n\\n\\t\\n\\tlet pJ2 = norm(pJ) ** 2;\\n\\tlet pC2 = pCnorm**2;\\n\\tlet pJpC = dot(pJ, pC);\\n\\tlet a = pJ2 + pC2 - 2.0 * pJpC;\\n\\tlet b = 2.0 * (pJpC - pC2);\\n\\tlet c = pC2 - delta**2;\\n\\tlet q = -0.5 * (b + Math.sign(b) * Math.sqrt(b**2 - 4.0 * a * c));\\n\\n\\t\\n\\tlet beta;\\n\\tif (Math.abs(b) &lt; 1e-12) beta = Math.sqrt(-c / a);\\n\\telse if (b &lt; 0.0) beta = q / a;\\n\\telse beta = c / q;\\n\\n\\t\\n\\tif (0.0 &lt;= beta &amp;&amp; beta &lt;= 1) {\\n\\t\\treturn vectorAdd(pC, svMult(beta, vectorAdd(pJ, svMult(-1.0, pC))));\\n\\t} else { \\n\\t\\treturn pC;\\n\\t}\\n\\n}\\n\\n\\nfunction jacCentralDiff(f, x, args=[], eps=4.7e-6) {\\n\\t\\n\\tlet xPlus = deepCopy(x);\\n\\tlet xMinus = deepCopy(x);\\n\\n\\t\\n\\tlet fOfx = f(x, ...args);\\n\\tlet m = fOfx.length;\\n\\n\\t\\n\\tlet n = x.length;\\n\\n\\t\\n\\tlet J = zeros(m, n);\\n\\n\\t\\n\\tlet fOfxPlus;\\n\\tlet fOfxMinus;\\n\\n\\tfor (let j = 0; j &lt; n; j++) {\\n\\t\\txPlus[j] += eps;\\n\\t\\txMinus[j] -= eps;\\n\\t\\tfOfxPlus = f(xPlus, ...args);\\n\\t\\tfOfxMinus = f(xMinus, ...args);\\n\\t\\txPlus[j] -= eps;\\n\\t\\txMinus[j] += eps;\\n\\n\\t\\tfor (let i = 0; i &lt; m; i++) {\\n\\t\\t\\tJ[i][j] = (fOfxPlus[i] - fOfxMinus[i]) / 2.0 / eps;\\n\\t\\t}\\n\\t}\\n\\n\\treturn J;\\n}\\n\\n\\nfunction zeros(...dims) {\\n  let A = [];\\n\\n  \\n  for (let i = dims.length - 1; i &gt;= 0; i--) {\\n    let size = dims[i];\\n    if (i === dims.length - 1) {\\n      \\n      A = new Array(size).fill(0.0);\\n    } else {\\n      \\n      A = new Array(size).fill().map(() =&gt; deepCopy(A));\\n    }\\n  }\\n\\n  return A;\\n}\\n\\n\\nfunction svMult(a, v) {\\n  return v.map(x =&gt; a * x);\\n}\\n\\n\\nfunction quadForm(A, x) {\\n   return dot(x, mvMult(A, x)); \\n}\\n\\n\\nfunction solvePosDef(A, b) {\\n  let [L, p, success] = modifiedCholesky(A);\\n\\n  if (!success) {\\n    return [zeros(b.length), success];\\n  }\\n\\n  return [modifiedCholeskySolve(L, p, b), success];\\n}\\n\\n\\nfunction modifiedCholesky(A) {\\n    const floatEps = 1.0e-14;\\n    const n = A.length;\\n\\n    \\n    let L = deepCopy(A); \\n    let p = arange(0, n);\\n\\n    \\n    let success = true;\\n\\n    let xi = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        for (let j = 0; j &lt; i; j++) {\\n            let temp = Math.abs(L[i][j]);\\n            xi = Math.max(xi, temp);\\n        }\\n    }\\n\\n    let eta = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        let temp = Math.abs(L[i][i]);\\n        eta = Math.max(eta, temp);\\n    }\\n\\n    let beta;\\n    if (n &gt; 1) {\\n        beta = Math.sqrt(Math.max(eta, xi / Math.sqrt(n * n - 1)));\\n    } else {\\n        beta = Math.sqrt(eta);\\n    }\\n    beta = Math.max(beta, floatEps);\\n\\n    for (let k = 0; k &lt; n; k++) {\\n        \\n        let muVal = L[k][k];\\n        let mu = k;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            let temp = L[i][i];\\n            if (muVal &lt; temp) {\\n                mu = i;\\n                muVal = temp;\\n            }\\n        }\\n\\n        \\n        let iTemp = p[mu];\\n        p[mu] = p[k];\\n        p[k] = iTemp;\\n\\n        for (let i = 0; i &lt; k; i++) {\\n            let temp = L[k][i];\\n            L[k][i] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        let temp = L[k][k];\\n        L[k][k] = L[mu][mu];\\n        L[mu][mu] = temp;\\n        for (let i = k + 1; i &lt; mu; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        for (let i = mu + 1; i &lt; n; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[i][mu];\\n            L[i][mu] = temp;\\n        }\\n\\n        \\n        let cSum = 0;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            cSum = Math.max(cSum, Math.abs(L[i][k]));\\n        }\\n        cSum /= beta;\\n        cSum = cSum * cSum;\\n\\n        \\n        if (L[k][k] &lt; 0) {\\n            success = false;\\n        }\\n\\n        temp = Math.abs(L[k][k]);\\n        temp = Math.max(temp, floatEps * eta);\\n        temp = Math.max(temp, cSum);\\n        L[k][k] = Math.sqrt(temp);\\n\\n        \\n        for (let i = k + 1; i &lt; n; i++) {\\n            L[i][k] /= L[k][k];\\n        }\\n\\n        \\n        for (let j = k + 1; j &lt; n; j++) {\\n            for (let i = j; i &lt; n; i++) {\\n                L[i][j] -= L[i][k] * L[j][k];\\n            }\\n        }\\n\\n        \\n        for (let i = 0; i &lt; n - 1; i++) {\\n            for (let j = i + 1; j &lt; n; j++) {\\n                L[i][j] = 0.0;\\n            }\\n        }\\n    }\\n\\n    return [L, p, success];\\n}\\n\\n\\nfunction modifiedCholeskySolve(L, p, b) {\\n    const n = L.length;\\n\\n    let U = transpose(L);\\n    let xp = new Array(n).fill(0);\\n    for (let i = 0; i &lt; n; i++) {\\n        xp[i] = b[p[i]];\\n    }\\n\\n    \\n    let x = lowerTriSolve(L, xp);\\n\\n    \\n    xp = upperTriSolve(U, x);\\n\\n    for (let i = 0; i &lt; n; i++) {\\n        x[p[i]] = xp[i];\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction lowerTriSolve(L, b) {\\n    const floatEps = 1.0e-14;\\n    const n = L.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = 0; j &lt; n - 1; j++) {\\n        if (Math.abs(L[j][j]) &gt; floatEps) {\\n            x[j] /= L[j][j];\\n            for (let i = j + 1; i &lt; n; i++) {\\n                x[i] -= x[j] * L[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(L[n - 1][n - 1]) &gt; floatEps) {\\n            x[n - 1] /= L[n - 1][n - 1];\\n        } else {\\n            x[n - 1] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction upperTriSolve(U, b) {\\n    const floatEps = 1.0e-14;\\n    const n = U.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = n - 1; j &gt; 0; j--) {\\n        if (Math.abs(U[j][j]) &gt; floatEps) {\\n            x[j] /= U[j][j];\\n            for (let i = 0; i &lt; j; i++) {\\n                x[i] -= x[j] * U[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(U[0][0]) &gt; floatEps) {\\n            x[0] /= U[0][0];\\n        } else {\\n            x[0] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nclass VonMisesDistribution extends ContinuousUnivariateDistribution {\\n  \\n  \\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Von Mises&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Math.PI;\\n    this.hardMax = Math.PI;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03ba&#x27;];\\n\\n    \\n    this.locationParam = &#x27;\\u03bc&#x27;;\\n\\n    \\n    this.paramMin = [-Math.PI, 0.0];\\n\\n    \\n    this.paramMax = [Math.PI, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds();\\n\\n    \\n    super.generateLocationParamIndex();\\n  }\\n\\n  xMin(params) {\\n    return this.hardMin;\\n  }\\n\\n  xMax(params) {\\n    return this.hardMax;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let [mu, kappa] = params.slice(0, 2);\\n\\n    return Math.exp(kappa * cosm1(x - mu)) / (2 * Math.PI * besseli0(kappa, true));\\n  }\\n\\n  cdfSingleValueNormalApprox(x, params) {\\n    \\n    let [mu, kappa] = params.slice(0, 2);\\n    let sigma = 1.0 / Math.sqrt(kappa);\\n    let twopi = 2.0 * Math.PI;\\n\\n    let normal = new NormalDistribution();\\n    let result = normal.cdfSingleValue(x, [mu - twopi, sigma]);\\n    result -= normal.cdfSingleValue(-Math.PI, [mu - twopi, sigma]);\\n    result += normal.cdfSingleValue(x, [mu, sigma]);\\n    result -= normal.cdfSingleValue(-Math.PI, [mu, sigma]);\\n    result += normal.cdfSingleValue(x, [mu + twopi, sigma]);\\n    result -= normal.cdfSingleValue(-Math.PI, [mu + twopi, sigma]);\\n\\n    return result\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let [mu, kappa] = params.slice(0, 2);\\n    let result;\\n\\n    if (isclose(x, this.hardMin)) result = 0;\\n    else if (isclose(x, this.hardMax)) result = 1;\\n    else if (kappa &gt; 50) {\\n      result = this.cdfSingleValueNormalApprox(x, params);\\n    } else {\\n      \\n      let nChebPoints = 100;\\n\\n      let f = (x) =&gt; this.pdfSingleValue(x, params);\\n      result = clenshawCurtisIntegrate(f, this.hardMin, x, nChebPoints);\\n    }\\n\\n    return result;\\n  }\\n\\n  \\n  cdfSingleValueForMu0(x, params) {\\n    let [mu, kappa] = params.slice(0, 2);\\n\\n    if (!isclose(mu, 0)) {\\n      throw new Error(\\"cdfSingleValueFor Mu0 only works for \\u03bc = 0.\\")\\n    }\\n\\n    let vonMisesSeries = (k, y, p) =&gt; {\\n      let s = Math.sin(y);\\n      let c = Math.cos(y);\\n      let sn = Math.sin(p * y);\\n      let cn = Math.cos(p * y);\\n      let R = 0;\\n      let V = 0;\\n\\n      for (let n = p - 1; n &gt; 0; n--) {\\n        [sn, cn] = [sn * c - cn * s, cn * c + sn * s];\\n        R = 1.0 / (2 * n / k + R);\\n        V = R * (sn / n + V);\\n      }\\n\\n      return 0.5 + y / (2 * Math.PI) + V / Math.PI;\\n    } \\n\\n    let vonMisesNormalApprox = (k, y) =&gt; {\\n      let b = Math.sqrt(2 * Math.PI) / besseli0(k, true);\\n      let z = b * Math.sin(y / 2.0)\\n\\n      return (1 + erf(z / Math.sqrt(2))) / 2;\\n    }\\n\\n    \\n    let y = x - mu;\\n\\n    \\n    let iy = Math.round(y / (2.0 * Math.PI))\\n    y -= iy * (2 * Math.PI)\\n\\n    \\n    let CK = 50;\\n    let [a1, a2, a3, a4] = [28.0, 0.5, 100.0, 5.0];\\n\\n    \\n    let result;\\n    if (kappa &gt;= CK) result = vonMisesNormalApprox(kappa, y);\\n    else {\\n    let p = Math.floor(1 + a1 + a2 * kappa - a3 / (kappa + a4));\\n        result = vonMisesSeries(kappa, y, p)\\n        result = result &lt; 0 ? 0 : result &gt; 1 ? 1 : result;\\n    }\\n\\n    return result;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p == 0) return 0.0;\\n    if (p == 1) return 2.0 * Math.PI;\\n\\n    \\n    let rootFun = (x, params, p) =&gt; p - this.cdfSingleValue(x, params);\\n    \\n    let result = brentSolve(rootFun, this.hardMin, this.hardMax, [params, p]);\\n\\n    if (result === null) return 0.0;\\n    else return result;\\n  }\\n\\n  defaultXRange(params) {\\n    return [this.hardMin, this.hardMax];\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    if (x1 &lt;= -Math.PI || x1 &gt;= Math.PI || x2 &lt;= -Math.PI || x2 &gt;= Math.PI) {\\n      throw new Error(\\"lower and upper \\" + this.varName + \\" must be in interval (-\\u03c0 and \\u03c0).\\")\\n    }\\n\\n    \\n    const quantileRootFun = (params, x1, p1, x2, p2) =&gt; {\\n      \\n      let mu = Math.PI * (2 / (1 + Math.exp(-params[0])) - 1);\\n      let kappa = Math.exp(params[1]);\\n\\n      let r1 = this.cdfSingleValue(x1, [mu, kappa]) - p1;\\n      let r2 = this.cdfSingleValue(x2, [mu, kappa]) - p2;\\n\\n      return [r1, r2];\\n    };\\n\\n    \\n    let normal = new NormalDistribution();\\n    let [paramsOpt, optimSuccess] = normal.quantileSet(x, p);\\n    let [muGuess, sigmaGuess] = paramsOpt;\\n    let guess;\\n    if (optimSuccess &amp;&amp; muGuess &gt; -Math.PI &amp;&amp; muGuess &lt; Math.PI) {\\n      guess = [Math.log((Math.PI + muGuess) / (Math.PI - muGuess)), -2 * Math.log(sigmaGuess)];\\n    }\\n    else {\\n      guess = [0.0, 0.0];\\n    }\\n\\n    \\n    let args = [x1, p1, x2, p2];\\n    [paramsOpt, optimSuccess] = findRootTrustRegion(\\n      quantileRootFun, \\n      guess, \\n      args, \\n      jacCentralDiff,\\n      0.00001,  \\n      1000      \\n    );\\n    paramsOpt = [Math.PI * (2 / (1 + Math.exp(-paramsOpt[0])) - 1), Math.exp(paramsOpt[1])];\\n\\n    return [paramsOpt, optimSuccess];\\n  }\\n}\\n\\n\\n\\nvar dist = new VonMisesDistribution();\\n\\n\\n\\nif (quantileSetterSwitch.active) {\\n  quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p);\\n}"}}]]]},"disabled":true,"width":80,"value":"-2.6246"}},{"id":"p3606"}]],["pBoxes",[{"id":"p3607"},{"id":"p3608"}]],["quantileSetterSwitch",{"id":"p3610"}],["quantileSetterDiv",{"id":"p3609"}],["triggerCallbacks",{"id":"p3611"}],["startBoxes",[{"id":"p3601"},{"id":"p3602"}]],["endBoxes",[{"id":"p3603"},{"id":"p3604"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.floor(xRange.start);\\n  let xRangeMax = Math.ceil(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c = [xRangeMin - 1, ...x_p.flatMap(x =&gt; [x, x]), xRangeMax + 1];\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = -0.04;\\n    p_c.y_range.end = 1.04;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = -pdfMax * 0.04;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264&#x27; + xMax.toString() + &#x27;.&lt;/p\\\\&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nclass NormalDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Normal&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.locationParam = &#x27;\\u03bc&#x27;;\\n\\n    \\n    this.paramMin = [-Infinity, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds();\\n\\n    \\n    super.generateLocationParamIndex();\\n}\\n\\n  xMin(params) {\\n    return -Infinity;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x === -Infinity || x === Infinity) return 0.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    let expTerm = (Math.pow(x - mu, 2) / 2.0 / Math.pow(sigma, 2));\\n    return Math.exp(-expTerm) / sigma / Math.sqrt(2 * Math.PI);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x === -Infinity) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    return (1 + erf((x - mu) / sigma / Math.sqrt(2))) / 2;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return -Infinity;\\n    if (p === 1) return Infinity;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return mu + sqrt2 * sigma * erfinv(2 * p - 1);\\n  }\\n\\n  defaultXRange(params) {\\n    return this.ppf([0.001, 0.999], params);\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    let sqrt2 = 1.4142135623730951;\\n\\n    let sigmaCoeff1 = sqrt2 * erfinv(2 * p1 - 1);\\n    let sigmaCoeff2 = sqrt2 * erfinv(2 * p2 - 1);\\n\\n    let sigma = (x2 - x1) / (sigmaCoeff2 - sigmaCoeff1);\\n    let mu = x2 - sigmaCoeff2 * sigma;\\n\\n    return [[mu, sigma], true];\\n  }\\n}\\n\\nfunction isclose(x, y, rtol = 1.0e-7, atol = 1.0e-8) {\\n  return Math.abs(x - y) &lt;= (atol + rtol * Math.abs(y));\\n}\\n\\n\\nfunction erf(x) {\\n  \\n  var a = [1.00002368,\\n           0.37409196,\\n           0.09678418,\\n           -0.18628806,\\n           0.27886807,\\n           -1.13520398,\\n           1.48851587,\\n           -0.82215223,\\n           0.17087277];\\n\\n  var t = 1 / (1 + Math.abs(x)/2);\\n  var expSum = -Math.pow(x, 2) - 1.26551223;\\n\\n  for (var i = 0; i &lt; a.length; i++) {\\n      expSum += a[i] * Math.pow(t, i+1);\\n  }\\n\\n  var result = 1 - t * Math.exp(expSum);\\n\\n  if (x &lt; 0) return -result;\\n  return result;\\n}\\n\\n\\nfunction besseli0(x, expWeighted = false) {\\n\\n  let A = [\\n    -4.41534164647933937950e-18,\\n     3.33079451882223809783e-17,\\n    -2.43127984654795469359e-16,\\n     1.71539128555513303061e-15,\\n    -1.16853328779934516808e-14,\\n     7.67618549860493561688e-14,\\n    -4.85644678311192946090e-13,\\n     2.95505266312963983461e-12,\\n    -1.72682629144155570723e-11,\\n     9.67580903537323691224e-11,\\n    -5.18979560163526290666e-10,\\n     2.65982372468238665035e-9,\\n    -1.30002500998624804212e-8,\\n     6.04699502254191894932e-8,\\n    -2.67079385394061173391e-7,\\n     1.11738753912010371815e-6,\\n    -4.41673835845875056359e-6,\\n     1.64484480707288970893e-5,\\n    -5.75419501008210370398e-5,\\n     1.88502885095841655729e-4,\\n    -5.76375574538582365885e-4,\\n     1.63947561694133579842e-3,\\n    -4.32430999505057594430e-3,\\n     1.05464603945949983183e-2,\\n    -2.37374148058994688156e-2,\\n     4.93052842396707084878e-2,\\n    -9.49010970480476444210e-2,\\n     1.71620901522208775349e-1,\\n    -3.04682672343198398683e-1,\\n     6.76795274409476084995e-1\\n  ];\\n\\n  let B = [\\n    -7.23318048787475395456e-18,\\n    -4.83050448594418207126e-18,\\n     4.46562142029675999901e-17,\\n     3.46122286769746109310e-17,\\n    -2.82762398051658348494e-16,\\n    -3.42548561967721913462e-16,\\n     1.77256013305652638360e-15,\\n     3.81168066935262242075e-15,\\n    -9.55484669882830764870e-15,\\n    -4.15056934728722208663e-14,\\n     1.54008621752140982691e-14,\\n     3.85277838274214270114e-13,\\n     7.18012445138366623367e-13,\\n    -1.79417853150680611778e-12,\\n    -1.32158118404477131188e-11,\\n    -3.14991652796324136454e-11,\\n     1.18891471078464383424e-11,\\n     4.94060238822496958910e-10,\\n     3.39623202570838634515e-9,\\n     2.26666899049817806459e-8,\\n     2.04891858946906374183e-7,\\n     2.89137052083475648297e-6,\\n     6.88975834691682398426e-5,\\n     3.36911647825569408990e-3,\\n     8.04490411014108831608e-1\\n  ];\\n\\n  if ( x &lt; 0 ) x = -x;\\n\\n  let result;\\n  if (x &lt;= 8.0) {\\n    let y = x / 2.0 - 2.0;\\n    result = chbevl(y, A);\\n  } else {\\n    result = chbevl(32.0 / x - 2.0, B) / Math.sqrt(x)\\n  }\\n\\n  if (expWeighted) return result;\\n  else return Math.exp(x) * result;\\n}\\n\\n\\nfunction cosm1(x) {\\n\\n  let coeffs = [\\n     4.7377507964246204691685E-14,\\n    -1.1470284843425359765671E-11,\\n     2.0876754287081521758361E-9,\\n    -2.7557319214999787979814E-7,\\n     2.4801587301570552304991E-5,\\n    -1.3888888888888872993737E-3,\\n     4.1666666666666666609054E-2\\n   ];\\n\\n  let quarterPi = Math.PI / 4;\\n\\n  if (x &lt; quarterPi || x &gt; quarterPi) return Math.cos(x) - 1.0;\\n\\n  let x2 = x * x;\\n  return -0.5 * x2 + x2 * x2 * polevl(x2, coeffs);\\n}\\n\\n\\nfunction clenshawCurtisIntegrate(f, a, b, n = 100, args = [], weights = undefined) {\\n\\n  if (weights === undefined) {\\n    \\n    let ccWeights = clenshawCurtisWeights(n);\\n\\n    \\n    weights = ccWeights.map((x) =&gt; (b - a) / 2.0 * x);\\n  }\\n\\n  \\n  let x = chebPoints(n);\\n\\n  \\n  x = x.map((x) =&gt; (b - a) / 2.0 * x + (b + a) / 2.0);\\n\\n  \\n  let fVals = x.map((x) =&gt; f(x, ...args));\\n\\n  \\n  return dot(weights, fVals);\\n}\\n\\n\\nfunction findRootTrustRegion(\\n\\t\\tf, \\n\\t\\tx0, \\n\\t\\targs=[],\\n\\t\\tjac=jacCentralDiff,\\n\\t\\ttol=0.000000001, \\n\\t\\tmaxIters=10000, \\n\\t\\tdeltaBar=1000.0, \\n\\t\\teta=0.125, \\n\\t\\tminDelta=1e-12\\n  ) {\\n\\t\\n\\tlet x = deepCopy(x0);\\n\\n\\t\\n\\tlet delta = 0.99 * deltaBar;\\n\\n\\t\\n\\tlet r = f(x, ...args);\\n\\n\\t\\n\\tlet J = jac(f, x, args);\\n\\n\\t\\n\\tlet JTJ = mmMult(transpose(J), J);\\n\\n\\t\\n\\tlet JTr = mvMult(transpose(J), r);\\n\\n\\t\\n\\tlet normJTr = norm(JTr);\\n\\n\\tlet iters = 0;\\n\\twhile (iters &lt; maxIters &amp;&amp; checkTol(r, tol) &amp;&amp; delta &gt;= minDelta) {\\n\\t\\t\\n\\t\\tlet p = doglegStep(JTJ, JTr, normJTr, delta);\\n\\n\\t\\t\\n\\t\\tlet newr = f(vectorAdd(x, p), ...args);\\n\\t\\tlet rho = computeRho(r, newr, J, p);\\n\\n\\t\\t\\n\\t\\tif  (rho &lt; 0.25) {\\n\\t\\t\\tdelta = norm(p) / 4.0;\\n\\t\\t} else if (rho &gt; 0.75 &amp;&amp; Math.abs(norm(p) - delta) &lt; 1e-12) {\\n\\t\\t\\t\\tdelta = Math.min(2 * delta, deltaBar);\\n\\t\\t}\\n\\n\\t\\t\\n\\t\\tif (rho &gt; eta) {\\n\\t\\t\\tx = vectorAdd(x, p);\\n\\n\\t\\t\\tr = newr;\\n\\t\\t\\tJ = jac(f, x, args);\\n\\t\\t\\tJTJ = mmMult(transpose(J), J);\\n\\t\\t\\tJTr = mvMult(transpose(J), r);\\n\\t\\t\\tnormJTr = norm(JTr);\\n\\t\\t}\\n\\n\\t\\titers += 1;\\n\\t}\\n\\n\\tlet success = !checkTol(r, tol);\\n\\n\\treturn [x, success];\\n\\n}\\n\\n\\nfunction brentSolve(f, lower, upper, args=[], tol=1e-8, maxIter=1000) {\\n\\tlet a = lower;\\n\\tlet b = upper;\\n  let fa = f(a, ...args);\\n  let fb = f(b, ...args);\\n\\n  \\n  if (Math.abs(fa) &lt; tol) return a;\\n  if (Math.abs(fb) &lt; tol) return b;\\n\\n  \\n  if (fa * fb &gt;= 0) {\\n  \\treturn null;\\n\\t}\\n\\n  \\n  let c = a;\\n  let fc = fa;\\n\\n\\tlet iter = 0;\\n  while (iter++ &lt; maxIter) {\\n  \\tlet prevStep = b - a;\\n\\n    \\n    if (Math.abs(fc) &lt; Math.abs(fb)) {      \\n    \\t[a, b, c] = [b, c, b];\\n    \\t[fa, fb, fc] = [fb, fc, fb];\\n    }\\n\\n    \\n    let newStep = (c - b) / 2.0;\\n\\n    \\n    let tolAdj = 1e-15 * Math.abs(b) + tol / 2;\\n\\n    \\n  \\tif (Math.abs(newStep) &lt;= tolAdj || fb === 0 ) {\\n    \\t\\treturn b;\\n  \\t}\\n\\n    \\n    if (Math.abs(prevStep) &gt; tolAdj &amp;&amp; Math.abs(fa) &gt; Math.abs(fb)) {\\n    \\tlet p;\\n    \\tlet q;\\n    \\tlet t1;\\n    \\tlet t2;\\n    \\tlet cb = c - b;\\n    \\tif (a === c) { \\n    \\t\\tt1 = fb / fa;\\n    \\t\\tp = cb * t1;\\n    \\t\\tq = 1.0 - t1;\\n    \\t}\\n    \\telse { \\n    \\t\\tq = fa / fc;\\n    \\t\\tt1 = fb / fc;\\n    \\t\\tt2 = fb / fa;\\n    \\t\\tp = t2 * (cb * q * (q - t1) - (b - a) * (t1 - 1.0));\\n    \\t\\tq = (q - 1.0) * (t1 - 1.0) * (t2 - 1.0);\\n    \\t}\\n\\n    \\t\\n    \\tif (p &gt; 0) q = -q;\\n    \\telse p = -p;\\n\\n    \\t\\n    \\tif (p &lt; (0.75 * cb * q - Math.abs(tolAdj * q) / 2.0) \\n    \\t\\t&amp;&amp; p &lt; Math.abs(prevStep * q / 2.0)) { \\n\\t        newStep = p / q;\\n      \\t}\\n    }\\n\\n    if (Math.abs(newStep) &lt; tolAdj) {\\n      newStep = (newStep &gt; 0) ? tolAdj : -tolAdj;\\n    }\\n\\n    \\n    a = b;\\n    fa = fb;\\n\\n    \\n    b += newStep;\\n    fb = f(b, ...args);\\n\\n\\t\\n    if ((fb &gt; 0 &amp;&amp; fc &gt; 0) || (fb &lt; 0 &amp;&amp; fc &lt; 0)) {\\n      c = a; \\n      fc = fa;\\n    }\\n  }\\n\\n  \\n  return null;\\n}\\n\\n\\nfunction erfinv(x) {\\n  \\n  let p = (x + 1.0) / 2.0;\\n\\n  \\n  if (p == 0.0) return -Infinity;\\n  if (p == 1.0) return Infinity;\\n  if (p &gt; 1.0 || p &lt; 0.0) return undefined;\\n\\n  let split1 = 0.425;\\n  let split2 = 5.0;\\n  let const1 = 0.180625;\\n  let const2 = 1.6;\\n\\n  \\n  let a0 = 3.3871327179;\\n  let a1 = 5.0434271938e1;\\n  let a2 = 1.5929113202e2;\\n  let a3 = 5.9109374720e1;\\n  let b1 = 1.7895169469e1;\\n  let b2 = 7.8757757664e1;\\n  let b3 = 6.7187563600e1;\\n\\n  \\n  let c0 = 1.4234372777;\\n  let c1 = 2.7568153900;\\n  let c2 = 1.3067284816;\\n  let c3 = 1.7023821103e-1;\\n  let d1 = 7.3700164250e-1;\\n  let d2 = 1.2021132975e-1;\\n\\n  \\n  let e0 = 6.6579051150;\\n  let e1 = 3.0812263860;\\n  let e2 = 4.2868294337e-1;\\n  let e3 = 1.7337203997e-2;\\n  let f1 = 2.4197894225e-1;\\n  let f2 = 1.2258202635e-2;\\n\\n  let r;\\n  let res;\\n  let q = p - 0.5;\\n\\n  if (Math.abs(q) &lt;= split1) {\\n    r = const1 - q * q;\\n    res = q * (((a3 * r + a2) * r + a1) * r + a0) /\\n              (((b3 * r + b2) * r + b1) * r + 1.0);\\n  } else {\\n    r = q &lt; 0 ? p : 1.0 - p;\\n\\n    r = Math.sqrt(-Math.log(r));\\n\\n    if (r &lt;= split2) {\\n      r -= const2;\\n      res = (((c3 * r + c2) * r + c1) * r + c0) /\\n             ((d2 * r + d1) * r + 1.0);\\n    } else {\\n      r -= split2;\\n      res = (((e3 * r + e2) * r + e1) * r + e0) /\\n             ((f2 * r + f1) * r + 1.0);\\n    }\\n  \\n    if (q &lt; 0) {\\n      res = -res;\\n    }\\n  }\\n\\n  \\n  return 0.7071067811865475 * res;\\n\\n}\\n\\n\\nfunction chbevl(x, A) {\\n\\n  let b0, b1, b2;\\n  let n = A.length;\\n  let i = n - 1;\\n\\n  b0 = A[0];\\n  b1 = 0.0;\\n\\n  for (let j = 1; j &lt;= i; j++) {\\n    b2 = b1;\\n    b1 = b0;\\n    b0 = x * b1 - b2 + A[j];\\n  }\\n\\n  return 0.5 * (b0 - b2);\\n}\\n\\n\\nfunction polevl(x, coef) {\\n\\n    let result;\\n    let n = coef.length;\\n\\n    let i = n;\\n\\n    result = coef[0];\\n\\n    for (let j = 1; j &lt;= n; j++) {\\n        result = result * x + coef[j];\\n    }\\n\\n    return result;\\n}\\n\\n\\nfunction chebPoints(n, low = -1, high = 1) {\\n  \\n  let points = Array.from({ length: n }, (_, i) =&gt; Math.cos(Math.PI * i / (n - 1)));\\n\\n  \\n  let m = (high - low) / 2.0;\\n  let b = (high + low) / 2.0;\\n\\n  points = points.map((x) =&gt; m * x + b);\\n\\n  return points;\\n}\\n\\n\\nfunction clenshawCurtisWeights(n) {\\n    n -= 1; \\n\\n    const theta = Array.from({ length: n + 1 }, (_, i) =&gt; Math.PI * i / n);\\n    let w = new Array(n + 1).fill(0);\\n    let v = new Array(n - 1).fill(1);\\n\\n    if (n % 2 === 0) {\\n        w[0] = 1.0 / (n ** 2 - 1);\\n        w[n] = w[0];\\n        for (let k = 1; k &lt; n / 2; k++) {\\n            for (let j = 1; j &lt; n; j++) {\\n                v[j - 1] -= 2.0 * Math.cos(2.0 * k * theta[j]) / (4.0 * k ** 2 - 1);\\n            }\\n        }\\n        for (let j = 1; j &lt; n; j++) {\\n            v[j - 1] -= Math.cos(n * theta[j]) / (n ** 2 - 1);\\n        }\\n    } else {\\n        w[0] = 1.0 / n ** 2;\\n        w[n] = w[0];\\n        for (let k = 1; k &lt;= (n - 1) / 2; k++) {\\n            for (let j = 1; j &lt; n; j++) {\\n                v[j - 1] -= 2.0 * Math.cos(2.0 * k * theta[j]) / (4.0 * k ** 2 - 1);\\n            }\\n        }\\n    }\\n\\n    for (let j = 1; j &lt; n; j++) {\\n        w[j] = 2.0 * v[j - 1] / n;\\n    }\\n\\n    return w;\\n}\\n\\n\\nfunction dot(v1, v2) {\\n  const n = v1.length;\\n  let result = 0.0;\\n  for (let i = 0; i &lt; n; i++) result += v1[i] * v2[i];\\n\\n  return result;\\n}\\n\\n\\nfunction transpose(A) {\\n    return A[0].map((_, colIndex) =&gt; A.map(row =&gt; row[colIndex]));\\n}\\n\\n\\nfunction mvMult(A, v) {\\n  return A.map(Arow =&gt; dot(Arow, v));\\n}\\n\\n\\nfunction mmMult(A, B) {\\n  let mA = A.length;\\n  let nA = A[0].length;\\n  let mB = B.length;\\n  let nB = B[0].length;\\n\\n  if (nA !== mB) {\\n      throw new Error(&#x27;Matrix dimension mismatch.&#x27;);\\n  }\\n\\n  let result = zeros(mA, nB);\\n\\n  for (let i = 0; i &lt; mA; i++) {\\n    for (let j = 0; j &lt; nB; j++) {\\n      for (let k = 0; k &lt; nA; k++) {\\n        result[i][j] += A[i][k] * B[k][j];\\n      }\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction vectorAdd() {\\n  let m = arguments.length;\\n  let n = arguments[0].length;\\n \\n  let result = new Array(n).fill(0.0);\\n \\n  for (let i = 0; i &lt; n; i++) {\\n    for (let j = 0; j &lt; m; j++) {\\n        result[i] += arguments[j][i];\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction norm(v) {\\n  return Math.sqrt(dot(v, v));\\n}\\n\\n\\nfunction deepCopy(x) {\\n  return JSON.parse(JSON.stringify(x));\\n}\\n\\n\\nfunction computeRho(r, newr, J, p) {\\n\\tlet r2 = norm(r) ** 2;\\n\\tlet num = r2 - norm(newr)**2;\\n\\tlet denom = r2 - norm(vectorAdd(r, mvMult(J, p))) ** 2;\\n\\n\\treturn num / denom;\\n}\\n\\n\\nfunction checkTol(r, tol) {\\n\\t\\n\\tconst n = r.length;\\n\\tfor (let i = 0; i &lt; n; i++) {\\n\\t\\tif (tol &lt; Math.abs(r[i])) return true;\\n\\t}\\n\\n\\treturn false;\\n}\\n\\n\\nfunction doglegStep(JTJ, JTr, normJTr, delta) {\\n\\t\\n\\tlet [pJ, posDef] = solvePosDef(JTJ, JTr);\\n\\tpJ = svMult(-1.0, pJ);\\n\\n\\t\\n\\tif (posDef &amp;&amp; norm(pJ) &lt;= delta) {\\n\\t\\treturn pJ;\\n\\t}\\n\\n\\t\\n\\tlet tau = Math.min(1, normJTr**3 / delta / quadForm(JTJ, JTr));\\n\\tlet pC = svMult(-tau * delta / normJTr, JTr);\\n\\n\\tlet pCnorm = norm(pC);\\n\\tif (!posDef || Math.abs(pCnorm - delta) &lt;= 1e-12) {\\n\\t\\treturn pC;\\n\\t}\\n\\n\\t\\n\\tlet pJ2 = norm(pJ) ** 2;\\n\\tlet pC2 = pCnorm**2;\\n\\tlet pJpC = dot(pJ, pC);\\n\\tlet a = pJ2 + pC2 - 2.0 * pJpC;\\n\\tlet b = 2.0 * (pJpC - pC2);\\n\\tlet c = pC2 - delta**2;\\n\\tlet q = -0.5 * (b + Math.sign(b) * Math.sqrt(b**2 - 4.0 * a * c));\\n\\n\\t\\n\\tlet beta;\\n\\tif (Math.abs(b) &lt; 1e-12) beta = Math.sqrt(-c / a);\\n\\telse if (b &lt; 0.0) beta = q / a;\\n\\telse beta = c / q;\\n\\n\\t\\n\\tif (0.0 &lt;= beta &amp;&amp; beta &lt;= 1) {\\n\\t\\treturn vectorAdd(pC, svMult(beta, vectorAdd(pJ, svMult(-1.0, pC))));\\n\\t} else { \\n\\t\\treturn pC;\\n\\t}\\n\\n}\\n\\n\\nfunction jacCentralDiff(f, x, args=[], eps=4.7e-6) {\\n\\t\\n\\tlet xPlus = deepCopy(x);\\n\\tlet xMinus = deepCopy(x);\\n\\n\\t\\n\\tlet fOfx = f(x, ...args);\\n\\tlet m = fOfx.length;\\n\\n\\t\\n\\tlet n = x.length;\\n\\n\\t\\n\\tlet J = zeros(m, n);\\n\\n\\t\\n\\tlet fOfxPlus;\\n\\tlet fOfxMinus;\\n\\n\\tfor (let j = 0; j &lt; n; j++) {\\n\\t\\txPlus[j] += eps;\\n\\t\\txMinus[j] -= eps;\\n\\t\\tfOfxPlus = f(xPlus, ...args);\\n\\t\\tfOfxMinus = f(xMinus, ...args);\\n\\t\\txPlus[j] -= eps;\\n\\t\\txMinus[j] += eps;\\n\\n\\t\\tfor (let i = 0; i &lt; m; i++) {\\n\\t\\t\\tJ[i][j] = (fOfxPlus[i] - fOfxMinus[i]) / 2.0 / eps;\\n\\t\\t}\\n\\t}\\n\\n\\treturn J;\\n}\\n\\n\\nfunction zeros(...dims) {\\n  let A = [];\\n\\n  \\n  for (let i = dims.length - 1; i &gt;= 0; i--) {\\n    let size = dims[i];\\n    if (i === dims.length - 1) {\\n      \\n      A = new Array(size).fill(0.0);\\n    } else {\\n      \\n      A = new Array(size).fill().map(() =&gt; deepCopy(A));\\n    }\\n  }\\n\\n  return A;\\n}\\n\\n\\nfunction svMult(a, v) {\\n  return v.map(x =&gt; a * x);\\n}\\n\\n\\nfunction quadForm(A, x) {\\n   return dot(x, mvMult(A, x)); \\n}\\n\\n\\nfunction solvePosDef(A, b) {\\n  let [L, p, success] = modifiedCholesky(A);\\n\\n  if (!success) {\\n    return [zeros(b.length), success];\\n  }\\n\\n  return [modifiedCholeskySolve(L, p, b), success];\\n}\\n\\n\\nfunction modifiedCholesky(A) {\\n    const floatEps = 1.0e-14;\\n    const n = A.length;\\n\\n    \\n    let L = deepCopy(A); \\n    let p = arange(0, n);\\n\\n    \\n    let success = true;\\n\\n    let xi = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        for (let j = 0; j &lt; i; j++) {\\n            let temp = Math.abs(L[i][j]);\\n            xi = Math.max(xi, temp);\\n        }\\n    }\\n\\n    let eta = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        let temp = Math.abs(L[i][i]);\\n        eta = Math.max(eta, temp);\\n    }\\n\\n    let beta;\\n    if (n &gt; 1) {\\n        beta = Math.sqrt(Math.max(eta, xi / Math.sqrt(n * n - 1)));\\n    } else {\\n        beta = Math.sqrt(eta);\\n    }\\n    beta = Math.max(beta, floatEps);\\n\\n    for (let k = 0; k &lt; n; k++) {\\n        \\n        let muVal = L[k][k];\\n        let mu = k;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            let temp = L[i][i];\\n            if (muVal &lt; temp) {\\n                mu = i;\\n                muVal = temp;\\n            }\\n        }\\n\\n        \\n        let iTemp = p[mu];\\n        p[mu] = p[k];\\n        p[k] = iTemp;\\n\\n        for (let i = 0; i &lt; k; i++) {\\n            let temp = L[k][i];\\n            L[k][i] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        let temp = L[k][k];\\n        L[k][k] = L[mu][mu];\\n        L[mu][mu] = temp;\\n        for (let i = k + 1; i &lt; mu; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        for (let i = mu + 1; i &lt; n; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[i][mu];\\n            L[i][mu] = temp;\\n        }\\n\\n        \\n        let cSum = 0;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            cSum = Math.max(cSum, Math.abs(L[i][k]));\\n        }\\n        cSum /= beta;\\n        cSum = cSum * cSum;\\n\\n        \\n        if (L[k][k] &lt; 0) {\\n            success = false;\\n        }\\n\\n        temp = Math.abs(L[k][k]);\\n        temp = Math.max(temp, floatEps * eta);\\n        temp = Math.max(temp, cSum);\\n        L[k][k] = Math.sqrt(temp);\\n\\n        \\n        for (let i = k + 1; i &lt; n; i++) {\\n            L[i][k] /= L[k][k];\\n        }\\n\\n        \\n        for (let j = k + 1; j &lt; n; j++) {\\n            for (let i = j; i &lt; n; i++) {\\n                L[i][j] -= L[i][k] * L[j][k];\\n            }\\n        }\\n\\n        \\n        for (let i = 0; i &lt; n - 1; i++) {\\n            for (let j = i + 1; j &lt; n; j++) {\\n                L[i][j] = 0.0;\\n            }\\n        }\\n    }\\n\\n    return [L, p, success];\\n}\\n\\n\\nfunction modifiedCholeskySolve(L, p, b) {\\n    const n = L.length;\\n\\n    let U = transpose(L);\\n    let xp = new Array(n).fill(0);\\n    for (let i = 0; i &lt; n; i++) {\\n        xp[i] = b[p[i]];\\n    }\\n\\n    \\n    let x = lowerTriSolve(L, xp);\\n\\n    \\n    xp = upperTriSolve(U, x);\\n\\n    for (let i = 0; i &lt; n; i++) {\\n        x[p[i]] = xp[i];\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction lowerTriSolve(L, b) {\\n    const floatEps = 1.0e-14;\\n    const n = L.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = 0; j &lt; n - 1; j++) {\\n        if (Math.abs(L[j][j]) &gt; floatEps) {\\n            x[j] /= L[j][j];\\n            for (let i = j + 1; i &lt; n; i++) {\\n                x[i] -= x[j] * L[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(L[n - 1][n - 1]) &gt; floatEps) {\\n            x[n - 1] /= L[n - 1][n - 1];\\n        } else {\\n            x[n - 1] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction upperTriSolve(U, b) {\\n    const floatEps = 1.0e-14;\\n    const n = U.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = n - 1; j &gt; 0; j--) {\\n        if (Math.abs(U[j][j]) &gt; floatEps) {\\n            x[j] /= U[j][j];\\n            for (let i = 0; i &lt; j; i++) {\\n                x[i] -= x[j] * U[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(U[0][0]) &gt; floatEps) {\\n            x[0] /= U[0][0];\\n        } else {\\n            x[0] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nclass VonMisesDistribution extends ContinuousUnivariateDistribution {\\n  \\n  \\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Von Mises&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Math.PI;\\n    this.hardMax = Math.PI;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03ba&#x27;];\\n\\n    \\n    this.locationParam = &#x27;\\u03bc&#x27;;\\n\\n    \\n    this.paramMin = [-Math.PI, 0.0];\\n\\n    \\n    this.paramMax = [Math.PI, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds();\\n\\n    \\n    super.generateLocationParamIndex();\\n  }\\n\\n  xMin(params) {\\n    return this.hardMin;\\n  }\\n\\n  xMax(params) {\\n    return this.hardMax;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let [mu, kappa] = params.slice(0, 2);\\n\\n    return Math.exp(kappa * cosm1(x - mu)) / (2 * Math.PI * besseli0(kappa, true));\\n  }\\n\\n  cdfSingleValueNormalApprox(x, params) {\\n    \\n    let [mu, kappa] = params.slice(0, 2);\\n    let sigma = 1.0 / Math.sqrt(kappa);\\n    let twopi = 2.0 * Math.PI;\\n\\n    let normal = new NormalDistribution();\\n    let result = normal.cdfSingleValue(x, [mu - twopi, sigma]);\\n    result -= normal.cdfSingleValue(-Math.PI, [mu - twopi, sigma]);\\n    result += normal.cdfSingleValue(x, [mu, sigma]);\\n    result -= normal.cdfSingleValue(-Math.PI, [mu, sigma]);\\n    result += normal.cdfSingleValue(x, [mu + twopi, sigma]);\\n    result -= normal.cdfSingleValue(-Math.PI, [mu + twopi, sigma]);\\n\\n    return result\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let [mu, kappa] = params.slice(0, 2);\\n    let result;\\n\\n    if (isclose(x, this.hardMin)) result = 0;\\n    else if (isclose(x, this.hardMax)) result = 1;\\n    else if (kappa &gt; 50) {\\n      result = this.cdfSingleValueNormalApprox(x, params);\\n    } else {\\n      \\n      let nChebPoints = 100;\\n\\n      let f = (x) =&gt; this.pdfSingleValue(x, params);\\n      result = clenshawCurtisIntegrate(f, this.hardMin, x, nChebPoints);\\n    }\\n\\n    return result;\\n  }\\n\\n  \\n  cdfSingleValueForMu0(x, params) {\\n    let [mu, kappa] = params.slice(0, 2);\\n\\n    if (!isclose(mu, 0)) {\\n      throw new Error(\\"cdfSingleValueFor Mu0 only works for \\u03bc = 0.\\")\\n    }\\n\\n    let vonMisesSeries = (k, y, p) =&gt; {\\n      let s = Math.sin(y);\\n      let c = Math.cos(y);\\n      let sn = Math.sin(p * y);\\n      let cn = Math.cos(p * y);\\n      let R = 0;\\n      let V = 0;\\n\\n      for (let n = p - 1; n &gt; 0; n--) {\\n        [sn, cn] = [sn * c - cn * s, cn * c + sn * s];\\n        R = 1.0 / (2 * n / k + R);\\n        V = R * (sn / n + V);\\n      }\\n\\n      return 0.5 + y / (2 * Math.PI) + V / Math.PI;\\n    } \\n\\n    let vonMisesNormalApprox = (k, y) =&gt; {\\n      let b = Math.sqrt(2 * Math.PI) / besseli0(k, true);\\n      let z = b * Math.sin(y / 2.0)\\n\\n      return (1 + erf(z / Math.sqrt(2))) / 2;\\n    }\\n\\n    \\n    let y = x - mu;\\n\\n    \\n    let iy = Math.round(y / (2.0 * Math.PI))\\n    y -= iy * (2 * Math.PI)\\n\\n    \\n    let CK = 50;\\n    let [a1, a2, a3, a4] = [28.0, 0.5, 100.0, 5.0];\\n\\n    \\n    let result;\\n    if (kappa &gt;= CK) result = vonMisesNormalApprox(kappa, y);\\n    else {\\n    let p = Math.floor(1 + a1 + a2 * kappa - a3 / (kappa + a4));\\n        result = vonMisesSeries(kappa, y, p)\\n        result = result &lt; 0 ? 0 : result &gt; 1 ? 1 : result;\\n    }\\n\\n    return result;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p == 0) return 0.0;\\n    if (p == 1) return 2.0 * Math.PI;\\n\\n    \\n    let rootFun = (x, params, p) =&gt; p - this.cdfSingleValue(x, params);\\n    \\n    let result = brentSolve(rootFun, this.hardMin, this.hardMax, [params, p]);\\n\\n    if (result === null) return 0.0;\\n    else return result;\\n  }\\n\\n  defaultXRange(params) {\\n    return [this.hardMin, this.hardMax];\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    if (x1 &lt;= -Math.PI || x1 &gt;= Math.PI || x2 &lt;= -Math.PI || x2 &gt;= Math.PI) {\\n      throw new Error(\\"lower and upper \\" + this.varName + \\" must be in interval (-\\u03c0 and \\u03c0).\\")\\n    }\\n\\n    \\n    const quantileRootFun = (params, x1, p1, x2, p2) =&gt; {\\n      \\n      let mu = Math.PI * (2 / (1 + Math.exp(-params[0])) - 1);\\n      let kappa = Math.exp(params[1]);\\n\\n      let r1 = this.cdfSingleValue(x1, [mu, kappa]) - p1;\\n      let r2 = this.cdfSingleValue(x2, [mu, kappa]) - p2;\\n\\n      return [r1, r2];\\n    };\\n\\n    \\n    let normal = new NormalDistribution();\\n    let [paramsOpt, optimSuccess] = normal.quantileSet(x, p);\\n    let [muGuess, sigmaGuess] = paramsOpt;\\n    let guess;\\n    if (optimSuccess &amp;&amp; muGuess &gt; -Math.PI &amp;&amp; muGuess &lt; Math.PI) {\\n      guess = [Math.log((Math.PI + muGuess) / (Math.PI - muGuess)), -2 * Math.log(sigmaGuess)];\\n    }\\n    else {\\n      guess = [0.0, 0.0];\\n    }\\n\\n    \\n    let args = [x1, p1, x2, p2];\\n    [paramsOpt, optimSuccess] = findRootTrustRegion(\\n      quantileRootFun, \\n      guess, \\n      args, \\n      jacCentralDiff,\\n      0.00001,  \\n      1000      \\n    );\\n    paramsOpt = [Math.PI * (2 / (1 + Math.exp(-paramsOpt[0])) - 1), Math.exp(paramsOpt[1])];\\n\\n    return [paramsOpt, optimSuccess];\\n  }\\n}\\n\\n\\n\\nvar dist = new VonMisesDistribution();\\n\\n\\n\\nif (triggerCallbacks.active &amp;&amp; !cb_obj.disabled) {\\n\\tif (quantileSetterSwitch.active) {\\n\\t\\tquantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p);\\n\\t}\\n\\telse {\\n\\t\\tupdateData(source_p, source_c, p_p, sliders, discrete);\\n\\t\\tupdateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes);\\n\\t}\\n}"}}]]]},"width":200,"title":"\\u03bc","format":{"type":"object","name":"CustomJSTickFormatter","id":"p3597","attributes":{"code":"return tick.toPrecision(4)"}},"start":-3.1416,"end":3.1416,"value":0,"step":0.01}},{"id":"p3600"}]],["xBoxes",[{"id":"p3605"},{"id":"p3606"}]],["pBoxes",[{"id":"p3607"},{"id":"p3608"}]],["quantileSetterSwitch",{"id":"p3610"}],["quantileSetterDiv",{"id":"p3609"}],["triggerCallbacks",{"id":"p3611"}],["startBoxes",[{"id":"p3601"},{"id":"p3602"}]],["endBoxes",[{"id":"p3603"},{"id":"p3604"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.floor(xRange.start);\\n  let xRangeMax = Math.ceil(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c = [xRangeMin - 1, ...x_p.flatMap(x =&gt; [x, x]), xRangeMax + 1];\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = -0.04;\\n    p_c.y_range.end = 1.04;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = -pdfMax * 0.04;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264&#x27; + xMax.toString() + &#x27;.&lt;/p\\\\&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nclass NormalDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Normal&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.locationParam = &#x27;\\u03bc&#x27;;\\n\\n    \\n    this.paramMin = [-Infinity, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds();\\n\\n    \\n    super.generateLocationParamIndex();\\n}\\n\\n  xMin(params) {\\n    return -Infinity;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x === -Infinity || x === Infinity) return 0.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    let expTerm = (Math.pow(x - mu, 2) / 2.0 / Math.pow(sigma, 2));\\n    return Math.exp(-expTerm) / sigma / Math.sqrt(2 * Math.PI);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x === -Infinity) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    return (1 + erf((x - mu) / sigma / Math.sqrt(2))) / 2;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return -Infinity;\\n    if (p === 1) return Infinity;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return mu + sqrt2 * sigma * erfinv(2 * p - 1);\\n  }\\n\\n  defaultXRange(params) {\\n    return this.ppf([0.001, 0.999], params);\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    let sqrt2 = 1.4142135623730951;\\n\\n    let sigmaCoeff1 = sqrt2 * erfinv(2 * p1 - 1);\\n    let sigmaCoeff2 = sqrt2 * erfinv(2 * p2 - 1);\\n\\n    let sigma = (x2 - x1) / (sigmaCoeff2 - sigmaCoeff1);\\n    let mu = x2 - sigmaCoeff2 * sigma;\\n\\n    return [[mu, sigma], true];\\n  }\\n}\\n\\nfunction isclose(x, y, rtol = 1.0e-7, atol = 1.0e-8) {\\n  return Math.abs(x - y) &lt;= (atol + rtol * Math.abs(y));\\n}\\n\\n\\nfunction erf(x) {\\n  \\n  var a = [1.00002368,\\n           0.37409196,\\n           0.09678418,\\n           -0.18628806,\\n           0.27886807,\\n           -1.13520398,\\n           1.48851587,\\n           -0.82215223,\\n           0.17087277];\\n\\n  var t = 1 / (1 + Math.abs(x)/2);\\n  var expSum = -Math.pow(x, 2) - 1.26551223;\\n\\n  for (var i = 0; i &lt; a.length; i++) {\\n      expSum += a[i] * Math.pow(t, i+1);\\n  }\\n\\n  var result = 1 - t * Math.exp(expSum);\\n\\n  if (x &lt; 0) return -result;\\n  return result;\\n}\\n\\n\\nfunction besseli0(x, expWeighted = false) {\\n\\n  let A = [\\n    -4.41534164647933937950e-18,\\n     3.33079451882223809783e-17,\\n    -2.43127984654795469359e-16,\\n     1.71539128555513303061e-15,\\n    -1.16853328779934516808e-14,\\n     7.67618549860493561688e-14,\\n    -4.85644678311192946090e-13,\\n     2.95505266312963983461e-12,\\n    -1.72682629144155570723e-11,\\n     9.67580903537323691224e-11,\\n    -5.18979560163526290666e-10,\\n     2.65982372468238665035e-9,\\n    -1.30002500998624804212e-8,\\n     6.04699502254191894932e-8,\\n    -2.67079385394061173391e-7,\\n     1.11738753912010371815e-6,\\n    -4.41673835845875056359e-6,\\n     1.64484480707288970893e-5,\\n    -5.75419501008210370398e-5,\\n     1.88502885095841655729e-4,\\n    -5.76375574538582365885e-4,\\n     1.63947561694133579842e-3,\\n    -4.32430999505057594430e-3,\\n     1.05464603945949983183e-2,\\n    -2.37374148058994688156e-2,\\n     4.93052842396707084878e-2,\\n    -9.49010970480476444210e-2,\\n     1.71620901522208775349e-1,\\n    -3.04682672343198398683e-1,\\n     6.76795274409476084995e-1\\n  ];\\n\\n  let B = [\\n    -7.23318048787475395456e-18,\\n    -4.83050448594418207126e-18,\\n     4.46562142029675999901e-17,\\n     3.46122286769746109310e-17,\\n    -2.82762398051658348494e-16,\\n    -3.42548561967721913462e-16,\\n     1.77256013305652638360e-15,\\n     3.81168066935262242075e-15,\\n    -9.55484669882830764870e-15,\\n    -4.15056934728722208663e-14,\\n     1.54008621752140982691e-14,\\n     3.85277838274214270114e-13,\\n     7.18012445138366623367e-13,\\n    -1.79417853150680611778e-12,\\n    -1.32158118404477131188e-11,\\n    -3.14991652796324136454e-11,\\n     1.18891471078464383424e-11,\\n     4.94060238822496958910e-10,\\n     3.39623202570838634515e-9,\\n     2.26666899049817806459e-8,\\n     2.04891858946906374183e-7,\\n     2.89137052083475648297e-6,\\n     6.88975834691682398426e-5,\\n     3.36911647825569408990e-3,\\n     8.04490411014108831608e-1\\n  ];\\n\\n  if ( x &lt; 0 ) x = -x;\\n\\n  let result;\\n  if (x &lt;= 8.0) {\\n    let y = x / 2.0 - 2.0;\\n    result = chbevl(y, A);\\n  } else {\\n    result = chbevl(32.0 / x - 2.0, B) / Math.sqrt(x)\\n  }\\n\\n  if (expWeighted) return result;\\n  else return Math.exp(x) * result;\\n}\\n\\n\\nfunction cosm1(x) {\\n\\n  let coeffs = [\\n     4.7377507964246204691685E-14,\\n    -1.1470284843425359765671E-11,\\n     2.0876754287081521758361E-9,\\n    -2.7557319214999787979814E-7,\\n     2.4801587301570552304991E-5,\\n    -1.3888888888888872993737E-3,\\n     4.1666666666666666609054E-2\\n   ];\\n\\n  let quarterPi = Math.PI / 4;\\n\\n  if (x &lt; quarterPi || x &gt; quarterPi) return Math.cos(x) - 1.0;\\n\\n  let x2 = x * x;\\n  return -0.5 * x2 + x2 * x2 * polevl(x2, coeffs);\\n}\\n\\n\\nfunction clenshawCurtisIntegrate(f, a, b, n = 100, args = [], weights = undefined) {\\n\\n  if (weights === undefined) {\\n    \\n    let ccWeights = clenshawCurtisWeights(n);\\n\\n    \\n    weights = ccWeights.map((x) =&gt; (b - a) / 2.0 * x);\\n  }\\n\\n  \\n  let x = chebPoints(n);\\n\\n  \\n  x = x.map((x) =&gt; (b - a) / 2.0 * x + (b + a) / 2.0);\\n\\n  \\n  let fVals = x.map((x) =&gt; f(x, ...args));\\n\\n  \\n  return dot(weights, fVals);\\n}\\n\\n\\nfunction findRootTrustRegion(\\n\\t\\tf, \\n\\t\\tx0, \\n\\t\\targs=[],\\n\\t\\tjac=jacCentralDiff,\\n\\t\\ttol=0.000000001, \\n\\t\\tmaxIters=10000, \\n\\t\\tdeltaBar=1000.0, \\n\\t\\teta=0.125, \\n\\t\\tminDelta=1e-12\\n  ) {\\n\\t\\n\\tlet x = deepCopy(x0);\\n\\n\\t\\n\\tlet delta = 0.99 * deltaBar;\\n\\n\\t\\n\\tlet r = f(x, ...args);\\n\\n\\t\\n\\tlet J = jac(f, x, args);\\n\\n\\t\\n\\tlet JTJ = mmMult(transpose(J), J);\\n\\n\\t\\n\\tlet JTr = mvMult(transpose(J), r);\\n\\n\\t\\n\\tlet normJTr = norm(JTr);\\n\\n\\tlet iters = 0;\\n\\twhile (iters &lt; maxIters &amp;&amp; checkTol(r, tol) &amp;&amp; delta &gt;= minDelta) {\\n\\t\\t\\n\\t\\tlet p = doglegStep(JTJ, JTr, normJTr, delta);\\n\\n\\t\\t\\n\\t\\tlet newr = f(vectorAdd(x, p), ...args);\\n\\t\\tlet rho = computeRho(r, newr, J, p);\\n\\n\\t\\t\\n\\t\\tif  (rho &lt; 0.25) {\\n\\t\\t\\tdelta = norm(p) / 4.0;\\n\\t\\t} else if (rho &gt; 0.75 &amp;&amp; Math.abs(norm(p) - delta) &lt; 1e-12) {\\n\\t\\t\\t\\tdelta = Math.min(2 * delta, deltaBar);\\n\\t\\t}\\n\\n\\t\\t\\n\\t\\tif (rho &gt; eta) {\\n\\t\\t\\tx = vectorAdd(x, p);\\n\\n\\t\\t\\tr = newr;\\n\\t\\t\\tJ = jac(f, x, args);\\n\\t\\t\\tJTJ = mmMult(transpose(J), J);\\n\\t\\t\\tJTr = mvMult(transpose(J), r);\\n\\t\\t\\tnormJTr = norm(JTr);\\n\\t\\t}\\n\\n\\t\\titers += 1;\\n\\t}\\n\\n\\tlet success = !checkTol(r, tol);\\n\\n\\treturn [x, success];\\n\\n}\\n\\n\\nfunction brentSolve(f, lower, upper, args=[], tol=1e-8, maxIter=1000) {\\n\\tlet a = lower;\\n\\tlet b = upper;\\n  let fa = f(a, ...args);\\n  let fb = f(b, ...args);\\n\\n  \\n  if (Math.abs(fa) &lt; tol) return a;\\n  if (Math.abs(fb) &lt; tol) return b;\\n\\n  \\n  if (fa * fb &gt;= 0) {\\n  \\treturn null;\\n\\t}\\n\\n  \\n  let c = a;\\n  let fc = fa;\\n\\n\\tlet iter = 0;\\n  while (iter++ &lt; maxIter) {\\n  \\tlet prevStep = b - a;\\n\\n    \\n    if (Math.abs(fc) &lt; Math.abs(fb)) {      \\n    \\t[a, b, c] = [b, c, b];\\n    \\t[fa, fb, fc] = [fb, fc, fb];\\n    }\\n\\n    \\n    let newStep = (c - b) / 2.0;\\n\\n    \\n    let tolAdj = 1e-15 * Math.abs(b) + tol / 2;\\n\\n    \\n  \\tif (Math.abs(newStep) &lt;= tolAdj || fb === 0 ) {\\n    \\t\\treturn b;\\n  \\t}\\n\\n    \\n    if (Math.abs(prevStep) &gt; tolAdj &amp;&amp; Math.abs(fa) &gt; Math.abs(fb)) {\\n    \\tlet p;\\n    \\tlet q;\\n    \\tlet t1;\\n    \\tlet t2;\\n    \\tlet cb = c - b;\\n    \\tif (a === c) { \\n    \\t\\tt1 = fb / fa;\\n    \\t\\tp = cb * t1;\\n    \\t\\tq = 1.0 - t1;\\n    \\t}\\n    \\telse { \\n    \\t\\tq = fa / fc;\\n    \\t\\tt1 = fb / fc;\\n    \\t\\tt2 = fb / fa;\\n    \\t\\tp = t2 * (cb * q * (q - t1) - (b - a) * (t1 - 1.0));\\n    \\t\\tq = (q - 1.0) * (t1 - 1.0) * (t2 - 1.0);\\n    \\t}\\n\\n    \\t\\n    \\tif (p &gt; 0) q = -q;\\n    \\telse p = -p;\\n\\n    \\t\\n    \\tif (p &lt; (0.75 * cb * q - Math.abs(tolAdj * q) / 2.0) \\n    \\t\\t&amp;&amp; p &lt; Math.abs(prevStep * q / 2.0)) { \\n\\t        newStep = p / q;\\n      \\t}\\n    }\\n\\n    if (Math.abs(newStep) &lt; tolAdj) {\\n      newStep = (newStep &gt; 0) ? tolAdj : -tolAdj;\\n    }\\n\\n    \\n    a = b;\\n    fa = fb;\\n\\n    \\n    b += newStep;\\n    fb = f(b, ...args);\\n\\n\\t\\n    if ((fb &gt; 0 &amp;&amp; fc &gt; 0) || (fb &lt; 0 &amp;&amp; fc &lt; 0)) {\\n      c = a; \\n      fc = fa;\\n    }\\n  }\\n\\n  \\n  return null;\\n}\\n\\n\\nfunction erfinv(x) {\\n  \\n  let p = (x + 1.0) / 2.0;\\n\\n  \\n  if (p == 0.0) return -Infinity;\\n  if (p == 1.0) return Infinity;\\n  if (p &gt; 1.0 || p &lt; 0.0) return undefined;\\n\\n  let split1 = 0.425;\\n  let split2 = 5.0;\\n  let const1 = 0.180625;\\n  let const2 = 1.6;\\n\\n  \\n  let a0 = 3.3871327179;\\n  let a1 = 5.0434271938e1;\\n  let a2 = 1.5929113202e2;\\n  let a3 = 5.9109374720e1;\\n  let b1 = 1.7895169469e1;\\n  let b2 = 7.8757757664e1;\\n  let b3 = 6.7187563600e1;\\n\\n  \\n  let c0 = 1.4234372777;\\n  let c1 = 2.7568153900;\\n  let c2 = 1.3067284816;\\n  let c3 = 1.7023821103e-1;\\n  let d1 = 7.3700164250e-1;\\n  let d2 = 1.2021132975e-1;\\n\\n  \\n  let e0 = 6.6579051150;\\n  let e1 = 3.0812263860;\\n  let e2 = 4.2868294337e-1;\\n  let e3 = 1.7337203997e-2;\\n  let f1 = 2.4197894225e-1;\\n  let f2 = 1.2258202635e-2;\\n\\n  let r;\\n  let res;\\n  let q = p - 0.5;\\n\\n  if (Math.abs(q) &lt;= split1) {\\n    r = const1 - q * q;\\n    res = q * (((a3 * r + a2) * r + a1) * r + a0) /\\n              (((b3 * r + b2) * r + b1) * r + 1.0);\\n  } else {\\n    r = q &lt; 0 ? p : 1.0 - p;\\n\\n    r = Math.sqrt(-Math.log(r));\\n\\n    if (r &lt;= split2) {\\n      r -= const2;\\n      res = (((c3 * r + c2) * r + c1) * r + c0) /\\n             ((d2 * r + d1) * r + 1.0);\\n    } else {\\n      r -= split2;\\n      res = (((e3 * r + e2) * r + e1) * r + e0) /\\n             ((f2 * r + f1) * r + 1.0);\\n    }\\n  \\n    if (q &lt; 0) {\\n      res = -res;\\n    }\\n  }\\n\\n  \\n  return 0.7071067811865475 * res;\\n\\n}\\n\\n\\nfunction chbevl(x, A) {\\n\\n  let b0, b1, b2;\\n  let n = A.length;\\n  let i = n - 1;\\n\\n  b0 = A[0];\\n  b1 = 0.0;\\n\\n  for (let j = 1; j &lt;= i; j++) {\\n    b2 = b1;\\n    b1 = b0;\\n    b0 = x * b1 - b2 + A[j];\\n  }\\n\\n  return 0.5 * (b0 - b2);\\n}\\n\\n\\nfunction polevl(x, coef) {\\n\\n    let result;\\n    let n = coef.length;\\n\\n    let i = n;\\n\\n    result = coef[0];\\n\\n    for (let j = 1; j &lt;= n; j++) {\\n        result = result * x + coef[j];\\n    }\\n\\n    return result;\\n}\\n\\n\\nfunction chebPoints(n, low = -1, high = 1) {\\n  \\n  let points = Array.from({ length: n }, (_, i) =&gt; Math.cos(Math.PI * i / (n - 1)));\\n\\n  \\n  let m = (high - low) / 2.0;\\n  let b = (high + low) / 2.0;\\n\\n  points = points.map((x) =&gt; m * x + b);\\n\\n  return points;\\n}\\n\\n\\nfunction clenshawCurtisWeights(n) {\\n    n -= 1; \\n\\n    const theta = Array.from({ length: n + 1 }, (_, i) =&gt; Math.PI * i / n);\\n    let w = new Array(n + 1).fill(0);\\n    let v = new Array(n - 1).fill(1);\\n\\n    if (n % 2 === 0) {\\n        w[0] = 1.0 / (n ** 2 - 1);\\n        w[n] = w[0];\\n        for (let k = 1; k &lt; n / 2; k++) {\\n            for (let j = 1; j &lt; n; j++) {\\n                v[j - 1] -= 2.0 * Math.cos(2.0 * k * theta[j]) / (4.0 * k ** 2 - 1);\\n            }\\n        }\\n        for (let j = 1; j &lt; n; j++) {\\n            v[j - 1] -= Math.cos(n * theta[j]) / (n ** 2 - 1);\\n        }\\n    } else {\\n        w[0] = 1.0 / n ** 2;\\n        w[n] = w[0];\\n        for (let k = 1; k &lt;= (n - 1) / 2; k++) {\\n            for (let j = 1; j &lt; n; j++) {\\n                v[j - 1] -= 2.0 * Math.cos(2.0 * k * theta[j]) / (4.0 * k ** 2 - 1);\\n            }\\n        }\\n    }\\n\\n    for (let j = 1; j &lt; n; j++) {\\n        w[j] = 2.0 * v[j - 1] / n;\\n    }\\n\\n    return w;\\n}\\n\\n\\nfunction dot(v1, v2) {\\n  const n = v1.length;\\n  let result = 0.0;\\n  for (let i = 0; i &lt; n; i++) result += v1[i] * v2[i];\\n\\n  return result;\\n}\\n\\n\\nfunction transpose(A) {\\n    return A[0].map((_, colIndex) =&gt; A.map(row =&gt; row[colIndex]));\\n}\\n\\n\\nfunction mvMult(A, v) {\\n  return A.map(Arow =&gt; dot(Arow, v));\\n}\\n\\n\\nfunction mmMult(A, B) {\\n  let mA = A.length;\\n  let nA = A[0].length;\\n  let mB = B.length;\\n  let nB = B[0].length;\\n\\n  if (nA !== mB) {\\n      throw new Error(&#x27;Matrix dimension mismatch.&#x27;);\\n  }\\n\\n  let result = zeros(mA, nB);\\n\\n  for (let i = 0; i &lt; mA; i++) {\\n    for (let j = 0; j &lt; nB; j++) {\\n      for (let k = 0; k &lt; nA; k++) {\\n        result[i][j] += A[i][k] * B[k][j];\\n      }\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction vectorAdd() {\\n  let m = arguments.length;\\n  let n = arguments[0].length;\\n \\n  let result = new Array(n).fill(0.0);\\n \\n  for (let i = 0; i &lt; n; i++) {\\n    for (let j = 0; j &lt; m; j++) {\\n        result[i] += arguments[j][i];\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction norm(v) {\\n  return Math.sqrt(dot(v, v));\\n}\\n\\n\\nfunction deepCopy(x) {\\n  return JSON.parse(JSON.stringify(x));\\n}\\n\\n\\nfunction computeRho(r, newr, J, p) {\\n\\tlet r2 = norm(r) ** 2;\\n\\tlet num = r2 - norm(newr)**2;\\n\\tlet denom = r2 - norm(vectorAdd(r, mvMult(J, p))) ** 2;\\n\\n\\treturn num / denom;\\n}\\n\\n\\nfunction checkTol(r, tol) {\\n\\t\\n\\tconst n = r.length;\\n\\tfor (let i = 0; i &lt; n; i++) {\\n\\t\\tif (tol &lt; Math.abs(r[i])) return true;\\n\\t}\\n\\n\\treturn false;\\n}\\n\\n\\nfunction doglegStep(JTJ, JTr, normJTr, delta) {\\n\\t\\n\\tlet [pJ, posDef] = solvePosDef(JTJ, JTr);\\n\\tpJ = svMult(-1.0, pJ);\\n\\n\\t\\n\\tif (posDef &amp;&amp; norm(pJ) &lt;= delta) {\\n\\t\\treturn pJ;\\n\\t}\\n\\n\\t\\n\\tlet tau = Math.min(1, normJTr**3 / delta / quadForm(JTJ, JTr));\\n\\tlet pC = svMult(-tau * delta / normJTr, JTr);\\n\\n\\tlet pCnorm = norm(pC);\\n\\tif (!posDef || Math.abs(pCnorm - delta) &lt;= 1e-12) {\\n\\t\\treturn pC;\\n\\t}\\n\\n\\t\\n\\tlet pJ2 = norm(pJ) ** 2;\\n\\tlet pC2 = pCnorm**2;\\n\\tlet pJpC = dot(pJ, pC);\\n\\tlet a = pJ2 + pC2 - 2.0 * pJpC;\\n\\tlet b = 2.0 * (pJpC - pC2);\\n\\tlet c = pC2 - delta**2;\\n\\tlet q = -0.5 * (b + Math.sign(b) * Math.sqrt(b**2 - 4.0 * a * c));\\n\\n\\t\\n\\tlet beta;\\n\\tif (Math.abs(b) &lt; 1e-12) beta = Math.sqrt(-c / a);\\n\\telse if (b &lt; 0.0) beta = q / a;\\n\\telse beta = c / q;\\n\\n\\t\\n\\tif (0.0 &lt;= beta &amp;&amp; beta &lt;= 1) {\\n\\t\\treturn vectorAdd(pC, svMult(beta, vectorAdd(pJ, svMult(-1.0, pC))));\\n\\t} else { \\n\\t\\treturn pC;\\n\\t}\\n\\n}\\n\\n\\nfunction jacCentralDiff(f, x, args=[], eps=4.7e-6) {\\n\\t\\n\\tlet xPlus = deepCopy(x);\\n\\tlet xMinus = deepCopy(x);\\n\\n\\t\\n\\tlet fOfx = f(x, ...args);\\n\\tlet m = fOfx.length;\\n\\n\\t\\n\\tlet n = x.length;\\n\\n\\t\\n\\tlet J = zeros(m, n);\\n\\n\\t\\n\\tlet fOfxPlus;\\n\\tlet fOfxMinus;\\n\\n\\tfor (let j = 0; j &lt; n; j++) {\\n\\t\\txPlus[j] += eps;\\n\\t\\txMinus[j] -= eps;\\n\\t\\tfOfxPlus = f(xPlus, ...args);\\n\\t\\tfOfxMinus = f(xMinus, ...args);\\n\\t\\txPlus[j] -= eps;\\n\\t\\txMinus[j] += eps;\\n\\n\\t\\tfor (let i = 0; i &lt; m; i++) {\\n\\t\\t\\tJ[i][j] = (fOfxPlus[i] - fOfxMinus[i]) / 2.0 / eps;\\n\\t\\t}\\n\\t}\\n\\n\\treturn J;\\n}\\n\\n\\nfunction zeros(...dims) {\\n  let A = [];\\n\\n  \\n  for (let i = dims.length - 1; i &gt;= 0; i--) {\\n    let size = dims[i];\\n    if (i === dims.length - 1) {\\n      \\n      A = new Array(size).fill(0.0);\\n    } else {\\n      \\n      A = new Array(size).fill().map(() =&gt; deepCopy(A));\\n    }\\n  }\\n\\n  return A;\\n}\\n\\n\\nfunction svMult(a, v) {\\n  return v.map(x =&gt; a * x);\\n}\\n\\n\\nfunction quadForm(A, x) {\\n   return dot(x, mvMult(A, x)); \\n}\\n\\n\\nfunction solvePosDef(A, b) {\\n  let [L, p, success] = modifiedCholesky(A);\\n\\n  if (!success) {\\n    return [zeros(b.length), success];\\n  }\\n\\n  return [modifiedCholeskySolve(L, p, b), success];\\n}\\n\\n\\nfunction modifiedCholesky(A) {\\n    const floatEps = 1.0e-14;\\n    const n = A.length;\\n\\n    \\n    let L = deepCopy(A); \\n    let p = arange(0, n);\\n\\n    \\n    let success = true;\\n\\n    let xi = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        for (let j = 0; j &lt; i; j++) {\\n            let temp = Math.abs(L[i][j]);\\n            xi = Math.max(xi, temp);\\n        }\\n    }\\n\\n    let eta = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        let temp = Math.abs(L[i][i]);\\n        eta = Math.max(eta, temp);\\n    }\\n\\n    let beta;\\n    if (n &gt; 1) {\\n        beta = Math.sqrt(Math.max(eta, xi / Math.sqrt(n * n - 1)));\\n    } else {\\n        beta = Math.sqrt(eta);\\n    }\\n    beta = Math.max(beta, floatEps);\\n\\n    for (let k = 0; k &lt; n; k++) {\\n        \\n        let muVal = L[k][k];\\n        let mu = k;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            let temp = L[i][i];\\n            if (muVal &lt; temp) {\\n                mu = i;\\n                muVal = temp;\\n            }\\n        }\\n\\n        \\n        let iTemp = p[mu];\\n        p[mu] = p[k];\\n        p[k] = iTemp;\\n\\n        for (let i = 0; i &lt; k; i++) {\\n            let temp = L[k][i];\\n            L[k][i] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        let temp = L[k][k];\\n        L[k][k] = L[mu][mu];\\n        L[mu][mu] = temp;\\n        for (let i = k + 1; i &lt; mu; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        for (let i = mu + 1; i &lt; n; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[i][mu];\\n            L[i][mu] = temp;\\n        }\\n\\n        \\n        let cSum = 0;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            cSum = Math.max(cSum, Math.abs(L[i][k]));\\n        }\\n        cSum /= beta;\\n        cSum = cSum * cSum;\\n\\n        \\n        if (L[k][k] &lt; 0) {\\n            success = false;\\n        }\\n\\n        temp = Math.abs(L[k][k]);\\n        temp = Math.max(temp, floatEps * eta);\\n        temp = Math.max(temp, cSum);\\n        L[k][k] = Math.sqrt(temp);\\n\\n        \\n        for (let i = k + 1; i &lt; n; i++) {\\n            L[i][k] /= L[k][k];\\n        }\\n\\n        \\n        for (let j = k + 1; j &lt; n; j++) {\\n            for (let i = j; i &lt; n; i++) {\\n                L[i][j] -= L[i][k] * L[j][k];\\n            }\\n        }\\n\\n        \\n        for (let i = 0; i &lt; n - 1; i++) {\\n            for (let j = i + 1; j &lt; n; j++) {\\n                L[i][j] = 0.0;\\n            }\\n        }\\n    }\\n\\n    return [L, p, success];\\n}\\n\\n\\nfunction modifiedCholeskySolve(L, p, b) {\\n    const n = L.length;\\n\\n    let U = transpose(L);\\n    let xp = new Array(n).fill(0);\\n    for (let i = 0; i &lt; n; i++) {\\n        xp[i] = b[p[i]];\\n    }\\n\\n    \\n    let x = lowerTriSolve(L, xp);\\n\\n    \\n    xp = upperTriSolve(U, x);\\n\\n    for (let i = 0; i &lt; n; i++) {\\n        x[p[i]] = xp[i];\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction lowerTriSolve(L, b) {\\n    const floatEps = 1.0e-14;\\n    const n = L.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = 0; j &lt; n - 1; j++) {\\n        if (Math.abs(L[j][j]) &gt; floatEps) {\\n            x[j] /= L[j][j];\\n            for (let i = j + 1; i &lt; n; i++) {\\n                x[i] -= x[j] * L[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(L[n - 1][n - 1]) &gt; floatEps) {\\n            x[n - 1] /= L[n - 1][n - 1];\\n        } else {\\n            x[n - 1] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction upperTriSolve(U, b) {\\n    const floatEps = 1.0e-14;\\n    const n = U.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = n - 1; j &gt; 0; j--) {\\n        if (Math.abs(U[j][j]) &gt; floatEps) {\\n            x[j] /= U[j][j];\\n            for (let i = 0; i &lt; j; i++) {\\n                x[i] -= x[j] * U[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(U[0][0]) &gt; floatEps) {\\n            x[0] /= U[0][0];\\n        } else {\\n            x[0] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nclass VonMisesDistribution extends ContinuousUnivariateDistribution {\\n  \\n  \\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Von Mises&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Math.PI;\\n    this.hardMax = Math.PI;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03ba&#x27;];\\n\\n    \\n    this.locationParam = &#x27;\\u03bc&#x27;;\\n\\n    \\n    this.paramMin = [-Math.PI, 0.0];\\n\\n    \\n    this.paramMax = [Math.PI, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds();\\n\\n    \\n    super.generateLocationParamIndex();\\n  }\\n\\n  xMin(params) {\\n    return this.hardMin;\\n  }\\n\\n  xMax(params) {\\n    return this.hardMax;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let [mu, kappa] = params.slice(0, 2);\\n\\n    return Math.exp(kappa * cosm1(x - mu)) / (2 * Math.PI * besseli0(kappa, true));\\n  }\\n\\n  cdfSingleValueNormalApprox(x, params) {\\n    \\n    let [mu, kappa] = params.slice(0, 2);\\n    let sigma = 1.0 / Math.sqrt(kappa);\\n    let twopi = 2.0 * Math.PI;\\n\\n    let normal = new NormalDistribution();\\n    let result = normal.cdfSingleValue(x, [mu - twopi, sigma]);\\n    result -= normal.cdfSingleValue(-Math.PI, [mu - twopi, sigma]);\\n    result += normal.cdfSingleValue(x, [mu, sigma]);\\n    result -= normal.cdfSingleValue(-Math.PI, [mu, sigma]);\\n    result += normal.cdfSingleValue(x, [mu + twopi, sigma]);\\n    result -= normal.cdfSingleValue(-Math.PI, [mu + twopi, sigma]);\\n\\n    return result\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let [mu, kappa] = params.slice(0, 2);\\n    let result;\\n\\n    if (isclose(x, this.hardMin)) result = 0;\\n    else if (isclose(x, this.hardMax)) result = 1;\\n    else if (kappa &gt; 50) {\\n      result = this.cdfSingleValueNormalApprox(x, params);\\n    } else {\\n      \\n      let nChebPoints = 100;\\n\\n      let f = (x) =&gt; this.pdfSingleValue(x, params);\\n      result = clenshawCurtisIntegrate(f, this.hardMin, x, nChebPoints);\\n    }\\n\\n    return result;\\n  }\\n\\n  \\n  cdfSingleValueForMu0(x, params) {\\n    let [mu, kappa] = params.slice(0, 2);\\n\\n    if (!isclose(mu, 0)) {\\n      throw new Error(\\"cdfSingleValueFor Mu0 only works for \\u03bc = 0.\\")\\n    }\\n\\n    let vonMisesSeries = (k, y, p) =&gt; {\\n      let s = Math.sin(y);\\n      let c = Math.cos(y);\\n      let sn = Math.sin(p * y);\\n      let cn = Math.cos(p * y);\\n      let R = 0;\\n      let V = 0;\\n\\n      for (let n = p - 1; n &gt; 0; n--) {\\n        [sn, cn] = [sn * c - cn * s, cn * c + sn * s];\\n        R = 1.0 / (2 * n / k + R);\\n        V = R * (sn / n + V);\\n      }\\n\\n      return 0.5 + y / (2 * Math.PI) + V / Math.PI;\\n    } \\n\\n    let vonMisesNormalApprox = (k, y) =&gt; {\\n      let b = Math.sqrt(2 * Math.PI) / besseli0(k, true);\\n      let z = b * Math.sin(y / 2.0)\\n\\n      return (1 + erf(z / Math.sqrt(2))) / 2;\\n    }\\n\\n    \\n    let y = x - mu;\\n\\n    \\n    let iy = Math.round(y / (2.0 * Math.PI))\\n    y -= iy * (2 * Math.PI)\\n\\n    \\n    let CK = 50;\\n    let [a1, a2, a3, a4] = [28.0, 0.5, 100.0, 5.0];\\n\\n    \\n    let result;\\n    if (kappa &gt;= CK) result = vonMisesNormalApprox(kappa, y);\\n    else {\\n    let p = Math.floor(1 + a1 + a2 * kappa - a3 / (kappa + a4));\\n        result = vonMisesSeries(kappa, y, p)\\n        result = result &lt; 0 ? 0 : result &gt; 1 ? 1 : result;\\n    }\\n\\n    return result;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p == 0) return 0.0;\\n    if (p == 1) return 2.0 * Math.PI;\\n\\n    \\n    let rootFun = (x, params, p) =&gt; p - this.cdfSingleValue(x, params);\\n    \\n    let result = brentSolve(rootFun, this.hardMin, this.hardMax, [params, p]);\\n\\n    if (result === null) return 0.0;\\n    else return result;\\n  }\\n\\n  defaultXRange(params) {\\n    return [this.hardMin, this.hardMax];\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    if (x1 &lt;= -Math.PI || x1 &gt;= Math.PI || x2 &lt;= -Math.PI || x2 &gt;= Math.PI) {\\n      throw new Error(\\"lower and upper \\" + this.varName + \\" must be in interval (-\\u03c0 and \\u03c0).\\")\\n    }\\n\\n    \\n    const quantileRootFun = (params, x1, p1, x2, p2) =&gt; {\\n      \\n      let mu = Math.PI * (2 / (1 + Math.exp(-params[0])) - 1);\\n      let kappa = Math.exp(params[1]);\\n\\n      let r1 = this.cdfSingleValue(x1, [mu, kappa]) - p1;\\n      let r2 = this.cdfSingleValue(x2, [mu, kappa]) - p2;\\n\\n      return [r1, r2];\\n    };\\n\\n    \\n    let normal = new NormalDistribution();\\n    let [paramsOpt, optimSuccess] = normal.quantileSet(x, p);\\n    let [muGuess, sigmaGuess] = paramsOpt;\\n    let guess;\\n    if (optimSuccess &amp;&amp; muGuess &gt; -Math.PI &amp;&amp; muGuess &lt; Math.PI) {\\n      guess = [Math.log((Math.PI + muGuess) / (Math.PI - muGuess)), -2 * Math.log(sigmaGuess)];\\n    }\\n    else {\\n      guess = [0.0, 0.0];\\n    }\\n\\n    \\n    let args = [x1, p1, x2, p2];\\n    [paramsOpt, optimSuccess] = findRootTrustRegion(\\n      quantileRootFun, \\n      guess, \\n      args, \\n      jacCentralDiff,\\n      0.00001,  \\n      1000      \\n    );\\n    paramsOpt = [Math.PI * (2 / (1 + Math.exp(-paramsOpt[0])) - 1), Math.exp(paramsOpt[1])];\\n\\n    return [paramsOpt, optimSuccess];\\n  }\\n}\\n\\n\\n\\nvar dist = new VonMisesDistribution();\\n\\n\\n\\nlet params = paramsFromSliders(sliders); \\n\\n\\nlet [x1, x2] = dist.defaultXRange(params);\\n\\n\\ntriggerCallbacks.active = false;\\n\\n\\np_p.x_range.start = x1;\\np_p.x_range.end = x2;\\n\\nupdateData(source_p, source_c, p_p, sliders, discrete);\\n\\n\\nsetYRanges(p_p, p_c, source_p);  \\n\\ntriggerCallbacks.active = true;\\n"}}]]]},"x_range":{"id":"p3571"},"y_range":{"type":"object","name":"Range1d","id":"p3572","attributes":{"start":-0.04,"end":1.04}},"x_scale":{"type":"object","name":"LinearScale","id":"p3557"},"y_scale":{"type":"object","name":"LinearScale","id":"p3558"},"title":{"type":"object","name":"Title","id":"p3550","attributes":{"text":" "}},"renderers":[{"type":"object","name":"GlyphRenderer","id":"p3585","attributes":{"data_source":{"id":"p3576"},"view":{"type":"object","name":"CDSView","id":"p3586","attributes":{"filter":{"type":"object","name":"AllIndices","id":"p3587"}}},"glyph":{"type":"object","name":"Line","id":"p3582","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_width":2}},"nonselection_glyph":{"type":"object","name":"Line","id":"p3583","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_alpha":0.1,"line_width":2}},"muted_glyph":{"type":"object","name":"Line","id":"p3584","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_alpha":0.2,"line_width":2}}}}],"toolbar":{"type":"object","name":"Toolbar","id":"p3556","attributes":{"tools":[{"type":"object","name":"ResetTool","id":"p3569"},{"type":"object","name":"SaveTool","id":"p3570"}]}},"toolbar_location":null,"left":[{"type":"object","name":"LinearAxis","id":"p3564","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p3565","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p3566"},"axis_label":"CDF","axis_label_text_font_style":"normal","major_label_policy":{"type":"object","name":"AllLabels","id":"p3567"}}}],"below":[{"type":"object","name":"LinearAxis","id":"p3559","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p3560","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p3561"},"axis_label":"y","major_label_policy":{"type":"object","name":"AllLabels","id":"p3562"}}}],"center":[{"type":"object","name":"Grid","id":"p3563","attributes":{"axis":{"id":"p3559"}}},{"type":"object","name":"Grid","id":"p3568","attributes":{"dimension":1,"axis":{"id":"p3564"}}}],"frame_width":300,"frame_height":175,"background_fill_alpha":0,"border_fill_alpha":0}}],["source_p",{"id":"p3573"}],["source_c",{"id":"p3576"}],["discrete",false],["n",400],["sliders",[{"id":"p3598"},{"id":"p3600"}]],["xBoxes",[{"id":"p3605"},{"id":"p3606"}]],["pBoxes",[{"id":"p3607"},{"id":"p3608"}]],["quantileSetterSwitch",{"id":"p3610"}],["quantileSetterDiv",{"id":"p3609"}],["triggerCallbacks",{"id":"p3611"}],["startBoxes",[{"id":"p3601"},{"id":"p3602"}]],["endBoxes",[{"id":"p3603"},{"id":"p3604"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.floor(xRange.start);\\n  let xRangeMax = Math.ceil(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c = [xRangeMin - 1, ...x_p.flatMap(x =&gt; [x, x]), xRangeMax + 1];\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = -0.04;\\n    p_c.y_range.end = 1.04;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = -pdfMax * 0.04;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264&#x27; + xMax.toString() + &#x27;.&lt;/p\\\\&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nclass NormalDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Normal&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.locationParam = &#x27;\\u03bc&#x27;;\\n\\n    \\n    this.paramMin = [-Infinity, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds();\\n\\n    \\n    super.generateLocationParamIndex();\\n}\\n\\n  xMin(params) {\\n    return -Infinity;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x === -Infinity || x === Infinity) return 0.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    let expTerm = (Math.pow(x - mu, 2) / 2.0 / Math.pow(sigma, 2));\\n    return Math.exp(-expTerm) / sigma / Math.sqrt(2 * Math.PI);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x === -Infinity) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    return (1 + erf((x - mu) / sigma / Math.sqrt(2))) / 2;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return -Infinity;\\n    if (p === 1) return Infinity;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return mu + sqrt2 * sigma * erfinv(2 * p - 1);\\n  }\\n\\n  defaultXRange(params) {\\n    return this.ppf([0.001, 0.999], params);\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    let sqrt2 = 1.4142135623730951;\\n\\n    let sigmaCoeff1 = sqrt2 * erfinv(2 * p1 - 1);\\n    let sigmaCoeff2 = sqrt2 * erfinv(2 * p2 - 1);\\n\\n    let sigma = (x2 - x1) / (sigmaCoeff2 - sigmaCoeff1);\\n    let mu = x2 - sigmaCoeff2 * sigma;\\n\\n    return [[mu, sigma], true];\\n  }\\n}\\n\\nfunction isclose(x, y, rtol = 1.0e-7, atol = 1.0e-8) {\\n  return Math.abs(x - y) &lt;= (atol + rtol * Math.abs(y));\\n}\\n\\n\\nfunction erf(x) {\\n  \\n  var a = [1.00002368,\\n           0.37409196,\\n           0.09678418,\\n           -0.18628806,\\n           0.27886807,\\n           -1.13520398,\\n           1.48851587,\\n           -0.82215223,\\n           0.17087277];\\n\\n  var t = 1 / (1 + Math.abs(x)/2);\\n  var expSum = -Math.pow(x, 2) - 1.26551223;\\n\\n  for (var i = 0; i &lt; a.length; i++) {\\n      expSum += a[i] * Math.pow(t, i+1);\\n  }\\n\\n  var result = 1 - t * Math.exp(expSum);\\n\\n  if (x &lt; 0) return -result;\\n  return result;\\n}\\n\\n\\nfunction besseli0(x, expWeighted = false) {\\n\\n  let A = [\\n    -4.41534164647933937950e-18,\\n     3.33079451882223809783e-17,\\n    -2.43127984654795469359e-16,\\n     1.71539128555513303061e-15,\\n    -1.16853328779934516808e-14,\\n     7.67618549860493561688e-14,\\n    -4.85644678311192946090e-13,\\n     2.95505266312963983461e-12,\\n    -1.72682629144155570723e-11,\\n     9.67580903537323691224e-11,\\n    -5.18979560163526290666e-10,\\n     2.65982372468238665035e-9,\\n    -1.30002500998624804212e-8,\\n     6.04699502254191894932e-8,\\n    -2.67079385394061173391e-7,\\n     1.11738753912010371815e-6,\\n    -4.41673835845875056359e-6,\\n     1.64484480707288970893e-5,\\n    -5.75419501008210370398e-5,\\n     1.88502885095841655729e-4,\\n    -5.76375574538582365885e-4,\\n     1.63947561694133579842e-3,\\n    -4.32430999505057594430e-3,\\n     1.05464603945949983183e-2,\\n    -2.37374148058994688156e-2,\\n     4.93052842396707084878e-2,\\n    -9.49010970480476444210e-2,\\n     1.71620901522208775349e-1,\\n    -3.04682672343198398683e-1,\\n     6.76795274409476084995e-1\\n  ];\\n\\n  let B = [\\n    -7.23318048787475395456e-18,\\n    -4.83050448594418207126e-18,\\n     4.46562142029675999901e-17,\\n     3.46122286769746109310e-17,\\n    -2.82762398051658348494e-16,\\n    -3.42548561967721913462e-16,\\n     1.77256013305652638360e-15,\\n     3.81168066935262242075e-15,\\n    -9.55484669882830764870e-15,\\n    -4.15056934728722208663e-14,\\n     1.54008621752140982691e-14,\\n     3.85277838274214270114e-13,\\n     7.18012445138366623367e-13,\\n    -1.79417853150680611778e-12,\\n    -1.32158118404477131188e-11,\\n    -3.14991652796324136454e-11,\\n     1.18891471078464383424e-11,\\n     4.94060238822496958910e-10,\\n     3.39623202570838634515e-9,\\n     2.26666899049817806459e-8,\\n     2.04891858946906374183e-7,\\n     2.89137052083475648297e-6,\\n     6.88975834691682398426e-5,\\n     3.36911647825569408990e-3,\\n     8.04490411014108831608e-1\\n  ];\\n\\n  if ( x &lt; 0 ) x = -x;\\n\\n  let result;\\n  if (x &lt;= 8.0) {\\n    let y = x / 2.0 - 2.0;\\n    result = chbevl(y, A);\\n  } else {\\n    result = chbevl(32.0 / x - 2.0, B) / Math.sqrt(x)\\n  }\\n\\n  if (expWeighted) return result;\\n  else return Math.exp(x) * result;\\n}\\n\\n\\nfunction cosm1(x) {\\n\\n  let coeffs = [\\n     4.7377507964246204691685E-14,\\n    -1.1470284843425359765671E-11,\\n     2.0876754287081521758361E-9,\\n    -2.7557319214999787979814E-7,\\n     2.4801587301570552304991E-5,\\n    -1.3888888888888872993737E-3,\\n     4.1666666666666666609054E-2\\n   ];\\n\\n  let quarterPi = Math.PI / 4;\\n\\n  if (x &lt; quarterPi || x &gt; quarterPi) return Math.cos(x) - 1.0;\\n\\n  let x2 = x * x;\\n  return -0.5 * x2 + x2 * x2 * polevl(x2, coeffs);\\n}\\n\\n\\nfunction clenshawCurtisIntegrate(f, a, b, n = 100, args = [], weights = undefined) {\\n\\n  if (weights === undefined) {\\n    \\n    let ccWeights = clenshawCurtisWeights(n);\\n\\n    \\n    weights = ccWeights.map((x) =&gt; (b - a) / 2.0 * x);\\n  }\\n\\n  \\n  let x = chebPoints(n);\\n\\n  \\n  x = x.map((x) =&gt; (b - a) / 2.0 * x + (b + a) / 2.0);\\n\\n  \\n  let fVals = x.map((x) =&gt; f(x, ...args));\\n\\n  \\n  return dot(weights, fVals);\\n}\\n\\n\\nfunction findRootTrustRegion(\\n\\t\\tf, \\n\\t\\tx0, \\n\\t\\targs=[],\\n\\t\\tjac=jacCentralDiff,\\n\\t\\ttol=0.000000001, \\n\\t\\tmaxIters=10000, \\n\\t\\tdeltaBar=1000.0, \\n\\t\\teta=0.125, \\n\\t\\tminDelta=1e-12\\n  ) {\\n\\t\\n\\tlet x = deepCopy(x0);\\n\\n\\t\\n\\tlet delta = 0.99 * deltaBar;\\n\\n\\t\\n\\tlet r = f(x, ...args);\\n\\n\\t\\n\\tlet J = jac(f, x, args);\\n\\n\\t\\n\\tlet JTJ = mmMult(transpose(J), J);\\n\\n\\t\\n\\tlet JTr = mvMult(transpose(J), r);\\n\\n\\t\\n\\tlet normJTr = norm(JTr);\\n\\n\\tlet iters = 0;\\n\\twhile (iters &lt; maxIters &amp;&amp; checkTol(r, tol) &amp;&amp; delta &gt;= minDelta) {\\n\\t\\t\\n\\t\\tlet p = doglegStep(JTJ, JTr, normJTr, delta);\\n\\n\\t\\t\\n\\t\\tlet newr = f(vectorAdd(x, p), ...args);\\n\\t\\tlet rho = computeRho(r, newr, J, p);\\n\\n\\t\\t\\n\\t\\tif  (rho &lt; 0.25) {\\n\\t\\t\\tdelta = norm(p) / 4.0;\\n\\t\\t} else if (rho &gt; 0.75 &amp;&amp; Math.abs(norm(p) - delta) &lt; 1e-12) {\\n\\t\\t\\t\\tdelta = Math.min(2 * delta, deltaBar);\\n\\t\\t}\\n\\n\\t\\t\\n\\t\\tif (rho &gt; eta) {\\n\\t\\t\\tx = vectorAdd(x, p);\\n\\n\\t\\t\\tr = newr;\\n\\t\\t\\tJ = jac(f, x, args);\\n\\t\\t\\tJTJ = mmMult(transpose(J), J);\\n\\t\\t\\tJTr = mvMult(transpose(J), r);\\n\\t\\t\\tnormJTr = norm(JTr);\\n\\t\\t}\\n\\n\\t\\titers += 1;\\n\\t}\\n\\n\\tlet success = !checkTol(r, tol);\\n\\n\\treturn [x, success];\\n\\n}\\n\\n\\nfunction brentSolve(f, lower, upper, args=[], tol=1e-8, maxIter=1000) {\\n\\tlet a = lower;\\n\\tlet b = upper;\\n  let fa = f(a, ...args);\\n  let fb = f(b, ...args);\\n\\n  \\n  if (Math.abs(fa) &lt; tol) return a;\\n  if (Math.abs(fb) &lt; tol) return b;\\n\\n  \\n  if (fa * fb &gt;= 0) {\\n  \\treturn null;\\n\\t}\\n\\n  \\n  let c = a;\\n  let fc = fa;\\n\\n\\tlet iter = 0;\\n  while (iter++ &lt; maxIter) {\\n  \\tlet prevStep = b - a;\\n\\n    \\n    if (Math.abs(fc) &lt; Math.abs(fb)) {      \\n    \\t[a, b, c] = [b, c, b];\\n    \\t[fa, fb, fc] = [fb, fc, fb];\\n    }\\n\\n    \\n    let newStep = (c - b) / 2.0;\\n\\n    \\n    let tolAdj = 1e-15 * Math.abs(b) + tol / 2;\\n\\n    \\n  \\tif (Math.abs(newStep) &lt;= tolAdj || fb === 0 ) {\\n    \\t\\treturn b;\\n  \\t}\\n\\n    \\n    if (Math.abs(prevStep) &gt; tolAdj &amp;&amp; Math.abs(fa) &gt; Math.abs(fb)) {\\n    \\tlet p;\\n    \\tlet q;\\n    \\tlet t1;\\n    \\tlet t2;\\n    \\tlet cb = c - b;\\n    \\tif (a === c) { \\n    \\t\\tt1 = fb / fa;\\n    \\t\\tp = cb * t1;\\n    \\t\\tq = 1.0 - t1;\\n    \\t}\\n    \\telse { \\n    \\t\\tq = fa / fc;\\n    \\t\\tt1 = fb / fc;\\n    \\t\\tt2 = fb / fa;\\n    \\t\\tp = t2 * (cb * q * (q - t1) - (b - a) * (t1 - 1.0));\\n    \\t\\tq = (q - 1.0) * (t1 - 1.0) * (t2 - 1.0);\\n    \\t}\\n\\n    \\t\\n    \\tif (p &gt; 0) q = -q;\\n    \\telse p = -p;\\n\\n    \\t\\n    \\tif (p &lt; (0.75 * cb * q - Math.abs(tolAdj * q) / 2.0) \\n    \\t\\t&amp;&amp; p &lt; Math.abs(prevStep * q / 2.0)) { \\n\\t        newStep = p / q;\\n      \\t}\\n    }\\n\\n    if (Math.abs(newStep) &lt; tolAdj) {\\n      newStep = (newStep &gt; 0) ? tolAdj : -tolAdj;\\n    }\\n\\n    \\n    a = b;\\n    fa = fb;\\n\\n    \\n    b += newStep;\\n    fb = f(b, ...args);\\n\\n\\t\\n    if ((fb &gt; 0 &amp;&amp; fc &gt; 0) || (fb &lt; 0 &amp;&amp; fc &lt; 0)) {\\n      c = a; \\n      fc = fa;\\n    }\\n  }\\n\\n  \\n  return null;\\n}\\n\\n\\nfunction erfinv(x) {\\n  \\n  let p = (x + 1.0) / 2.0;\\n\\n  \\n  if (p == 0.0) return -Infinity;\\n  if (p == 1.0) return Infinity;\\n  if (p &gt; 1.0 || p &lt; 0.0) return undefined;\\n\\n  let split1 = 0.425;\\n  let split2 = 5.0;\\n  let const1 = 0.180625;\\n  let const2 = 1.6;\\n\\n  \\n  let a0 = 3.3871327179;\\n  let a1 = 5.0434271938e1;\\n  let a2 = 1.5929113202e2;\\n  let a3 = 5.9109374720e1;\\n  let b1 = 1.7895169469e1;\\n  let b2 = 7.8757757664e1;\\n  let b3 = 6.7187563600e1;\\n\\n  \\n  let c0 = 1.4234372777;\\n  let c1 = 2.7568153900;\\n  let c2 = 1.3067284816;\\n  let c3 = 1.7023821103e-1;\\n  let d1 = 7.3700164250e-1;\\n  let d2 = 1.2021132975e-1;\\n\\n  \\n  let e0 = 6.6579051150;\\n  let e1 = 3.0812263860;\\n  let e2 = 4.2868294337e-1;\\n  let e3 = 1.7337203997e-2;\\n  let f1 = 2.4197894225e-1;\\n  let f2 = 1.2258202635e-2;\\n\\n  let r;\\n  let res;\\n  let q = p - 0.5;\\n\\n  if (Math.abs(q) &lt;= split1) {\\n    r = const1 - q * q;\\n    res = q * (((a3 * r + a2) * r + a1) * r + a0) /\\n              (((b3 * r + b2) * r + b1) * r + 1.0);\\n  } else {\\n    r = q &lt; 0 ? p : 1.0 - p;\\n\\n    r = Math.sqrt(-Math.log(r));\\n\\n    if (r &lt;= split2) {\\n      r -= const2;\\n      res = (((c3 * r + c2) * r + c1) * r + c0) /\\n             ((d2 * r + d1) * r + 1.0);\\n    } else {\\n      r -= split2;\\n      res = (((e3 * r + e2) * r + e1) * r + e0) /\\n             ((f2 * r + f1) * r + 1.0);\\n    }\\n  \\n    if (q &lt; 0) {\\n      res = -res;\\n    }\\n  }\\n\\n  \\n  return 0.7071067811865475 * res;\\n\\n}\\n\\n\\nfunction chbevl(x, A) {\\n\\n  let b0, b1, b2;\\n  let n = A.length;\\n  let i = n - 1;\\n\\n  b0 = A[0];\\n  b1 = 0.0;\\n\\n  for (let j = 1; j &lt;= i; j++) {\\n    b2 = b1;\\n    b1 = b0;\\n    b0 = x * b1 - b2 + A[j];\\n  }\\n\\n  return 0.5 * (b0 - b2);\\n}\\n\\n\\nfunction polevl(x, coef) {\\n\\n    let result;\\n    let n = coef.length;\\n\\n    let i = n;\\n\\n    result = coef[0];\\n\\n    for (let j = 1; j &lt;= n; j++) {\\n        result = result * x + coef[j];\\n    }\\n\\n    return result;\\n}\\n\\n\\nfunction chebPoints(n, low = -1, high = 1) {\\n  \\n  let points = Array.from({ length: n }, (_, i) =&gt; Math.cos(Math.PI * i / (n - 1)));\\n\\n  \\n  let m = (high - low) / 2.0;\\n  let b = (high + low) / 2.0;\\n\\n  points = points.map((x) =&gt; m * x + b);\\n\\n  return points;\\n}\\n\\n\\nfunction clenshawCurtisWeights(n) {\\n    n -= 1; \\n\\n    const theta = Array.from({ length: n + 1 }, (_, i) =&gt; Math.PI * i / n);\\n    let w = new Array(n + 1).fill(0);\\n    let v = new Array(n - 1).fill(1);\\n\\n    if (n % 2 === 0) {\\n        w[0] = 1.0 / (n ** 2 - 1);\\n        w[n] = w[0];\\n        for (let k = 1; k &lt; n / 2; k++) {\\n            for (let j = 1; j &lt; n; j++) {\\n                v[j - 1] -= 2.0 * Math.cos(2.0 * k * theta[j]) / (4.0 * k ** 2 - 1);\\n            }\\n        }\\n        for (let j = 1; j &lt; n; j++) {\\n            v[j - 1] -= Math.cos(n * theta[j]) / (n ** 2 - 1);\\n        }\\n    } else {\\n        w[0] = 1.0 / n ** 2;\\n        w[n] = w[0];\\n        for (let k = 1; k &lt;= (n - 1) / 2; k++) {\\n            for (let j = 1; j &lt; n; j++) {\\n                v[j - 1] -= 2.0 * Math.cos(2.0 * k * theta[j]) / (4.0 * k ** 2 - 1);\\n            }\\n        }\\n    }\\n\\n    for (let j = 1; j &lt; n; j++) {\\n        w[j] = 2.0 * v[j - 1] / n;\\n    }\\n\\n    return w;\\n}\\n\\n\\nfunction dot(v1, v2) {\\n  const n = v1.length;\\n  let result = 0.0;\\n  for (let i = 0; i &lt; n; i++) result += v1[i] * v2[i];\\n\\n  return result;\\n}\\n\\n\\nfunction transpose(A) {\\n    return A[0].map((_, colIndex) =&gt; A.map(row =&gt; row[colIndex]));\\n}\\n\\n\\nfunction mvMult(A, v) {\\n  return A.map(Arow =&gt; dot(Arow, v));\\n}\\n\\n\\nfunction mmMult(A, B) {\\n  let mA = A.length;\\n  let nA = A[0].length;\\n  let mB = B.length;\\n  let nB = B[0].length;\\n\\n  if (nA !== mB) {\\n      throw new Error(&#x27;Matrix dimension mismatch.&#x27;);\\n  }\\n\\n  let result = zeros(mA, nB);\\n\\n  for (let i = 0; i &lt; mA; i++) {\\n    for (let j = 0; j &lt; nB; j++) {\\n      for (let k = 0; k &lt; nA; k++) {\\n        result[i][j] += A[i][k] * B[k][j];\\n      }\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction vectorAdd() {\\n  let m = arguments.length;\\n  let n = arguments[0].length;\\n \\n  let result = new Array(n).fill(0.0);\\n \\n  for (let i = 0; i &lt; n; i++) {\\n    for (let j = 0; j &lt; m; j++) {\\n        result[i] += arguments[j][i];\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction norm(v) {\\n  return Math.sqrt(dot(v, v));\\n}\\n\\n\\nfunction deepCopy(x) {\\n  return JSON.parse(JSON.stringify(x));\\n}\\n\\n\\nfunction computeRho(r, newr, J, p) {\\n\\tlet r2 = norm(r) ** 2;\\n\\tlet num = r2 - norm(newr)**2;\\n\\tlet denom = r2 - norm(vectorAdd(r, mvMult(J, p))) ** 2;\\n\\n\\treturn num / denom;\\n}\\n\\n\\nfunction checkTol(r, tol) {\\n\\t\\n\\tconst n = r.length;\\n\\tfor (let i = 0; i &lt; n; i++) {\\n\\t\\tif (tol &lt; Math.abs(r[i])) return true;\\n\\t}\\n\\n\\treturn false;\\n}\\n\\n\\nfunction doglegStep(JTJ, JTr, normJTr, delta) {\\n\\t\\n\\tlet [pJ, posDef] = solvePosDef(JTJ, JTr);\\n\\tpJ = svMult(-1.0, pJ);\\n\\n\\t\\n\\tif (posDef &amp;&amp; norm(pJ) &lt;= delta) {\\n\\t\\treturn pJ;\\n\\t}\\n\\n\\t\\n\\tlet tau = Math.min(1, normJTr**3 / delta / quadForm(JTJ, JTr));\\n\\tlet pC = svMult(-tau * delta / normJTr, JTr);\\n\\n\\tlet pCnorm = norm(pC);\\n\\tif (!posDef || Math.abs(pCnorm - delta) &lt;= 1e-12) {\\n\\t\\treturn pC;\\n\\t}\\n\\n\\t\\n\\tlet pJ2 = norm(pJ) ** 2;\\n\\tlet pC2 = pCnorm**2;\\n\\tlet pJpC = dot(pJ, pC);\\n\\tlet a = pJ2 + pC2 - 2.0 * pJpC;\\n\\tlet b = 2.0 * (pJpC - pC2);\\n\\tlet c = pC2 - delta**2;\\n\\tlet q = -0.5 * (b + Math.sign(b) * Math.sqrt(b**2 - 4.0 * a * c));\\n\\n\\t\\n\\tlet beta;\\n\\tif (Math.abs(b) &lt; 1e-12) beta = Math.sqrt(-c / a);\\n\\telse if (b &lt; 0.0) beta = q / a;\\n\\telse beta = c / q;\\n\\n\\t\\n\\tif (0.0 &lt;= beta &amp;&amp; beta &lt;= 1) {\\n\\t\\treturn vectorAdd(pC, svMult(beta, vectorAdd(pJ, svMult(-1.0, pC))));\\n\\t} else { \\n\\t\\treturn pC;\\n\\t}\\n\\n}\\n\\n\\nfunction jacCentralDiff(f, x, args=[], eps=4.7e-6) {\\n\\t\\n\\tlet xPlus = deepCopy(x);\\n\\tlet xMinus = deepCopy(x);\\n\\n\\t\\n\\tlet fOfx = f(x, ...args);\\n\\tlet m = fOfx.length;\\n\\n\\t\\n\\tlet n = x.length;\\n\\n\\t\\n\\tlet J = zeros(m, n);\\n\\n\\t\\n\\tlet fOfxPlus;\\n\\tlet fOfxMinus;\\n\\n\\tfor (let j = 0; j &lt; n; j++) {\\n\\t\\txPlus[j] += eps;\\n\\t\\txMinus[j] -= eps;\\n\\t\\tfOfxPlus = f(xPlus, ...args);\\n\\t\\tfOfxMinus = f(xMinus, ...args);\\n\\t\\txPlus[j] -= eps;\\n\\t\\txMinus[j] += eps;\\n\\n\\t\\tfor (let i = 0; i &lt; m; i++) {\\n\\t\\t\\tJ[i][j] = (fOfxPlus[i] - fOfxMinus[i]) / 2.0 / eps;\\n\\t\\t}\\n\\t}\\n\\n\\treturn J;\\n}\\n\\n\\nfunction zeros(...dims) {\\n  let A = [];\\n\\n  \\n  for (let i = dims.length - 1; i &gt;= 0; i--) {\\n    let size = dims[i];\\n    if (i === dims.length - 1) {\\n      \\n      A = new Array(size).fill(0.0);\\n    } else {\\n      \\n      A = new Array(size).fill().map(() =&gt; deepCopy(A));\\n    }\\n  }\\n\\n  return A;\\n}\\n\\n\\nfunction svMult(a, v) {\\n  return v.map(x =&gt; a * x);\\n}\\n\\n\\nfunction quadForm(A, x) {\\n   return dot(x, mvMult(A, x)); \\n}\\n\\n\\nfunction solvePosDef(A, b) {\\n  let [L, p, success] = modifiedCholesky(A);\\n\\n  if (!success) {\\n    return [zeros(b.length), success];\\n  }\\n\\n  return [modifiedCholeskySolve(L, p, b), success];\\n}\\n\\n\\nfunction modifiedCholesky(A) {\\n    const floatEps = 1.0e-14;\\n    const n = A.length;\\n\\n    \\n    let L = deepCopy(A); \\n    let p = arange(0, n);\\n\\n    \\n    let success = true;\\n\\n    let xi = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        for (let j = 0; j &lt; i; j++) {\\n            let temp = Math.abs(L[i][j]);\\n            xi = Math.max(xi, temp);\\n        }\\n    }\\n\\n    let eta = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        let temp = Math.abs(L[i][i]);\\n        eta = Math.max(eta, temp);\\n    }\\n\\n    let beta;\\n    if (n &gt; 1) {\\n        beta = Math.sqrt(Math.max(eta, xi / Math.sqrt(n * n - 1)));\\n    } else {\\n        beta = Math.sqrt(eta);\\n    }\\n    beta = Math.max(beta, floatEps);\\n\\n    for (let k = 0; k &lt; n; k++) {\\n        \\n        let muVal = L[k][k];\\n        let mu = k;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            let temp = L[i][i];\\n            if (muVal &lt; temp) {\\n                mu = i;\\n                muVal = temp;\\n            }\\n        }\\n\\n        \\n        let iTemp = p[mu];\\n        p[mu] = p[k];\\n        p[k] = iTemp;\\n\\n        for (let i = 0; i &lt; k; i++) {\\n            let temp = L[k][i];\\n            L[k][i] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        let temp = L[k][k];\\n        L[k][k] = L[mu][mu];\\n        L[mu][mu] = temp;\\n        for (let i = k + 1; i &lt; mu; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        for (let i = mu + 1; i &lt; n; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[i][mu];\\n            L[i][mu] = temp;\\n        }\\n\\n        \\n        let cSum = 0;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            cSum = Math.max(cSum, Math.abs(L[i][k]));\\n        }\\n        cSum /= beta;\\n        cSum = cSum * cSum;\\n\\n        \\n        if (L[k][k] &lt; 0) {\\n            success = false;\\n        }\\n\\n        temp = Math.abs(L[k][k]);\\n        temp = Math.max(temp, floatEps * eta);\\n        temp = Math.max(temp, cSum);\\n        L[k][k] = Math.sqrt(temp);\\n\\n        \\n        for (let i = k + 1; i &lt; n; i++) {\\n            L[i][k] /= L[k][k];\\n        }\\n\\n        \\n        for (let j = k + 1; j &lt; n; j++) {\\n            for (let i = j; i &lt; n; i++) {\\n                L[i][j] -= L[i][k] * L[j][k];\\n            }\\n        }\\n\\n        \\n        for (let i = 0; i &lt; n - 1; i++) {\\n            for (let j = i + 1; j &lt; n; j++) {\\n                L[i][j] = 0.0;\\n            }\\n        }\\n    }\\n\\n    return [L, p, success];\\n}\\n\\n\\nfunction modifiedCholeskySolve(L, p, b) {\\n    const n = L.length;\\n\\n    let U = transpose(L);\\n    let xp = new Array(n).fill(0);\\n    for (let i = 0; i &lt; n; i++) {\\n        xp[i] = b[p[i]];\\n    }\\n\\n    \\n    let x = lowerTriSolve(L, xp);\\n\\n    \\n    xp = upperTriSolve(U, x);\\n\\n    for (let i = 0; i &lt; n; i++) {\\n        x[p[i]] = xp[i];\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction lowerTriSolve(L, b) {\\n    const floatEps = 1.0e-14;\\n    const n = L.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = 0; j &lt; n - 1; j++) {\\n        if (Math.abs(L[j][j]) &gt; floatEps) {\\n            x[j] /= L[j][j];\\n            for (let i = j + 1; i &lt; n; i++) {\\n                x[i] -= x[j] * L[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(L[n - 1][n - 1]) &gt; floatEps) {\\n            x[n - 1] /= L[n - 1][n - 1];\\n        } else {\\n            x[n - 1] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction upperTriSolve(U, b) {\\n    const floatEps = 1.0e-14;\\n    const n = U.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = n - 1; j &gt; 0; j--) {\\n        if (Math.abs(U[j][j]) &gt; floatEps) {\\n            x[j] /= U[j][j];\\n            for (let i = 0; i &lt; j; i++) {\\n                x[i] -= x[j] * U[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(U[0][0]) &gt; floatEps) {\\n            x[0] /= U[0][0];\\n        } else {\\n            x[0] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nclass VonMisesDistribution extends ContinuousUnivariateDistribution {\\n  \\n  \\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Von Mises&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Math.PI;\\n    this.hardMax = Math.PI;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03ba&#x27;];\\n\\n    \\n    this.locationParam = &#x27;\\u03bc&#x27;;\\n\\n    \\n    this.paramMin = [-Math.PI, 0.0];\\n\\n    \\n    this.paramMax = [Math.PI, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds();\\n\\n    \\n    super.generateLocationParamIndex();\\n  }\\n\\n  xMin(params) {\\n    return this.hardMin;\\n  }\\n\\n  xMax(params) {\\n    return this.hardMax;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let [mu, kappa] = params.slice(0, 2);\\n\\n    return Math.exp(kappa * cosm1(x - mu)) / (2 * Math.PI * besseli0(kappa, true));\\n  }\\n\\n  cdfSingleValueNormalApprox(x, params) {\\n    \\n    let [mu, kappa] = params.slice(0, 2);\\n    let sigma = 1.0 / Math.sqrt(kappa);\\n    let twopi = 2.0 * Math.PI;\\n\\n    let normal = new NormalDistribution();\\n    let result = normal.cdfSingleValue(x, [mu - twopi, sigma]);\\n    result -= normal.cdfSingleValue(-Math.PI, [mu - twopi, sigma]);\\n    result += normal.cdfSingleValue(x, [mu, sigma]);\\n    result -= normal.cdfSingleValue(-Math.PI, [mu, sigma]);\\n    result += normal.cdfSingleValue(x, [mu + twopi, sigma]);\\n    result -= normal.cdfSingleValue(-Math.PI, [mu + twopi, sigma]);\\n\\n    return result\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let [mu, kappa] = params.slice(0, 2);\\n    let result;\\n\\n    if (isclose(x, this.hardMin)) result = 0;\\n    else if (isclose(x, this.hardMax)) result = 1;\\n    else if (kappa &gt; 50) {\\n      result = this.cdfSingleValueNormalApprox(x, params);\\n    } else {\\n      \\n      let nChebPoints = 100;\\n\\n      let f = (x) =&gt; this.pdfSingleValue(x, params);\\n      result = clenshawCurtisIntegrate(f, this.hardMin, x, nChebPoints);\\n    }\\n\\n    return result;\\n  }\\n\\n  \\n  cdfSingleValueForMu0(x, params) {\\n    let [mu, kappa] = params.slice(0, 2);\\n\\n    if (!isclose(mu, 0)) {\\n      throw new Error(\\"cdfSingleValueFor Mu0 only works for \\u03bc = 0.\\")\\n    }\\n\\n    let vonMisesSeries = (k, y, p) =&gt; {\\n      let s = Math.sin(y);\\n      let c = Math.cos(y);\\n      let sn = Math.sin(p * y);\\n      let cn = Math.cos(p * y);\\n      let R = 0;\\n      let V = 0;\\n\\n      for (let n = p - 1; n &gt; 0; n--) {\\n        [sn, cn] = [sn * c - cn * s, cn * c + sn * s];\\n        R = 1.0 / (2 * n / k + R);\\n        V = R * (sn / n + V);\\n      }\\n\\n      return 0.5 + y / (2 * Math.PI) + V / Math.PI;\\n    } \\n\\n    let vonMisesNormalApprox = (k, y) =&gt; {\\n      let b = Math.sqrt(2 * Math.PI) / besseli0(k, true);\\n      let z = b * Math.sin(y / 2.0)\\n\\n      return (1 + erf(z / Math.sqrt(2))) / 2;\\n    }\\n\\n    \\n    let y = x - mu;\\n\\n    \\n    let iy = Math.round(y / (2.0 * Math.PI))\\n    y -= iy * (2 * Math.PI)\\n\\n    \\n    let CK = 50;\\n    let [a1, a2, a3, a4] = [28.0, 0.5, 100.0, 5.0];\\n\\n    \\n    let result;\\n    if (kappa &gt;= CK) result = vonMisesNormalApprox(kappa, y);\\n    else {\\n    let p = Math.floor(1 + a1 + a2 * kappa - a3 / (kappa + a4));\\n        result = vonMisesSeries(kappa, y, p)\\n        result = result &lt; 0 ? 0 : result &gt; 1 ? 1 : result;\\n    }\\n\\n    return result;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p == 0) return 0.0;\\n    if (p == 1) return 2.0 * Math.PI;\\n\\n    \\n    let rootFun = (x, params, p) =&gt; p - this.cdfSingleValue(x, params);\\n    \\n    let result = brentSolve(rootFun, this.hardMin, this.hardMax, [params, p]);\\n\\n    if (result === null) return 0.0;\\n    else return result;\\n  }\\n\\n  defaultXRange(params) {\\n    return [this.hardMin, this.hardMax];\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    if (x1 &lt;= -Math.PI || x1 &gt;= Math.PI || x2 &lt;= -Math.PI || x2 &gt;= Math.PI) {\\n      throw new Error(\\"lower and upper \\" + this.varName + \\" must be in interval (-\\u03c0 and \\u03c0).\\")\\n    }\\n\\n    \\n    const quantileRootFun = (params, x1, p1, x2, p2) =&gt; {\\n      \\n      let mu = Math.PI * (2 / (1 + Math.exp(-params[0])) - 1);\\n      let kappa = Math.exp(params[1]);\\n\\n      let r1 = this.cdfSingleValue(x1, [mu, kappa]) - p1;\\n      let r2 = this.cdfSingleValue(x2, [mu, kappa]) - p2;\\n\\n      return [r1, r2];\\n    };\\n\\n    \\n    let normal = new NormalDistribution();\\n    let [paramsOpt, optimSuccess] = normal.quantileSet(x, p);\\n    let [muGuess, sigmaGuess] = paramsOpt;\\n    let guess;\\n    if (optimSuccess &amp;&amp; muGuess &gt; -Math.PI &amp;&amp; muGuess &lt; Math.PI) {\\n      guess = [Math.log((Math.PI + muGuess) / (Math.PI - muGuess)), -2 * Math.log(sigmaGuess)];\\n    }\\n    else {\\n      guess = [0.0, 0.0];\\n    }\\n\\n    \\n    let args = [x1, p1, x2, p2];\\n    [paramsOpt, optimSuccess] = findRootTrustRegion(\\n      quantileRootFun, \\n      guess, \\n      args, \\n      jacCentralDiff,\\n      0.00001,  \\n      1000      \\n    );\\n    paramsOpt = [Math.PI * (2 / (1 + Math.exp(-paramsOpt[0])) - 1), Math.exp(paramsOpt[1])];\\n\\n    return [paramsOpt, optimSuccess];\\n  }\\n}\\n\\n\\n\\nvar dist = new VonMisesDistribution();\\n\\n\\nif (triggerCallbacks.active) {\\n  updateData(source_p, source_c, p_p, sliders, discrete);\\n}"}}]],["change:end",[{"id":"p3613"}]]]},"start":-3.141592653589793,"end":3.141592653589793}},"y_range":{"type":"object","name":"DataRange1d","id":"p3525"},"x_scale":{"type":"object","name":"LinearScale","id":"p3533"},"y_scale":{"type":"object","name":"LinearScale","id":"p3534"},"title":{"type":"object","name":"Title","id":"p3526","attributes":{"text":"Von Mises"}},"renderers":[{"type":"object","name":"GlyphRenderer","id":"p3594","attributes":{"data_source":{"id":"p3573"},"view":{"type":"object","name":"CDSView","id":"p3595","attributes":{"filter":{"type":"object","name":"AllIndices","id":"p3596"}}},"glyph":{"type":"object","name":"Line","id":"p3591","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"line_color":"#1f77b4","line_width":2}},"nonselection_glyph":{"type":"object","name":"Line","id":"p3592","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"line_color":"#1f77b4","line_alpha":0.1,"line_width":2}},"muted_glyph":{"type":"object","name":"Line","id":"p3593","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"line_color":"#1f77b4","line_alpha":0.2,"line_width":2}}}}],"toolbar":{"type":"object","name":"Toolbar","id":"p3532","attributes":{"tools":[{"type":"object","name":"ResetTool","id":"p3545"},{"type":"object","name":"SaveTool","id":"p3546"}]}},"toolbar_location":null,"left":[{"type":"object","name":"LinearAxis","id":"p3540","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p3541","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p3542"},"axis_label":"PDF","axis_label_text_font_style":"normal","major_label_policy":{"type":"object","name":"AllLabels","id":"p3543"}}}],"below":[{"type":"object","name":"LinearAxis","id":"p3535","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p3536","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p3537"},"axis_label":"y","major_label_policy":{"type":"object","name":"AllLabels","id":"p3538"}}}],"center":[{"type":"object","name":"Grid","id":"p3539","attributes":{"axis":{"id":"p3535"}}},{"type":"object","name":"Grid","id":"p3544","attributes":{"dimension":1,"axis":{"id":"p3540"}}}],"frame_width":300,"frame_height":175,"background_fill_alpha":0,"border_fill_alpha":0}}],["p_c",{"id":"p3547"}],["source_p",{"id":"p3573"}],["source_c",{"id":"p3576"}],["discrete",false],["n",400],["sliders",[{"id":"p3598"},{"id":"p3600"}]],["xBoxes",[{"id":"p3605"},{"id":"p3606"}]],["pBoxes",[{"id":"p3607"},{"id":"p3608"}]],["quantileSetterSwitch",{"id":"p3610"}],["quantileSetterDiv",{"id":"p3609"}],["triggerCallbacks",{"id":"p3611"}],["startBoxes",[{"id":"p3601"},{"id":"p3602"}]],["endBoxes",[{"id":"p3603"},{"id":"p3604"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.floor(xRange.start);\\n  let xRangeMax = Math.ceil(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c = [xRangeMin - 1, ...x_p.flatMap(x =&gt; [x, x]), xRangeMax + 1];\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = -0.04;\\n    p_c.y_range.end = 1.04;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = -pdfMax * 0.04;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264&#x27; + xMax.toString() + &#x27;.&lt;/p\\\\&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nclass NormalDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Normal&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.locationParam = &#x27;\\u03bc&#x27;;\\n\\n    \\n    this.paramMin = [-Infinity, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds();\\n\\n    \\n    super.generateLocationParamIndex();\\n}\\n\\n  xMin(params) {\\n    return -Infinity;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x === -Infinity || x === Infinity) return 0.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    let expTerm = (Math.pow(x - mu, 2) / 2.0 / Math.pow(sigma, 2));\\n    return Math.exp(-expTerm) / sigma / Math.sqrt(2 * Math.PI);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x === -Infinity) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    return (1 + erf((x - mu) / sigma / Math.sqrt(2))) / 2;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return -Infinity;\\n    if (p === 1) return Infinity;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return mu + sqrt2 * sigma * erfinv(2 * p - 1);\\n  }\\n\\n  defaultXRange(params) {\\n    return this.ppf([0.001, 0.999], params);\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    let sqrt2 = 1.4142135623730951;\\n\\n    let sigmaCoeff1 = sqrt2 * erfinv(2 * p1 - 1);\\n    let sigmaCoeff2 = sqrt2 * erfinv(2 * p2 - 1);\\n\\n    let sigma = (x2 - x1) / (sigmaCoeff2 - sigmaCoeff1);\\n    let mu = x2 - sigmaCoeff2 * sigma;\\n\\n    return [[mu, sigma], true];\\n  }\\n}\\n\\nfunction isclose(x, y, rtol = 1.0e-7, atol = 1.0e-8) {\\n  return Math.abs(x - y) &lt;= (atol + rtol * Math.abs(y));\\n}\\n\\n\\nfunction erf(x) {\\n  \\n  var a = [1.00002368,\\n           0.37409196,\\n           0.09678418,\\n           -0.18628806,\\n           0.27886807,\\n           -1.13520398,\\n           1.48851587,\\n           -0.82215223,\\n           0.17087277];\\n\\n  var t = 1 / (1 + Math.abs(x)/2);\\n  var expSum = -Math.pow(x, 2) - 1.26551223;\\n\\n  for (var i = 0; i &lt; a.length; i++) {\\n      expSum += a[i] * Math.pow(t, i+1);\\n  }\\n\\n  var result = 1 - t * Math.exp(expSum);\\n\\n  if (x &lt; 0) return -result;\\n  return result;\\n}\\n\\n\\nfunction besseli0(x, expWeighted = false) {\\n\\n  let A = [\\n    -4.41534164647933937950e-18,\\n     3.33079451882223809783e-17,\\n    -2.43127984654795469359e-16,\\n     1.71539128555513303061e-15,\\n    -1.16853328779934516808e-14,\\n     7.67618549860493561688e-14,\\n    -4.85644678311192946090e-13,\\n     2.95505266312963983461e-12,\\n    -1.72682629144155570723e-11,\\n     9.67580903537323691224e-11,\\n    -5.18979560163526290666e-10,\\n     2.65982372468238665035e-9,\\n    -1.30002500998624804212e-8,\\n     6.04699502254191894932e-8,\\n    -2.67079385394061173391e-7,\\n     1.11738753912010371815e-6,\\n    -4.41673835845875056359e-6,\\n     1.64484480707288970893e-5,\\n    -5.75419501008210370398e-5,\\n     1.88502885095841655729e-4,\\n    -5.76375574538582365885e-4,\\n     1.63947561694133579842e-3,\\n    -4.32430999505057594430e-3,\\n     1.05464603945949983183e-2,\\n    -2.37374148058994688156e-2,\\n     4.93052842396707084878e-2,\\n    -9.49010970480476444210e-2,\\n     1.71620901522208775349e-1,\\n    -3.04682672343198398683e-1,\\n     6.76795274409476084995e-1\\n  ];\\n\\n  let B = [\\n    -7.23318048787475395456e-18,\\n    -4.83050448594418207126e-18,\\n     4.46562142029675999901e-17,\\n     3.46122286769746109310e-17,\\n    -2.82762398051658348494e-16,\\n    -3.42548561967721913462e-16,\\n     1.77256013305652638360e-15,\\n     3.81168066935262242075e-15,\\n    -9.55484669882830764870e-15,\\n    -4.15056934728722208663e-14,\\n     1.54008621752140982691e-14,\\n     3.85277838274214270114e-13,\\n     7.18012445138366623367e-13,\\n    -1.79417853150680611778e-12,\\n    -1.32158118404477131188e-11,\\n    -3.14991652796324136454e-11,\\n     1.18891471078464383424e-11,\\n     4.94060238822496958910e-10,\\n     3.39623202570838634515e-9,\\n     2.26666899049817806459e-8,\\n     2.04891858946906374183e-7,\\n     2.89137052083475648297e-6,\\n     6.88975834691682398426e-5,\\n     3.36911647825569408990e-3,\\n     8.04490411014108831608e-1\\n  ];\\n\\n  if ( x &lt; 0 ) x = -x;\\n\\n  let result;\\n  if (x &lt;= 8.0) {\\n    let y = x / 2.0 - 2.0;\\n    result = chbevl(y, A);\\n  } else {\\n    result = chbevl(32.0 / x - 2.0, B) / Math.sqrt(x)\\n  }\\n\\n  if (expWeighted) return result;\\n  else return Math.exp(x) * result;\\n}\\n\\n\\nfunction cosm1(x) {\\n\\n  let coeffs = [\\n     4.7377507964246204691685E-14,\\n    -1.1470284843425359765671E-11,\\n     2.0876754287081521758361E-9,\\n    -2.7557319214999787979814E-7,\\n     2.4801587301570552304991E-5,\\n    -1.3888888888888872993737E-3,\\n     4.1666666666666666609054E-2\\n   ];\\n\\n  let quarterPi = Math.PI / 4;\\n\\n  if (x &lt; quarterPi || x &gt; quarterPi) return Math.cos(x) - 1.0;\\n\\n  let x2 = x * x;\\n  return -0.5 * x2 + x2 * x2 * polevl(x2, coeffs);\\n}\\n\\n\\nfunction clenshawCurtisIntegrate(f, a, b, n = 100, args = [], weights = undefined) {\\n\\n  if (weights === undefined) {\\n    \\n    let ccWeights = clenshawCurtisWeights(n);\\n\\n    \\n    weights = ccWeights.map((x) =&gt; (b - a) / 2.0 * x);\\n  }\\n\\n  \\n  let x = chebPoints(n);\\n\\n  \\n  x = x.map((x) =&gt; (b - a) / 2.0 * x + (b + a) / 2.0);\\n\\n  \\n  let fVals = x.map((x) =&gt; f(x, ...args));\\n\\n  \\n  return dot(weights, fVals);\\n}\\n\\n\\nfunction findRootTrustRegion(\\n\\t\\tf, \\n\\t\\tx0, \\n\\t\\targs=[],\\n\\t\\tjac=jacCentralDiff,\\n\\t\\ttol=0.000000001, \\n\\t\\tmaxIters=10000, \\n\\t\\tdeltaBar=1000.0, \\n\\t\\teta=0.125, \\n\\t\\tminDelta=1e-12\\n  ) {\\n\\t\\n\\tlet x = deepCopy(x0);\\n\\n\\t\\n\\tlet delta = 0.99 * deltaBar;\\n\\n\\t\\n\\tlet r = f(x, ...args);\\n\\n\\t\\n\\tlet J = jac(f, x, args);\\n\\n\\t\\n\\tlet JTJ = mmMult(transpose(J), J);\\n\\n\\t\\n\\tlet JTr = mvMult(transpose(J), r);\\n\\n\\t\\n\\tlet normJTr = norm(JTr);\\n\\n\\tlet iters = 0;\\n\\twhile (iters &lt; maxIters &amp;&amp; checkTol(r, tol) &amp;&amp; delta &gt;= minDelta) {\\n\\t\\t\\n\\t\\tlet p = doglegStep(JTJ, JTr, normJTr, delta);\\n\\n\\t\\t\\n\\t\\tlet newr = f(vectorAdd(x, p), ...args);\\n\\t\\tlet rho = computeRho(r, newr, J, p);\\n\\n\\t\\t\\n\\t\\tif  (rho &lt; 0.25) {\\n\\t\\t\\tdelta = norm(p) / 4.0;\\n\\t\\t} else if (rho &gt; 0.75 &amp;&amp; Math.abs(norm(p) - delta) &lt; 1e-12) {\\n\\t\\t\\t\\tdelta = Math.min(2 * delta, deltaBar);\\n\\t\\t}\\n\\n\\t\\t\\n\\t\\tif (rho &gt; eta) {\\n\\t\\t\\tx = vectorAdd(x, p);\\n\\n\\t\\t\\tr = newr;\\n\\t\\t\\tJ = jac(f, x, args);\\n\\t\\t\\tJTJ = mmMult(transpose(J), J);\\n\\t\\t\\tJTr = mvMult(transpose(J), r);\\n\\t\\t\\tnormJTr = norm(JTr);\\n\\t\\t}\\n\\n\\t\\titers += 1;\\n\\t}\\n\\n\\tlet success = !checkTol(r, tol);\\n\\n\\treturn [x, success];\\n\\n}\\n\\n\\nfunction brentSolve(f, lower, upper, args=[], tol=1e-8, maxIter=1000) {\\n\\tlet a = lower;\\n\\tlet b = upper;\\n  let fa = f(a, ...args);\\n  let fb = f(b, ...args);\\n\\n  \\n  if (Math.abs(fa) &lt; tol) return a;\\n  if (Math.abs(fb) &lt; tol) return b;\\n\\n  \\n  if (fa * fb &gt;= 0) {\\n  \\treturn null;\\n\\t}\\n\\n  \\n  let c = a;\\n  let fc = fa;\\n\\n\\tlet iter = 0;\\n  while (iter++ &lt; maxIter) {\\n  \\tlet prevStep = b - a;\\n\\n    \\n    if (Math.abs(fc) &lt; Math.abs(fb)) {      \\n    \\t[a, b, c] = [b, c, b];\\n    \\t[fa, fb, fc] = [fb, fc, fb];\\n    }\\n\\n    \\n    let newStep = (c - b) / 2.0;\\n\\n    \\n    let tolAdj = 1e-15 * Math.abs(b) + tol / 2;\\n\\n    \\n  \\tif (Math.abs(newStep) &lt;= tolAdj || fb === 0 ) {\\n    \\t\\treturn b;\\n  \\t}\\n\\n    \\n    if (Math.abs(prevStep) &gt; tolAdj &amp;&amp; Math.abs(fa) &gt; Math.abs(fb)) {\\n    \\tlet p;\\n    \\tlet q;\\n    \\tlet t1;\\n    \\tlet t2;\\n    \\tlet cb = c - b;\\n    \\tif (a === c) { \\n    \\t\\tt1 = fb / fa;\\n    \\t\\tp = cb * t1;\\n    \\t\\tq = 1.0 - t1;\\n    \\t}\\n    \\telse { \\n    \\t\\tq = fa / fc;\\n    \\t\\tt1 = fb / fc;\\n    \\t\\tt2 = fb / fa;\\n    \\t\\tp = t2 * (cb * q * (q - t1) - (b - a) * (t1 - 1.0));\\n    \\t\\tq = (q - 1.0) * (t1 - 1.0) * (t2 - 1.0);\\n    \\t}\\n\\n    \\t\\n    \\tif (p &gt; 0) q = -q;\\n    \\telse p = -p;\\n\\n    \\t\\n    \\tif (p &lt; (0.75 * cb * q - Math.abs(tolAdj * q) / 2.0) \\n    \\t\\t&amp;&amp; p &lt; Math.abs(prevStep * q / 2.0)) { \\n\\t        newStep = p / q;\\n      \\t}\\n    }\\n\\n    if (Math.abs(newStep) &lt; tolAdj) {\\n      newStep = (newStep &gt; 0) ? tolAdj : -tolAdj;\\n    }\\n\\n    \\n    a = b;\\n    fa = fb;\\n\\n    \\n    b += newStep;\\n    fb = f(b, ...args);\\n\\n\\t\\n    if ((fb &gt; 0 &amp;&amp; fc &gt; 0) || (fb &lt; 0 &amp;&amp; fc &lt; 0)) {\\n      c = a; \\n      fc = fa;\\n    }\\n  }\\n\\n  \\n  return null;\\n}\\n\\n\\nfunction erfinv(x) {\\n  \\n  let p = (x + 1.0) / 2.0;\\n\\n  \\n  if (p == 0.0) return -Infinity;\\n  if (p == 1.0) return Infinity;\\n  if (p &gt; 1.0 || p &lt; 0.0) return undefined;\\n\\n  let split1 = 0.425;\\n  let split2 = 5.0;\\n  let const1 = 0.180625;\\n  let const2 = 1.6;\\n\\n  \\n  let a0 = 3.3871327179;\\n  let a1 = 5.0434271938e1;\\n  let a2 = 1.5929113202e2;\\n  let a3 = 5.9109374720e1;\\n  let b1 = 1.7895169469e1;\\n  let b2 = 7.8757757664e1;\\n  let b3 = 6.7187563600e1;\\n\\n  \\n  let c0 = 1.4234372777;\\n  let c1 = 2.7568153900;\\n  let c2 = 1.3067284816;\\n  let c3 = 1.7023821103e-1;\\n  let d1 = 7.3700164250e-1;\\n  let d2 = 1.2021132975e-1;\\n\\n  \\n  let e0 = 6.6579051150;\\n  let e1 = 3.0812263860;\\n  let e2 = 4.2868294337e-1;\\n  let e3 = 1.7337203997e-2;\\n  let f1 = 2.4197894225e-1;\\n  let f2 = 1.2258202635e-2;\\n\\n  let r;\\n  let res;\\n  let q = p - 0.5;\\n\\n  if (Math.abs(q) &lt;= split1) {\\n    r = const1 - q * q;\\n    res = q * (((a3 * r + a2) * r + a1) * r + a0) /\\n              (((b3 * r + b2) * r + b1) * r + 1.0);\\n  } else {\\n    r = q &lt; 0 ? p : 1.0 - p;\\n\\n    r = Math.sqrt(-Math.log(r));\\n\\n    if (r &lt;= split2) {\\n      r -= const2;\\n      res = (((c3 * r + c2) * r + c1) * r + c0) /\\n             ((d2 * r + d1) * r + 1.0);\\n    } else {\\n      r -= split2;\\n      res = (((e3 * r + e2) * r + e1) * r + e0) /\\n             ((f2 * r + f1) * r + 1.0);\\n    }\\n  \\n    if (q &lt; 0) {\\n      res = -res;\\n    }\\n  }\\n\\n  \\n  return 0.7071067811865475 * res;\\n\\n}\\n\\n\\nfunction chbevl(x, A) {\\n\\n  let b0, b1, b2;\\n  let n = A.length;\\n  let i = n - 1;\\n\\n  b0 = A[0];\\n  b1 = 0.0;\\n\\n  for (let j = 1; j &lt;= i; j++) {\\n    b2 = b1;\\n    b1 = b0;\\n    b0 = x * b1 - b2 + A[j];\\n  }\\n\\n  return 0.5 * (b0 - b2);\\n}\\n\\n\\nfunction polevl(x, coef) {\\n\\n    let result;\\n    let n = coef.length;\\n\\n    let i = n;\\n\\n    result = coef[0];\\n\\n    for (let j = 1; j &lt;= n; j++) {\\n        result = result * x + coef[j];\\n    }\\n\\n    return result;\\n}\\n\\n\\nfunction chebPoints(n, low = -1, high = 1) {\\n  \\n  let points = Array.from({ length: n }, (_, i) =&gt; Math.cos(Math.PI * i / (n - 1)));\\n\\n  \\n  let m = (high - low) / 2.0;\\n  let b = (high + low) / 2.0;\\n\\n  points = points.map((x) =&gt; m * x + b);\\n\\n  return points;\\n}\\n\\n\\nfunction clenshawCurtisWeights(n) {\\n    n -= 1; \\n\\n    const theta = Array.from({ length: n + 1 }, (_, i) =&gt; Math.PI * i / n);\\n    let w = new Array(n + 1).fill(0);\\n    let v = new Array(n - 1).fill(1);\\n\\n    if (n % 2 === 0) {\\n        w[0] = 1.0 / (n ** 2 - 1);\\n        w[n] = w[0];\\n        for (let k = 1; k &lt; n / 2; k++) {\\n            for (let j = 1; j &lt; n; j++) {\\n                v[j - 1] -= 2.0 * Math.cos(2.0 * k * theta[j]) / (4.0 * k ** 2 - 1);\\n            }\\n        }\\n        for (let j = 1; j &lt; n; j++) {\\n            v[j - 1] -= Math.cos(n * theta[j]) / (n ** 2 - 1);\\n        }\\n    } else {\\n        w[0] = 1.0 / n ** 2;\\n        w[n] = w[0];\\n        for (let k = 1; k &lt;= (n - 1) / 2; k++) {\\n            for (let j = 1; j &lt; n; j++) {\\n                v[j - 1] -= 2.0 * Math.cos(2.0 * k * theta[j]) / (4.0 * k ** 2 - 1);\\n            }\\n        }\\n    }\\n\\n    for (let j = 1; j &lt; n; j++) {\\n        w[j] = 2.0 * v[j - 1] / n;\\n    }\\n\\n    return w;\\n}\\n\\n\\nfunction dot(v1, v2) {\\n  const n = v1.length;\\n  let result = 0.0;\\n  for (let i = 0; i &lt; n; i++) result += v1[i] * v2[i];\\n\\n  return result;\\n}\\n\\n\\nfunction transpose(A) {\\n    return A[0].map((_, colIndex) =&gt; A.map(row =&gt; row[colIndex]));\\n}\\n\\n\\nfunction mvMult(A, v) {\\n  return A.map(Arow =&gt; dot(Arow, v));\\n}\\n\\n\\nfunction mmMult(A, B) {\\n  let mA = A.length;\\n  let nA = A[0].length;\\n  let mB = B.length;\\n  let nB = B[0].length;\\n\\n  if (nA !== mB) {\\n      throw new Error(&#x27;Matrix dimension mismatch.&#x27;);\\n  }\\n\\n  let result = zeros(mA, nB);\\n\\n  for (let i = 0; i &lt; mA; i++) {\\n    for (let j = 0; j &lt; nB; j++) {\\n      for (let k = 0; k &lt; nA; k++) {\\n        result[i][j] += A[i][k] * B[k][j];\\n      }\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction vectorAdd() {\\n  let m = arguments.length;\\n  let n = arguments[0].length;\\n \\n  let result = new Array(n).fill(0.0);\\n \\n  for (let i = 0; i &lt; n; i++) {\\n    for (let j = 0; j &lt; m; j++) {\\n        result[i] += arguments[j][i];\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction norm(v) {\\n  return Math.sqrt(dot(v, v));\\n}\\n\\n\\nfunction deepCopy(x) {\\n  return JSON.parse(JSON.stringify(x));\\n}\\n\\n\\nfunction computeRho(r, newr, J, p) {\\n\\tlet r2 = norm(r) ** 2;\\n\\tlet num = r2 - norm(newr)**2;\\n\\tlet denom = r2 - norm(vectorAdd(r, mvMult(J, p))) ** 2;\\n\\n\\treturn num / denom;\\n}\\n\\n\\nfunction checkTol(r, tol) {\\n\\t\\n\\tconst n = r.length;\\n\\tfor (let i = 0; i &lt; n; i++) {\\n\\t\\tif (tol &lt; Math.abs(r[i])) return true;\\n\\t}\\n\\n\\treturn false;\\n}\\n\\n\\nfunction doglegStep(JTJ, JTr, normJTr, delta) {\\n\\t\\n\\tlet [pJ, posDef] = solvePosDef(JTJ, JTr);\\n\\tpJ = svMult(-1.0, pJ);\\n\\n\\t\\n\\tif (posDef &amp;&amp; norm(pJ) &lt;= delta) {\\n\\t\\treturn pJ;\\n\\t}\\n\\n\\t\\n\\tlet tau = Math.min(1, normJTr**3 / delta / quadForm(JTJ, JTr));\\n\\tlet pC = svMult(-tau * delta / normJTr, JTr);\\n\\n\\tlet pCnorm = norm(pC);\\n\\tif (!posDef || Math.abs(pCnorm - delta) &lt;= 1e-12) {\\n\\t\\treturn pC;\\n\\t}\\n\\n\\t\\n\\tlet pJ2 = norm(pJ) ** 2;\\n\\tlet pC2 = pCnorm**2;\\n\\tlet pJpC = dot(pJ, pC);\\n\\tlet a = pJ2 + pC2 - 2.0 * pJpC;\\n\\tlet b = 2.0 * (pJpC - pC2);\\n\\tlet c = pC2 - delta**2;\\n\\tlet q = -0.5 * (b + Math.sign(b) * Math.sqrt(b**2 - 4.0 * a * c));\\n\\n\\t\\n\\tlet beta;\\n\\tif (Math.abs(b) &lt; 1e-12) beta = Math.sqrt(-c / a);\\n\\telse if (b &lt; 0.0) beta = q / a;\\n\\telse beta = c / q;\\n\\n\\t\\n\\tif (0.0 &lt;= beta &amp;&amp; beta &lt;= 1) {\\n\\t\\treturn vectorAdd(pC, svMult(beta, vectorAdd(pJ, svMult(-1.0, pC))));\\n\\t} else { \\n\\t\\treturn pC;\\n\\t}\\n\\n}\\n\\n\\nfunction jacCentralDiff(f, x, args=[], eps=4.7e-6) {\\n\\t\\n\\tlet xPlus = deepCopy(x);\\n\\tlet xMinus = deepCopy(x);\\n\\n\\t\\n\\tlet fOfx = f(x, ...args);\\n\\tlet m = fOfx.length;\\n\\n\\t\\n\\tlet n = x.length;\\n\\n\\t\\n\\tlet J = zeros(m, n);\\n\\n\\t\\n\\tlet fOfxPlus;\\n\\tlet fOfxMinus;\\n\\n\\tfor (let j = 0; j &lt; n; j++) {\\n\\t\\txPlus[j] += eps;\\n\\t\\txMinus[j] -= eps;\\n\\t\\tfOfxPlus = f(xPlus, ...args);\\n\\t\\tfOfxMinus = f(xMinus, ...args);\\n\\t\\txPlus[j] -= eps;\\n\\t\\txMinus[j] += eps;\\n\\n\\t\\tfor (let i = 0; i &lt; m; i++) {\\n\\t\\t\\tJ[i][j] = (fOfxPlus[i] - fOfxMinus[i]) / 2.0 / eps;\\n\\t\\t}\\n\\t}\\n\\n\\treturn J;\\n}\\n\\n\\nfunction zeros(...dims) {\\n  let A = [];\\n\\n  \\n  for (let i = dims.length - 1; i &gt;= 0; i--) {\\n    let size = dims[i];\\n    if (i === dims.length - 1) {\\n      \\n      A = new Array(size).fill(0.0);\\n    } else {\\n      \\n      A = new Array(size).fill().map(() =&gt; deepCopy(A));\\n    }\\n  }\\n\\n  return A;\\n}\\n\\n\\nfunction svMult(a, v) {\\n  return v.map(x =&gt; a * x);\\n}\\n\\n\\nfunction quadForm(A, x) {\\n   return dot(x, mvMult(A, x)); \\n}\\n\\n\\nfunction solvePosDef(A, b) {\\n  let [L, p, success] = modifiedCholesky(A);\\n\\n  if (!success) {\\n    return [zeros(b.length), success];\\n  }\\n\\n  return [modifiedCholeskySolve(L, p, b), success];\\n}\\n\\n\\nfunction modifiedCholesky(A) {\\n    const floatEps = 1.0e-14;\\n    const n = A.length;\\n\\n    \\n    let L = deepCopy(A); \\n    let p = arange(0, n);\\n\\n    \\n    let success = true;\\n\\n    let xi = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        for (let j = 0; j &lt; i; j++) {\\n            let temp = Math.abs(L[i][j]);\\n            xi = Math.max(xi, temp);\\n        }\\n    }\\n\\n    let eta = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        let temp = Math.abs(L[i][i]);\\n        eta = Math.max(eta, temp);\\n    }\\n\\n    let beta;\\n    if (n &gt; 1) {\\n        beta = Math.sqrt(Math.max(eta, xi / Math.sqrt(n * n - 1)));\\n    } else {\\n        beta = Math.sqrt(eta);\\n    }\\n    beta = Math.max(beta, floatEps);\\n\\n    for (let k = 0; k &lt; n; k++) {\\n        \\n        let muVal = L[k][k];\\n        let mu = k;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            let temp = L[i][i];\\n            if (muVal &lt; temp) {\\n                mu = i;\\n                muVal = temp;\\n            }\\n        }\\n\\n        \\n        let iTemp = p[mu];\\n        p[mu] = p[k];\\n        p[k] = iTemp;\\n\\n        for (let i = 0; i &lt; k; i++) {\\n            let temp = L[k][i];\\n            L[k][i] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        let temp = L[k][k];\\n        L[k][k] = L[mu][mu];\\n        L[mu][mu] = temp;\\n        for (let i = k + 1; i &lt; mu; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        for (let i = mu + 1; i &lt; n; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[i][mu];\\n            L[i][mu] = temp;\\n        }\\n\\n        \\n        let cSum = 0;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            cSum = Math.max(cSum, Math.abs(L[i][k]));\\n        }\\n        cSum /= beta;\\n        cSum = cSum * cSum;\\n\\n        \\n        if (L[k][k] &lt; 0) {\\n            success = false;\\n        }\\n\\n        temp = Math.abs(L[k][k]);\\n        temp = Math.max(temp, floatEps * eta);\\n        temp = Math.max(temp, cSum);\\n        L[k][k] = Math.sqrt(temp);\\n\\n        \\n        for (let i = k + 1; i &lt; n; i++) {\\n            L[i][k] /= L[k][k];\\n        }\\n\\n        \\n        for (let j = k + 1; j &lt; n; j++) {\\n            for (let i = j; i &lt; n; i++) {\\n                L[i][j] -= L[i][k] * L[j][k];\\n            }\\n        }\\n\\n        \\n        for (let i = 0; i &lt; n - 1; i++) {\\n            for (let j = i + 1; j &lt; n; j++) {\\n                L[i][j] = 0.0;\\n            }\\n        }\\n    }\\n\\n    return [L, p, success];\\n}\\n\\n\\nfunction modifiedCholeskySolve(L, p, b) {\\n    const n = L.length;\\n\\n    let U = transpose(L);\\n    let xp = new Array(n).fill(0);\\n    for (let i = 0; i &lt; n; i++) {\\n        xp[i] = b[p[i]];\\n    }\\n\\n    \\n    let x = lowerTriSolve(L, xp);\\n\\n    \\n    xp = upperTriSolve(U, x);\\n\\n    for (let i = 0; i &lt; n; i++) {\\n        x[p[i]] = xp[i];\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction lowerTriSolve(L, b) {\\n    const floatEps = 1.0e-14;\\n    const n = L.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = 0; j &lt; n - 1; j++) {\\n        if (Math.abs(L[j][j]) &gt; floatEps) {\\n            x[j] /= L[j][j];\\n            for (let i = j + 1; i &lt; n; i++) {\\n                x[i] -= x[j] * L[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(L[n - 1][n - 1]) &gt; floatEps) {\\n            x[n - 1] /= L[n - 1][n - 1];\\n        } else {\\n            x[n - 1] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction upperTriSolve(U, b) {\\n    const floatEps = 1.0e-14;\\n    const n = U.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = n - 1; j &gt; 0; j--) {\\n        if (Math.abs(U[j][j]) &gt; floatEps) {\\n            x[j] /= U[j][j];\\n            for (let i = 0; i &lt; j; i++) {\\n                x[i] -= x[j] * U[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(U[0][0]) &gt; floatEps) {\\n            x[0] /= U[0][0];\\n        } else {\\n            x[0] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nclass VonMisesDistribution extends ContinuousUnivariateDistribution {\\n  \\n  \\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Von Mises&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Math.PI;\\n    this.hardMax = Math.PI;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03ba&#x27;];\\n\\n    \\n    this.locationParam = &#x27;\\u03bc&#x27;;\\n\\n    \\n    this.paramMin = [-Math.PI, 0.0];\\n\\n    \\n    this.paramMax = [Math.PI, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds();\\n\\n    \\n    super.generateLocationParamIndex();\\n  }\\n\\n  xMin(params) {\\n    return this.hardMin;\\n  }\\n\\n  xMax(params) {\\n    return this.hardMax;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let [mu, kappa] = params.slice(0, 2);\\n\\n    return Math.exp(kappa * cosm1(x - mu)) / (2 * Math.PI * besseli0(kappa, true));\\n  }\\n\\n  cdfSingleValueNormalApprox(x, params) {\\n    \\n    let [mu, kappa] = params.slice(0, 2);\\n    let sigma = 1.0 / Math.sqrt(kappa);\\n    let twopi = 2.0 * Math.PI;\\n\\n    let normal = new NormalDistribution();\\n    let result = normal.cdfSingleValue(x, [mu - twopi, sigma]);\\n    result -= normal.cdfSingleValue(-Math.PI, [mu - twopi, sigma]);\\n    result += normal.cdfSingleValue(x, [mu, sigma]);\\n    result -= normal.cdfSingleValue(-Math.PI, [mu, sigma]);\\n    result += normal.cdfSingleValue(x, [mu + twopi, sigma]);\\n    result -= normal.cdfSingleValue(-Math.PI, [mu + twopi, sigma]);\\n\\n    return result\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let [mu, kappa] = params.slice(0, 2);\\n    let result;\\n\\n    if (isclose(x, this.hardMin)) result = 0;\\n    else if (isclose(x, this.hardMax)) result = 1;\\n    else if (kappa &gt; 50) {\\n      result = this.cdfSingleValueNormalApprox(x, params);\\n    } else {\\n      \\n      let nChebPoints = 100;\\n\\n      let f = (x) =&gt; this.pdfSingleValue(x, params);\\n      result = clenshawCurtisIntegrate(f, this.hardMin, x, nChebPoints);\\n    }\\n\\n    return result;\\n  }\\n\\n  \\n  cdfSingleValueForMu0(x, params) {\\n    let [mu, kappa] = params.slice(0, 2);\\n\\n    if (!isclose(mu, 0)) {\\n      throw new Error(\\"cdfSingleValueFor Mu0 only works for \\u03bc = 0.\\")\\n    }\\n\\n    let vonMisesSeries = (k, y, p) =&gt; {\\n      let s = Math.sin(y);\\n      let c = Math.cos(y);\\n      let sn = Math.sin(p * y);\\n      let cn = Math.cos(p * y);\\n      let R = 0;\\n      let V = 0;\\n\\n      for (let n = p - 1; n &gt; 0; n--) {\\n        [sn, cn] = [sn * c - cn * s, cn * c + sn * s];\\n        R = 1.0 / (2 * n / k + R);\\n        V = R * (sn / n + V);\\n      }\\n\\n      return 0.5 + y / (2 * Math.PI) + V / Math.PI;\\n    } \\n\\n    let vonMisesNormalApprox = (k, y) =&gt; {\\n      let b = Math.sqrt(2 * Math.PI) / besseli0(k, true);\\n      let z = b * Math.sin(y / 2.0)\\n\\n      return (1 + erf(z / Math.sqrt(2))) / 2;\\n    }\\n\\n    \\n    let y = x - mu;\\n\\n    \\n    let iy = Math.round(y / (2.0 * Math.PI))\\n    y -= iy * (2 * Math.PI)\\n\\n    \\n    let CK = 50;\\n    let [a1, a2, a3, a4] = [28.0, 0.5, 100.0, 5.0];\\n\\n    \\n    let result;\\n    if (kappa &gt;= CK) result = vonMisesNormalApprox(kappa, y);\\n    else {\\n    let p = Math.floor(1 + a1 + a2 * kappa - a3 / (kappa + a4));\\n        result = vonMisesSeries(kappa, y, p)\\n        result = result &lt; 0 ? 0 : result &gt; 1 ? 1 : result;\\n    }\\n\\n    return result;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p == 0) return 0.0;\\n    if (p == 1) return 2.0 * Math.PI;\\n\\n    \\n    let rootFun = (x, params, p) =&gt; p - this.cdfSingleValue(x, params);\\n    \\n    let result = brentSolve(rootFun, this.hardMin, this.hardMax, [params, p]);\\n\\n    if (result === null) return 0.0;\\n    else return result;\\n  }\\n\\n  defaultXRange(params) {\\n    return [this.hardMin, this.hardMax];\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    if (x1 &lt;= -Math.PI || x1 &gt;= Math.PI || x2 &lt;= -Math.PI || x2 &gt;= Math.PI) {\\n      throw new Error(\\"lower and upper \\" + this.varName + \\" must be in interval (-\\u03c0 and \\u03c0).\\")\\n    }\\n\\n    \\n    const quantileRootFun = (params, x1, p1, x2, p2) =&gt; {\\n      \\n      let mu = Math.PI * (2 / (1 + Math.exp(-params[0])) - 1);\\n      let kappa = Math.exp(params[1]);\\n\\n      let r1 = this.cdfSingleValue(x1, [mu, kappa]) - p1;\\n      let r2 = this.cdfSingleValue(x2, [mu, kappa]) - p2;\\n\\n      return [r1, r2];\\n    };\\n\\n    \\n    let normal = new NormalDistribution();\\n    let [paramsOpt, optimSuccess] = normal.quantileSet(x, p);\\n    let [muGuess, sigmaGuess] = paramsOpt;\\n    let guess;\\n    if (optimSuccess &amp;&amp; muGuess &gt; -Math.PI &amp;&amp; muGuess &lt; Math.PI) {\\n      guess = [Math.log((Math.PI + muGuess) / (Math.PI - muGuess)), -2 * Math.log(sigmaGuess)];\\n    }\\n    else {\\n      guess = [0.0, 0.0];\\n    }\\n\\n    \\n    let args = [x1, p1, x2, p2];\\n    [paramsOpt, optimSuccess] = findRootTrustRegion(\\n      quantileRootFun, \\n      guess, \\n      args, \\n      jacCentralDiff,\\n      0.00001,  \\n      1000      \\n    );\\n    paramsOpt = [Math.PI * (2 / (1 + Math.exp(-paramsOpt[0])) - 1), Math.exp(paramsOpt[1])];\\n\\n    return [paramsOpt, optimSuccess];\\n  }\\n}\\n\\n\\n\\nvar dist = new VonMisesDistribution();\\n\\n\\n\\nif (cb_obj.active) {\\n  for (let i = 0; i &lt; sliders.length; i++) {\\n    if (!dist.fixedParamsInds.includes(i)) {\\n      sliders[i].title = dist.paramNames[i] + &#x27; (computed)&#x27;;\\n      sliders[i].disabled = true;\\n    }\\n  }\\n  for (let xBox of xBoxes) {\\n    xBox.disabled = false;\\n  }\\n  for (let pBox of pBoxes) {\\n    pBox.disabled = false;\\n  }\\n} else {\\n  for (let i = 0; i &lt; sliders.length; i++) {\\n    if (!dist.fixedParamsInds.includes(i)) {\\n      sliders[i].title = dist.paramNames[i];\\n      sliders[i].disabled = false;\\n    }\\n  }\\n  for (let xBox of xBoxes) {\\n    xBox.disabled = true;\\n  }\\n  for (let pBox of pBoxes) {\\n    pBox.disabled = true;\\n  }\\n  quantileSetterDiv.text = &#x27;&#x27;;\\n}"}}]]]}}}]}},{"type":"object","name":"Spacer","id":"p3661","attributes":{"width":10}},{"id":"p3609"}]}},{"type":"object","name":"Spacer","id":"p3663","attributes":{"height":10}},{"type":"object","name":"Row","id":"p3665","attributes":{"children":[{"type":"object","name":"Column","id":"p3653","attributes":{"children":[{"type":"object","name":"Row","id":"p3651","attributes":{"children":[{"type":"object","name":"Column","id":"p3644","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3643","attributes":{"height":4}},{"id":"p3601"}]}},{"id":"p3598"},{"type":"object","name":"Column","id":"p3646","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3645","attributes":{"height":4}},{"id":"p3603"}]}}]}},{"type":"object","name":"Row","id":"p3652","attributes":{"children":[{"type":"object","name":"Column","id":"p3648","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3647","attributes":{"height":4}},{"id":"p3602"}]}},{"id":"p3600"},{"type":"object","name":"Column","id":"p3650","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3649","attributes":{"height":4}},{"id":"p3604"}]}}]}}]}},{"type":"object","name":"Spacer","id":"p3664","attributes":{"width":20}},{"type":"object","name":"Column","id":"p3642","attributes":{"children":[{"type":"object","name":"Row","id":"p3640","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3624","attributes":{"width":20}},{"type":"object","name":"Column","id":"p3627","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3625","attributes":{"height":7}},{"type":"object","name":"Div","id":"p3626","attributes":{"text":"&lt;p&gt;&lt;b&gt;lower y: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p3605"},{"type":"object","name":"Spacer","id":"p3628","attributes":{"width":34}},{"type":"object","name":"Column","id":"p3631","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3629","attributes":{"height":7}},{"type":"object","name":"Div","id":"p3630","attributes":{"text":"&lt;p&gt;&lt;b&gt;upper y: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p3606"}]}},{"type":"object","name":"Row","id":"p3641","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3632","attributes":{"width":16}},{"type":"object","name":"Column","id":"p3635","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3633","attributes":{"height":7}},{"type":"object","name":"Div","id":"p3634","attributes":{"text":"&lt;p&gt;&lt;b&gt;quantile: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p3607"},{"type":"object","name":"Spacer","id":"p3636","attributes":{"width":30}},{"type":"object","name":"Column","id":"p3639","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3637","attributes":{"height":7}},{"type":"object","name":"Div","id":"p3638","attributes":{"text":"&lt;p&gt;&lt;b&gt;quantile: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p3608"}]}}]}}]}},{"type":"object","name":"Spacer","id":"p3666","attributes":{"height":10}},{"type":"object","name":"GridPlot","id":"p3658","attributes":{"rows":null,"cols":null,"toolbar":{"type":"object","name":"Toolbar","id":"p3657","attributes":{"tools":[{"type":"object","name":"ToolProxy","id":"p3655","attributes":{"tools":[{"id":"p3545"},{"id":"p3569"},{"id":"p3545"},{"id":"p3569"}]}},{"type":"object","name":"SaveTool","id":"p3656"}]}},"toolbar_location":"right","children":[[{"id":"p3523"},0,0],[{"type":"object","name":"Spacer","id":"p3654","attributes":{"width":30}},0,1],[{"id":"p3547"},0,2]]}}]}}]}}';
                  const render_items = [{"docid":"d1674beb-572a-4990-8a59-0f9ae68dd20f","roots":{"p3667":"bf32a522-bb8c-4bd1-8a92-34883f1c74b8"},"root_ids":["p3667"]}];
                  root.Bokeh.embed.embed_items(docs_json, render_items);
                  }
                  if (root.Bokeh !== undefined) {
                    embed_document(root);
                  } else {
                    let attempts = 0;
                    const timer = setInterval(function(root) {
                      if (root.Bokeh !== undefined) {
                        clearInterval(timer);
                        embed_document(root);
                      } else {
                        attempts++;
                        if (attempts > 100) {
                          clearInterval(timer);
                          console.log("Bokeh: ERROR: Unable to run BokehJS code because BokehJS library is missing");
                        }
                      }
                    }, 10, root)
                  }
                })(window);
              });
            };
            if (document.readyState != "loading") fn();
            else document.addEventListener("DOMContentLoaded", fn);
          })();
        },
    function(Bokeh) {
        }
      ];
    
      function run_inline_js() {
        for (let i = 0; i < inline_js.length; i++) {
          inline_js[i].call(root, root.Bokeh);
        }
      }
    
      if (root._bokeh_is_loading === 0) {
        console.debug("Bokeh: BokehJS loaded, going straight to plotting");
        run_inline_js();
      } else {
        load_libs(css_urls, js_urls, function() {
          console.debug("Bokeh: BokehJS plotting callback run at", now());
          run_inline_js();
        });
      }
    }(window));
  };
  if (document.readyState != "loading") fn();
  else document.addEventListener("DOMContentLoaded", fn);
})();