(function() {
  const fn = function() {
    (function(root) {
      function now() {
        return new Date();
      }
    
      const force = false;
    
      if (typeof root._bokeh_onload_callbacks === "undefined" || force === true) {
        root._bokeh_onload_callbacks = [];
        root._bokeh_is_loading = undefined;
      }
    
    
    const element = document.getElementById("f6a001de-6399-4e46-a2eb-a0428fc2ea57");
        if (element == null) {
          console.warn("Bokeh: autoload.js configured with elementid 'f6a001de-6399-4e46-a2eb-a0428fc2ea57' but no matching script tag was found.")
        }
      function run_callbacks() {
        try {
          root._bokeh_onload_callbacks.forEach(function(callback) {
            if (callback != null)
              callback();
          });
        } finally {
          delete root._bokeh_onload_callbacks
        }
        console.debug("Bokeh: all callbacks have finished");
      }
    
      function load_libs(css_urls, js_urls, callback) {
        if (css_urls == null) css_urls = [];
        if (js_urls == null) js_urls = [];
    
        root._bokeh_onload_callbacks.push(callback);
        if (root._bokeh_is_loading > 0) {
          console.debug("Bokeh: BokehJS is being loaded, scheduling callback at", now());
          return null;
        }
        if (js_urls == null || js_urls.length === 0) {
          run_callbacks();
          return null;
        }
        console.debug("Bokeh: BokehJS not loaded, scheduling load and callback at", now());
        root._bokeh_is_loading = css_urls.length + js_urls.length;
    
        function on_load() {
          root._bokeh_is_loading--;
          if (root._bokeh_is_loading === 0) {
            console.debug("Bokeh: all BokehJS libraries/stylesheets loaded");
            run_callbacks()
          }
        }
    
        function on_error(url) {
          console.error("failed to load " + url);
        }
    
        for (let i = 0; i < css_urls.length; i++) {
          const url = css_urls[i];
          const element = document.createElement("link");
          element.onload = on_load;
          element.onerror = on_error.bind(null, url);
          element.rel = "stylesheet";
          element.type = "text/css";
          element.href = url;
          console.debug("Bokeh: injecting link tag for BokehJS stylesheet: ", url);
          document.body.appendChild(element);
        }
    
        for (let i = 0; i < js_urls.length; i++) {
          const url = js_urls[i];
          const element = document.createElement('script');
          element.onload = on_load;
          element.onerror = on_error.bind(null, url);
          element.async = false;
          element.src = url;
          console.debug("Bokeh: injecting script tag for BokehJS library: ", url);
          document.head.appendChild(element);
        }
      };
    
      function inject_raw_css(css) {
        const element = document.createElement("style");
        element.appendChild(document.createTextNode(css));
        document.body.appendChild(element);
      }
    
      const js_urls = ["https://cdn.bokeh.org/bokeh/release/bokeh-3.3.0.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-gl-3.3.0.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-widgets-3.3.0.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-tables-3.3.0.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-mathjax-3.3.0.min.js"];
      const css_urls = [];
    
      const inline_js = [    function(Bokeh) {
          Bokeh.set_log_level("info");
        },
        function(Bokeh) {
          (function() {
            const fn = function() {
              Bokeh.safely(function() {
                (function(root) {
                  function embed_document(root) {
                  const docs_json = '{"cebc3a65-9e53-44af-94ed-81508f64b824":{"version":"3.3.0","title":"Bokeh Application","roots":[{"type":"object","name":"Column","id":"p2542","attributes":{"children":[{"type":"object","name":"Row","id":"p2537","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2535","attributes":{"width":409}},{"type":"object","name":"Row","id":"p2498","attributes":{"children":[{"type":"object","name":"Div","id":"p2496","attributes":{"text":"&lt;p&gt;&lt;b&gt;Quantile setter mode&lt;/b&gt;&lt;/p&gt;"}},{"type":"object","name":"Spacer","id":"p2497","attributes":{"width":2}},{"type":"object","name":"Switch","id":"p2483","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:active",[{"type":"object","name":"CustomJS","id":"p2487","attributes":{"args":{"type":"map","entries":[["p_p",{"type":"object","name":"Figure","id":"p2384","attributes":{"x_range":{"type":"object","name":"Range1d","id":"p2442","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:start",[{"type":"object","name":"CustomJS","id":"p2486","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p2384"}],["p_c",{"type":"object","name":"Figure","id":"p2413","attributes":{"js_event_callbacks":{"type":"map","entries":[["reset",[{"type":"object","name":"CustomJS","id":"p2489","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p2384"}],["p_c",{"id":"p2413"}],["source_p",{"type":"object","name":"ColumnDataSource","id":"p2444","attributes":{"selected":{"type":"object","name":"Selection","id":"p2445","attributes":{"indices":[],"line_indices":[]}},"selection_policy":{"type":"object","name":"UnionRenderers","id":"p2446"},"data":{"type":"map","entries":[["x",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}],["y_p",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}]]}}}],["source_c",{"type":"object","name":"ColumnDataSource","id":"p2447","attributes":{"selected":{"type":"object","name":"Selection","id":"p2448","attributes":{"indices":[],"line_indices":[]}},"selection_policy":{"type":"object","name":"UnionRenderers","id":"p2449"},"data":{"type":"map","entries":[["x",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}],["y_c",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}]]}}}],["discrete",false],["n",400],["sliders",[{"type":"object","name":"Slider","id":"p2469","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p2485","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p2384"}],["p_c",{"id":"p2413"}],["source_p",{"id":"p2444"}],["source_c",{"id":"p2447"}],["discrete",false],["n",400],["sliders",[{"id":"p2469"},{"type":"object","name":"Slider","id":"p2471","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p2485"}]]]},"width":200,"title":"\\u03bc","format":{"type":"object","name":"CustomJSTickFormatter","id":"p2470","attributes":{"code":"return tick.toPrecision(4)"}},"start":0.0,"end":1.0,"value":0,"step":0.01}},{"type":"object","name":"Slider","id":"p2473","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p2485"}]]]},"width":200,"title":"\\u03c3","format":{"type":"object","name":"CustomJSTickFormatter","id":"p2472","attributes":{"code":"return tick.toPrecision(4)"}},"start":0.1,"end":1.0,"value":0.2,"step":0.01}}]],["xBoxes",[{"type":"object","name":"TextInput","id":"p2480","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p2488","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p2384"}],["p_c",{"id":"p2413"}],["source_p",{"id":"p2444"}],["source_c",{"id":"p2447"}],["discrete",false],["n",400],["sliders",[{"id":"p2469"},{"id":"p2471"},{"id":"p2473"}]],["xBoxes",[{"id":"p2480"}]],["pBoxes",[{"type":"object","name":"TextInput","id":"p2481","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p2488"}]]]},"disabled":true,"width":80,"value":"0.9500"}}]],["quantileSetterSwitch",{"id":"p2483"}],["quantileSetterDiv",{"type":"object","name":"Div","id":"p2482"}],["triggerCallbacks",{"type":"object","name":"Switch","id":"p2484","attributes":{"active":true}}],["startBoxes",[{"type":"object","name":"TextInput","id":"p2474","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p2490","attributes":{"args":{"type":"map","entries":[["minValue","0"],["maxValue","Infinity"],["slider",{"id":"p2469"}]]},"code":"\\n\\nslider.start = Math.max(minValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"1"}},{"type":"object","name":"TextInput","id":"p2475","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p2492","attributes":{"args":{"type":"map","entries":[["minValue","-Infinity"],["maxValue","Infinity"],["slider",{"id":"p2471"}]]},"code":"\\n\\nslider.start = Math.max(minValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"0.0"}},{"type":"object","name":"TextInput","id":"p2476","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p2494","attributes":{"args":{"type":"map","entries":[["minValue","0"],["maxValue","Infinity"],["slider",{"id":"p2473"}]]},"code":"\\n\\nslider.start = Math.max(minValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"0.1"}}]],["endBoxes",[{"type":"object","name":"TextInput","id":"p2477","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p2491","attributes":{"args":{"type":"map","entries":[["minValue","0"],["maxValue","Infinity"],["slider",{"id":"p2469"}]]},"code":"\\n\\nslider.end = Math.min(maxValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"10"}},{"type":"object","name":"TextInput","id":"p2478","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p2493","attributes":{"args":{"type":"map","entries":[["minValue","-Infinity"],["maxValue","Infinity"],["slider",{"id":"p2471"}]]},"code":"\\n\\nslider.end = Math.min(maxValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"1.0"}},{"type":"object","name":"TextInput","id":"p2479","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p2495","attributes":{"args":{"type":"map","entries":[["minValue","0"],["maxValue","Infinity"],["slider",{"id":"p2473"}]]},"code":"\\n\\nslider.end = Math.min(maxValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"1.0"}}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let x = paramsFromBoxes(xBoxes);\\n  let p = paramsFromBoxes(pBoxes);\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ){\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n          endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);        \\n        }\\n        sliders[dist.activeParamsInds[i]].value = optimParams[i];\\n      }\\n\\n      params = paramsFromSliders(sliders); \\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.floor(xRange.start);\\n  let xRangeMax = Math.ceil(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c = [xRangeMin - 1, ...x_p.flatMap(x =&gt; [x, x]), xRangeMax + 1];\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = -0.04;\\n    p_c.y_range.end = 1.04;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = -pdfMax * 0.04;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264&#x27; + xMax.toString() + &#x27;.&lt;/p\\\\&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nclass CauchyDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Cauchy&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return -Infinity;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x == Infinity || x == -Infinity) return 0.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    return 1.0 / Math.PI / sigma / (1 + Math.pow((x - mu) / sigma, 2))\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    return 0.5 + Math.atan((x - mu) / sigma) / Math.PI;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    return mu + sigma * Math.tan(Math.PI * (p - 0.5));\\n  }\\n\\n  defaultXRange(params) {\\n    \\n    return this.ppf([0.025, 0.975], params);\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    let cotp1 = 1.0 / Math.tan(Math.PI * p1);\\n    let cotp2 = 1.0 / Math.tan(Math.PI * p2);\\n\\n    let mu = (x2 * cotp1 - x1 * cotp2) / (cotp1 - cotp2);\\n    let sigma = (x1 - x2) * Math.sin(Math.PI * p1) * Math.sin(Math.PI * p1) \\n                / Math.sin(Math.PI * (p1 - p2));\\n\\n    return [[mu, sigma], true];\\n  }\\n}\\n\\nclass HalfCauchyDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;HalfCauchy&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u00b5&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.fixedParams = [&#x27;\\u00b5&#x27;];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return params[0];\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x &lt; mu) return NaN;\\n    if (x === Infinity) return 0.0;\\n\\n    return 2.0 / Math.PI / sigma / (1 + Math.pow((x - mu) / sigma, 2));\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x &lt;= mu) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    return 2.0 * Math.atan((x - mu) / sigma) / Math.PI;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    return mu + sigma * Math.tan(Math.PI * p / 2.0);\\n  }\\n\\n  defaultXRange(params) {\\n    \\n    return [params[0], this.ppf(0.9, params)];\\n  }\\n\\n  quantileSet(x, p, extraParams) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n    let mu = extraParams[0];\\n\\n    return [[(x1 - mu) / Math.tan(Math.PI * p1 / 2)], true];\\n  }\\n}\\n\\nclass HalfNormalDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;HalfNormal&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u00b5&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.fixedParams = [&#x27;\\u00b5&#x27;];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return params[0];\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x &lt; mu) return NaN;\\n    if (x === Infinity) return 0.0;\\n\\n    let expTerm = (Math.pow(x - mu, 2) / 2.0 / Math.pow(sigma, 2));\\n    return Math.exp(-expTerm) / sigma * Math.sqrt(2.0 / Math.PI);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x &lt;= mu) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    return erf((x - mu) / sigma / Math.sqrt(2));\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return mu + sqrt2 * sigma * erfinv(p);\\n  }\\n\\n  defaultXRange(params) {\\n    return [params[0], this.ppf(0.999, params)];\\n  }\\n\\n  quantileSet(x, p, extraParams) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n    let mu = extraParams[0];\\n\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return [[(x1 - mu) / sqrt2 / erfinv(p1)], true];\\n  }\\n}\\n\\nclass NormalDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Normal&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n}\\n\\n  xMin(params) {\\n    return -Infinity;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x === -Infinity || x === Infinity) return 0.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    let expTerm = (Math.pow(x - mu, 2) / 2.0 / Math.pow(sigma, 2));\\n    return Math.exp(-expTerm) / sigma / Math.sqrt(2 * Math.PI);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x === -Infinity) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    return (1 + erf((x - mu) / sigma / Math.sqrt(2))) / 2;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return -Infinity;\\n    if (p === 1) return Infinity;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return mu + sqrt2 * sigma * erfinv(2 * p - 1);\\n  }\\n\\n  defaultXRange(params) {\\n    return this.ppf([0.001, 0.999], params);\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    let sqrt2 = 1.4142135623730951;\\n\\n    let sigmaCoeff1 = sqrt2 * erfinv(2 * p1 - 1);\\n    let sigmaCoeff2 = sqrt2 * erfinv(2 * p2 - 1);\\n\\n    let sigma = (x2 - x1) / (sigmaCoeff2 - sigmaCoeff1);\\n    let mu = x2 - sigmaCoeff2 * sigma;\\n\\n    return [[mu, sigma], true];\\n  }\\n}\\n\\nclass StudentTDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;StudentT&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bd&#x27;, &#x27;\\u03bc&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.fixedParams = [&#x27;\\u03bd&#x27;];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return -Infinity;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x === -Infinity || x === Infinity) return 0.0;\\n\\n    let [nu, mu, sigma] = params.slice(0, 3);\\n\\n    let lnprob;\\n\\n    lnprob = lngamma((nu + 1) / 2) - lngamma(nu / 2) - Math.log(Math.PI * nu) / 2 - Math.log(sigma)\\n             - (nu + 1) / 2 * log1p(Math.pow(x - mu, 2) / nu / Math.pow(sigma, 2));\\n\\n    return Math.exp(lnprob);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x === -Infinity) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let [nu, mu, sigma] = params.slice(0, 3);\\n\\n    let y = (x - mu) / sigma;\\n\\n    if (y &gt;= 0) {\\n        return 1 - regularizedIncompleteBeta(nu / (Math.pow(y, 2) + nu), 0.5 * nu, 0.5) / 2;\\n    }\\n    else {\\n        return regularizedIncompleteBeta(nu / (Math.pow(y, 2) + nu), 0.5 * nu, 0.5) / 2;        \\n    }\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let [nu, mu, sigma] = params.slice(0, 3);\\n\\n    \\n    let guess;\\n    if (nu &lt; 3) { \\n      guess = Math.tan(Math.PI * (p - 0.5));\\n    } else {\\n      guess = Math.sqrt(2) * erfinv(2 * p - 1)\\n    }\\n\\n    \\n    if (nu === 1 || nu === Infinity) return mu + sigma * guess;\\n\\n    \\n    let rootFun = (x, nu, p) =&gt; [p - this.cdfSingleValue(x, [nu, 0, 1])];\\n    let [xOpt, success] = findRootTrustRegion(rootFun, [guess], [nu, p]);\\n\\n    return mu + sigma * xOpt[0];\\n  }\\n\\n  defaultXRange(params) {\\n    \\n    let [nu, mu, sigma] = params.slice(0, 3);\\n\\n    let p1;\\n    let p2;\\n\\n    if (nu &lt; 2) {\\n        p1 = 0.05;\\n        p2 = 0.95;\\n    }\\n    if (nu &lt; 4) {\\n        p1 = 0.01;\\n        p2 = 0.99;\\n    }\\n    else if (nu &lt; 10) {\\n        p1 = 0.005;\\n        p2 = 0.995;\\n    }\\n    else {\\n        p1 = 0.001;\\n        p2 = 0.999;\\n    }\\n\\n    return this.ppf([p1, p2], params);\\n  }\\n\\n  quantileSet(x, p, extraParams) {\\n\\n    let nu = extraParams[0];\\n\\n    \\n    if (nu === 1) { \\n      let cauchy = new CauchyDistribution();\\n      return cauchy.quantileSet(x, p);\\n    }\\n    if (nu === Infinity) { \\n      let normal = new NormalDistribution();\\n      return normal.quantileSet(x, p);\\n    }\\n\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    \\n    const quantileRootFun = (params, nu, x1, p1, x2, p2) =&gt; {\\n      let mu = params[0];\\n      let sigma = Math.exp(params[1]);\\n\\n      let r1 = this.cdfSingleValue(x1, [nu, mu, sigma]) - p1;\\n      let r2 = this.cdfSingleValue(x2, [nu, mu, sigma]) - p2;\\n\\n      return [r1, r2];\\n    };\\n\\n    let args = [nu, x1, p1, x2, p2];\\n\\n    \\n    let guess;\\n    let guessSuccess;\\n    if (nu &lt; 3) {\\n      let cauchy = new CauchyDistribution();\\n      [guess, guessSuccess] = cauchy.quantileSet(x, p);\\n    } else {\\n      let normal = new NormalDistribution();\\n      [guess, guessSuccess] = normal.quantileSet(x, p);      \\n    }\\n\\n    \\n    guess = [guess[0], Math.log(guess[1])];\\n\\n    let [paramsFirstPass, optimSuccess] = findRootTrustRegion(quantileRootFun, guess, args=args);\\n\\n    \\n    paramsFirstPass[1] = Math.exp(paramsFirstPass[1]);\\n\\n    \\n    if (!optimSuccess) {\\n      return [[paramsFirstPass[0], paramsFirstPass[1]], optimSuccess];\\n    }\\n\\n    \\n    const closeQuantileRootFun = (params, nu, x1, p1, x2, p2) =&gt; {\\n      let [mu, sigma] = params.slice(0, 2);\\n\\n      let r1 = this.cdfSingleValue(x1, [nu, mu, sigma]) - p1;\\n      let r2 = this.cdfSingleValue(x2, [nu, mu, sigma]) - p2;\\n\\n      return [r1, r2];\\n    };\\n\\n    let paramsOpt;\\n    [paramsOpt, optimSuccess] = findRootTrustRegion(closeQuantileRootFun, paramsFirstPass, args=args);\\n\\n    let retval;\\n    if (optimSuccess &amp;&amp; norm(closeQuantileRootFun(paramsOpt, nu, x1, p1, x2, p2)) &lt; norm(closeQuantileRootFun(paramsFirstPass, nu, x1, p1, x2, p2))) {\\n      retval = [paramsOpt, optimSuccess];\\n    } else {\\n      retval = [paramsOpt, optimSuccess];\\n    }\\n\\n    return retval;\\n  }\\n\\n}\\n\\nfunction log1p(x) {\\n  \\n  \\n  if (x &lt;= -1.0) {\\n    throw new RangeError(&#x27;Argument must be greater than -1.0&#x27;);\\n  }\\n\\n  \\n  else if (Math.abs(x) &gt; 1e-4) {\\n    return Math.log(1.0 + x);\\n  }\\n\\n  else {\\n    return (-0.5*x + 1.0)*x;\\n  }\\n}\\n\\n\\nfunction regularizedIncompleteBeta(x, a, b) {\\n    \\n    \\n    if (x &lt; 0 || x &gt; 1) {\\n        throw new RangeError(&#x27;First argument must be between 0 and 1.&#x27;);\\n    }\\n\\n    \\n    else if (a === 1 &amp;&amp; b === 1) return x;\\n    else if (x === 0) return 0;\\n    else if (x === 1) return 1;\\n    else if (a === 0) return 1;\\n    else if (b === 0) return 0;\\n\\n    else {\\n        var bt = Math.exp(lngamma(a + b) - lngamma(a) - lngamma(b) + a * Math.log(x) + b * log1p(-x));\\n\\n        \\n        if (x &lt; (a + 1) / (a + b + 2)) return bt * betacf(x, a, b) / a;\\n\\n        \\n        else return 1 - bt * betacf(1 - x, b, a) / b;\\n    }\\n}\\n\\n\\nfunction lngamma(z) {\\n\\n    if(z &lt; 0) return Number(&#x27;0/0&#x27;);\\n\\n    if (z &lt; 0.5) return Math.log(Math.PI) - Math.log(Math.sin(Math.PI * z)) - lngamma(1-z);\\n\\n    var p = [676.5203681218851,\\n             -1259.1392167224028,\\n             771.32342877765313,\\n             -176.61502916214059,\\n             12.507343278686905,\\n             -0.13857109526572012,\\n             9.9843695780195716e-6,\\n             1.5056327351493116e-7];\\n\\n    z -= 1.0;\\n    var Ag = 0.99999999999980993;\\n    for (var i = 0; i &lt; p.length; i++) {\\n        Ag += p[i] / (z + i + 1);\\n    }\\n    var t = z + p.length - 0.5;\\n\\n    return 0.5 * Math.log(2*Math.PI) + (z + 0.5)*Math.log(t) - t + Math.log(Ag);\\n}\\n\\n\\nfunction norm(v) {\\n  return Math.sqrt(dot(v, v));\\n}\\n\\n\\nfunction findRootTrustRegion(\\n\\t\\tf, \\n\\t\\tx0, \\n\\t\\targs=[],\\n\\t\\tjac=jacCentralDiff,\\n\\t\\ttol=0.000000001, \\n\\t\\tmaxIters=10000, \\n\\t\\tdeltaBar=1000.0, \\n\\t\\teta=0.125, \\n\\t\\tminDelta=1e-12\\n  ) {\\n\\t\\n\\tlet x = deepCopy(x0);\\n\\n\\t\\n\\tlet delta = 0.99 * deltaBar;\\n\\n\\t\\n\\tlet r = f(x, ...args);\\n\\n\\t\\n\\tlet J = jac(f, x, args);\\n\\n\\t\\n\\tlet JTJ = mmMult(transpose(J), J);\\n\\n\\t\\n\\tlet JTr = mvMult(transpose(J), r);\\n\\n\\t\\n\\tlet normJTr = norm(JTr);\\n\\n\\tlet iters = 0;\\n\\twhile (iters &lt; maxIters &amp;&amp; checkTol(r, tol) &amp;&amp; delta &gt;= minDelta) {\\n\\t\\t\\n\\t\\tlet p = doglegStep(JTJ, JTr, normJTr, delta);\\n\\n\\t\\t\\n\\t\\tlet newr = f(vectorAdd(x, p), ...args);\\n\\t\\tlet rho = computeRho(r, newr, J, p);\\n\\n\\t\\t\\n\\t\\tif  (rho &lt; 0.25) {\\n\\t\\t\\tdelta = norm(p) / 4.0;\\n\\t\\t} else if (rho &gt; 0.75 &amp;&amp; Math.abs(norm(p) - delta) &lt; 1e-12) {\\n\\t\\t\\t\\tdelta = Math.min(2 * delta, deltaBar);\\n\\t\\t}\\n\\n\\t\\t\\n\\t\\tif (rho &gt; eta) {\\n\\t\\t\\tx = vectorAdd(x, p);\\n\\n\\t\\t\\tr = newr;\\n\\t\\t\\tJ = jac(f, x, args);\\n\\t\\t\\tJTJ = mmMult(transpose(J), J);\\n\\t\\t\\tJTr = mvMult(transpose(J), r);\\n\\t\\t\\tnormJTr = norm(JTr);\\n\\t\\t}\\n\\n\\t\\titers += 1;\\n\\t}\\n\\n\\tlet success = !checkTol(r, tol);\\n\\n\\treturn [x, success];\\n\\n}\\n\\n\\nfunction erf(x) {\\n  \\n  var a = [1.00002368,\\n           0.37409196,\\n           0.09678418,\\n           -0.18628806,\\n           0.27886807,\\n           -1.13520398,\\n           1.48851587,\\n           -0.82215223,\\n           0.17087277];\\n\\n  var t = 1 / (1 + Math.abs(x)/2);\\n  var expSum = -Math.pow(x, 2) - 1.26551223;\\n\\n  for (var i = 0; i &lt; a.length; i++) {\\n      expSum += a[i] * Math.pow(t, i+1);\\n  }\\n\\n  var result = 1 - t * Math.exp(expSum);\\n\\n  if (x &lt; 0) return -result;\\n  return result;\\n}\\n\\n\\nfunction erfinv(x) {\\n  \\n  let p = (x + 1.0) / 2.0;\\n\\n  \\n  if (p == 0.0) return -Infinity;\\n  if (p == 1.0) return Infinity;\\n  if (p &gt; 1.0 || p &lt; 0.0) return undefined;\\n\\n  let split1 = 0.425;\\n  let split2 = 5.0;\\n  let const1 = 0.180625;\\n  let const2 = 1.6;\\n\\n  \\n  let a0 = 3.3871327179;\\n  let a1 = 5.0434271938e1;\\n  let a2 = 1.5929113202e2;\\n  let a3 = 5.9109374720e1;\\n  let b1 = 1.7895169469e1;\\n  let b2 = 7.8757757664e1;\\n  let b3 = 6.7187563600e1;\\n\\n  \\n  let c0 = 1.4234372777;\\n  let c1 = 2.7568153900;\\n  let c2 = 1.3067284816;\\n  let c3 = 1.7023821103e-1;\\n  let d1 = 7.3700164250e-1;\\n  let d2 = 1.2021132975e-1;\\n\\n  \\n  let e0 = 6.6579051150;\\n  let e1 = 3.0812263860;\\n  let e2 = 4.2868294337e-1;\\n  let e3 = 1.7337203997e-2;\\n  let f1 = 2.4197894225e-1;\\n  let f2 = 1.2258202635e-2;\\n\\n  let r;\\n  let res;\\n  let q = p - 0.5;\\n\\n  if (Math.abs(q) &lt;= split1) {\\n    r = const1 - q * q;\\n    res = q * (((a3 * r + a2) * r + a1) * r + a0) /\\n              (((b3 * r + b2) * r + b1) * r + 1.0);\\n  } else {\\n    r = q &lt; 0 ? p : 1.0 - p;\\n\\n    r = Math.sqrt(-Math.log(r));\\n\\n    if (r &lt;= split2) {\\n      r -= const2;\\n      res = (((c3 * r + c2) * r + c1) * r + c0) /\\n             ((d2 * r + d1) * r + 1.0);\\n    } else {\\n      r -= split2;\\n      res = (((e3 * r + e2) * r + e1) * r + e0) /\\n             ((f2 * r + f1) * r + 1.0);\\n    }\\n  \\n    if (q &lt; 0) {\\n      res = -res;\\n    }\\n  }\\n\\n  \\n  return 0.7071067811865475 * res;\\n\\n}\\n\\n\\nfunction betacf(x, a, b) {\\n    \\n    \\n    var fpmin = 1e-30,\\n        m = 1,\\n        m2, aa, c, d, del, h, qab, qam, qap;\\n    \\n    qab = a + b;\\n    qap = a + 1;\\n    qam = a - 1;\\n    c = 1;\\n    d = 1 - qab * x / qap;\\n    if (Math.abs(d) &lt; fpmin) d = fpmin;\\n    d = 1 / d;\\n    h = d;\\n    for (; m &lt;= 100; m++) {\\n        m2 = 2 * m;\\n        aa = m * (b - m) * x / ((qam + m2) * (a + m2));\\n        \\n        d = 1 + aa * d;\\n        if (Math.abs(d) &lt; fpmin) d = fpmin;\\n        c = 1 + aa / c;\\n        if (Math.abs(c) &lt; fpmin) c = fpmin;\\n        d = 1 / d;\\n        h *= d * c;\\n        aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));\\n        \\n        d = 1 + aa * d;\\n        if (Math.abs(d) &lt; fpmin) d = fpmin;\\n        c = 1 + aa / c;\\n        if (Math.abs(c) &lt; fpmin) c = fpmin;\\n        d = 1 / d;\\n        del = d * c;\\n        h *= del;\\n        if (Math.abs(del - 1.0) &lt; 3e-7) break;\\n    }\\n    return h;\\n}\\n\\n\\nfunction dot(v1, v2) {\\n  const n = v1.length;\\n  let result = 0.0;\\n  for (let i = 0; i &lt; n; i++) result += v1[i] * v2[i];\\n\\n  return result;\\n}\\n\\n\\nfunction transpose(A) {\\n    return A[0].map((_, colIndex) =&gt; A.map(row =&gt; row[colIndex]));\\n}\\n\\n\\nfunction mvMult(A, v) {\\n  return A.map(Arow =&gt; dot(Arow, v));\\n}\\n\\n\\nfunction mmMult(A, B) {\\n  let mA = A.length;\\n  let nA = A[0].length;\\n  let mB = B.length;\\n  let nB = B[0].length;\\n\\n  if (nA !== mB) {\\n      throw new Error(&#x27;Matrix dimension mismatch.&#x27;);\\n  }\\n\\n  let result = zeros(mA, nB);\\n\\n  for (let i = 0; i &lt; mA; i++) {\\n    for (let j = 0; j &lt; nB; j++) {\\n      for (let k = 0; k &lt; nA; k++) {\\n        result[i][j] += A[i][k] * B[k][j];\\n      }\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction vectorAdd() {\\n  let m = arguments.length;\\n  let n = arguments[0].length;\\n \\n  let result = new Array(n).fill(0.0);\\n \\n  for (let i = 0; i &lt; n; i++) {\\n    for (let j = 0; j &lt; m; j++) {\\n        result[i] += arguments[j][i];\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction deepCopy(x) {\\n  return JSON.parse(JSON.stringify(x));\\n}\\n\\n\\nfunction computeRho(r, newr, J, p) {\\n\\tlet r2 = norm(r) ** 2;\\n\\tlet num = r2 - norm(newr)**2;\\n\\tlet denom = r2 - norm(vectorAdd(r, mvMult(J, p))) ** 2;\\n\\n\\treturn num / denom;\\n}\\n\\n\\nfunction checkTol(r, tol) {\\n\\t\\n\\tconst n = r.length;\\n\\tfor (let i = 0; i &lt; n; i++) {\\n\\t\\tif (tol &lt; Math.abs(r[i])) return true;\\n\\t}\\n\\n\\treturn false;\\n}\\n\\n\\nfunction doglegStep(JTJ, JTr, normJTr, delta) {\\n\\t\\n\\tlet [pJ, posDef] = solvePosDef(JTJ, JTr);\\n\\tpJ = svMult(-1.0, pJ);\\n\\n\\t\\n\\tif (posDef &amp;&amp; norm(pJ) &lt;= delta) {\\n\\t\\treturn pJ;\\n\\t}\\n\\n\\t\\n\\tlet tau = Math.min(1, normJTr**3 / delta / quadForm(JTJ, JTr));\\n\\tlet pC = svMult(-tau * delta / normJTr, JTr);\\n\\n\\tlet pCnorm = norm(pC);\\n\\tif (!posDef || Math.abs(pCnorm - delta) &lt;= 1e-12) {\\n\\t\\treturn pC;\\n\\t}\\n\\n\\t\\n\\tlet pJ2 = norm(pJ) ** 2;\\n\\tlet pC2 = pCnorm**2;\\n\\tlet pJpC = dot(pJ, pC);\\n\\tlet a = pJ2 + pC2 - 2.0 * pJpC;\\n\\tlet b = 2.0 * (pJpC - pC2);\\n\\tlet c = pC2 - delta**2;\\n\\tlet q = -0.5 * (b + Math.sign(b) * Math.sqrt(b**2 - 4.0 * a * c));\\n\\n\\t\\n\\tlet beta;\\n\\tif (Math.abs(b) &lt; 1e-12) beta = Math.sqrt(-c / a);\\n\\telse if (b &lt; 0.0) beta = q / a;\\n\\telse beta = c / q;\\n\\n\\t\\n\\tif (0.0 &lt;= beta &amp;&amp; beta &lt;= 1) {\\n\\t\\treturn vectorAdd(pC, svMult(beta, vectorAdd(pJ, svMult(-1.0, pC))));\\n\\t} else { \\n\\t\\treturn pC;\\n\\t}\\n\\n}\\n\\n\\nfunction jacCentralDiff(f, x, args=[], eps=4.7e-6) {\\n\\t\\n\\tlet xPlus = deepCopy(x);\\n\\tlet xMinus = deepCopy(x);\\n\\n\\t\\n\\tlet fOfx = f(x, ...args);\\n\\tlet m = fOfx.length;\\n\\n\\t\\n\\tlet n = x.length;\\n\\n\\t\\n\\tlet J = zeros(m, n);\\n\\n\\t\\n\\tlet fOfxPlus;\\n\\tlet fOfxMinus;\\n\\n\\tfor (let j = 0; j &lt; n; j++) {\\n\\t\\txPlus[j] += eps;\\n\\t\\txMinus[j] -= eps;\\n\\t\\tfOfxPlus = f(xPlus, ...args);\\n\\t\\tfOfxMinus = f(xMinus, ...args);\\n\\t\\txPlus[j] -= eps;\\n\\t\\txMinus[j] += eps;\\n\\n\\t\\tfor (let i = 0; i &lt; m; i++) {\\n\\t\\t\\tJ[i][j] = (fOfxPlus[i] - fOfxMinus[i]) / 2.0 / eps;\\n\\t\\t}\\n\\t}\\n\\n\\treturn J;\\n}\\n\\n\\nfunction zeros(...dims) {\\n  let A = [];\\n\\n  \\n  for (let i = dims.length - 1; i &gt;= 0; i--) {\\n    let size = dims[i];\\n    if (i === dims.length - 1) {\\n      \\n      A = new Array(size).fill(0.0);\\n    } else {\\n      \\n      A = new Array(size).fill().map(() =&gt; deepCopy(A));\\n    }\\n  }\\n\\n  return A;\\n}\\n\\n\\nfunction svMult(a, v) {\\n  return v.map(x =&gt; a * x);\\n}\\n\\n\\nfunction quadForm(A, x) {\\n   return dot(x, mvMult(A, x)); \\n}\\n\\n\\nfunction solvePosDef(A, b) {\\n  let [L, p, success] = modifiedCholesky(A);\\n\\n  if (!success) {\\n    return [zeros(b.length), success];\\n  }\\n\\n  return [modifiedCholeskySolve(L, p, b), success];\\n}\\n\\n\\nfunction modifiedCholesky(A) {\\n    const floatEps = 1.0e-14;\\n    const n = A.length;\\n\\n    \\n    let L = deepCopy(A); \\n    let p = arange(0, n);\\n\\n    \\n    let success = true;\\n\\n    let xi = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        for (let j = 0; j &lt; i; j++) {\\n            let temp = Math.abs(L[i][j]);\\n            xi = Math.max(xi, temp);\\n        }\\n    }\\n\\n    let eta = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        let temp = Math.abs(L[i][i]);\\n        eta = Math.max(eta, temp);\\n    }\\n\\n    let beta;\\n    if (n &gt; 1) {\\n        beta = Math.sqrt(Math.max(eta, xi / Math.sqrt(n * n - 1)));\\n    } else {\\n        beta = Math.sqrt(eta);\\n    }\\n    beta = Math.max(beta, floatEps);\\n\\n    for (let k = 0; k &lt; n; k++) {\\n        \\n        let muVal = L[k][k];\\n        let mu = k;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            let temp = L[i][i];\\n            if (muVal &lt; temp) {\\n                mu = i;\\n                muVal = temp;\\n            }\\n        }\\n\\n        \\n        let iTemp = p[mu];\\n        p[mu] = p[k];\\n        p[k] = iTemp;\\n\\n        for (let i = 0; i &lt; k; i++) {\\n            let temp = L[k][i];\\n            L[k][i] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        let temp = L[k][k];\\n        L[k][k] = L[mu][mu];\\n        L[mu][mu] = temp;\\n        for (let i = k + 1; i &lt; mu; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        for (let i = mu + 1; i &lt; n; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[i][mu];\\n            L[i][mu] = temp;\\n        }\\n\\n        \\n        let cSum = 0;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            cSum = Math.max(cSum, Math.abs(L[i][k]));\\n        }\\n        cSum /= beta;\\n        cSum = cSum * cSum;\\n\\n        \\n        if (L[k][k] &lt; 0) {\\n            success = false;\\n        }\\n\\n        temp = Math.abs(L[k][k]);\\n        temp = Math.max(temp, floatEps * eta);\\n        temp = Math.max(temp, cSum);\\n        L[k][k] = Math.sqrt(temp);\\n\\n        \\n        for (let i = k + 1; i &lt; n; i++) {\\n            L[i][k] /= L[k][k];\\n        }\\n\\n        \\n        for (let j = k + 1; j &lt; n; j++) {\\n            for (let i = j; i &lt; n; i++) {\\n                L[i][j] -= L[i][k] * L[j][k];\\n            }\\n        }\\n\\n        \\n        for (let i = 0; i &lt; n - 1; i++) {\\n            for (let j = i + 1; j &lt; n; j++) {\\n                L[i][j] = 0.0;\\n            }\\n        }\\n    }\\n\\n    return [L, p, success];\\n}\\n\\n\\nfunction modifiedCholeskySolve(L, p, b) {\\n    const n = L.length;\\n\\n    let U = transpose(L);\\n    let xp = new Array(n).fill(0);\\n    for (let i = 0; i &lt; n; i++) {\\n        xp[i] = b[p[i]];\\n    }\\n\\n    \\n    let x = lowerTriSolve(L, xp);\\n\\n    \\n    xp = upperTriSolve(U, x);\\n\\n    for (let i = 0; i &lt; n; i++) {\\n        x[p[i]] = xp[i];\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction lowerTriSolve(L, b) {\\n    const floatEps = 1.0e-14;\\n    const n = L.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = 0; j &lt; n - 1; j++) {\\n        if (Math.abs(L[j][j]) &gt; floatEps) {\\n            x[j] /= L[j][j];\\n            for (let i = j + 1; i &lt; n; i++) {\\n                x[i] -= x[j] * L[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(L[n - 1][n - 1]) &gt; floatEps) {\\n            x[n - 1] /= L[n - 1][n - 1];\\n        } else {\\n            x[n - 1] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction upperTriSolve(U, b) {\\n    const floatEps = 1.0e-14;\\n    const n = U.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = n - 1; j &gt; 0; j--) {\\n        if (Math.abs(U[j][j]) &gt; floatEps) {\\n            x[j] /= U[j][j];\\n            for (let i = 0; i &lt; j; i++) {\\n                x[i] -= x[j] * U[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(U[0][0]) &gt; floatEps) {\\n            x[0] /= U[0][0];\\n        } else {\\n            x[0] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nclass HalfStudentTDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;HalfStudentT&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bd&#x27;, &#x27;\\u00b5&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.fixedParams = [&#x27;\\u03bd&#x27;, &#x27;\\u00b5&#x27;];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return params[1];\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let [nu, mu, sigma] = params.slice(0, 3);\\n\\n    if (x &lt; mu) return NaN;\\n    if (x === Infinity) return 0.0;\\n\\n    let lnprob;\\n\\n    lnprob = Math.log(2.0) + lngamma((nu + 1) / 2) - lngamma(nu / 2) - Math.log(Math.PI * nu) / 2 \\n             - Math.log(sigma) - (nu + 1) / 2 * log1p(Math.pow(x - mu, 2) / nu / Math.pow(sigma, 2));\\n\\n    return Math.exp(lnprob);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let [nu, mu, sigma] = params.slice(0, 3);\\n\\n    if (x &lt;= mu) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let y = (x - mu) / sigma;\\n\\n    return 1 - regularizedIncompleteBeta(nu / (Math.pow(y, 2) + nu), 0.5 * nu, 0.5);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return params[1];\\n    if (p === 1) return Infinity;\\n\\n    let studentT = new StudentTDistribution();\\n    return studentT.ppf((1 + p) / 2, params);\\n  }\\n\\n  defaultXRange(params) {\\n    \\n    let [nu, mu, sigma] = params.slice(0, 3);\\n    let p2;\\n\\n    if (nu &lt; 2) p2 = 0.95;\\n    else if (nu &lt; 4) p2 = 0.99;\\n    else if (nu &lt; 10) p2 = 0.995;\\n    else p2 = 0.999;\\n\\n    return [params[1], this.ppf(p2, params)];\\n  }\\n\\n  quantileSet(x, p, extraParams) {\\n    let [nu, mu] = extraParams;\\n\\n    \\n    if (nu === 1) { \\n      let halfCauchy = new HalfCauchyDistribution();\\n      return halfCauchy.quantileSet(x, p, [mu]);\\n    }\\n    if (nu === Infinity) { \\n      let halfNormal = new HalfNormalDistribution();\\n      return halfNormal.quantileSet(x, p, [mu]);\\n    }\\n\\n    let x1 = x[0];\\n    let p1 = p[0];\\n\\n    \\n    const quantileRootFun = (params, nu, mu, x1, p1) =&gt; {\\n      let sigma = Math.exp(params[0]);\\n\\n      return [this.cdfSingleValue(x1, [nu, mu, sigma]) - p1];\\n    };\\n\\n    let args = [nu, mu, x1, p1];\\n\\n    \\n    let guess;\\n    let guessSuccess;\\n    if (nu &lt; 3) {\\n      let halfCauchy = new HalfCauchyDistribution();\\n      [guess, guessSuccess] = halfCauchy.quantileSet(x, p, [mu]);\\n    } else {\\n      let halfNormal = new HalfNormalDistribution();\\n      [guess, guessSuccess] = halfNormal.quantileSet(x, p, [mu]);      \\n    }\\n\\n    \\n    guess = [Math.log(guess[0])];\\n\\n    let [paramsFirstPass, optimSuccess] = findRootTrustRegion(quantileRootFun, guess, args=args);\\n\\n    \\n    paramsFirstPass[0] = Math.exp(paramsFirstPass[0]);\\n\\n    \\n    if (!optimSuccess) {\\n      return [[paramsFirstPass[0]], optimSuccess];\\n    }\\n\\n    \\n    const closeQuantileRootFun = (params, nu, mu, x1, p1) =&gt; {\\n      let sigma = params[0];\\n\\n      return [this.cdfSingleValue(x1, [nu, mu, sigma]) - p1];\\n    };\\n\\n    let paramsOpt;\\n    [paramsOpt, optimSuccess] = findRootTrustRegion(closeQuantileRootFun, paramsFirstPass, args=args);\\n\\n    let retval;\\n    if (optimSuccess &amp;&amp; norm(closeQuantileRootFun(paramsOpt, nu, x1, p1)) &lt; norm(closeQuantileRootFun(paramsFirstPass, nu, x1, p1))) {\\n      retval = [paramsOpt, optimSuccess];\\n    } else {\\n      retval = [paramsOpt, optimSuccess];\\n    }\\n\\n    return retval;\\n  }\\n}\\n\\n\\n\\nvar dist = new HalfStudentTDistribution();\\n\\n\\n\\nif (quantileSetterSwitch.active) {\\n  quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p);\\n}"}}]]]},"disabled":true,"width":80,"value":"4.3027"}}]],["pBoxes",[{"id":"p2481"}]],["quantileSetterSwitch",{"id":"p2483"}],["quantileSetterDiv",{"id":"p2482"}],["triggerCallbacks",{"id":"p2484"}],["startBoxes",[{"id":"p2474"},{"id":"p2475"},{"id":"p2476"}]],["endBoxes",[{"id":"p2477"},{"id":"p2478"},{"id":"p2479"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let x = paramsFromBoxes(xBoxes);\\n  let p = paramsFromBoxes(pBoxes);\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ){\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n          endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);        \\n        }\\n        sliders[dist.activeParamsInds[i]].value = optimParams[i];\\n      }\\n\\n      params = paramsFromSliders(sliders); \\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.floor(xRange.start);\\n  let xRangeMax = Math.ceil(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c = [xRangeMin - 1, ...x_p.flatMap(x =&gt; [x, x]), xRangeMax + 1];\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = -0.04;\\n    p_c.y_range.end = 1.04;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = -pdfMax * 0.04;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264&#x27; + xMax.toString() + &#x27;.&lt;/p\\\\&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nclass CauchyDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Cauchy&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return -Infinity;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x == Infinity || x == -Infinity) return 0.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    return 1.0 / Math.PI / sigma / (1 + Math.pow((x - mu) / sigma, 2))\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    return 0.5 + Math.atan((x - mu) / sigma) / Math.PI;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    return mu + sigma * Math.tan(Math.PI * (p - 0.5));\\n  }\\n\\n  defaultXRange(params) {\\n    \\n    return this.ppf([0.025, 0.975], params);\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    let cotp1 = 1.0 / Math.tan(Math.PI * p1);\\n    let cotp2 = 1.0 / Math.tan(Math.PI * p2);\\n\\n    let mu = (x2 * cotp1 - x1 * cotp2) / (cotp1 - cotp2);\\n    let sigma = (x1 - x2) * Math.sin(Math.PI * p1) * Math.sin(Math.PI * p1) \\n                / Math.sin(Math.PI * (p1 - p2));\\n\\n    return [[mu, sigma], true];\\n  }\\n}\\n\\nclass HalfCauchyDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;HalfCauchy&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u00b5&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.fixedParams = [&#x27;\\u00b5&#x27;];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return params[0];\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x &lt; mu) return NaN;\\n    if (x === Infinity) return 0.0;\\n\\n    return 2.0 / Math.PI / sigma / (1 + Math.pow((x - mu) / sigma, 2));\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x &lt;= mu) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    return 2.0 * Math.atan((x - mu) / sigma) / Math.PI;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    return mu + sigma * Math.tan(Math.PI * p / 2.0);\\n  }\\n\\n  defaultXRange(params) {\\n    \\n    return [params[0], this.ppf(0.9, params)];\\n  }\\n\\n  quantileSet(x, p, extraParams) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n    let mu = extraParams[0];\\n\\n    return [[(x1 - mu) / Math.tan(Math.PI * p1 / 2)], true];\\n  }\\n}\\n\\nclass HalfNormalDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;HalfNormal&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u00b5&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.fixedParams = [&#x27;\\u00b5&#x27;];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return params[0];\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x &lt; mu) return NaN;\\n    if (x === Infinity) return 0.0;\\n\\n    let expTerm = (Math.pow(x - mu, 2) / 2.0 / Math.pow(sigma, 2));\\n    return Math.exp(-expTerm) / sigma * Math.sqrt(2.0 / Math.PI);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x &lt;= mu) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    return erf((x - mu) / sigma / Math.sqrt(2));\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return mu + sqrt2 * sigma * erfinv(p);\\n  }\\n\\n  defaultXRange(params) {\\n    return [params[0], this.ppf(0.999, params)];\\n  }\\n\\n  quantileSet(x, p, extraParams) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n    let mu = extraParams[0];\\n\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return [[(x1 - mu) / sqrt2 / erfinv(p1)], true];\\n  }\\n}\\n\\nclass NormalDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Normal&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n}\\n\\n  xMin(params) {\\n    return -Infinity;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x === -Infinity || x === Infinity) return 0.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    let expTerm = (Math.pow(x - mu, 2) / 2.0 / Math.pow(sigma, 2));\\n    return Math.exp(-expTerm) / sigma / Math.sqrt(2 * Math.PI);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x === -Infinity) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    return (1 + erf((x - mu) / sigma / Math.sqrt(2))) / 2;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return -Infinity;\\n    if (p === 1) return Infinity;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return mu + sqrt2 * sigma * erfinv(2 * p - 1);\\n  }\\n\\n  defaultXRange(params) {\\n    return this.ppf([0.001, 0.999], params);\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    let sqrt2 = 1.4142135623730951;\\n\\n    let sigmaCoeff1 = sqrt2 * erfinv(2 * p1 - 1);\\n    let sigmaCoeff2 = sqrt2 * erfinv(2 * p2 - 1);\\n\\n    let sigma = (x2 - x1) / (sigmaCoeff2 - sigmaCoeff1);\\n    let mu = x2 - sigmaCoeff2 * sigma;\\n\\n    return [[mu, sigma], true];\\n  }\\n}\\n\\nclass StudentTDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;StudentT&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bd&#x27;, &#x27;\\u03bc&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.fixedParams = [&#x27;\\u03bd&#x27;];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return -Infinity;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x === -Infinity || x === Infinity) return 0.0;\\n\\n    let [nu, mu, sigma] = params.slice(0, 3);\\n\\n    let lnprob;\\n\\n    lnprob = lngamma((nu + 1) / 2) - lngamma(nu / 2) - Math.log(Math.PI * nu) / 2 - Math.log(sigma)\\n             - (nu + 1) / 2 * log1p(Math.pow(x - mu, 2) / nu / Math.pow(sigma, 2));\\n\\n    return Math.exp(lnprob);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x === -Infinity) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let [nu, mu, sigma] = params.slice(0, 3);\\n\\n    let y = (x - mu) / sigma;\\n\\n    if (y &gt;= 0) {\\n        return 1 - regularizedIncompleteBeta(nu / (Math.pow(y, 2) + nu), 0.5 * nu, 0.5) / 2;\\n    }\\n    else {\\n        return regularizedIncompleteBeta(nu / (Math.pow(y, 2) + nu), 0.5 * nu, 0.5) / 2;        \\n    }\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let [nu, mu, sigma] = params.slice(0, 3);\\n\\n    \\n    let guess;\\n    if (nu &lt; 3) { \\n      guess = Math.tan(Math.PI * (p - 0.5));\\n    } else {\\n      guess = Math.sqrt(2) * erfinv(2 * p - 1)\\n    }\\n\\n    \\n    if (nu === 1 || nu === Infinity) return mu + sigma * guess;\\n\\n    \\n    let rootFun = (x, nu, p) =&gt; [p - this.cdfSingleValue(x, [nu, 0, 1])];\\n    let [xOpt, success] = findRootTrustRegion(rootFun, [guess], [nu, p]);\\n\\n    return mu + sigma * xOpt[0];\\n  }\\n\\n  defaultXRange(params) {\\n    \\n    let [nu, mu, sigma] = params.slice(0, 3);\\n\\n    let p1;\\n    let p2;\\n\\n    if (nu &lt; 2) {\\n        p1 = 0.05;\\n        p2 = 0.95;\\n    }\\n    if (nu &lt; 4) {\\n        p1 = 0.01;\\n        p2 = 0.99;\\n    }\\n    else if (nu &lt; 10) {\\n        p1 = 0.005;\\n        p2 = 0.995;\\n    }\\n    else {\\n        p1 = 0.001;\\n        p2 = 0.999;\\n    }\\n\\n    return this.ppf([p1, p2], params);\\n  }\\n\\n  quantileSet(x, p, extraParams) {\\n\\n    let nu = extraParams[0];\\n\\n    \\n    if (nu === 1) { \\n      let cauchy = new CauchyDistribution();\\n      return cauchy.quantileSet(x, p);\\n    }\\n    if (nu === Infinity) { \\n      let normal = new NormalDistribution();\\n      return normal.quantileSet(x, p);\\n    }\\n\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    \\n    const quantileRootFun = (params, nu, x1, p1, x2, p2) =&gt; {\\n      let mu = params[0];\\n      let sigma = Math.exp(params[1]);\\n\\n      let r1 = this.cdfSingleValue(x1, [nu, mu, sigma]) - p1;\\n      let r2 = this.cdfSingleValue(x2, [nu, mu, sigma]) - p2;\\n\\n      return [r1, r2];\\n    };\\n\\n    let args = [nu, x1, p1, x2, p2];\\n\\n    \\n    let guess;\\n    let guessSuccess;\\n    if (nu &lt; 3) {\\n      let cauchy = new CauchyDistribution();\\n      [guess, guessSuccess] = cauchy.quantileSet(x, p);\\n    } else {\\n      let normal = new NormalDistribution();\\n      [guess, guessSuccess] = normal.quantileSet(x, p);      \\n    }\\n\\n    \\n    guess = [guess[0], Math.log(guess[1])];\\n\\n    let [paramsFirstPass, optimSuccess] = findRootTrustRegion(quantileRootFun, guess, args=args);\\n\\n    \\n    paramsFirstPass[1] = Math.exp(paramsFirstPass[1]);\\n\\n    \\n    if (!optimSuccess) {\\n      return [[paramsFirstPass[0], paramsFirstPass[1]], optimSuccess];\\n    }\\n\\n    \\n    const closeQuantileRootFun = (params, nu, x1, p1, x2, p2) =&gt; {\\n      let [mu, sigma] = params.slice(0, 2);\\n\\n      let r1 = this.cdfSingleValue(x1, [nu, mu, sigma]) - p1;\\n      let r2 = this.cdfSingleValue(x2, [nu, mu, sigma]) - p2;\\n\\n      return [r1, r2];\\n    };\\n\\n    let paramsOpt;\\n    [paramsOpt, optimSuccess] = findRootTrustRegion(closeQuantileRootFun, paramsFirstPass, args=args);\\n\\n    let retval;\\n    if (optimSuccess &amp;&amp; norm(closeQuantileRootFun(paramsOpt, nu, x1, p1, x2, p2)) &lt; norm(closeQuantileRootFun(paramsFirstPass, nu, x1, p1, x2, p2))) {\\n      retval = [paramsOpt, optimSuccess];\\n    } else {\\n      retval = [paramsOpt, optimSuccess];\\n    }\\n\\n    return retval;\\n  }\\n\\n}\\n\\nfunction log1p(x) {\\n  \\n  \\n  if (x &lt;= -1.0) {\\n    throw new RangeError(&#x27;Argument must be greater than -1.0&#x27;);\\n  }\\n\\n  \\n  else if (Math.abs(x) &gt; 1e-4) {\\n    return Math.log(1.0 + x);\\n  }\\n\\n  else {\\n    return (-0.5*x + 1.0)*x;\\n  }\\n}\\n\\n\\nfunction regularizedIncompleteBeta(x, a, b) {\\n    \\n    \\n    if (x &lt; 0 || x &gt; 1) {\\n        throw new RangeError(&#x27;First argument must be between 0 and 1.&#x27;);\\n    }\\n\\n    \\n    else if (a === 1 &amp;&amp; b === 1) return x;\\n    else if (x === 0) return 0;\\n    else if (x === 1) return 1;\\n    else if (a === 0) return 1;\\n    else if (b === 0) return 0;\\n\\n    else {\\n        var bt = Math.exp(lngamma(a + b) - lngamma(a) - lngamma(b) + a * Math.log(x) + b * log1p(-x));\\n\\n        \\n        if (x &lt; (a + 1) / (a + b + 2)) return bt * betacf(x, a, b) / a;\\n\\n        \\n        else return 1 - bt * betacf(1 - x, b, a) / b;\\n    }\\n}\\n\\n\\nfunction lngamma(z) {\\n\\n    if(z &lt; 0) return Number(&#x27;0/0&#x27;);\\n\\n    if (z &lt; 0.5) return Math.log(Math.PI) - Math.log(Math.sin(Math.PI * z)) - lngamma(1-z);\\n\\n    var p = [676.5203681218851,\\n             -1259.1392167224028,\\n             771.32342877765313,\\n             -176.61502916214059,\\n             12.507343278686905,\\n             -0.13857109526572012,\\n             9.9843695780195716e-6,\\n             1.5056327351493116e-7];\\n\\n    z -= 1.0;\\n    var Ag = 0.99999999999980993;\\n    for (var i = 0; i &lt; p.length; i++) {\\n        Ag += p[i] / (z + i + 1);\\n    }\\n    var t = z + p.length - 0.5;\\n\\n    return 0.5 * Math.log(2*Math.PI) + (z + 0.5)*Math.log(t) - t + Math.log(Ag);\\n}\\n\\n\\nfunction norm(v) {\\n  return Math.sqrt(dot(v, v));\\n}\\n\\n\\nfunction findRootTrustRegion(\\n\\t\\tf, \\n\\t\\tx0, \\n\\t\\targs=[],\\n\\t\\tjac=jacCentralDiff,\\n\\t\\ttol=0.000000001, \\n\\t\\tmaxIters=10000, \\n\\t\\tdeltaBar=1000.0, \\n\\t\\teta=0.125, \\n\\t\\tminDelta=1e-12\\n  ) {\\n\\t\\n\\tlet x = deepCopy(x0);\\n\\n\\t\\n\\tlet delta = 0.99 * deltaBar;\\n\\n\\t\\n\\tlet r = f(x, ...args);\\n\\n\\t\\n\\tlet J = jac(f, x, args);\\n\\n\\t\\n\\tlet JTJ = mmMult(transpose(J), J);\\n\\n\\t\\n\\tlet JTr = mvMult(transpose(J), r);\\n\\n\\t\\n\\tlet normJTr = norm(JTr);\\n\\n\\tlet iters = 0;\\n\\twhile (iters &lt; maxIters &amp;&amp; checkTol(r, tol) &amp;&amp; delta &gt;= minDelta) {\\n\\t\\t\\n\\t\\tlet p = doglegStep(JTJ, JTr, normJTr, delta);\\n\\n\\t\\t\\n\\t\\tlet newr = f(vectorAdd(x, p), ...args);\\n\\t\\tlet rho = computeRho(r, newr, J, p);\\n\\n\\t\\t\\n\\t\\tif  (rho &lt; 0.25) {\\n\\t\\t\\tdelta = norm(p) / 4.0;\\n\\t\\t} else if (rho &gt; 0.75 &amp;&amp; Math.abs(norm(p) - delta) &lt; 1e-12) {\\n\\t\\t\\t\\tdelta = Math.min(2 * delta, deltaBar);\\n\\t\\t}\\n\\n\\t\\t\\n\\t\\tif (rho &gt; eta) {\\n\\t\\t\\tx = vectorAdd(x, p);\\n\\n\\t\\t\\tr = newr;\\n\\t\\t\\tJ = jac(f, x, args);\\n\\t\\t\\tJTJ = mmMult(transpose(J), J);\\n\\t\\t\\tJTr = mvMult(transpose(J), r);\\n\\t\\t\\tnormJTr = norm(JTr);\\n\\t\\t}\\n\\n\\t\\titers += 1;\\n\\t}\\n\\n\\tlet success = !checkTol(r, tol);\\n\\n\\treturn [x, success];\\n\\n}\\n\\n\\nfunction erf(x) {\\n  \\n  var a = [1.00002368,\\n           0.37409196,\\n           0.09678418,\\n           -0.18628806,\\n           0.27886807,\\n           -1.13520398,\\n           1.48851587,\\n           -0.82215223,\\n           0.17087277];\\n\\n  var t = 1 / (1 + Math.abs(x)/2);\\n  var expSum = -Math.pow(x, 2) - 1.26551223;\\n\\n  for (var i = 0; i &lt; a.length; i++) {\\n      expSum += a[i] * Math.pow(t, i+1);\\n  }\\n\\n  var result = 1 - t * Math.exp(expSum);\\n\\n  if (x &lt; 0) return -result;\\n  return result;\\n}\\n\\n\\nfunction erfinv(x) {\\n  \\n  let p = (x + 1.0) / 2.0;\\n\\n  \\n  if (p == 0.0) return -Infinity;\\n  if (p == 1.0) return Infinity;\\n  if (p &gt; 1.0 || p &lt; 0.0) return undefined;\\n\\n  let split1 = 0.425;\\n  let split2 = 5.0;\\n  let const1 = 0.180625;\\n  let const2 = 1.6;\\n\\n  \\n  let a0 = 3.3871327179;\\n  let a1 = 5.0434271938e1;\\n  let a2 = 1.5929113202e2;\\n  let a3 = 5.9109374720e1;\\n  let b1 = 1.7895169469e1;\\n  let b2 = 7.8757757664e1;\\n  let b3 = 6.7187563600e1;\\n\\n  \\n  let c0 = 1.4234372777;\\n  let c1 = 2.7568153900;\\n  let c2 = 1.3067284816;\\n  let c3 = 1.7023821103e-1;\\n  let d1 = 7.3700164250e-1;\\n  let d2 = 1.2021132975e-1;\\n\\n  \\n  let e0 = 6.6579051150;\\n  let e1 = 3.0812263860;\\n  let e2 = 4.2868294337e-1;\\n  let e3 = 1.7337203997e-2;\\n  let f1 = 2.4197894225e-1;\\n  let f2 = 1.2258202635e-2;\\n\\n  let r;\\n  let res;\\n  let q = p - 0.5;\\n\\n  if (Math.abs(q) &lt;= split1) {\\n    r = const1 - q * q;\\n    res = q * (((a3 * r + a2) * r + a1) * r + a0) /\\n              (((b3 * r + b2) * r + b1) * r + 1.0);\\n  } else {\\n    r = q &lt; 0 ? p : 1.0 - p;\\n\\n    r = Math.sqrt(-Math.log(r));\\n\\n    if (r &lt;= split2) {\\n      r -= const2;\\n      res = (((c3 * r + c2) * r + c1) * r + c0) /\\n             ((d2 * r + d1) * r + 1.0);\\n    } else {\\n      r -= split2;\\n      res = (((e3 * r + e2) * r + e1) * r + e0) /\\n             ((f2 * r + f1) * r + 1.0);\\n    }\\n  \\n    if (q &lt; 0) {\\n      res = -res;\\n    }\\n  }\\n\\n  \\n  return 0.7071067811865475 * res;\\n\\n}\\n\\n\\nfunction betacf(x, a, b) {\\n    \\n    \\n    var fpmin = 1e-30,\\n        m = 1,\\n        m2, aa, c, d, del, h, qab, qam, qap;\\n    \\n    qab = a + b;\\n    qap = a + 1;\\n    qam = a - 1;\\n    c = 1;\\n    d = 1 - qab * x / qap;\\n    if (Math.abs(d) &lt; fpmin) d = fpmin;\\n    d = 1 / d;\\n    h = d;\\n    for (; m &lt;= 100; m++) {\\n        m2 = 2 * m;\\n        aa = m * (b - m) * x / ((qam + m2) * (a + m2));\\n        \\n        d = 1 + aa * d;\\n        if (Math.abs(d) &lt; fpmin) d = fpmin;\\n        c = 1 + aa / c;\\n        if (Math.abs(c) &lt; fpmin) c = fpmin;\\n        d = 1 / d;\\n        h *= d * c;\\n        aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));\\n        \\n        d = 1 + aa * d;\\n        if (Math.abs(d) &lt; fpmin) d = fpmin;\\n        c = 1 + aa / c;\\n        if (Math.abs(c) &lt; fpmin) c = fpmin;\\n        d = 1 / d;\\n        del = d * c;\\n        h *= del;\\n        if (Math.abs(del - 1.0) &lt; 3e-7) break;\\n    }\\n    return h;\\n}\\n\\n\\nfunction dot(v1, v2) {\\n  const n = v1.length;\\n  let result = 0.0;\\n  for (let i = 0; i &lt; n; i++) result += v1[i] * v2[i];\\n\\n  return result;\\n}\\n\\n\\nfunction transpose(A) {\\n    return A[0].map((_, colIndex) =&gt; A.map(row =&gt; row[colIndex]));\\n}\\n\\n\\nfunction mvMult(A, v) {\\n  return A.map(Arow =&gt; dot(Arow, v));\\n}\\n\\n\\nfunction mmMult(A, B) {\\n  let mA = A.length;\\n  let nA = A[0].length;\\n  let mB = B.length;\\n  let nB = B[0].length;\\n\\n  if (nA !== mB) {\\n      throw new Error(&#x27;Matrix dimension mismatch.&#x27;);\\n  }\\n\\n  let result = zeros(mA, nB);\\n\\n  for (let i = 0; i &lt; mA; i++) {\\n    for (let j = 0; j &lt; nB; j++) {\\n      for (let k = 0; k &lt; nA; k++) {\\n        result[i][j] += A[i][k] * B[k][j];\\n      }\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction vectorAdd() {\\n  let m = arguments.length;\\n  let n = arguments[0].length;\\n \\n  let result = new Array(n).fill(0.0);\\n \\n  for (let i = 0; i &lt; n; i++) {\\n    for (let j = 0; j &lt; m; j++) {\\n        result[i] += arguments[j][i];\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction deepCopy(x) {\\n  return JSON.parse(JSON.stringify(x));\\n}\\n\\n\\nfunction computeRho(r, newr, J, p) {\\n\\tlet r2 = norm(r) ** 2;\\n\\tlet num = r2 - norm(newr)**2;\\n\\tlet denom = r2 - norm(vectorAdd(r, mvMult(J, p))) ** 2;\\n\\n\\treturn num / denom;\\n}\\n\\n\\nfunction checkTol(r, tol) {\\n\\t\\n\\tconst n = r.length;\\n\\tfor (let i = 0; i &lt; n; i++) {\\n\\t\\tif (tol &lt; Math.abs(r[i])) return true;\\n\\t}\\n\\n\\treturn false;\\n}\\n\\n\\nfunction doglegStep(JTJ, JTr, normJTr, delta) {\\n\\t\\n\\tlet [pJ, posDef] = solvePosDef(JTJ, JTr);\\n\\tpJ = svMult(-1.0, pJ);\\n\\n\\t\\n\\tif (posDef &amp;&amp; norm(pJ) &lt;= delta) {\\n\\t\\treturn pJ;\\n\\t}\\n\\n\\t\\n\\tlet tau = Math.min(1, normJTr**3 / delta / quadForm(JTJ, JTr));\\n\\tlet pC = svMult(-tau * delta / normJTr, JTr);\\n\\n\\tlet pCnorm = norm(pC);\\n\\tif (!posDef || Math.abs(pCnorm - delta) &lt;= 1e-12) {\\n\\t\\treturn pC;\\n\\t}\\n\\n\\t\\n\\tlet pJ2 = norm(pJ) ** 2;\\n\\tlet pC2 = pCnorm**2;\\n\\tlet pJpC = dot(pJ, pC);\\n\\tlet a = pJ2 + pC2 - 2.0 * pJpC;\\n\\tlet b = 2.0 * (pJpC - pC2);\\n\\tlet c = pC2 - delta**2;\\n\\tlet q = -0.5 * (b + Math.sign(b) * Math.sqrt(b**2 - 4.0 * a * c));\\n\\n\\t\\n\\tlet beta;\\n\\tif (Math.abs(b) &lt; 1e-12) beta = Math.sqrt(-c / a);\\n\\telse if (b &lt; 0.0) beta = q / a;\\n\\telse beta = c / q;\\n\\n\\t\\n\\tif (0.0 &lt;= beta &amp;&amp; beta &lt;= 1) {\\n\\t\\treturn vectorAdd(pC, svMult(beta, vectorAdd(pJ, svMult(-1.0, pC))));\\n\\t} else { \\n\\t\\treturn pC;\\n\\t}\\n\\n}\\n\\n\\nfunction jacCentralDiff(f, x, args=[], eps=4.7e-6) {\\n\\t\\n\\tlet xPlus = deepCopy(x);\\n\\tlet xMinus = deepCopy(x);\\n\\n\\t\\n\\tlet fOfx = f(x, ...args);\\n\\tlet m = fOfx.length;\\n\\n\\t\\n\\tlet n = x.length;\\n\\n\\t\\n\\tlet J = zeros(m, n);\\n\\n\\t\\n\\tlet fOfxPlus;\\n\\tlet fOfxMinus;\\n\\n\\tfor (let j = 0; j &lt; n; j++) {\\n\\t\\txPlus[j] += eps;\\n\\t\\txMinus[j] -= eps;\\n\\t\\tfOfxPlus = f(xPlus, ...args);\\n\\t\\tfOfxMinus = f(xMinus, ...args);\\n\\t\\txPlus[j] -= eps;\\n\\t\\txMinus[j] += eps;\\n\\n\\t\\tfor (let i = 0; i &lt; m; i++) {\\n\\t\\t\\tJ[i][j] = (fOfxPlus[i] - fOfxMinus[i]) / 2.0 / eps;\\n\\t\\t}\\n\\t}\\n\\n\\treturn J;\\n}\\n\\n\\nfunction zeros(...dims) {\\n  let A = [];\\n\\n  \\n  for (let i = dims.length - 1; i &gt;= 0; i--) {\\n    let size = dims[i];\\n    if (i === dims.length - 1) {\\n      \\n      A = new Array(size).fill(0.0);\\n    } else {\\n      \\n      A = new Array(size).fill().map(() =&gt; deepCopy(A));\\n    }\\n  }\\n\\n  return A;\\n}\\n\\n\\nfunction svMult(a, v) {\\n  return v.map(x =&gt; a * x);\\n}\\n\\n\\nfunction quadForm(A, x) {\\n   return dot(x, mvMult(A, x)); \\n}\\n\\n\\nfunction solvePosDef(A, b) {\\n  let [L, p, success] = modifiedCholesky(A);\\n\\n  if (!success) {\\n    return [zeros(b.length), success];\\n  }\\n\\n  return [modifiedCholeskySolve(L, p, b), success];\\n}\\n\\n\\nfunction modifiedCholesky(A) {\\n    const floatEps = 1.0e-14;\\n    const n = A.length;\\n\\n    \\n    let L = deepCopy(A); \\n    let p = arange(0, n);\\n\\n    \\n    let success = true;\\n\\n    let xi = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        for (let j = 0; j &lt; i; j++) {\\n            let temp = Math.abs(L[i][j]);\\n            xi = Math.max(xi, temp);\\n        }\\n    }\\n\\n    let eta = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        let temp = Math.abs(L[i][i]);\\n        eta = Math.max(eta, temp);\\n    }\\n\\n    let beta;\\n    if (n &gt; 1) {\\n        beta = Math.sqrt(Math.max(eta, xi / Math.sqrt(n * n - 1)));\\n    } else {\\n        beta = Math.sqrt(eta);\\n    }\\n    beta = Math.max(beta, floatEps);\\n\\n    for (let k = 0; k &lt; n; k++) {\\n        \\n        let muVal = L[k][k];\\n        let mu = k;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            let temp = L[i][i];\\n            if (muVal &lt; temp) {\\n                mu = i;\\n                muVal = temp;\\n            }\\n        }\\n\\n        \\n        let iTemp = p[mu];\\n        p[mu] = p[k];\\n        p[k] = iTemp;\\n\\n        for (let i = 0; i &lt; k; i++) {\\n            let temp = L[k][i];\\n            L[k][i] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        let temp = L[k][k];\\n        L[k][k] = L[mu][mu];\\n        L[mu][mu] = temp;\\n        for (let i = k + 1; i &lt; mu; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        for (let i = mu + 1; i &lt; n; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[i][mu];\\n            L[i][mu] = temp;\\n        }\\n\\n        \\n        let cSum = 0;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            cSum = Math.max(cSum, Math.abs(L[i][k]));\\n        }\\n        cSum /= beta;\\n        cSum = cSum * cSum;\\n\\n        \\n        if (L[k][k] &lt; 0) {\\n            success = false;\\n        }\\n\\n        temp = Math.abs(L[k][k]);\\n        temp = Math.max(temp, floatEps * eta);\\n        temp = Math.max(temp, cSum);\\n        L[k][k] = Math.sqrt(temp);\\n\\n        \\n        for (let i = k + 1; i &lt; n; i++) {\\n            L[i][k] /= L[k][k];\\n        }\\n\\n        \\n        for (let j = k + 1; j &lt; n; j++) {\\n            for (let i = j; i &lt; n; i++) {\\n                L[i][j] -= L[i][k] * L[j][k];\\n            }\\n        }\\n\\n        \\n        for (let i = 0; i &lt; n - 1; i++) {\\n            for (let j = i + 1; j &lt; n; j++) {\\n                L[i][j] = 0.0;\\n            }\\n        }\\n    }\\n\\n    return [L, p, success];\\n}\\n\\n\\nfunction modifiedCholeskySolve(L, p, b) {\\n    const n = L.length;\\n\\n    let U = transpose(L);\\n    let xp = new Array(n).fill(0);\\n    for (let i = 0; i &lt; n; i++) {\\n        xp[i] = b[p[i]];\\n    }\\n\\n    \\n    let x = lowerTriSolve(L, xp);\\n\\n    \\n    xp = upperTriSolve(U, x);\\n\\n    for (let i = 0; i &lt; n; i++) {\\n        x[p[i]] = xp[i];\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction lowerTriSolve(L, b) {\\n    const floatEps = 1.0e-14;\\n    const n = L.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = 0; j &lt; n - 1; j++) {\\n        if (Math.abs(L[j][j]) &gt; floatEps) {\\n            x[j] /= L[j][j];\\n            for (let i = j + 1; i &lt; n; i++) {\\n                x[i] -= x[j] * L[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(L[n - 1][n - 1]) &gt; floatEps) {\\n            x[n - 1] /= L[n - 1][n - 1];\\n        } else {\\n            x[n - 1] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction upperTriSolve(U, b) {\\n    const floatEps = 1.0e-14;\\n    const n = U.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = n - 1; j &gt; 0; j--) {\\n        if (Math.abs(U[j][j]) &gt; floatEps) {\\n            x[j] /= U[j][j];\\n            for (let i = 0; i &lt; j; i++) {\\n                x[i] -= x[j] * U[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(U[0][0]) &gt; floatEps) {\\n            x[0] /= U[0][0];\\n        } else {\\n            x[0] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nclass HalfStudentTDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;HalfStudentT&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bd&#x27;, &#x27;\\u00b5&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.fixedParams = [&#x27;\\u03bd&#x27;, &#x27;\\u00b5&#x27;];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return params[1];\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let [nu, mu, sigma] = params.slice(0, 3);\\n\\n    if (x &lt; mu) return NaN;\\n    if (x === Infinity) return 0.0;\\n\\n    let lnprob;\\n\\n    lnprob = Math.log(2.0) + lngamma((nu + 1) / 2) - lngamma(nu / 2) - Math.log(Math.PI * nu) / 2 \\n             - Math.log(sigma) - (nu + 1) / 2 * log1p(Math.pow(x - mu, 2) / nu / Math.pow(sigma, 2));\\n\\n    return Math.exp(lnprob);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let [nu, mu, sigma] = params.slice(0, 3);\\n\\n    if (x &lt;= mu) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let y = (x - mu) / sigma;\\n\\n    return 1 - regularizedIncompleteBeta(nu / (Math.pow(y, 2) + nu), 0.5 * nu, 0.5);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return params[1];\\n    if (p === 1) return Infinity;\\n\\n    let studentT = new StudentTDistribution();\\n    return studentT.ppf((1 + p) / 2, params);\\n  }\\n\\n  defaultXRange(params) {\\n    \\n    let [nu, mu, sigma] = params.slice(0, 3);\\n    let p2;\\n\\n    if (nu &lt; 2) p2 = 0.95;\\n    else if (nu &lt; 4) p2 = 0.99;\\n    else if (nu &lt; 10) p2 = 0.995;\\n    else p2 = 0.999;\\n\\n    return [params[1], this.ppf(p2, params)];\\n  }\\n\\n  quantileSet(x, p, extraParams) {\\n    let [nu, mu] = extraParams;\\n\\n    \\n    if (nu === 1) { \\n      let halfCauchy = new HalfCauchyDistribution();\\n      return halfCauchy.quantileSet(x, p, [mu]);\\n    }\\n    if (nu === Infinity) { \\n      let halfNormal = new HalfNormalDistribution();\\n      return halfNormal.quantileSet(x, p, [mu]);\\n    }\\n\\n    let x1 = x[0];\\n    let p1 = p[0];\\n\\n    \\n    const quantileRootFun = (params, nu, mu, x1, p1) =&gt; {\\n      let sigma = Math.exp(params[0]);\\n\\n      return [this.cdfSingleValue(x1, [nu, mu, sigma]) - p1];\\n    };\\n\\n    let args = [nu, mu, x1, p1];\\n\\n    \\n    let guess;\\n    let guessSuccess;\\n    if (nu &lt; 3) {\\n      let halfCauchy = new HalfCauchyDistribution();\\n      [guess, guessSuccess] = halfCauchy.quantileSet(x, p, [mu]);\\n    } else {\\n      let halfNormal = new HalfNormalDistribution();\\n      [guess, guessSuccess] = halfNormal.quantileSet(x, p, [mu]);      \\n    }\\n\\n    \\n    guess = [Math.log(guess[0])];\\n\\n    let [paramsFirstPass, optimSuccess] = findRootTrustRegion(quantileRootFun, guess, args=args);\\n\\n    \\n    paramsFirstPass[0] = Math.exp(paramsFirstPass[0]);\\n\\n    \\n    if (!optimSuccess) {\\n      return [[paramsFirstPass[0]], optimSuccess];\\n    }\\n\\n    \\n    const closeQuantileRootFun = (params, nu, mu, x1, p1) =&gt; {\\n      let sigma = params[0];\\n\\n      return [this.cdfSingleValue(x1, [nu, mu, sigma]) - p1];\\n    };\\n\\n    let paramsOpt;\\n    [paramsOpt, optimSuccess] = findRootTrustRegion(closeQuantileRootFun, paramsFirstPass, args=args);\\n\\n    let retval;\\n    if (optimSuccess &amp;&amp; norm(closeQuantileRootFun(paramsOpt, nu, x1, p1)) &lt; norm(closeQuantileRootFun(paramsFirstPass, nu, x1, p1))) {\\n      retval = [paramsOpt, optimSuccess];\\n    } else {\\n      retval = [paramsOpt, optimSuccess];\\n    }\\n\\n    return retval;\\n  }\\n}\\n\\n\\n\\nvar dist = new HalfStudentTDistribution();\\n\\n\\n\\nif (triggerCallbacks.active &amp;&amp; !cb_obj.disabled) {\\n\\tif (quantileSetterSwitch.active) {\\n\\t\\tquantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p);\\n\\t}\\n\\telse {\\n\\t\\tupdateData(source_p, source_c, p_p, sliders, discrete);\\n\\t\\tupdateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes);\\n\\t}\\n}"}}]]]},"width":200,"title":"\\u03bd","format":{"type":"object","name":"CustomJSTickFormatter","id":"p2468","attributes":{"code":"return tick.toPrecision(4)"}},"start":1,"end":10,"value":2,"step":0.01}},{"id":"p2471"},{"id":"p2473"}]],["xBoxes",[{"id":"p2480"}]],["pBoxes",[{"id":"p2481"}]],["quantileSetterSwitch",{"id":"p2483"}],["quantileSetterDiv",{"id":"p2482"}],["triggerCallbacks",{"id":"p2484"}],["startBoxes",[{"id":"p2474"},{"id":"p2475"},{"id":"p2476"}]],["endBoxes",[{"id":"p2477"},{"id":"p2478"},{"id":"p2479"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let x = paramsFromBoxes(xBoxes);\\n  let p = paramsFromBoxes(pBoxes);\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ){\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n          endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);        \\n        }\\n        sliders[dist.activeParamsInds[i]].value = optimParams[i];\\n      }\\n\\n      params = paramsFromSliders(sliders); \\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.floor(xRange.start);\\n  let xRangeMax = Math.ceil(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c = [xRangeMin - 1, ...x_p.flatMap(x =&gt; [x, x]), xRangeMax + 1];\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = -0.04;\\n    p_c.y_range.end = 1.04;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = -pdfMax * 0.04;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264&#x27; + xMax.toString() + &#x27;.&lt;/p\\\\&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nclass CauchyDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Cauchy&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return -Infinity;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x == Infinity || x == -Infinity) return 0.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    return 1.0 / Math.PI / sigma / (1 + Math.pow((x - mu) / sigma, 2))\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    return 0.5 + Math.atan((x - mu) / sigma) / Math.PI;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    return mu + sigma * Math.tan(Math.PI * (p - 0.5));\\n  }\\n\\n  defaultXRange(params) {\\n    \\n    return this.ppf([0.025, 0.975], params);\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    let cotp1 = 1.0 / Math.tan(Math.PI * p1);\\n    let cotp2 = 1.0 / Math.tan(Math.PI * p2);\\n\\n    let mu = (x2 * cotp1 - x1 * cotp2) / (cotp1 - cotp2);\\n    let sigma = (x1 - x2) * Math.sin(Math.PI * p1) * Math.sin(Math.PI * p1) \\n                / Math.sin(Math.PI * (p1 - p2));\\n\\n    return [[mu, sigma], true];\\n  }\\n}\\n\\nclass HalfCauchyDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;HalfCauchy&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u00b5&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.fixedParams = [&#x27;\\u00b5&#x27;];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return params[0];\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x &lt; mu) return NaN;\\n    if (x === Infinity) return 0.0;\\n\\n    return 2.0 / Math.PI / sigma / (1 + Math.pow((x - mu) / sigma, 2));\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x &lt;= mu) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    return 2.0 * Math.atan((x - mu) / sigma) / Math.PI;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    return mu + sigma * Math.tan(Math.PI * p / 2.0);\\n  }\\n\\n  defaultXRange(params) {\\n    \\n    return [params[0], this.ppf(0.9, params)];\\n  }\\n\\n  quantileSet(x, p, extraParams) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n    let mu = extraParams[0];\\n\\n    return [[(x1 - mu) / Math.tan(Math.PI * p1 / 2)], true];\\n  }\\n}\\n\\nclass HalfNormalDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;HalfNormal&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u00b5&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.fixedParams = [&#x27;\\u00b5&#x27;];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return params[0];\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x &lt; mu) return NaN;\\n    if (x === Infinity) return 0.0;\\n\\n    let expTerm = (Math.pow(x - mu, 2) / 2.0 / Math.pow(sigma, 2));\\n    return Math.exp(-expTerm) / sigma * Math.sqrt(2.0 / Math.PI);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x &lt;= mu) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    return erf((x - mu) / sigma / Math.sqrt(2));\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return mu + sqrt2 * sigma * erfinv(p);\\n  }\\n\\n  defaultXRange(params) {\\n    return [params[0], this.ppf(0.999, params)];\\n  }\\n\\n  quantileSet(x, p, extraParams) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n    let mu = extraParams[0];\\n\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return [[(x1 - mu) / sqrt2 / erfinv(p1)], true];\\n  }\\n}\\n\\nclass NormalDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Normal&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n}\\n\\n  xMin(params) {\\n    return -Infinity;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x === -Infinity || x === Infinity) return 0.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    let expTerm = (Math.pow(x - mu, 2) / 2.0 / Math.pow(sigma, 2));\\n    return Math.exp(-expTerm) / sigma / Math.sqrt(2 * Math.PI);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x === -Infinity) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    return (1 + erf((x - mu) / sigma / Math.sqrt(2))) / 2;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return -Infinity;\\n    if (p === 1) return Infinity;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return mu + sqrt2 * sigma * erfinv(2 * p - 1);\\n  }\\n\\n  defaultXRange(params) {\\n    return this.ppf([0.001, 0.999], params);\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    let sqrt2 = 1.4142135623730951;\\n\\n    let sigmaCoeff1 = sqrt2 * erfinv(2 * p1 - 1);\\n    let sigmaCoeff2 = sqrt2 * erfinv(2 * p2 - 1);\\n\\n    let sigma = (x2 - x1) / (sigmaCoeff2 - sigmaCoeff1);\\n    let mu = x2 - sigmaCoeff2 * sigma;\\n\\n    return [[mu, sigma], true];\\n  }\\n}\\n\\nclass StudentTDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;StudentT&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bd&#x27;, &#x27;\\u03bc&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.fixedParams = [&#x27;\\u03bd&#x27;];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return -Infinity;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x === -Infinity || x === Infinity) return 0.0;\\n\\n    let [nu, mu, sigma] = params.slice(0, 3);\\n\\n    let lnprob;\\n\\n    lnprob = lngamma((nu + 1) / 2) - lngamma(nu / 2) - Math.log(Math.PI * nu) / 2 - Math.log(sigma)\\n             - (nu + 1) / 2 * log1p(Math.pow(x - mu, 2) / nu / Math.pow(sigma, 2));\\n\\n    return Math.exp(lnprob);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x === -Infinity) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let [nu, mu, sigma] = params.slice(0, 3);\\n\\n    let y = (x - mu) / sigma;\\n\\n    if (y &gt;= 0) {\\n        return 1 - regularizedIncompleteBeta(nu / (Math.pow(y, 2) + nu), 0.5 * nu, 0.5) / 2;\\n    }\\n    else {\\n        return regularizedIncompleteBeta(nu / (Math.pow(y, 2) + nu), 0.5 * nu, 0.5) / 2;        \\n    }\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let [nu, mu, sigma] = params.slice(0, 3);\\n\\n    \\n    let guess;\\n    if (nu &lt; 3) { \\n      guess = Math.tan(Math.PI * (p - 0.5));\\n    } else {\\n      guess = Math.sqrt(2) * erfinv(2 * p - 1)\\n    }\\n\\n    \\n    if (nu === 1 || nu === Infinity) return mu + sigma * guess;\\n\\n    \\n    let rootFun = (x, nu, p) =&gt; [p - this.cdfSingleValue(x, [nu, 0, 1])];\\n    let [xOpt, success] = findRootTrustRegion(rootFun, [guess], [nu, p]);\\n\\n    return mu + sigma * xOpt[0];\\n  }\\n\\n  defaultXRange(params) {\\n    \\n    let [nu, mu, sigma] = params.slice(0, 3);\\n\\n    let p1;\\n    let p2;\\n\\n    if (nu &lt; 2) {\\n        p1 = 0.05;\\n        p2 = 0.95;\\n    }\\n    if (nu &lt; 4) {\\n        p1 = 0.01;\\n        p2 = 0.99;\\n    }\\n    else if (nu &lt; 10) {\\n        p1 = 0.005;\\n        p2 = 0.995;\\n    }\\n    else {\\n        p1 = 0.001;\\n        p2 = 0.999;\\n    }\\n\\n    return this.ppf([p1, p2], params);\\n  }\\n\\n  quantileSet(x, p, extraParams) {\\n\\n    let nu = extraParams[0];\\n\\n    \\n    if (nu === 1) { \\n      let cauchy = new CauchyDistribution();\\n      return cauchy.quantileSet(x, p);\\n    }\\n    if (nu === Infinity) { \\n      let normal = new NormalDistribution();\\n      return normal.quantileSet(x, p);\\n    }\\n\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    \\n    const quantileRootFun = (params, nu, x1, p1, x2, p2) =&gt; {\\n      let mu = params[0];\\n      let sigma = Math.exp(params[1]);\\n\\n      let r1 = this.cdfSingleValue(x1, [nu, mu, sigma]) - p1;\\n      let r2 = this.cdfSingleValue(x2, [nu, mu, sigma]) - p2;\\n\\n      return [r1, r2];\\n    };\\n\\n    let args = [nu, x1, p1, x2, p2];\\n\\n    \\n    let guess;\\n    let guessSuccess;\\n    if (nu &lt; 3) {\\n      let cauchy = new CauchyDistribution();\\n      [guess, guessSuccess] = cauchy.quantileSet(x, p);\\n    } else {\\n      let normal = new NormalDistribution();\\n      [guess, guessSuccess] = normal.quantileSet(x, p);      \\n    }\\n\\n    \\n    guess = [guess[0], Math.log(guess[1])];\\n\\n    let [paramsFirstPass, optimSuccess] = findRootTrustRegion(quantileRootFun, guess, args=args);\\n\\n    \\n    paramsFirstPass[1] = Math.exp(paramsFirstPass[1]);\\n\\n    \\n    if (!optimSuccess) {\\n      return [[paramsFirstPass[0], paramsFirstPass[1]], optimSuccess];\\n    }\\n\\n    \\n    const closeQuantileRootFun = (params, nu, x1, p1, x2, p2) =&gt; {\\n      let [mu, sigma] = params.slice(0, 2);\\n\\n      let r1 = this.cdfSingleValue(x1, [nu, mu, sigma]) - p1;\\n      let r2 = this.cdfSingleValue(x2, [nu, mu, sigma]) - p2;\\n\\n      return [r1, r2];\\n    };\\n\\n    let paramsOpt;\\n    [paramsOpt, optimSuccess] = findRootTrustRegion(closeQuantileRootFun, paramsFirstPass, args=args);\\n\\n    let retval;\\n    if (optimSuccess &amp;&amp; norm(closeQuantileRootFun(paramsOpt, nu, x1, p1, x2, p2)) &lt; norm(closeQuantileRootFun(paramsFirstPass, nu, x1, p1, x2, p2))) {\\n      retval = [paramsOpt, optimSuccess];\\n    } else {\\n      retval = [paramsOpt, optimSuccess];\\n    }\\n\\n    return retval;\\n  }\\n\\n}\\n\\nfunction log1p(x) {\\n  \\n  \\n  if (x &lt;= -1.0) {\\n    throw new RangeError(&#x27;Argument must be greater than -1.0&#x27;);\\n  }\\n\\n  \\n  else if (Math.abs(x) &gt; 1e-4) {\\n    return Math.log(1.0 + x);\\n  }\\n\\n  else {\\n    return (-0.5*x + 1.0)*x;\\n  }\\n}\\n\\n\\nfunction regularizedIncompleteBeta(x, a, b) {\\n    \\n    \\n    if (x &lt; 0 || x &gt; 1) {\\n        throw new RangeError(&#x27;First argument must be between 0 and 1.&#x27;);\\n    }\\n\\n    \\n    else if (a === 1 &amp;&amp; b === 1) return x;\\n    else if (x === 0) return 0;\\n    else if (x === 1) return 1;\\n    else if (a === 0) return 1;\\n    else if (b === 0) return 0;\\n\\n    else {\\n        var bt = Math.exp(lngamma(a + b) - lngamma(a) - lngamma(b) + a * Math.log(x) + b * log1p(-x));\\n\\n        \\n        if (x &lt; (a + 1) / (a + b + 2)) return bt * betacf(x, a, b) / a;\\n\\n        \\n        else return 1 - bt * betacf(1 - x, b, a) / b;\\n    }\\n}\\n\\n\\nfunction lngamma(z) {\\n\\n    if(z &lt; 0) return Number(&#x27;0/0&#x27;);\\n\\n    if (z &lt; 0.5) return Math.log(Math.PI) - Math.log(Math.sin(Math.PI * z)) - lngamma(1-z);\\n\\n    var p = [676.5203681218851,\\n             -1259.1392167224028,\\n             771.32342877765313,\\n             -176.61502916214059,\\n             12.507343278686905,\\n             -0.13857109526572012,\\n             9.9843695780195716e-6,\\n             1.5056327351493116e-7];\\n\\n    z -= 1.0;\\n    var Ag = 0.99999999999980993;\\n    for (var i = 0; i &lt; p.length; i++) {\\n        Ag += p[i] / (z + i + 1);\\n    }\\n    var t = z + p.length - 0.5;\\n\\n    return 0.5 * Math.log(2*Math.PI) + (z + 0.5)*Math.log(t) - t + Math.log(Ag);\\n}\\n\\n\\nfunction norm(v) {\\n  return Math.sqrt(dot(v, v));\\n}\\n\\n\\nfunction findRootTrustRegion(\\n\\t\\tf, \\n\\t\\tx0, \\n\\t\\targs=[],\\n\\t\\tjac=jacCentralDiff,\\n\\t\\ttol=0.000000001, \\n\\t\\tmaxIters=10000, \\n\\t\\tdeltaBar=1000.0, \\n\\t\\teta=0.125, \\n\\t\\tminDelta=1e-12\\n  ) {\\n\\t\\n\\tlet x = deepCopy(x0);\\n\\n\\t\\n\\tlet delta = 0.99 * deltaBar;\\n\\n\\t\\n\\tlet r = f(x, ...args);\\n\\n\\t\\n\\tlet J = jac(f, x, args);\\n\\n\\t\\n\\tlet JTJ = mmMult(transpose(J), J);\\n\\n\\t\\n\\tlet JTr = mvMult(transpose(J), r);\\n\\n\\t\\n\\tlet normJTr = norm(JTr);\\n\\n\\tlet iters = 0;\\n\\twhile (iters &lt; maxIters &amp;&amp; checkTol(r, tol) &amp;&amp; delta &gt;= minDelta) {\\n\\t\\t\\n\\t\\tlet p = doglegStep(JTJ, JTr, normJTr, delta);\\n\\n\\t\\t\\n\\t\\tlet newr = f(vectorAdd(x, p), ...args);\\n\\t\\tlet rho = computeRho(r, newr, J, p);\\n\\n\\t\\t\\n\\t\\tif  (rho &lt; 0.25) {\\n\\t\\t\\tdelta = norm(p) / 4.0;\\n\\t\\t} else if (rho &gt; 0.75 &amp;&amp; Math.abs(norm(p) - delta) &lt; 1e-12) {\\n\\t\\t\\t\\tdelta = Math.min(2 * delta, deltaBar);\\n\\t\\t}\\n\\n\\t\\t\\n\\t\\tif (rho &gt; eta) {\\n\\t\\t\\tx = vectorAdd(x, p);\\n\\n\\t\\t\\tr = newr;\\n\\t\\t\\tJ = jac(f, x, args);\\n\\t\\t\\tJTJ = mmMult(transpose(J), J);\\n\\t\\t\\tJTr = mvMult(transpose(J), r);\\n\\t\\t\\tnormJTr = norm(JTr);\\n\\t\\t}\\n\\n\\t\\titers += 1;\\n\\t}\\n\\n\\tlet success = !checkTol(r, tol);\\n\\n\\treturn [x, success];\\n\\n}\\n\\n\\nfunction erf(x) {\\n  \\n  var a = [1.00002368,\\n           0.37409196,\\n           0.09678418,\\n           -0.18628806,\\n           0.27886807,\\n           -1.13520398,\\n           1.48851587,\\n           -0.82215223,\\n           0.17087277];\\n\\n  var t = 1 / (1 + Math.abs(x)/2);\\n  var expSum = -Math.pow(x, 2) - 1.26551223;\\n\\n  for (var i = 0; i &lt; a.length; i++) {\\n      expSum += a[i] * Math.pow(t, i+1);\\n  }\\n\\n  var result = 1 - t * Math.exp(expSum);\\n\\n  if (x &lt; 0) return -result;\\n  return result;\\n}\\n\\n\\nfunction erfinv(x) {\\n  \\n  let p = (x + 1.0) / 2.0;\\n\\n  \\n  if (p == 0.0) return -Infinity;\\n  if (p == 1.0) return Infinity;\\n  if (p &gt; 1.0 || p &lt; 0.0) return undefined;\\n\\n  let split1 = 0.425;\\n  let split2 = 5.0;\\n  let const1 = 0.180625;\\n  let const2 = 1.6;\\n\\n  \\n  let a0 = 3.3871327179;\\n  let a1 = 5.0434271938e1;\\n  let a2 = 1.5929113202e2;\\n  let a3 = 5.9109374720e1;\\n  let b1 = 1.7895169469e1;\\n  let b2 = 7.8757757664e1;\\n  let b3 = 6.7187563600e1;\\n\\n  \\n  let c0 = 1.4234372777;\\n  let c1 = 2.7568153900;\\n  let c2 = 1.3067284816;\\n  let c3 = 1.7023821103e-1;\\n  let d1 = 7.3700164250e-1;\\n  let d2 = 1.2021132975e-1;\\n\\n  \\n  let e0 = 6.6579051150;\\n  let e1 = 3.0812263860;\\n  let e2 = 4.2868294337e-1;\\n  let e3 = 1.7337203997e-2;\\n  let f1 = 2.4197894225e-1;\\n  let f2 = 1.2258202635e-2;\\n\\n  let r;\\n  let res;\\n  let q = p - 0.5;\\n\\n  if (Math.abs(q) &lt;= split1) {\\n    r = const1 - q * q;\\n    res = q * (((a3 * r + a2) * r + a1) * r + a0) /\\n              (((b3 * r + b2) * r + b1) * r + 1.0);\\n  } else {\\n    r = q &lt; 0 ? p : 1.0 - p;\\n\\n    r = Math.sqrt(-Math.log(r));\\n\\n    if (r &lt;= split2) {\\n      r -= const2;\\n      res = (((c3 * r + c2) * r + c1) * r + c0) /\\n             ((d2 * r + d1) * r + 1.0);\\n    } else {\\n      r -= split2;\\n      res = (((e3 * r + e2) * r + e1) * r + e0) /\\n             ((f2 * r + f1) * r + 1.0);\\n    }\\n  \\n    if (q &lt; 0) {\\n      res = -res;\\n    }\\n  }\\n\\n  \\n  return 0.7071067811865475 * res;\\n\\n}\\n\\n\\nfunction betacf(x, a, b) {\\n    \\n    \\n    var fpmin = 1e-30,\\n        m = 1,\\n        m2, aa, c, d, del, h, qab, qam, qap;\\n    \\n    qab = a + b;\\n    qap = a + 1;\\n    qam = a - 1;\\n    c = 1;\\n    d = 1 - qab * x / qap;\\n    if (Math.abs(d) &lt; fpmin) d = fpmin;\\n    d = 1 / d;\\n    h = d;\\n    for (; m &lt;= 100; m++) {\\n        m2 = 2 * m;\\n        aa = m * (b - m) * x / ((qam + m2) * (a + m2));\\n        \\n        d = 1 + aa * d;\\n        if (Math.abs(d) &lt; fpmin) d = fpmin;\\n        c = 1 + aa / c;\\n        if (Math.abs(c) &lt; fpmin) c = fpmin;\\n        d = 1 / d;\\n        h *= d * c;\\n        aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));\\n        \\n        d = 1 + aa * d;\\n        if (Math.abs(d) &lt; fpmin) d = fpmin;\\n        c = 1 + aa / c;\\n        if (Math.abs(c) &lt; fpmin) c = fpmin;\\n        d = 1 / d;\\n        del = d * c;\\n        h *= del;\\n        if (Math.abs(del - 1.0) &lt; 3e-7) break;\\n    }\\n    return h;\\n}\\n\\n\\nfunction dot(v1, v2) {\\n  const n = v1.length;\\n  let result = 0.0;\\n  for (let i = 0; i &lt; n; i++) result += v1[i] * v2[i];\\n\\n  return result;\\n}\\n\\n\\nfunction transpose(A) {\\n    return A[0].map((_, colIndex) =&gt; A.map(row =&gt; row[colIndex]));\\n}\\n\\n\\nfunction mvMult(A, v) {\\n  return A.map(Arow =&gt; dot(Arow, v));\\n}\\n\\n\\nfunction mmMult(A, B) {\\n  let mA = A.length;\\n  let nA = A[0].length;\\n  let mB = B.length;\\n  let nB = B[0].length;\\n\\n  if (nA !== mB) {\\n      throw new Error(&#x27;Matrix dimension mismatch.&#x27;);\\n  }\\n\\n  let result = zeros(mA, nB);\\n\\n  for (let i = 0; i &lt; mA; i++) {\\n    for (let j = 0; j &lt; nB; j++) {\\n      for (let k = 0; k &lt; nA; k++) {\\n        result[i][j] += A[i][k] * B[k][j];\\n      }\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction vectorAdd() {\\n  let m = arguments.length;\\n  let n = arguments[0].length;\\n \\n  let result = new Array(n).fill(0.0);\\n \\n  for (let i = 0; i &lt; n; i++) {\\n    for (let j = 0; j &lt; m; j++) {\\n        result[i] += arguments[j][i];\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction deepCopy(x) {\\n  return JSON.parse(JSON.stringify(x));\\n}\\n\\n\\nfunction computeRho(r, newr, J, p) {\\n\\tlet r2 = norm(r) ** 2;\\n\\tlet num = r2 - norm(newr)**2;\\n\\tlet denom = r2 - norm(vectorAdd(r, mvMult(J, p))) ** 2;\\n\\n\\treturn num / denom;\\n}\\n\\n\\nfunction checkTol(r, tol) {\\n\\t\\n\\tconst n = r.length;\\n\\tfor (let i = 0; i &lt; n; i++) {\\n\\t\\tif (tol &lt; Math.abs(r[i])) return true;\\n\\t}\\n\\n\\treturn false;\\n}\\n\\n\\nfunction doglegStep(JTJ, JTr, normJTr, delta) {\\n\\t\\n\\tlet [pJ, posDef] = solvePosDef(JTJ, JTr);\\n\\tpJ = svMult(-1.0, pJ);\\n\\n\\t\\n\\tif (posDef &amp;&amp; norm(pJ) &lt;= delta) {\\n\\t\\treturn pJ;\\n\\t}\\n\\n\\t\\n\\tlet tau = Math.min(1, normJTr**3 / delta / quadForm(JTJ, JTr));\\n\\tlet pC = svMult(-tau * delta / normJTr, JTr);\\n\\n\\tlet pCnorm = norm(pC);\\n\\tif (!posDef || Math.abs(pCnorm - delta) &lt;= 1e-12) {\\n\\t\\treturn pC;\\n\\t}\\n\\n\\t\\n\\tlet pJ2 = norm(pJ) ** 2;\\n\\tlet pC2 = pCnorm**2;\\n\\tlet pJpC = dot(pJ, pC);\\n\\tlet a = pJ2 + pC2 - 2.0 * pJpC;\\n\\tlet b = 2.0 * (pJpC - pC2);\\n\\tlet c = pC2 - delta**2;\\n\\tlet q = -0.5 * (b + Math.sign(b) * Math.sqrt(b**2 - 4.0 * a * c));\\n\\n\\t\\n\\tlet beta;\\n\\tif (Math.abs(b) &lt; 1e-12) beta = Math.sqrt(-c / a);\\n\\telse if (b &lt; 0.0) beta = q / a;\\n\\telse beta = c / q;\\n\\n\\t\\n\\tif (0.0 &lt;= beta &amp;&amp; beta &lt;= 1) {\\n\\t\\treturn vectorAdd(pC, svMult(beta, vectorAdd(pJ, svMult(-1.0, pC))));\\n\\t} else { \\n\\t\\treturn pC;\\n\\t}\\n\\n}\\n\\n\\nfunction jacCentralDiff(f, x, args=[], eps=4.7e-6) {\\n\\t\\n\\tlet xPlus = deepCopy(x);\\n\\tlet xMinus = deepCopy(x);\\n\\n\\t\\n\\tlet fOfx = f(x, ...args);\\n\\tlet m = fOfx.length;\\n\\n\\t\\n\\tlet n = x.length;\\n\\n\\t\\n\\tlet J = zeros(m, n);\\n\\n\\t\\n\\tlet fOfxPlus;\\n\\tlet fOfxMinus;\\n\\n\\tfor (let j = 0; j &lt; n; j++) {\\n\\t\\txPlus[j] += eps;\\n\\t\\txMinus[j] -= eps;\\n\\t\\tfOfxPlus = f(xPlus, ...args);\\n\\t\\tfOfxMinus = f(xMinus, ...args);\\n\\t\\txPlus[j] -= eps;\\n\\t\\txMinus[j] += eps;\\n\\n\\t\\tfor (let i = 0; i &lt; m; i++) {\\n\\t\\t\\tJ[i][j] = (fOfxPlus[i] - fOfxMinus[i]) / 2.0 / eps;\\n\\t\\t}\\n\\t}\\n\\n\\treturn J;\\n}\\n\\n\\nfunction zeros(...dims) {\\n  let A = [];\\n\\n  \\n  for (let i = dims.length - 1; i &gt;= 0; i--) {\\n    let size = dims[i];\\n    if (i === dims.length - 1) {\\n      \\n      A = new Array(size).fill(0.0);\\n    } else {\\n      \\n      A = new Array(size).fill().map(() =&gt; deepCopy(A));\\n    }\\n  }\\n\\n  return A;\\n}\\n\\n\\nfunction svMult(a, v) {\\n  return v.map(x =&gt; a * x);\\n}\\n\\n\\nfunction quadForm(A, x) {\\n   return dot(x, mvMult(A, x)); \\n}\\n\\n\\nfunction solvePosDef(A, b) {\\n  let [L, p, success] = modifiedCholesky(A);\\n\\n  if (!success) {\\n    return [zeros(b.length), success];\\n  }\\n\\n  return [modifiedCholeskySolve(L, p, b), success];\\n}\\n\\n\\nfunction modifiedCholesky(A) {\\n    const floatEps = 1.0e-14;\\n    const n = A.length;\\n\\n    \\n    let L = deepCopy(A); \\n    let p = arange(0, n);\\n\\n    \\n    let success = true;\\n\\n    let xi = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        for (let j = 0; j &lt; i; j++) {\\n            let temp = Math.abs(L[i][j]);\\n            xi = Math.max(xi, temp);\\n        }\\n    }\\n\\n    let eta = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        let temp = Math.abs(L[i][i]);\\n        eta = Math.max(eta, temp);\\n    }\\n\\n    let beta;\\n    if (n &gt; 1) {\\n        beta = Math.sqrt(Math.max(eta, xi / Math.sqrt(n * n - 1)));\\n    } else {\\n        beta = Math.sqrt(eta);\\n    }\\n    beta = Math.max(beta, floatEps);\\n\\n    for (let k = 0; k &lt; n; k++) {\\n        \\n        let muVal = L[k][k];\\n        let mu = k;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            let temp = L[i][i];\\n            if (muVal &lt; temp) {\\n                mu = i;\\n                muVal = temp;\\n            }\\n        }\\n\\n        \\n        let iTemp = p[mu];\\n        p[mu] = p[k];\\n        p[k] = iTemp;\\n\\n        for (let i = 0; i &lt; k; i++) {\\n            let temp = L[k][i];\\n            L[k][i] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        let temp = L[k][k];\\n        L[k][k] = L[mu][mu];\\n        L[mu][mu] = temp;\\n        for (let i = k + 1; i &lt; mu; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        for (let i = mu + 1; i &lt; n; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[i][mu];\\n            L[i][mu] = temp;\\n        }\\n\\n        \\n        let cSum = 0;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            cSum = Math.max(cSum, Math.abs(L[i][k]));\\n        }\\n        cSum /= beta;\\n        cSum = cSum * cSum;\\n\\n        \\n        if (L[k][k] &lt; 0) {\\n            success = false;\\n        }\\n\\n        temp = Math.abs(L[k][k]);\\n        temp = Math.max(temp, floatEps * eta);\\n        temp = Math.max(temp, cSum);\\n        L[k][k] = Math.sqrt(temp);\\n\\n        \\n        for (let i = k + 1; i &lt; n; i++) {\\n            L[i][k] /= L[k][k];\\n        }\\n\\n        \\n        for (let j = k + 1; j &lt; n; j++) {\\n            for (let i = j; i &lt; n; i++) {\\n                L[i][j] -= L[i][k] * L[j][k];\\n            }\\n        }\\n\\n        \\n        for (let i = 0; i &lt; n - 1; i++) {\\n            for (let j = i + 1; j &lt; n; j++) {\\n                L[i][j] = 0.0;\\n            }\\n        }\\n    }\\n\\n    return [L, p, success];\\n}\\n\\n\\nfunction modifiedCholeskySolve(L, p, b) {\\n    const n = L.length;\\n\\n    let U = transpose(L);\\n    let xp = new Array(n).fill(0);\\n    for (let i = 0; i &lt; n; i++) {\\n        xp[i] = b[p[i]];\\n    }\\n\\n    \\n    let x = lowerTriSolve(L, xp);\\n\\n    \\n    xp = upperTriSolve(U, x);\\n\\n    for (let i = 0; i &lt; n; i++) {\\n        x[p[i]] = xp[i];\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction lowerTriSolve(L, b) {\\n    const floatEps = 1.0e-14;\\n    const n = L.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = 0; j &lt; n - 1; j++) {\\n        if (Math.abs(L[j][j]) &gt; floatEps) {\\n            x[j] /= L[j][j];\\n            for (let i = j + 1; i &lt; n; i++) {\\n                x[i] -= x[j] * L[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(L[n - 1][n - 1]) &gt; floatEps) {\\n            x[n - 1] /= L[n - 1][n - 1];\\n        } else {\\n            x[n - 1] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction upperTriSolve(U, b) {\\n    const floatEps = 1.0e-14;\\n    const n = U.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = n - 1; j &gt; 0; j--) {\\n        if (Math.abs(U[j][j]) &gt; floatEps) {\\n            x[j] /= U[j][j];\\n            for (let i = 0; i &lt; j; i++) {\\n                x[i] -= x[j] * U[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(U[0][0]) &gt; floatEps) {\\n            x[0] /= U[0][0];\\n        } else {\\n            x[0] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nclass HalfStudentTDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;HalfStudentT&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bd&#x27;, &#x27;\\u00b5&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.fixedParams = [&#x27;\\u03bd&#x27;, &#x27;\\u00b5&#x27;];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return params[1];\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let [nu, mu, sigma] = params.slice(0, 3);\\n\\n    if (x &lt; mu) return NaN;\\n    if (x === Infinity) return 0.0;\\n\\n    let lnprob;\\n\\n    lnprob = Math.log(2.0) + lngamma((nu + 1) / 2) - lngamma(nu / 2) - Math.log(Math.PI * nu) / 2 \\n             - Math.log(sigma) - (nu + 1) / 2 * log1p(Math.pow(x - mu, 2) / nu / Math.pow(sigma, 2));\\n\\n    return Math.exp(lnprob);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let [nu, mu, sigma] = params.slice(0, 3);\\n\\n    if (x &lt;= mu) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let y = (x - mu) / sigma;\\n\\n    return 1 - regularizedIncompleteBeta(nu / (Math.pow(y, 2) + nu), 0.5 * nu, 0.5);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return params[1];\\n    if (p === 1) return Infinity;\\n\\n    let studentT = new StudentTDistribution();\\n    return studentT.ppf((1 + p) / 2, params);\\n  }\\n\\n  defaultXRange(params) {\\n    \\n    let [nu, mu, sigma] = params.slice(0, 3);\\n    let p2;\\n\\n    if (nu &lt; 2) p2 = 0.95;\\n    else if (nu &lt; 4) p2 = 0.99;\\n    else if (nu &lt; 10) p2 = 0.995;\\n    else p2 = 0.999;\\n\\n    return [params[1], this.ppf(p2, params)];\\n  }\\n\\n  quantileSet(x, p, extraParams) {\\n    let [nu, mu] = extraParams;\\n\\n    \\n    if (nu === 1) { \\n      let halfCauchy = new HalfCauchyDistribution();\\n      return halfCauchy.quantileSet(x, p, [mu]);\\n    }\\n    if (nu === Infinity) { \\n      let halfNormal = new HalfNormalDistribution();\\n      return halfNormal.quantileSet(x, p, [mu]);\\n    }\\n\\n    let x1 = x[0];\\n    let p1 = p[0];\\n\\n    \\n    const quantileRootFun = (params, nu, mu, x1, p1) =&gt; {\\n      let sigma = Math.exp(params[0]);\\n\\n      return [this.cdfSingleValue(x1, [nu, mu, sigma]) - p1];\\n    };\\n\\n    let args = [nu, mu, x1, p1];\\n\\n    \\n    let guess;\\n    let guessSuccess;\\n    if (nu &lt; 3) {\\n      let halfCauchy = new HalfCauchyDistribution();\\n      [guess, guessSuccess] = halfCauchy.quantileSet(x, p, [mu]);\\n    } else {\\n      let halfNormal = new HalfNormalDistribution();\\n      [guess, guessSuccess] = halfNormal.quantileSet(x, p, [mu]);      \\n    }\\n\\n    \\n    guess = [Math.log(guess[0])];\\n\\n    let [paramsFirstPass, optimSuccess] = findRootTrustRegion(quantileRootFun, guess, args=args);\\n\\n    \\n    paramsFirstPass[0] = Math.exp(paramsFirstPass[0]);\\n\\n    \\n    if (!optimSuccess) {\\n      return [[paramsFirstPass[0]], optimSuccess];\\n    }\\n\\n    \\n    const closeQuantileRootFun = (params, nu, mu, x1, p1) =&gt; {\\n      let sigma = params[0];\\n\\n      return [this.cdfSingleValue(x1, [nu, mu, sigma]) - p1];\\n    };\\n\\n    let paramsOpt;\\n    [paramsOpt, optimSuccess] = findRootTrustRegion(closeQuantileRootFun, paramsFirstPass, args=args);\\n\\n    let retval;\\n    if (optimSuccess &amp;&amp; norm(closeQuantileRootFun(paramsOpt, nu, x1, p1)) &lt; norm(closeQuantileRootFun(paramsFirstPass, nu, x1, p1))) {\\n      retval = [paramsOpt, optimSuccess];\\n    } else {\\n      retval = [paramsOpt, optimSuccess];\\n    }\\n\\n    return retval;\\n  }\\n}\\n\\n\\n\\nvar dist = new HalfStudentTDistribution();\\n\\n\\n\\nlet params = paramsFromSliders(sliders); \\n\\n\\nlet [x1, x2] = dist.defaultXRange(params);\\n\\n\\ntriggerCallbacks.active = false;\\n\\n\\np_p.x_range.start = x1;\\np_p.x_range.end = x2;\\n\\nupdateData(source_p, source_c, p_p, sliders, discrete);\\n\\n\\nsetYRanges(p_p, p_c, source_p);  \\n\\ntriggerCallbacks.active = true;\\n"}}]]]},"x_range":{"id":"p2442"},"y_range":{"type":"object","name":"Range1d","id":"p2443","attributes":{"start":-0.04,"end":1.04}},"x_scale":{"type":"object","name":"LinearScale","id":"p2423"},"y_scale":{"type":"object","name":"LinearScale","id":"p2424"},"title":{"type":"object","name":"Title","id":"p2416","attributes":{"text":" "}},"renderers":[{"type":"object","name":"GlyphRenderer","id":"p2456","attributes":{"data_source":{"id":"p2447"},"view":{"type":"object","name":"CDSView","id":"p2457","attributes":{"filter":{"type":"object","name":"AllIndices","id":"p2458"}}},"glyph":{"type":"object","name":"Line","id":"p2453","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_width":2}},"nonselection_glyph":{"type":"object","name":"Line","id":"p2454","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_alpha":0.1,"line_width":2}},"muted_glyph":{"type":"object","name":"Line","id":"p2455","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_alpha":0.2,"line_width":2}}}}],"toolbar":{"type":"object","name":"Toolbar","id":"p2422","attributes":{"tools":[{"type":"object","name":"PanTool","id":"p2435"},{"type":"object","name":"WheelZoomTool","id":"p2436","attributes":{"renderers":"auto"}},{"type":"object","name":"BoxZoomTool","id":"p2437","attributes":{"overlay":{"type":"object","name":"BoxAnnotation","id":"p2438","attributes":{"syncable":false,"level":"overlay","visible":false,"left_units":"canvas","right_units":"canvas","top_units":"canvas","bottom_units":"canvas","line_color":"black","line_alpha":1.0,"line_width":2,"line_dash":[4,4],"fill_color":"lightgrey","fill_alpha":0.5}}}},{"type":"object","name":"SaveTool","id":"p2439"},{"type":"object","name":"ResetTool","id":"p2440"},{"type":"object","name":"HelpTool","id":"p2441"}]}},"toolbar_location":null,"left":[{"type":"object","name":"LinearAxis","id":"p2430","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p2431","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p2432"},"axis_label":"CDF","axis_label_text_font_style":"normal","major_label_policy":{"type":"object","name":"AllLabels","id":"p2433"}}}],"below":[{"type":"object","name":"LinearAxis","id":"p2425","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p2426","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p2427"},"axis_label":"y","major_label_policy":{"type":"object","name":"AllLabels","id":"p2428"}}}],"center":[{"type":"object","name":"Grid","id":"p2429","attributes":{"axis":{"id":"p2425"}}},{"type":"object","name":"Grid","id":"p2434","attributes":{"dimension":1,"axis":{"id":"p2430"}}}],"frame_width":300,"frame_height":175,"background_fill_alpha":0,"border_fill_alpha":0}}],["source_p",{"id":"p2444"}],["source_c",{"id":"p2447"}],["discrete",false],["n",400],["sliders",[{"id":"p2469"},{"id":"p2471"},{"id":"p2473"}]],["xBoxes",[{"id":"p2480"}]],["pBoxes",[{"id":"p2481"}]],["quantileSetterSwitch",{"id":"p2483"}],["quantileSetterDiv",{"id":"p2482"}],["triggerCallbacks",{"id":"p2484"}],["startBoxes",[{"id":"p2474"},{"id":"p2475"},{"id":"p2476"}]],["endBoxes",[{"id":"p2477"},{"id":"p2478"},{"id":"p2479"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let x = paramsFromBoxes(xBoxes);\\n  let p = paramsFromBoxes(pBoxes);\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ){\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n          endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);        \\n        }\\n        sliders[dist.activeParamsInds[i]].value = optimParams[i];\\n      }\\n\\n      params = paramsFromSliders(sliders); \\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.floor(xRange.start);\\n  let xRangeMax = Math.ceil(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c = [xRangeMin - 1, ...x_p.flatMap(x =&gt; [x, x]), xRangeMax + 1];\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = -0.04;\\n    p_c.y_range.end = 1.04;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = -pdfMax * 0.04;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264&#x27; + xMax.toString() + &#x27;.&lt;/p\\\\&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nclass CauchyDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Cauchy&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return -Infinity;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x == Infinity || x == -Infinity) return 0.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    return 1.0 / Math.PI / sigma / (1 + Math.pow((x - mu) / sigma, 2))\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    return 0.5 + Math.atan((x - mu) / sigma) / Math.PI;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    return mu + sigma * Math.tan(Math.PI * (p - 0.5));\\n  }\\n\\n  defaultXRange(params) {\\n    \\n    return this.ppf([0.025, 0.975], params);\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    let cotp1 = 1.0 / Math.tan(Math.PI * p1);\\n    let cotp2 = 1.0 / Math.tan(Math.PI * p2);\\n\\n    let mu = (x2 * cotp1 - x1 * cotp2) / (cotp1 - cotp2);\\n    let sigma = (x1 - x2) * Math.sin(Math.PI * p1) * Math.sin(Math.PI * p1) \\n                / Math.sin(Math.PI * (p1 - p2));\\n\\n    return [[mu, sigma], true];\\n  }\\n}\\n\\nclass HalfCauchyDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;HalfCauchy&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u00b5&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.fixedParams = [&#x27;\\u00b5&#x27;];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return params[0];\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x &lt; mu) return NaN;\\n    if (x === Infinity) return 0.0;\\n\\n    return 2.0 / Math.PI / sigma / (1 + Math.pow((x - mu) / sigma, 2));\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x &lt;= mu) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    return 2.0 * Math.atan((x - mu) / sigma) / Math.PI;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    return mu + sigma * Math.tan(Math.PI * p / 2.0);\\n  }\\n\\n  defaultXRange(params) {\\n    \\n    return [params[0], this.ppf(0.9, params)];\\n  }\\n\\n  quantileSet(x, p, extraParams) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n    let mu = extraParams[0];\\n\\n    return [[(x1 - mu) / Math.tan(Math.PI * p1 / 2)], true];\\n  }\\n}\\n\\nclass HalfNormalDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;HalfNormal&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u00b5&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.fixedParams = [&#x27;\\u00b5&#x27;];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return params[0];\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x &lt; mu) return NaN;\\n    if (x === Infinity) return 0.0;\\n\\n    let expTerm = (Math.pow(x - mu, 2) / 2.0 / Math.pow(sigma, 2));\\n    return Math.exp(-expTerm) / sigma * Math.sqrt(2.0 / Math.PI);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x &lt;= mu) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    return erf((x - mu) / sigma / Math.sqrt(2));\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return mu + sqrt2 * sigma * erfinv(p);\\n  }\\n\\n  defaultXRange(params) {\\n    return [params[0], this.ppf(0.999, params)];\\n  }\\n\\n  quantileSet(x, p, extraParams) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n    let mu = extraParams[0];\\n\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return [[(x1 - mu) / sqrt2 / erfinv(p1)], true];\\n  }\\n}\\n\\nclass NormalDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Normal&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n}\\n\\n  xMin(params) {\\n    return -Infinity;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x === -Infinity || x === Infinity) return 0.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    let expTerm = (Math.pow(x - mu, 2) / 2.0 / Math.pow(sigma, 2));\\n    return Math.exp(-expTerm) / sigma / Math.sqrt(2 * Math.PI);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x === -Infinity) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    return (1 + erf((x - mu) / sigma / Math.sqrt(2))) / 2;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return -Infinity;\\n    if (p === 1) return Infinity;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return mu + sqrt2 * sigma * erfinv(2 * p - 1);\\n  }\\n\\n  defaultXRange(params) {\\n    return this.ppf([0.001, 0.999], params);\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    let sqrt2 = 1.4142135623730951;\\n\\n    let sigmaCoeff1 = sqrt2 * erfinv(2 * p1 - 1);\\n    let sigmaCoeff2 = sqrt2 * erfinv(2 * p2 - 1);\\n\\n    let sigma = (x2 - x1) / (sigmaCoeff2 - sigmaCoeff1);\\n    let mu = x2 - sigmaCoeff2 * sigma;\\n\\n    return [[mu, sigma], true];\\n  }\\n}\\n\\nclass StudentTDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;StudentT&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bd&#x27;, &#x27;\\u03bc&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.fixedParams = [&#x27;\\u03bd&#x27;];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return -Infinity;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x === -Infinity || x === Infinity) return 0.0;\\n\\n    let [nu, mu, sigma] = params.slice(0, 3);\\n\\n    let lnprob;\\n\\n    lnprob = lngamma((nu + 1) / 2) - lngamma(nu / 2) - Math.log(Math.PI * nu) / 2 - Math.log(sigma)\\n             - (nu + 1) / 2 * log1p(Math.pow(x - mu, 2) / nu / Math.pow(sigma, 2));\\n\\n    return Math.exp(lnprob);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x === -Infinity) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let [nu, mu, sigma] = params.slice(0, 3);\\n\\n    let y = (x - mu) / sigma;\\n\\n    if (y &gt;= 0) {\\n        return 1 - regularizedIncompleteBeta(nu / (Math.pow(y, 2) + nu), 0.5 * nu, 0.5) / 2;\\n    }\\n    else {\\n        return regularizedIncompleteBeta(nu / (Math.pow(y, 2) + nu), 0.5 * nu, 0.5) / 2;        \\n    }\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let [nu, mu, sigma] = params.slice(0, 3);\\n\\n    \\n    let guess;\\n    if (nu &lt; 3) { \\n      guess = Math.tan(Math.PI * (p - 0.5));\\n    } else {\\n      guess = Math.sqrt(2) * erfinv(2 * p - 1)\\n    }\\n\\n    \\n    if (nu === 1 || nu === Infinity) return mu + sigma * guess;\\n\\n    \\n    let rootFun = (x, nu, p) =&gt; [p - this.cdfSingleValue(x, [nu, 0, 1])];\\n    let [xOpt, success] = findRootTrustRegion(rootFun, [guess], [nu, p]);\\n\\n    return mu + sigma * xOpt[0];\\n  }\\n\\n  defaultXRange(params) {\\n    \\n    let [nu, mu, sigma] = params.slice(0, 3);\\n\\n    let p1;\\n    let p2;\\n\\n    if (nu &lt; 2) {\\n        p1 = 0.05;\\n        p2 = 0.95;\\n    }\\n    if (nu &lt; 4) {\\n        p1 = 0.01;\\n        p2 = 0.99;\\n    }\\n    else if (nu &lt; 10) {\\n        p1 = 0.005;\\n        p2 = 0.995;\\n    }\\n    else {\\n        p1 = 0.001;\\n        p2 = 0.999;\\n    }\\n\\n    return this.ppf([p1, p2], params);\\n  }\\n\\n  quantileSet(x, p, extraParams) {\\n\\n    let nu = extraParams[0];\\n\\n    \\n    if (nu === 1) { \\n      let cauchy = new CauchyDistribution();\\n      return cauchy.quantileSet(x, p);\\n    }\\n    if (nu === Infinity) { \\n      let normal = new NormalDistribution();\\n      return normal.quantileSet(x, p);\\n    }\\n\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    \\n    const quantileRootFun = (params, nu, x1, p1, x2, p2) =&gt; {\\n      let mu = params[0];\\n      let sigma = Math.exp(params[1]);\\n\\n      let r1 = this.cdfSingleValue(x1, [nu, mu, sigma]) - p1;\\n      let r2 = this.cdfSingleValue(x2, [nu, mu, sigma]) - p2;\\n\\n      return [r1, r2];\\n    };\\n\\n    let args = [nu, x1, p1, x2, p2];\\n\\n    \\n    let guess;\\n    let guessSuccess;\\n    if (nu &lt; 3) {\\n      let cauchy = new CauchyDistribution();\\n      [guess, guessSuccess] = cauchy.quantileSet(x, p);\\n    } else {\\n      let normal = new NormalDistribution();\\n      [guess, guessSuccess] = normal.quantileSet(x, p);      \\n    }\\n\\n    \\n    guess = [guess[0], Math.log(guess[1])];\\n\\n    let [paramsFirstPass, optimSuccess] = findRootTrustRegion(quantileRootFun, guess, args=args);\\n\\n    \\n    paramsFirstPass[1] = Math.exp(paramsFirstPass[1]);\\n\\n    \\n    if (!optimSuccess) {\\n      return [[paramsFirstPass[0], paramsFirstPass[1]], optimSuccess];\\n    }\\n\\n    \\n    const closeQuantileRootFun = (params, nu, x1, p1, x2, p2) =&gt; {\\n      let [mu, sigma] = params.slice(0, 2);\\n\\n      let r1 = this.cdfSingleValue(x1, [nu, mu, sigma]) - p1;\\n      let r2 = this.cdfSingleValue(x2, [nu, mu, sigma]) - p2;\\n\\n      return [r1, r2];\\n    };\\n\\n    let paramsOpt;\\n    [paramsOpt, optimSuccess] = findRootTrustRegion(closeQuantileRootFun, paramsFirstPass, args=args);\\n\\n    let retval;\\n    if (optimSuccess &amp;&amp; norm(closeQuantileRootFun(paramsOpt, nu, x1, p1, x2, p2)) &lt; norm(closeQuantileRootFun(paramsFirstPass, nu, x1, p1, x2, p2))) {\\n      retval = [paramsOpt, optimSuccess];\\n    } else {\\n      retval = [paramsOpt, optimSuccess];\\n    }\\n\\n    return retval;\\n  }\\n\\n}\\n\\nfunction log1p(x) {\\n  \\n  \\n  if (x &lt;= -1.0) {\\n    throw new RangeError(&#x27;Argument must be greater than -1.0&#x27;);\\n  }\\n\\n  \\n  else if (Math.abs(x) &gt; 1e-4) {\\n    return Math.log(1.0 + x);\\n  }\\n\\n  else {\\n    return (-0.5*x + 1.0)*x;\\n  }\\n}\\n\\n\\nfunction regularizedIncompleteBeta(x, a, b) {\\n    \\n    \\n    if (x &lt; 0 || x &gt; 1) {\\n        throw new RangeError(&#x27;First argument must be between 0 and 1.&#x27;);\\n    }\\n\\n    \\n    else if (a === 1 &amp;&amp; b === 1) return x;\\n    else if (x === 0) return 0;\\n    else if (x === 1) return 1;\\n    else if (a === 0) return 1;\\n    else if (b === 0) return 0;\\n\\n    else {\\n        var bt = Math.exp(lngamma(a + b) - lngamma(a) - lngamma(b) + a * Math.log(x) + b * log1p(-x));\\n\\n        \\n        if (x &lt; (a + 1) / (a + b + 2)) return bt * betacf(x, a, b) / a;\\n\\n        \\n        else return 1 - bt * betacf(1 - x, b, a) / b;\\n    }\\n}\\n\\n\\nfunction lngamma(z) {\\n\\n    if(z &lt; 0) return Number(&#x27;0/0&#x27;);\\n\\n    if (z &lt; 0.5) return Math.log(Math.PI) - Math.log(Math.sin(Math.PI * z)) - lngamma(1-z);\\n\\n    var p = [676.5203681218851,\\n             -1259.1392167224028,\\n             771.32342877765313,\\n             -176.61502916214059,\\n             12.507343278686905,\\n             -0.13857109526572012,\\n             9.9843695780195716e-6,\\n             1.5056327351493116e-7];\\n\\n    z -= 1.0;\\n    var Ag = 0.99999999999980993;\\n    for (var i = 0; i &lt; p.length; i++) {\\n        Ag += p[i] / (z + i + 1);\\n    }\\n    var t = z + p.length - 0.5;\\n\\n    return 0.5 * Math.log(2*Math.PI) + (z + 0.5)*Math.log(t) - t + Math.log(Ag);\\n}\\n\\n\\nfunction norm(v) {\\n  return Math.sqrt(dot(v, v));\\n}\\n\\n\\nfunction findRootTrustRegion(\\n\\t\\tf, \\n\\t\\tx0, \\n\\t\\targs=[],\\n\\t\\tjac=jacCentralDiff,\\n\\t\\ttol=0.000000001, \\n\\t\\tmaxIters=10000, \\n\\t\\tdeltaBar=1000.0, \\n\\t\\teta=0.125, \\n\\t\\tminDelta=1e-12\\n  ) {\\n\\t\\n\\tlet x = deepCopy(x0);\\n\\n\\t\\n\\tlet delta = 0.99 * deltaBar;\\n\\n\\t\\n\\tlet r = f(x, ...args);\\n\\n\\t\\n\\tlet J = jac(f, x, args);\\n\\n\\t\\n\\tlet JTJ = mmMult(transpose(J), J);\\n\\n\\t\\n\\tlet JTr = mvMult(transpose(J), r);\\n\\n\\t\\n\\tlet normJTr = norm(JTr);\\n\\n\\tlet iters = 0;\\n\\twhile (iters &lt; maxIters &amp;&amp; checkTol(r, tol) &amp;&amp; delta &gt;= minDelta) {\\n\\t\\t\\n\\t\\tlet p = doglegStep(JTJ, JTr, normJTr, delta);\\n\\n\\t\\t\\n\\t\\tlet newr = f(vectorAdd(x, p), ...args);\\n\\t\\tlet rho = computeRho(r, newr, J, p);\\n\\n\\t\\t\\n\\t\\tif  (rho &lt; 0.25) {\\n\\t\\t\\tdelta = norm(p) / 4.0;\\n\\t\\t} else if (rho &gt; 0.75 &amp;&amp; Math.abs(norm(p) - delta) &lt; 1e-12) {\\n\\t\\t\\t\\tdelta = Math.min(2 * delta, deltaBar);\\n\\t\\t}\\n\\n\\t\\t\\n\\t\\tif (rho &gt; eta) {\\n\\t\\t\\tx = vectorAdd(x, p);\\n\\n\\t\\t\\tr = newr;\\n\\t\\t\\tJ = jac(f, x, args);\\n\\t\\t\\tJTJ = mmMult(transpose(J), J);\\n\\t\\t\\tJTr = mvMult(transpose(J), r);\\n\\t\\t\\tnormJTr = norm(JTr);\\n\\t\\t}\\n\\n\\t\\titers += 1;\\n\\t}\\n\\n\\tlet success = !checkTol(r, tol);\\n\\n\\treturn [x, success];\\n\\n}\\n\\n\\nfunction erf(x) {\\n  \\n  var a = [1.00002368,\\n           0.37409196,\\n           0.09678418,\\n           -0.18628806,\\n           0.27886807,\\n           -1.13520398,\\n           1.48851587,\\n           -0.82215223,\\n           0.17087277];\\n\\n  var t = 1 / (1 + Math.abs(x)/2);\\n  var expSum = -Math.pow(x, 2) - 1.26551223;\\n\\n  for (var i = 0; i &lt; a.length; i++) {\\n      expSum += a[i] * Math.pow(t, i+1);\\n  }\\n\\n  var result = 1 - t * Math.exp(expSum);\\n\\n  if (x &lt; 0) return -result;\\n  return result;\\n}\\n\\n\\nfunction erfinv(x) {\\n  \\n  let p = (x + 1.0) / 2.0;\\n\\n  \\n  if (p == 0.0) return -Infinity;\\n  if (p == 1.0) return Infinity;\\n  if (p &gt; 1.0 || p &lt; 0.0) return undefined;\\n\\n  let split1 = 0.425;\\n  let split2 = 5.0;\\n  let const1 = 0.180625;\\n  let const2 = 1.6;\\n\\n  \\n  let a0 = 3.3871327179;\\n  let a1 = 5.0434271938e1;\\n  let a2 = 1.5929113202e2;\\n  let a3 = 5.9109374720e1;\\n  let b1 = 1.7895169469e1;\\n  let b2 = 7.8757757664e1;\\n  let b3 = 6.7187563600e1;\\n\\n  \\n  let c0 = 1.4234372777;\\n  let c1 = 2.7568153900;\\n  let c2 = 1.3067284816;\\n  let c3 = 1.7023821103e-1;\\n  let d1 = 7.3700164250e-1;\\n  let d2 = 1.2021132975e-1;\\n\\n  \\n  let e0 = 6.6579051150;\\n  let e1 = 3.0812263860;\\n  let e2 = 4.2868294337e-1;\\n  let e3 = 1.7337203997e-2;\\n  let f1 = 2.4197894225e-1;\\n  let f2 = 1.2258202635e-2;\\n\\n  let r;\\n  let res;\\n  let q = p - 0.5;\\n\\n  if (Math.abs(q) &lt;= split1) {\\n    r = const1 - q * q;\\n    res = q * (((a3 * r + a2) * r + a1) * r + a0) /\\n              (((b3 * r + b2) * r + b1) * r + 1.0);\\n  } else {\\n    r = q &lt; 0 ? p : 1.0 - p;\\n\\n    r = Math.sqrt(-Math.log(r));\\n\\n    if (r &lt;= split2) {\\n      r -= const2;\\n      res = (((c3 * r + c2) * r + c1) * r + c0) /\\n             ((d2 * r + d1) * r + 1.0);\\n    } else {\\n      r -= split2;\\n      res = (((e3 * r + e2) * r + e1) * r + e0) /\\n             ((f2 * r + f1) * r + 1.0);\\n    }\\n  \\n    if (q &lt; 0) {\\n      res = -res;\\n    }\\n  }\\n\\n  \\n  return 0.7071067811865475 * res;\\n\\n}\\n\\n\\nfunction betacf(x, a, b) {\\n    \\n    \\n    var fpmin = 1e-30,\\n        m = 1,\\n        m2, aa, c, d, del, h, qab, qam, qap;\\n    \\n    qab = a + b;\\n    qap = a + 1;\\n    qam = a - 1;\\n    c = 1;\\n    d = 1 - qab * x / qap;\\n    if (Math.abs(d) &lt; fpmin) d = fpmin;\\n    d = 1 / d;\\n    h = d;\\n    for (; m &lt;= 100; m++) {\\n        m2 = 2 * m;\\n        aa = m * (b - m) * x / ((qam + m2) * (a + m2));\\n        \\n        d = 1 + aa * d;\\n        if (Math.abs(d) &lt; fpmin) d = fpmin;\\n        c = 1 + aa / c;\\n        if (Math.abs(c) &lt; fpmin) c = fpmin;\\n        d = 1 / d;\\n        h *= d * c;\\n        aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));\\n        \\n        d = 1 + aa * d;\\n        if (Math.abs(d) &lt; fpmin) d = fpmin;\\n        c = 1 + aa / c;\\n        if (Math.abs(c) &lt; fpmin) c = fpmin;\\n        d = 1 / d;\\n        del = d * c;\\n        h *= del;\\n        if (Math.abs(del - 1.0) &lt; 3e-7) break;\\n    }\\n    return h;\\n}\\n\\n\\nfunction dot(v1, v2) {\\n  const n = v1.length;\\n  let result = 0.0;\\n  for (let i = 0; i &lt; n; i++) result += v1[i] * v2[i];\\n\\n  return result;\\n}\\n\\n\\nfunction transpose(A) {\\n    return A[0].map((_, colIndex) =&gt; A.map(row =&gt; row[colIndex]));\\n}\\n\\n\\nfunction mvMult(A, v) {\\n  return A.map(Arow =&gt; dot(Arow, v));\\n}\\n\\n\\nfunction mmMult(A, B) {\\n  let mA = A.length;\\n  let nA = A[0].length;\\n  let mB = B.length;\\n  let nB = B[0].length;\\n\\n  if (nA !== mB) {\\n      throw new Error(&#x27;Matrix dimension mismatch.&#x27;);\\n  }\\n\\n  let result = zeros(mA, nB);\\n\\n  for (let i = 0; i &lt; mA; i++) {\\n    for (let j = 0; j &lt; nB; j++) {\\n      for (let k = 0; k &lt; nA; k++) {\\n        result[i][j] += A[i][k] * B[k][j];\\n      }\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction vectorAdd() {\\n  let m = arguments.length;\\n  let n = arguments[0].length;\\n \\n  let result = new Array(n).fill(0.0);\\n \\n  for (let i = 0; i &lt; n; i++) {\\n    for (let j = 0; j &lt; m; j++) {\\n        result[i] += arguments[j][i];\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction deepCopy(x) {\\n  return JSON.parse(JSON.stringify(x));\\n}\\n\\n\\nfunction computeRho(r, newr, J, p) {\\n\\tlet r2 = norm(r) ** 2;\\n\\tlet num = r2 - norm(newr)**2;\\n\\tlet denom = r2 - norm(vectorAdd(r, mvMult(J, p))) ** 2;\\n\\n\\treturn num / denom;\\n}\\n\\n\\nfunction checkTol(r, tol) {\\n\\t\\n\\tconst n = r.length;\\n\\tfor (let i = 0; i &lt; n; i++) {\\n\\t\\tif (tol &lt; Math.abs(r[i])) return true;\\n\\t}\\n\\n\\treturn false;\\n}\\n\\n\\nfunction doglegStep(JTJ, JTr, normJTr, delta) {\\n\\t\\n\\tlet [pJ, posDef] = solvePosDef(JTJ, JTr);\\n\\tpJ = svMult(-1.0, pJ);\\n\\n\\t\\n\\tif (posDef &amp;&amp; norm(pJ) &lt;= delta) {\\n\\t\\treturn pJ;\\n\\t}\\n\\n\\t\\n\\tlet tau = Math.min(1, normJTr**3 / delta / quadForm(JTJ, JTr));\\n\\tlet pC = svMult(-tau * delta / normJTr, JTr);\\n\\n\\tlet pCnorm = norm(pC);\\n\\tif (!posDef || Math.abs(pCnorm - delta) &lt;= 1e-12) {\\n\\t\\treturn pC;\\n\\t}\\n\\n\\t\\n\\tlet pJ2 = norm(pJ) ** 2;\\n\\tlet pC2 = pCnorm**2;\\n\\tlet pJpC = dot(pJ, pC);\\n\\tlet a = pJ2 + pC2 - 2.0 * pJpC;\\n\\tlet b = 2.0 * (pJpC - pC2);\\n\\tlet c = pC2 - delta**2;\\n\\tlet q = -0.5 * (b + Math.sign(b) * Math.sqrt(b**2 - 4.0 * a * c));\\n\\n\\t\\n\\tlet beta;\\n\\tif (Math.abs(b) &lt; 1e-12) beta = Math.sqrt(-c / a);\\n\\telse if (b &lt; 0.0) beta = q / a;\\n\\telse beta = c / q;\\n\\n\\t\\n\\tif (0.0 &lt;= beta &amp;&amp; beta &lt;= 1) {\\n\\t\\treturn vectorAdd(pC, svMult(beta, vectorAdd(pJ, svMult(-1.0, pC))));\\n\\t} else { \\n\\t\\treturn pC;\\n\\t}\\n\\n}\\n\\n\\nfunction jacCentralDiff(f, x, args=[], eps=4.7e-6) {\\n\\t\\n\\tlet xPlus = deepCopy(x);\\n\\tlet xMinus = deepCopy(x);\\n\\n\\t\\n\\tlet fOfx = f(x, ...args);\\n\\tlet m = fOfx.length;\\n\\n\\t\\n\\tlet n = x.length;\\n\\n\\t\\n\\tlet J = zeros(m, n);\\n\\n\\t\\n\\tlet fOfxPlus;\\n\\tlet fOfxMinus;\\n\\n\\tfor (let j = 0; j &lt; n; j++) {\\n\\t\\txPlus[j] += eps;\\n\\t\\txMinus[j] -= eps;\\n\\t\\tfOfxPlus = f(xPlus, ...args);\\n\\t\\tfOfxMinus = f(xMinus, ...args);\\n\\t\\txPlus[j] -= eps;\\n\\t\\txMinus[j] += eps;\\n\\n\\t\\tfor (let i = 0; i &lt; m; i++) {\\n\\t\\t\\tJ[i][j] = (fOfxPlus[i] - fOfxMinus[i]) / 2.0 / eps;\\n\\t\\t}\\n\\t}\\n\\n\\treturn J;\\n}\\n\\n\\nfunction zeros(...dims) {\\n  let A = [];\\n\\n  \\n  for (let i = dims.length - 1; i &gt;= 0; i--) {\\n    let size = dims[i];\\n    if (i === dims.length - 1) {\\n      \\n      A = new Array(size).fill(0.0);\\n    } else {\\n      \\n      A = new Array(size).fill().map(() =&gt; deepCopy(A));\\n    }\\n  }\\n\\n  return A;\\n}\\n\\n\\nfunction svMult(a, v) {\\n  return v.map(x =&gt; a * x);\\n}\\n\\n\\nfunction quadForm(A, x) {\\n   return dot(x, mvMult(A, x)); \\n}\\n\\n\\nfunction solvePosDef(A, b) {\\n  let [L, p, success] = modifiedCholesky(A);\\n\\n  if (!success) {\\n    return [zeros(b.length), success];\\n  }\\n\\n  return [modifiedCholeskySolve(L, p, b), success];\\n}\\n\\n\\nfunction modifiedCholesky(A) {\\n    const floatEps = 1.0e-14;\\n    const n = A.length;\\n\\n    \\n    let L = deepCopy(A); \\n    let p = arange(0, n);\\n\\n    \\n    let success = true;\\n\\n    let xi = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        for (let j = 0; j &lt; i; j++) {\\n            let temp = Math.abs(L[i][j]);\\n            xi = Math.max(xi, temp);\\n        }\\n    }\\n\\n    let eta = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        let temp = Math.abs(L[i][i]);\\n        eta = Math.max(eta, temp);\\n    }\\n\\n    let beta;\\n    if (n &gt; 1) {\\n        beta = Math.sqrt(Math.max(eta, xi / Math.sqrt(n * n - 1)));\\n    } else {\\n        beta = Math.sqrt(eta);\\n    }\\n    beta = Math.max(beta, floatEps);\\n\\n    for (let k = 0; k &lt; n; k++) {\\n        \\n        let muVal = L[k][k];\\n        let mu = k;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            let temp = L[i][i];\\n            if (muVal &lt; temp) {\\n                mu = i;\\n                muVal = temp;\\n            }\\n        }\\n\\n        \\n        let iTemp = p[mu];\\n        p[mu] = p[k];\\n        p[k] = iTemp;\\n\\n        for (let i = 0; i &lt; k; i++) {\\n            let temp = L[k][i];\\n            L[k][i] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        let temp = L[k][k];\\n        L[k][k] = L[mu][mu];\\n        L[mu][mu] = temp;\\n        for (let i = k + 1; i &lt; mu; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        for (let i = mu + 1; i &lt; n; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[i][mu];\\n            L[i][mu] = temp;\\n        }\\n\\n        \\n        let cSum = 0;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            cSum = Math.max(cSum, Math.abs(L[i][k]));\\n        }\\n        cSum /= beta;\\n        cSum = cSum * cSum;\\n\\n        \\n        if (L[k][k] &lt; 0) {\\n            success = false;\\n        }\\n\\n        temp = Math.abs(L[k][k]);\\n        temp = Math.max(temp, floatEps * eta);\\n        temp = Math.max(temp, cSum);\\n        L[k][k] = Math.sqrt(temp);\\n\\n        \\n        for (let i = k + 1; i &lt; n; i++) {\\n            L[i][k] /= L[k][k];\\n        }\\n\\n        \\n        for (let j = k + 1; j &lt; n; j++) {\\n            for (let i = j; i &lt; n; i++) {\\n                L[i][j] -= L[i][k] * L[j][k];\\n            }\\n        }\\n\\n        \\n        for (let i = 0; i &lt; n - 1; i++) {\\n            for (let j = i + 1; j &lt; n; j++) {\\n                L[i][j] = 0.0;\\n            }\\n        }\\n    }\\n\\n    return [L, p, success];\\n}\\n\\n\\nfunction modifiedCholeskySolve(L, p, b) {\\n    const n = L.length;\\n\\n    let U = transpose(L);\\n    let xp = new Array(n).fill(0);\\n    for (let i = 0; i &lt; n; i++) {\\n        xp[i] = b[p[i]];\\n    }\\n\\n    \\n    let x = lowerTriSolve(L, xp);\\n\\n    \\n    xp = upperTriSolve(U, x);\\n\\n    for (let i = 0; i &lt; n; i++) {\\n        x[p[i]] = xp[i];\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction lowerTriSolve(L, b) {\\n    const floatEps = 1.0e-14;\\n    const n = L.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = 0; j &lt; n - 1; j++) {\\n        if (Math.abs(L[j][j]) &gt; floatEps) {\\n            x[j] /= L[j][j];\\n            for (let i = j + 1; i &lt; n; i++) {\\n                x[i] -= x[j] * L[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(L[n - 1][n - 1]) &gt; floatEps) {\\n            x[n - 1] /= L[n - 1][n - 1];\\n        } else {\\n            x[n - 1] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction upperTriSolve(U, b) {\\n    const floatEps = 1.0e-14;\\n    const n = U.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = n - 1; j &gt; 0; j--) {\\n        if (Math.abs(U[j][j]) &gt; floatEps) {\\n            x[j] /= U[j][j];\\n            for (let i = 0; i &lt; j; i++) {\\n                x[i] -= x[j] * U[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(U[0][0]) &gt; floatEps) {\\n            x[0] /= U[0][0];\\n        } else {\\n            x[0] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nclass HalfStudentTDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;HalfStudentT&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bd&#x27;, &#x27;\\u00b5&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.fixedParams = [&#x27;\\u03bd&#x27;, &#x27;\\u00b5&#x27;];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return params[1];\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let [nu, mu, sigma] = params.slice(0, 3);\\n\\n    if (x &lt; mu) return NaN;\\n    if (x === Infinity) return 0.0;\\n\\n    let lnprob;\\n\\n    lnprob = Math.log(2.0) + lngamma((nu + 1) / 2) - lngamma(nu / 2) - Math.log(Math.PI * nu) / 2 \\n             - Math.log(sigma) - (nu + 1) / 2 * log1p(Math.pow(x - mu, 2) / nu / Math.pow(sigma, 2));\\n\\n    return Math.exp(lnprob);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let [nu, mu, sigma] = params.slice(0, 3);\\n\\n    if (x &lt;= mu) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let y = (x - mu) / sigma;\\n\\n    return 1 - regularizedIncompleteBeta(nu / (Math.pow(y, 2) + nu), 0.5 * nu, 0.5);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return params[1];\\n    if (p === 1) return Infinity;\\n\\n    let studentT = new StudentTDistribution();\\n    return studentT.ppf((1 + p) / 2, params);\\n  }\\n\\n  defaultXRange(params) {\\n    \\n    let [nu, mu, sigma] = params.slice(0, 3);\\n    let p2;\\n\\n    if (nu &lt; 2) p2 = 0.95;\\n    else if (nu &lt; 4) p2 = 0.99;\\n    else if (nu &lt; 10) p2 = 0.995;\\n    else p2 = 0.999;\\n\\n    return [params[1], this.ppf(p2, params)];\\n  }\\n\\n  quantileSet(x, p, extraParams) {\\n    let [nu, mu] = extraParams;\\n\\n    \\n    if (nu === 1) { \\n      let halfCauchy = new HalfCauchyDistribution();\\n      return halfCauchy.quantileSet(x, p, [mu]);\\n    }\\n    if (nu === Infinity) { \\n      let halfNormal = new HalfNormalDistribution();\\n      return halfNormal.quantileSet(x, p, [mu]);\\n    }\\n\\n    let x1 = x[0];\\n    let p1 = p[0];\\n\\n    \\n    const quantileRootFun = (params, nu, mu, x1, p1) =&gt; {\\n      let sigma = Math.exp(params[0]);\\n\\n      return [this.cdfSingleValue(x1, [nu, mu, sigma]) - p1];\\n    };\\n\\n    let args = [nu, mu, x1, p1];\\n\\n    \\n    let guess;\\n    let guessSuccess;\\n    if (nu &lt; 3) {\\n      let halfCauchy = new HalfCauchyDistribution();\\n      [guess, guessSuccess] = halfCauchy.quantileSet(x, p, [mu]);\\n    } else {\\n      let halfNormal = new HalfNormalDistribution();\\n      [guess, guessSuccess] = halfNormal.quantileSet(x, p, [mu]);      \\n    }\\n\\n    \\n    guess = [Math.log(guess[0])];\\n\\n    let [paramsFirstPass, optimSuccess] = findRootTrustRegion(quantileRootFun, guess, args=args);\\n\\n    \\n    paramsFirstPass[0] = Math.exp(paramsFirstPass[0]);\\n\\n    \\n    if (!optimSuccess) {\\n      return [[paramsFirstPass[0]], optimSuccess];\\n    }\\n\\n    \\n    const closeQuantileRootFun = (params, nu, mu, x1, p1) =&gt; {\\n      let sigma = params[0];\\n\\n      return [this.cdfSingleValue(x1, [nu, mu, sigma]) - p1];\\n    };\\n\\n    let paramsOpt;\\n    [paramsOpt, optimSuccess] = findRootTrustRegion(closeQuantileRootFun, paramsFirstPass, args=args);\\n\\n    let retval;\\n    if (optimSuccess &amp;&amp; norm(closeQuantileRootFun(paramsOpt, nu, x1, p1)) &lt; norm(closeQuantileRootFun(paramsFirstPass, nu, x1, p1))) {\\n      retval = [paramsOpt, optimSuccess];\\n    } else {\\n      retval = [paramsOpt, optimSuccess];\\n    }\\n\\n    return retval;\\n  }\\n}\\n\\n\\n\\nvar dist = new HalfStudentTDistribution();\\n\\n\\nif (triggerCallbacks.active) {\\n  updateData(source_p, source_c, p_p, sliders, discrete);\\n}"}}]],["change:end",[{"id":"p2486"}]]]},"end":2}},"y_range":{"type":"object","name":"DataRange1d","id":"p2386"},"x_scale":{"type":"object","name":"LinearScale","id":"p2394"},"y_scale":{"type":"object","name":"LinearScale","id":"p2395"},"title":{"type":"object","name":"Title","id":"p2387","attributes":{"text":"Half-Student-t"}},"renderers":[{"type":"object","name":"GlyphRenderer","id":"p2465","attributes":{"data_source":{"id":"p2444"},"view":{"type":"object","name":"CDSView","id":"p2466","attributes":{"filter":{"type":"object","name":"AllIndices","id":"p2467"}}},"glyph":{"type":"object","name":"Line","id":"p2462","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"line_color":"#1f77b4","line_width":2}},"nonselection_glyph":{"type":"object","name":"Line","id":"p2463","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"line_color":"#1f77b4","line_alpha":0.1,"line_width":2}},"muted_glyph":{"type":"object","name":"Line","id":"p2464","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"line_color":"#1f77b4","line_alpha":0.2,"line_width":2}}}}],"toolbar":{"type":"object","name":"Toolbar","id":"p2393","attributes":{"tools":[{"type":"object","name":"PanTool","id":"p2406"},{"type":"object","name":"WheelZoomTool","id":"p2407","attributes":{"renderers":"auto"}},{"type":"object","name":"BoxZoomTool","id":"p2408","attributes":{"overlay":{"type":"object","name":"BoxAnnotation","id":"p2409","attributes":{"syncable":false,"level":"overlay","visible":false,"left_units":"canvas","right_units":"canvas","top_units":"canvas","bottom_units":"canvas","line_color":"black","line_alpha":1.0,"line_width":2,"line_dash":[4,4],"fill_color":"lightgrey","fill_alpha":0.5}}}},{"type":"object","name":"SaveTool","id":"p2410"},{"type":"object","name":"ResetTool","id":"p2411"},{"type":"object","name":"HelpTool","id":"p2412"}]}},"toolbar_location":null,"left":[{"type":"object","name":"LinearAxis","id":"p2401","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p2402","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p2403"},"axis_label":"PDF","axis_label_text_font_style":"normal","major_label_policy":{"type":"object","name":"AllLabels","id":"p2404"}}}],"below":[{"type":"object","name":"LinearAxis","id":"p2396","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p2397","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p2398"},"axis_label":"y","major_label_policy":{"type":"object","name":"AllLabels","id":"p2399"}}}],"center":[{"type":"object","name":"Grid","id":"p2400","attributes":{"axis":{"id":"p2396"}}},{"type":"object","name":"Grid","id":"p2405","attributes":{"dimension":1,"axis":{"id":"p2401"}}}],"frame_width":300,"frame_height":175,"background_fill_alpha":0,"border_fill_alpha":0}}],["p_c",{"id":"p2413"}],["source_p",{"id":"p2444"}],["source_c",{"id":"p2447"}],["discrete",false],["n",400],["sliders",[{"id":"p2469"},{"id":"p2471"},{"id":"p2473"}]],["xBoxes",[{"id":"p2480"}]],["pBoxes",[{"id":"p2481"}]],["quantileSetterSwitch",{"id":"p2483"}],["quantileSetterDiv",{"id":"p2482"}],["triggerCallbacks",{"id":"p2484"}],["startBoxes",[{"id":"p2474"},{"id":"p2475"},{"id":"p2476"}]],["endBoxes",[{"id":"p2477"},{"id":"p2478"},{"id":"p2479"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let x = paramsFromBoxes(xBoxes);\\n  let p = paramsFromBoxes(pBoxes);\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ){\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n          endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);        \\n        }\\n        sliders[dist.activeParamsInds[i]].value = optimParams[i];\\n      }\\n\\n      params = paramsFromSliders(sliders); \\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.floor(xRange.start);\\n  let xRangeMax = Math.ceil(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c = [xRangeMin - 1, ...x_p.flatMap(x =&gt; [x, x]), xRangeMax + 1];\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = -0.04;\\n    p_c.y_range.end = 1.04;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = -pdfMax * 0.04;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264&#x27; + xMax.toString() + &#x27;.&lt;/p\\\\&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nclass CauchyDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Cauchy&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return -Infinity;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x == Infinity || x == -Infinity) return 0.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    return 1.0 / Math.PI / sigma / (1 + Math.pow((x - mu) / sigma, 2))\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    return 0.5 + Math.atan((x - mu) / sigma) / Math.PI;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    return mu + sigma * Math.tan(Math.PI * (p - 0.5));\\n  }\\n\\n  defaultXRange(params) {\\n    \\n    return this.ppf([0.025, 0.975], params);\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    let cotp1 = 1.0 / Math.tan(Math.PI * p1);\\n    let cotp2 = 1.0 / Math.tan(Math.PI * p2);\\n\\n    let mu = (x2 * cotp1 - x1 * cotp2) / (cotp1 - cotp2);\\n    let sigma = (x1 - x2) * Math.sin(Math.PI * p1) * Math.sin(Math.PI * p1) \\n                / Math.sin(Math.PI * (p1 - p2));\\n\\n    return [[mu, sigma], true];\\n  }\\n}\\n\\nclass HalfCauchyDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;HalfCauchy&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u00b5&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.fixedParams = [&#x27;\\u00b5&#x27;];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return params[0];\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x &lt; mu) return NaN;\\n    if (x === Infinity) return 0.0;\\n\\n    return 2.0 / Math.PI / sigma / (1 + Math.pow((x - mu) / sigma, 2));\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x &lt;= mu) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    return 2.0 * Math.atan((x - mu) / sigma) / Math.PI;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    return mu + sigma * Math.tan(Math.PI * p / 2.0);\\n  }\\n\\n  defaultXRange(params) {\\n    \\n    return [params[0], this.ppf(0.9, params)];\\n  }\\n\\n  quantileSet(x, p, extraParams) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n    let mu = extraParams[0];\\n\\n    return [[(x1 - mu) / Math.tan(Math.PI * p1 / 2)], true];\\n  }\\n}\\n\\nclass HalfNormalDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;HalfNormal&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u00b5&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.fixedParams = [&#x27;\\u00b5&#x27;];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return params[0];\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x &lt; mu) return NaN;\\n    if (x === Infinity) return 0.0;\\n\\n    let expTerm = (Math.pow(x - mu, 2) / 2.0 / Math.pow(sigma, 2));\\n    return Math.exp(-expTerm) / sigma * Math.sqrt(2.0 / Math.PI);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x &lt;= mu) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    return erf((x - mu) / sigma / Math.sqrt(2));\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return mu + sqrt2 * sigma * erfinv(p);\\n  }\\n\\n  defaultXRange(params) {\\n    return [params[0], this.ppf(0.999, params)];\\n  }\\n\\n  quantileSet(x, p, extraParams) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n    let mu = extraParams[0];\\n\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return [[(x1 - mu) / sqrt2 / erfinv(p1)], true];\\n  }\\n}\\n\\nclass NormalDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Normal&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n}\\n\\n  xMin(params) {\\n    return -Infinity;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x === -Infinity || x === Infinity) return 0.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    let expTerm = (Math.pow(x - mu, 2) / 2.0 / Math.pow(sigma, 2));\\n    return Math.exp(-expTerm) / sigma / Math.sqrt(2 * Math.PI);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x === -Infinity) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    return (1 + erf((x - mu) / sigma / Math.sqrt(2))) / 2;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return -Infinity;\\n    if (p === 1) return Infinity;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return mu + sqrt2 * sigma * erfinv(2 * p - 1);\\n  }\\n\\n  defaultXRange(params) {\\n    return this.ppf([0.001, 0.999], params);\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    let sqrt2 = 1.4142135623730951;\\n\\n    let sigmaCoeff1 = sqrt2 * erfinv(2 * p1 - 1);\\n    let sigmaCoeff2 = sqrt2 * erfinv(2 * p2 - 1);\\n\\n    let sigma = (x2 - x1) / (sigmaCoeff2 - sigmaCoeff1);\\n    let mu = x2 - sigmaCoeff2 * sigma;\\n\\n    return [[mu, sigma], true];\\n  }\\n}\\n\\nclass StudentTDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;StudentT&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bd&#x27;, &#x27;\\u03bc&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.fixedParams = [&#x27;\\u03bd&#x27;];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return -Infinity;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x === -Infinity || x === Infinity) return 0.0;\\n\\n    let [nu, mu, sigma] = params.slice(0, 3);\\n\\n    let lnprob;\\n\\n    lnprob = lngamma((nu + 1) / 2) - lngamma(nu / 2) - Math.log(Math.PI * nu) / 2 - Math.log(sigma)\\n             - (nu + 1) / 2 * log1p(Math.pow(x - mu, 2) / nu / Math.pow(sigma, 2));\\n\\n    return Math.exp(lnprob);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x === -Infinity) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let [nu, mu, sigma] = params.slice(0, 3);\\n\\n    let y = (x - mu) / sigma;\\n\\n    if (y &gt;= 0) {\\n        return 1 - regularizedIncompleteBeta(nu / (Math.pow(y, 2) + nu), 0.5 * nu, 0.5) / 2;\\n    }\\n    else {\\n        return regularizedIncompleteBeta(nu / (Math.pow(y, 2) + nu), 0.5 * nu, 0.5) / 2;        \\n    }\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let [nu, mu, sigma] = params.slice(0, 3);\\n\\n    \\n    let guess;\\n    if (nu &lt; 3) { \\n      guess = Math.tan(Math.PI * (p - 0.5));\\n    } else {\\n      guess = Math.sqrt(2) * erfinv(2 * p - 1)\\n    }\\n\\n    \\n    if (nu === 1 || nu === Infinity) return mu + sigma * guess;\\n\\n    \\n    let rootFun = (x, nu, p) =&gt; [p - this.cdfSingleValue(x, [nu, 0, 1])];\\n    let [xOpt, success] = findRootTrustRegion(rootFun, [guess], [nu, p]);\\n\\n    return mu + sigma * xOpt[0];\\n  }\\n\\n  defaultXRange(params) {\\n    \\n    let [nu, mu, sigma] = params.slice(0, 3);\\n\\n    let p1;\\n    let p2;\\n\\n    if (nu &lt; 2) {\\n        p1 = 0.05;\\n        p2 = 0.95;\\n    }\\n    if (nu &lt; 4) {\\n        p1 = 0.01;\\n        p2 = 0.99;\\n    }\\n    else if (nu &lt; 10) {\\n        p1 = 0.005;\\n        p2 = 0.995;\\n    }\\n    else {\\n        p1 = 0.001;\\n        p2 = 0.999;\\n    }\\n\\n    return this.ppf([p1, p2], params);\\n  }\\n\\n  quantileSet(x, p, extraParams) {\\n\\n    let nu = extraParams[0];\\n\\n    \\n    if (nu === 1) { \\n      let cauchy = new CauchyDistribution();\\n      return cauchy.quantileSet(x, p);\\n    }\\n    if (nu === Infinity) { \\n      let normal = new NormalDistribution();\\n      return normal.quantileSet(x, p);\\n    }\\n\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    \\n    const quantileRootFun = (params, nu, x1, p1, x2, p2) =&gt; {\\n      let mu = params[0];\\n      let sigma = Math.exp(params[1]);\\n\\n      let r1 = this.cdfSingleValue(x1, [nu, mu, sigma]) - p1;\\n      let r2 = this.cdfSingleValue(x2, [nu, mu, sigma]) - p2;\\n\\n      return [r1, r2];\\n    };\\n\\n    let args = [nu, x1, p1, x2, p2];\\n\\n    \\n    let guess;\\n    let guessSuccess;\\n    if (nu &lt; 3) {\\n      let cauchy = new CauchyDistribution();\\n      [guess, guessSuccess] = cauchy.quantileSet(x, p);\\n    } else {\\n      let normal = new NormalDistribution();\\n      [guess, guessSuccess] = normal.quantileSet(x, p);      \\n    }\\n\\n    \\n    guess = [guess[0], Math.log(guess[1])];\\n\\n    let [paramsFirstPass, optimSuccess] = findRootTrustRegion(quantileRootFun, guess, args=args);\\n\\n    \\n    paramsFirstPass[1] = Math.exp(paramsFirstPass[1]);\\n\\n    \\n    if (!optimSuccess) {\\n      return [[paramsFirstPass[0], paramsFirstPass[1]], optimSuccess];\\n    }\\n\\n    \\n    const closeQuantileRootFun = (params, nu, x1, p1, x2, p2) =&gt; {\\n      let [mu, sigma] = params.slice(0, 2);\\n\\n      let r1 = this.cdfSingleValue(x1, [nu, mu, sigma]) - p1;\\n      let r2 = this.cdfSingleValue(x2, [nu, mu, sigma]) - p2;\\n\\n      return [r1, r2];\\n    };\\n\\n    let paramsOpt;\\n    [paramsOpt, optimSuccess] = findRootTrustRegion(closeQuantileRootFun, paramsFirstPass, args=args);\\n\\n    let retval;\\n    if (optimSuccess &amp;&amp; norm(closeQuantileRootFun(paramsOpt, nu, x1, p1, x2, p2)) &lt; norm(closeQuantileRootFun(paramsFirstPass, nu, x1, p1, x2, p2))) {\\n      retval = [paramsOpt, optimSuccess];\\n    } else {\\n      retval = [paramsOpt, optimSuccess];\\n    }\\n\\n    return retval;\\n  }\\n\\n}\\n\\nfunction log1p(x) {\\n  \\n  \\n  if (x &lt;= -1.0) {\\n    throw new RangeError(&#x27;Argument must be greater than -1.0&#x27;);\\n  }\\n\\n  \\n  else if (Math.abs(x) &gt; 1e-4) {\\n    return Math.log(1.0 + x);\\n  }\\n\\n  else {\\n    return (-0.5*x + 1.0)*x;\\n  }\\n}\\n\\n\\nfunction regularizedIncompleteBeta(x, a, b) {\\n    \\n    \\n    if (x &lt; 0 || x &gt; 1) {\\n        throw new RangeError(&#x27;First argument must be between 0 and 1.&#x27;);\\n    }\\n\\n    \\n    else if (a === 1 &amp;&amp; b === 1) return x;\\n    else if (x === 0) return 0;\\n    else if (x === 1) return 1;\\n    else if (a === 0) return 1;\\n    else if (b === 0) return 0;\\n\\n    else {\\n        var bt = Math.exp(lngamma(a + b) - lngamma(a) - lngamma(b) + a * Math.log(x) + b * log1p(-x));\\n\\n        \\n        if (x &lt; (a + 1) / (a + b + 2)) return bt * betacf(x, a, b) / a;\\n\\n        \\n        else return 1 - bt * betacf(1 - x, b, a) / b;\\n    }\\n}\\n\\n\\nfunction lngamma(z) {\\n\\n    if(z &lt; 0) return Number(&#x27;0/0&#x27;);\\n\\n    if (z &lt; 0.5) return Math.log(Math.PI) - Math.log(Math.sin(Math.PI * z)) - lngamma(1-z);\\n\\n    var p = [676.5203681218851,\\n             -1259.1392167224028,\\n             771.32342877765313,\\n             -176.61502916214059,\\n             12.507343278686905,\\n             -0.13857109526572012,\\n             9.9843695780195716e-6,\\n             1.5056327351493116e-7];\\n\\n    z -= 1.0;\\n    var Ag = 0.99999999999980993;\\n    for (var i = 0; i &lt; p.length; i++) {\\n        Ag += p[i] / (z + i + 1);\\n    }\\n    var t = z + p.length - 0.5;\\n\\n    return 0.5 * Math.log(2*Math.PI) + (z + 0.5)*Math.log(t) - t + Math.log(Ag);\\n}\\n\\n\\nfunction norm(v) {\\n  return Math.sqrt(dot(v, v));\\n}\\n\\n\\nfunction findRootTrustRegion(\\n\\t\\tf, \\n\\t\\tx0, \\n\\t\\targs=[],\\n\\t\\tjac=jacCentralDiff,\\n\\t\\ttol=0.000000001, \\n\\t\\tmaxIters=10000, \\n\\t\\tdeltaBar=1000.0, \\n\\t\\teta=0.125, \\n\\t\\tminDelta=1e-12\\n  ) {\\n\\t\\n\\tlet x = deepCopy(x0);\\n\\n\\t\\n\\tlet delta = 0.99 * deltaBar;\\n\\n\\t\\n\\tlet r = f(x, ...args);\\n\\n\\t\\n\\tlet J = jac(f, x, args);\\n\\n\\t\\n\\tlet JTJ = mmMult(transpose(J), J);\\n\\n\\t\\n\\tlet JTr = mvMult(transpose(J), r);\\n\\n\\t\\n\\tlet normJTr = norm(JTr);\\n\\n\\tlet iters = 0;\\n\\twhile (iters &lt; maxIters &amp;&amp; checkTol(r, tol) &amp;&amp; delta &gt;= minDelta) {\\n\\t\\t\\n\\t\\tlet p = doglegStep(JTJ, JTr, normJTr, delta);\\n\\n\\t\\t\\n\\t\\tlet newr = f(vectorAdd(x, p), ...args);\\n\\t\\tlet rho = computeRho(r, newr, J, p);\\n\\n\\t\\t\\n\\t\\tif  (rho &lt; 0.25) {\\n\\t\\t\\tdelta = norm(p) / 4.0;\\n\\t\\t} else if (rho &gt; 0.75 &amp;&amp; Math.abs(norm(p) - delta) &lt; 1e-12) {\\n\\t\\t\\t\\tdelta = Math.min(2 * delta, deltaBar);\\n\\t\\t}\\n\\n\\t\\t\\n\\t\\tif (rho &gt; eta) {\\n\\t\\t\\tx = vectorAdd(x, p);\\n\\n\\t\\t\\tr = newr;\\n\\t\\t\\tJ = jac(f, x, args);\\n\\t\\t\\tJTJ = mmMult(transpose(J), J);\\n\\t\\t\\tJTr = mvMult(transpose(J), r);\\n\\t\\t\\tnormJTr = norm(JTr);\\n\\t\\t}\\n\\n\\t\\titers += 1;\\n\\t}\\n\\n\\tlet success = !checkTol(r, tol);\\n\\n\\treturn [x, success];\\n\\n}\\n\\n\\nfunction erf(x) {\\n  \\n  var a = [1.00002368,\\n           0.37409196,\\n           0.09678418,\\n           -0.18628806,\\n           0.27886807,\\n           -1.13520398,\\n           1.48851587,\\n           -0.82215223,\\n           0.17087277];\\n\\n  var t = 1 / (1 + Math.abs(x)/2);\\n  var expSum = -Math.pow(x, 2) - 1.26551223;\\n\\n  for (var i = 0; i &lt; a.length; i++) {\\n      expSum += a[i] * Math.pow(t, i+1);\\n  }\\n\\n  var result = 1 - t * Math.exp(expSum);\\n\\n  if (x &lt; 0) return -result;\\n  return result;\\n}\\n\\n\\nfunction erfinv(x) {\\n  \\n  let p = (x + 1.0) / 2.0;\\n\\n  \\n  if (p == 0.0) return -Infinity;\\n  if (p == 1.0) return Infinity;\\n  if (p &gt; 1.0 || p &lt; 0.0) return undefined;\\n\\n  let split1 = 0.425;\\n  let split2 = 5.0;\\n  let const1 = 0.180625;\\n  let const2 = 1.6;\\n\\n  \\n  let a0 = 3.3871327179;\\n  let a1 = 5.0434271938e1;\\n  let a2 = 1.5929113202e2;\\n  let a3 = 5.9109374720e1;\\n  let b1 = 1.7895169469e1;\\n  let b2 = 7.8757757664e1;\\n  let b3 = 6.7187563600e1;\\n\\n  \\n  let c0 = 1.4234372777;\\n  let c1 = 2.7568153900;\\n  let c2 = 1.3067284816;\\n  let c3 = 1.7023821103e-1;\\n  let d1 = 7.3700164250e-1;\\n  let d2 = 1.2021132975e-1;\\n\\n  \\n  let e0 = 6.6579051150;\\n  let e1 = 3.0812263860;\\n  let e2 = 4.2868294337e-1;\\n  let e3 = 1.7337203997e-2;\\n  let f1 = 2.4197894225e-1;\\n  let f2 = 1.2258202635e-2;\\n\\n  let r;\\n  let res;\\n  let q = p - 0.5;\\n\\n  if (Math.abs(q) &lt;= split1) {\\n    r = const1 - q * q;\\n    res = q * (((a3 * r + a2) * r + a1) * r + a0) /\\n              (((b3 * r + b2) * r + b1) * r + 1.0);\\n  } else {\\n    r = q &lt; 0 ? p : 1.0 - p;\\n\\n    r = Math.sqrt(-Math.log(r));\\n\\n    if (r &lt;= split2) {\\n      r -= const2;\\n      res = (((c3 * r + c2) * r + c1) * r + c0) /\\n             ((d2 * r + d1) * r + 1.0);\\n    } else {\\n      r -= split2;\\n      res = (((e3 * r + e2) * r + e1) * r + e0) /\\n             ((f2 * r + f1) * r + 1.0);\\n    }\\n  \\n    if (q &lt; 0) {\\n      res = -res;\\n    }\\n  }\\n\\n  \\n  return 0.7071067811865475 * res;\\n\\n}\\n\\n\\nfunction betacf(x, a, b) {\\n    \\n    \\n    var fpmin = 1e-30,\\n        m = 1,\\n        m2, aa, c, d, del, h, qab, qam, qap;\\n    \\n    qab = a + b;\\n    qap = a + 1;\\n    qam = a - 1;\\n    c = 1;\\n    d = 1 - qab * x / qap;\\n    if (Math.abs(d) &lt; fpmin) d = fpmin;\\n    d = 1 / d;\\n    h = d;\\n    for (; m &lt;= 100; m++) {\\n        m2 = 2 * m;\\n        aa = m * (b - m) * x / ((qam + m2) * (a + m2));\\n        \\n        d = 1 + aa * d;\\n        if (Math.abs(d) &lt; fpmin) d = fpmin;\\n        c = 1 + aa / c;\\n        if (Math.abs(c) &lt; fpmin) c = fpmin;\\n        d = 1 / d;\\n        h *= d * c;\\n        aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));\\n        \\n        d = 1 + aa * d;\\n        if (Math.abs(d) &lt; fpmin) d = fpmin;\\n        c = 1 + aa / c;\\n        if (Math.abs(c) &lt; fpmin) c = fpmin;\\n        d = 1 / d;\\n        del = d * c;\\n        h *= del;\\n        if (Math.abs(del - 1.0) &lt; 3e-7) break;\\n    }\\n    return h;\\n}\\n\\n\\nfunction dot(v1, v2) {\\n  const n = v1.length;\\n  let result = 0.0;\\n  for (let i = 0; i &lt; n; i++) result += v1[i] * v2[i];\\n\\n  return result;\\n}\\n\\n\\nfunction transpose(A) {\\n    return A[0].map((_, colIndex) =&gt; A.map(row =&gt; row[colIndex]));\\n}\\n\\n\\nfunction mvMult(A, v) {\\n  return A.map(Arow =&gt; dot(Arow, v));\\n}\\n\\n\\nfunction mmMult(A, B) {\\n  let mA = A.length;\\n  let nA = A[0].length;\\n  let mB = B.length;\\n  let nB = B[0].length;\\n\\n  if (nA !== mB) {\\n      throw new Error(&#x27;Matrix dimension mismatch.&#x27;);\\n  }\\n\\n  let result = zeros(mA, nB);\\n\\n  for (let i = 0; i &lt; mA; i++) {\\n    for (let j = 0; j &lt; nB; j++) {\\n      for (let k = 0; k &lt; nA; k++) {\\n        result[i][j] += A[i][k] * B[k][j];\\n      }\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction vectorAdd() {\\n  let m = arguments.length;\\n  let n = arguments[0].length;\\n \\n  let result = new Array(n).fill(0.0);\\n \\n  for (let i = 0; i &lt; n; i++) {\\n    for (let j = 0; j &lt; m; j++) {\\n        result[i] += arguments[j][i];\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction deepCopy(x) {\\n  return JSON.parse(JSON.stringify(x));\\n}\\n\\n\\nfunction computeRho(r, newr, J, p) {\\n\\tlet r2 = norm(r) ** 2;\\n\\tlet num = r2 - norm(newr)**2;\\n\\tlet denom = r2 - norm(vectorAdd(r, mvMult(J, p))) ** 2;\\n\\n\\treturn num / denom;\\n}\\n\\n\\nfunction checkTol(r, tol) {\\n\\t\\n\\tconst n = r.length;\\n\\tfor (let i = 0; i &lt; n; i++) {\\n\\t\\tif (tol &lt; Math.abs(r[i])) return true;\\n\\t}\\n\\n\\treturn false;\\n}\\n\\n\\nfunction doglegStep(JTJ, JTr, normJTr, delta) {\\n\\t\\n\\tlet [pJ, posDef] = solvePosDef(JTJ, JTr);\\n\\tpJ = svMult(-1.0, pJ);\\n\\n\\t\\n\\tif (posDef &amp;&amp; norm(pJ) &lt;= delta) {\\n\\t\\treturn pJ;\\n\\t}\\n\\n\\t\\n\\tlet tau = Math.min(1, normJTr**3 / delta / quadForm(JTJ, JTr));\\n\\tlet pC = svMult(-tau * delta / normJTr, JTr);\\n\\n\\tlet pCnorm = norm(pC);\\n\\tif (!posDef || Math.abs(pCnorm - delta) &lt;= 1e-12) {\\n\\t\\treturn pC;\\n\\t}\\n\\n\\t\\n\\tlet pJ2 = norm(pJ) ** 2;\\n\\tlet pC2 = pCnorm**2;\\n\\tlet pJpC = dot(pJ, pC);\\n\\tlet a = pJ2 + pC2 - 2.0 * pJpC;\\n\\tlet b = 2.0 * (pJpC - pC2);\\n\\tlet c = pC2 - delta**2;\\n\\tlet q = -0.5 * (b + Math.sign(b) * Math.sqrt(b**2 - 4.0 * a * c));\\n\\n\\t\\n\\tlet beta;\\n\\tif (Math.abs(b) &lt; 1e-12) beta = Math.sqrt(-c / a);\\n\\telse if (b &lt; 0.0) beta = q / a;\\n\\telse beta = c / q;\\n\\n\\t\\n\\tif (0.0 &lt;= beta &amp;&amp; beta &lt;= 1) {\\n\\t\\treturn vectorAdd(pC, svMult(beta, vectorAdd(pJ, svMult(-1.0, pC))));\\n\\t} else { \\n\\t\\treturn pC;\\n\\t}\\n\\n}\\n\\n\\nfunction jacCentralDiff(f, x, args=[], eps=4.7e-6) {\\n\\t\\n\\tlet xPlus = deepCopy(x);\\n\\tlet xMinus = deepCopy(x);\\n\\n\\t\\n\\tlet fOfx = f(x, ...args);\\n\\tlet m = fOfx.length;\\n\\n\\t\\n\\tlet n = x.length;\\n\\n\\t\\n\\tlet J = zeros(m, n);\\n\\n\\t\\n\\tlet fOfxPlus;\\n\\tlet fOfxMinus;\\n\\n\\tfor (let j = 0; j &lt; n; j++) {\\n\\t\\txPlus[j] += eps;\\n\\t\\txMinus[j] -= eps;\\n\\t\\tfOfxPlus = f(xPlus, ...args);\\n\\t\\tfOfxMinus = f(xMinus, ...args);\\n\\t\\txPlus[j] -= eps;\\n\\t\\txMinus[j] += eps;\\n\\n\\t\\tfor (let i = 0; i &lt; m; i++) {\\n\\t\\t\\tJ[i][j] = (fOfxPlus[i] - fOfxMinus[i]) / 2.0 / eps;\\n\\t\\t}\\n\\t}\\n\\n\\treturn J;\\n}\\n\\n\\nfunction zeros(...dims) {\\n  let A = [];\\n\\n  \\n  for (let i = dims.length - 1; i &gt;= 0; i--) {\\n    let size = dims[i];\\n    if (i === dims.length - 1) {\\n      \\n      A = new Array(size).fill(0.0);\\n    } else {\\n      \\n      A = new Array(size).fill().map(() =&gt; deepCopy(A));\\n    }\\n  }\\n\\n  return A;\\n}\\n\\n\\nfunction svMult(a, v) {\\n  return v.map(x =&gt; a * x);\\n}\\n\\n\\nfunction quadForm(A, x) {\\n   return dot(x, mvMult(A, x)); \\n}\\n\\n\\nfunction solvePosDef(A, b) {\\n  let [L, p, success] = modifiedCholesky(A);\\n\\n  if (!success) {\\n    return [zeros(b.length), success];\\n  }\\n\\n  return [modifiedCholeskySolve(L, p, b), success];\\n}\\n\\n\\nfunction modifiedCholesky(A) {\\n    const floatEps = 1.0e-14;\\n    const n = A.length;\\n\\n    \\n    let L = deepCopy(A); \\n    let p = arange(0, n);\\n\\n    \\n    let success = true;\\n\\n    let xi = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        for (let j = 0; j &lt; i; j++) {\\n            let temp = Math.abs(L[i][j]);\\n            xi = Math.max(xi, temp);\\n        }\\n    }\\n\\n    let eta = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        let temp = Math.abs(L[i][i]);\\n        eta = Math.max(eta, temp);\\n    }\\n\\n    let beta;\\n    if (n &gt; 1) {\\n        beta = Math.sqrt(Math.max(eta, xi / Math.sqrt(n * n - 1)));\\n    } else {\\n        beta = Math.sqrt(eta);\\n    }\\n    beta = Math.max(beta, floatEps);\\n\\n    for (let k = 0; k &lt; n; k++) {\\n        \\n        let muVal = L[k][k];\\n        let mu = k;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            let temp = L[i][i];\\n            if (muVal &lt; temp) {\\n                mu = i;\\n                muVal = temp;\\n            }\\n        }\\n\\n        \\n        let iTemp = p[mu];\\n        p[mu] = p[k];\\n        p[k] = iTemp;\\n\\n        for (let i = 0; i &lt; k; i++) {\\n            let temp = L[k][i];\\n            L[k][i] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        let temp = L[k][k];\\n        L[k][k] = L[mu][mu];\\n        L[mu][mu] = temp;\\n        for (let i = k + 1; i &lt; mu; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        for (let i = mu + 1; i &lt; n; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[i][mu];\\n            L[i][mu] = temp;\\n        }\\n\\n        \\n        let cSum = 0;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            cSum = Math.max(cSum, Math.abs(L[i][k]));\\n        }\\n        cSum /= beta;\\n        cSum = cSum * cSum;\\n\\n        \\n        if (L[k][k] &lt; 0) {\\n            success = false;\\n        }\\n\\n        temp = Math.abs(L[k][k]);\\n        temp = Math.max(temp, floatEps * eta);\\n        temp = Math.max(temp, cSum);\\n        L[k][k] = Math.sqrt(temp);\\n\\n        \\n        for (let i = k + 1; i &lt; n; i++) {\\n            L[i][k] /= L[k][k];\\n        }\\n\\n        \\n        for (let j = k + 1; j &lt; n; j++) {\\n            for (let i = j; i &lt; n; i++) {\\n                L[i][j] -= L[i][k] * L[j][k];\\n            }\\n        }\\n\\n        \\n        for (let i = 0; i &lt; n - 1; i++) {\\n            for (let j = i + 1; j &lt; n; j++) {\\n                L[i][j] = 0.0;\\n            }\\n        }\\n    }\\n\\n    return [L, p, success];\\n}\\n\\n\\nfunction modifiedCholeskySolve(L, p, b) {\\n    const n = L.length;\\n\\n    let U = transpose(L);\\n    let xp = new Array(n).fill(0);\\n    for (let i = 0; i &lt; n; i++) {\\n        xp[i] = b[p[i]];\\n    }\\n\\n    \\n    let x = lowerTriSolve(L, xp);\\n\\n    \\n    xp = upperTriSolve(U, x);\\n\\n    for (let i = 0; i &lt; n; i++) {\\n        x[p[i]] = xp[i];\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction lowerTriSolve(L, b) {\\n    const floatEps = 1.0e-14;\\n    const n = L.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = 0; j &lt; n - 1; j++) {\\n        if (Math.abs(L[j][j]) &gt; floatEps) {\\n            x[j] /= L[j][j];\\n            for (let i = j + 1; i &lt; n; i++) {\\n                x[i] -= x[j] * L[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(L[n - 1][n - 1]) &gt; floatEps) {\\n            x[n - 1] /= L[n - 1][n - 1];\\n        } else {\\n            x[n - 1] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction upperTriSolve(U, b) {\\n    const floatEps = 1.0e-14;\\n    const n = U.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = n - 1; j &gt; 0; j--) {\\n        if (Math.abs(U[j][j]) &gt; floatEps) {\\n            x[j] /= U[j][j];\\n            for (let i = 0; i &lt; j; i++) {\\n                x[i] -= x[j] * U[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(U[0][0]) &gt; floatEps) {\\n            x[0] /= U[0][0];\\n        } else {\\n            x[0] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nclass HalfStudentTDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;HalfStudentT&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bd&#x27;, &#x27;\\u00b5&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.fixedParams = [&#x27;\\u03bd&#x27;, &#x27;\\u00b5&#x27;];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return params[1];\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let [nu, mu, sigma] = params.slice(0, 3);\\n\\n    if (x &lt; mu) return NaN;\\n    if (x === Infinity) return 0.0;\\n\\n    let lnprob;\\n\\n    lnprob = Math.log(2.0) + lngamma((nu + 1) / 2) - lngamma(nu / 2) - Math.log(Math.PI * nu) / 2 \\n             - Math.log(sigma) - (nu + 1) / 2 * log1p(Math.pow(x - mu, 2) / nu / Math.pow(sigma, 2));\\n\\n    return Math.exp(lnprob);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let [nu, mu, sigma] = params.slice(0, 3);\\n\\n    if (x &lt;= mu) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let y = (x - mu) / sigma;\\n\\n    return 1 - regularizedIncompleteBeta(nu / (Math.pow(y, 2) + nu), 0.5 * nu, 0.5);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return params[1];\\n    if (p === 1) return Infinity;\\n\\n    let studentT = new StudentTDistribution();\\n    return studentT.ppf((1 + p) / 2, params);\\n  }\\n\\n  defaultXRange(params) {\\n    \\n    let [nu, mu, sigma] = params.slice(0, 3);\\n    let p2;\\n\\n    if (nu &lt; 2) p2 = 0.95;\\n    else if (nu &lt; 4) p2 = 0.99;\\n    else if (nu &lt; 10) p2 = 0.995;\\n    else p2 = 0.999;\\n\\n    return [params[1], this.ppf(p2, params)];\\n  }\\n\\n  quantileSet(x, p, extraParams) {\\n    let [nu, mu] = extraParams;\\n\\n    \\n    if (nu === 1) { \\n      let halfCauchy = new HalfCauchyDistribution();\\n      return halfCauchy.quantileSet(x, p, [mu]);\\n    }\\n    if (nu === Infinity) { \\n      let halfNormal = new HalfNormalDistribution();\\n      return halfNormal.quantileSet(x, p, [mu]);\\n    }\\n\\n    let x1 = x[0];\\n    let p1 = p[0];\\n\\n    \\n    const quantileRootFun = (params, nu, mu, x1, p1) =&gt; {\\n      let sigma = Math.exp(params[0]);\\n\\n      return [this.cdfSingleValue(x1, [nu, mu, sigma]) - p1];\\n    };\\n\\n    let args = [nu, mu, x1, p1];\\n\\n    \\n    let guess;\\n    let guessSuccess;\\n    if (nu &lt; 3) {\\n      let halfCauchy = new HalfCauchyDistribution();\\n      [guess, guessSuccess] = halfCauchy.quantileSet(x, p, [mu]);\\n    } else {\\n      let halfNormal = new HalfNormalDistribution();\\n      [guess, guessSuccess] = halfNormal.quantileSet(x, p, [mu]);      \\n    }\\n\\n    \\n    guess = [Math.log(guess[0])];\\n\\n    let [paramsFirstPass, optimSuccess] = findRootTrustRegion(quantileRootFun, guess, args=args);\\n\\n    \\n    paramsFirstPass[0] = Math.exp(paramsFirstPass[0]);\\n\\n    \\n    if (!optimSuccess) {\\n      return [[paramsFirstPass[0]], optimSuccess];\\n    }\\n\\n    \\n    const closeQuantileRootFun = (params, nu, mu, x1, p1) =&gt; {\\n      let sigma = params[0];\\n\\n      return [this.cdfSingleValue(x1, [nu, mu, sigma]) - p1];\\n    };\\n\\n    let paramsOpt;\\n    [paramsOpt, optimSuccess] = findRootTrustRegion(closeQuantileRootFun, paramsFirstPass, args=args);\\n\\n    let retval;\\n    if (optimSuccess &amp;&amp; norm(closeQuantileRootFun(paramsOpt, nu, x1, p1)) &lt; norm(closeQuantileRootFun(paramsFirstPass, nu, x1, p1))) {\\n      retval = [paramsOpt, optimSuccess];\\n    } else {\\n      retval = [paramsOpt, optimSuccess];\\n    }\\n\\n    return retval;\\n  }\\n}\\n\\n\\n\\nvar dist = new HalfStudentTDistribution();\\n\\n\\n\\nif (cb_obj.active) {\\n  for (let i = 0; i &lt; sliders.length; i++) {\\n    if (!dist.fixedParamsInds.includes(i)) {\\n      sliders[i].title = dist.paramNames[i] + &#x27; (computed)&#x27;;\\n      sliders[i].disabled = true;\\n    }\\n  }\\n  for (let xBox of xBoxes) {\\n    xBox.disabled = false;\\n  }\\n  for (let pBox of pBoxes) {\\n    pBox.disabled = false;\\n  }\\n} else {\\n  for (let i = 0; i &lt; sliders.length; i++) {\\n    if (!dist.fixedParamsInds.includes(i)) {\\n      sliders[i].title = dist.paramNames[i];\\n      sliders[i].disabled = false;\\n    }\\n  }\\n  for (let xBox of xBoxes) {\\n    xBox.disabled = true;\\n  }\\n  for (let pBox of pBoxes) {\\n    pBox.disabled = true;\\n  }\\n  quantileSetterDiv.text = &#x27;&#x27;;\\n}"}}]]]}}}]}},{"type":"object","name":"Spacer","id":"p2536","attributes":{"width":10}},{"id":"p2482"}]}},{"type":"object","name":"Spacer","id":"p2538","attributes":{"height":10}},{"type":"object","name":"Row","id":"p2540","attributes":{"children":[{"type":"object","name":"Column","id":"p2524","attributes":{"children":[{"type":"object","name":"Row","id":"p2521","attributes":{"children":[{"type":"object","name":"Column","id":"p2510","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2509","attributes":{"height":4}},{"id":"p2474"}]}},{"id":"p2469"},{"type":"object","name":"Column","id":"p2512","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2511","attributes":{"height":4}},{"id":"p2477"}]}}]}},{"type":"object","name":"Row","id":"p2522","attributes":{"children":[{"type":"object","name":"Column","id":"p2514","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2513","attributes":{"height":4}},{"id":"p2475"}]}},{"id":"p2471"},{"type":"object","name":"Column","id":"p2516","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2515","attributes":{"height":4}},{"id":"p2478"}]}}]}},{"type":"object","name":"Row","id":"p2523","attributes":{"children":[{"type":"object","name":"Column","id":"p2518","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2517","attributes":{"height":4}},{"id":"p2476"}]}},{"id":"p2473"},{"type":"object","name":"Column","id":"p2520","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2519","attributes":{"height":4}},{"id":"p2479"}]}}]}}]}},{"type":"object","name":"Spacer","id":"p2539","attributes":{"width":20}},{"type":"object","name":"Column","id":"p2508","attributes":{"children":[{"type":"object","name":"Row","id":"p2507","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2499","attributes":{"width":20}},{"type":"object","name":"Column","id":"p2502","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2500","attributes":{"height":7}},{"type":"object","name":"Div","id":"p2501","attributes":{"text":"&lt;p&gt;&lt;b&gt;y: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p2480"},{"type":"object","name":"Spacer","id":"p2503","attributes":{"width":16}},{"type":"object","name":"Column","id":"p2506","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2504","attributes":{"height":7}},{"type":"object","name":"Div","id":"p2505","attributes":{"text":"&lt;p&gt;&lt;b&gt;quantile: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p2481"}]}}]}}]}},{"type":"object","name":"Spacer","id":"p2541","attributes":{"height":10}},{"type":"object","name":"GridPlot","id":"p2533","attributes":{"rows":null,"cols":null,"toolbar":{"type":"object","name":"Toolbar","id":"p2532","attributes":{"tools":[{"type":"object","name":"ToolProxy","id":"p2526","attributes":{"tools":[{"id":"p2406"},{"id":"p2435"},{"id":"p2406"},{"id":"p2435"}]}},{"type":"object","name":"ToolProxy","id":"p2527","attributes":{"tools":[{"id":"p2407"},{"id":"p2436"},{"id":"p2407"},{"id":"p2436"}]}},{"type":"object","name":"ToolProxy","id":"p2528","attributes":{"tools":[{"id":"p2408"},{"id":"p2437"},{"id":"p2408"},{"id":"p2437"}]}},{"type":"object","name":"SaveTool","id":"p2529"},{"type":"object","name":"ToolProxy","id":"p2530","attributes":{"tools":[{"id":"p2411"},{"id":"p2440"},{"id":"p2411"},{"id":"p2440"}]}},{"type":"object","name":"ToolProxy","id":"p2531","attributes":{"tools":[{"id":"p2412"},{"id":"p2441"},{"id":"p2412"},{"id":"p2441"}]}}]}},"toolbar_location":"right","children":[[{"id":"p2384"},0,0],[{"type":"object","name":"Spacer","id":"p2525","attributes":{"width":30}},0,1],[{"id":"p2413"},0,2]]}}]}}]}}';
                  const render_items = [{"docid":"cebc3a65-9e53-44af-94ed-81508f64b824","roots":{"p2542":"f6a001de-6399-4e46-a2eb-a0428fc2ea57"},"root_ids":["p2542"]}];
                  root.Bokeh.embed.embed_items(docs_json, render_items);
                  }
                  if (root.Bokeh !== undefined) {
                    embed_document(root);
                  } else {
                    let attempts = 0;
                    const timer = setInterval(function(root) {
                      if (root.Bokeh !== undefined) {
                        clearInterval(timer);
                        embed_document(root);
                      } else {
                        attempts++;
                        if (attempts > 100) {
                          clearInterval(timer);
                          console.log("Bokeh: ERROR: Unable to run BokehJS code because BokehJS library is missing");
                        }
                      }
                    }, 10, root)
                  }
                })(window);
              });
            };
            if (document.readyState != "loading") fn();
            else document.addEventListener("DOMContentLoaded", fn);
          })();
        },
    function(Bokeh) {
        }
      ];
    
      function run_inline_js() {
        for (let i = 0; i < inline_js.length; i++) {
          inline_js[i].call(root, root.Bokeh);
        }
      }
    
      if (root._bokeh_is_loading === 0) {
        console.debug("Bokeh: BokehJS loaded, going straight to plotting");
        run_inline_js();
      } else {
        load_libs(css_urls, js_urls, function() {
          console.debug("Bokeh: BokehJS plotting callback run at", now());
          run_inline_js();
        });
      }
    }(window));
  };
  if (document.readyState != "loading") fn();
  else document.addEventListener("DOMContentLoaded", fn);
})();