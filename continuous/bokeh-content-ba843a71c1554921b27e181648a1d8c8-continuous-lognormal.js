(function() {
  const fn = function() {
    'use strict';
    (function(root) {
      function now() {
        return new Date();
      }
    
      const force = false;
    
      if (typeof root._bokeh_onload_callbacks === "undefined" || force === true) {
        root._bokeh_onload_callbacks = [];
        root._bokeh_is_loading = undefined;
      }
    
    
    const element = document.getElementById("e61ab3fc-613f-42b6-99ea-8b30f839dc5e");
        if (element == null) {
          console.warn("Bokeh: autoload.js configured with elementid 'e61ab3fc-613f-42b6-99ea-8b30f839dc5e' but no matching script tag was found.")
        }
      function run_callbacks() {
        try {
          root._bokeh_onload_callbacks.forEach(function(callback) {
            if (callback != null)
              callback();
          });
        } finally {
          delete root._bokeh_onload_callbacks
        }
        console.debug("Bokeh: all callbacks have finished");
      }
    
      function load_libs(css_urls, js_urls, callback) {
        if (css_urls == null) css_urls = [];
        if (js_urls == null) js_urls = [];
    
        root._bokeh_onload_callbacks.push(callback);
        if (root._bokeh_is_loading > 0) {
          console.debug("Bokeh: BokehJS is being loaded, scheduling callback at", now());
          return null;
        }
        if (js_urls == null || js_urls.length === 0) {
          run_callbacks();
          return null;
        }
        console.debug("Bokeh: BokehJS not loaded, scheduling load and callback at", now());
        root._bokeh_is_loading = css_urls.length + js_urls.length;
    
        function on_load() {
          root._bokeh_is_loading--;
          if (root._bokeh_is_loading === 0) {
            console.debug("Bokeh: all BokehJS libraries/stylesheets loaded");
            run_callbacks()
          }
        }
    
        function on_error(url) {
          console.error("failed to load " + url);
        }
    
        for (let i = 0; i < css_urls.length; i++) {
          const url = css_urls[i];
          const element = document.createElement("link");
          element.onload = on_load;
          element.onerror = on_error.bind(null, url);
          element.rel = "stylesheet";
          element.type = "text/css";
          element.href = url;
          console.debug("Bokeh: injecting link tag for BokehJS stylesheet: ", url);
          document.body.appendChild(element);
        }
    
        for (let i = 0; i < js_urls.length; i++) {
          const url = js_urls[i];
          const element = document.createElement('script');
          element.onload = on_load;
          element.onerror = on_error.bind(null, url);
          element.async = false;
          element.src = url;
          console.debug("Bokeh: injecting script tag for BokehJS library: ", url);
          document.head.appendChild(element);
        }
      };
    
      function inject_raw_css(css) {
        const element = document.createElement("style");
        element.appendChild(document.createTextNode(css));
        document.body.appendChild(element);
      }
    
      const js_urls = ["https://cdn.bokeh.org/bokeh/release/bokeh-3.4.1.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-gl-3.4.1.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-widgets-3.4.1.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-tables-3.4.1.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-mathjax-3.4.1.min.js"];
      const css_urls = [];
    
      const inline_js = [    function(Bokeh) {
          Bokeh.set_log_level("info");
        },
        function(Bokeh) {
          (function() {
            const fn = function() {
              Bokeh.safely(function() {
                (function(root) {
                  function embed_document(root) {
                  const docs_json = '{"cebccd9a-40dc-4e60-bb9d-b421fc3e5af4":{"version":"3.4.1","title":"Bokeh Application","roots":[{"type":"object","name":"Column","id":"p3422","attributes":{"children":[{"type":"object","name":"Row","id":"p3417","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3415","attributes":{"width":409}},{"type":"object","name":"Row","id":"p3375","attributes":{"children":[{"type":"object","name":"Div","id":"p3373","attributes":{"text":"&lt;p&gt;&lt;b&gt;Quantile setter mode&lt;/b&gt;&lt;/p&gt;"}},{"type":"object","name":"Spacer","id":"p3374","attributes":{"width":2}},{"type":"object","name":"Switch","id":"p3362","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:active",[{"type":"object","name":"CustomJS","id":"p3366","attributes":{"args":{"type":"map","entries":[["p_p",{"type":"object","name":"Figure","id":"p3259","attributes":{"x_range":{"type":"object","name":"Range1d","id":"p3323","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:start",[{"type":"object","name":"CustomJS","id":"p3365","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p3259"}],["p_c",{"type":"object","name":"Figure","id":"p3291","attributes":{"js_event_callbacks":{"type":"map","entries":[["reset",[{"type":"object","name":"CustomJS","id":"p3368","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p3259"}],["p_c",{"id":"p3291"}],["source_p",{"type":"object","name":"ColumnDataSource","id":"p3325","attributes":{"selected":{"type":"object","name":"Selection","id":"p3326","attributes":{"indices":[],"line_indices":[]}},"selection_policy":{"type":"object","name":"UnionRenderers","id":"p3327"},"data":{"type":"map","entries":[["x",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}],["y_p",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}]]}}}],["source_c",{"type":"object","name":"ColumnDataSource","id":"p3328","attributes":{"selected":{"type":"object","name":"Selection","id":"p3329","attributes":{"indices":[],"line_indices":[]}},"selection_policy":{"type":"object","name":"UnionRenderers","id":"p3330"},"data":{"type":"map","entries":[["x",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}],["y_c",{"type":"ndarray","array":{"type":"bytes","data":"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qCGkGc7/7z81p2ej0v/vP1C9/cPW/+8/dT3bhNr/7z9qfZ3u3f/vP507HQnh/+8/MOp/2+P/7z+7e0ds5v/vP9rRYMHo/+8/OOsw4Or/7z8k7KDN7P/vP7gaKY7u/+8/X+XaJfD/7z/CCGqY8f/vP2LoNOny/+8/eitMG/T/7z9frnkx9f/vPyLXRi72/+8/IVsCFPf/7z/QgcXk9//vPzXweKL4/+8/dAfZTvn/7z/v33nr+f/vP7Lpynn6/+8/HDoa+/r/7z8Njpdw+//vP0UHV9v7/+8/+KpTPPz/7z8wp3GU/P/vPwdkgOT8/+8/X2U8Lf3/7z9DAVFv/f/vP+DuWav9/+8/frHk4f3/7z/M4nET/v/vP1NfdkD+/+8/yVdcaf7/7z+pSYSO/v/vP0/hRbD+/+8/l8fwzv7/7z/aXM3q/v/vP/ViHQT//+8/3pccG///7z80QgEw///vPwCx/EL//+8/3687VP//7z+V8OZj///vPwJrI3L//+8/X7QSf///7z9/TtOK///vP9rvgJX//+8/BsU0n///7z8yrAWo///vPzZrCLD//+8/ruBPt///7z+gMO29///vPwHt78P//+8/kjpmyf//7z9T8lzO///vP+y/39L//+8/TT351v//7z/CC7Pa///vP8PqFd7//+8/o8wp4f//7z9i6fXj///vP8PPgOb//+8/y3TQ6P//7z/hQerq///vP5Yh0+z//+8/R4uP7v//7z+sjSPw///vP3TYkvH//+8/9MTg8v//7z8aXhD0///vP5RnJPX//+8/XGQf9v//7z+pnAP3///vP0gj0/f//+8/i9qP+P//7z+yeDv5///vP/iL1/n//+8/Pn5l+v//7z9bmOb6///vPyUFXPv//+8/MdTG+///7z9O/Cf8///vP8tdgPz//+8/h8TQ/P//7z/M6Rn9///vPwZ2XP3//+8/SgKZ/f//7z+/GdD9///vP+I6Av7//+8/sNgv/v//7z+yW1n+///vP+8if/7//+8/zoSh/v//7z/dz8D+///vP4dL3f7//+8/vjj3/v//7z+P0g7////vP6xOJP///+8/6903////7z+0rEn////vP2njWf///+8/x6Zo////7z81GHb////vPxdWgv///+8/EHyN////7z9Go5f////vP5nioP///+8/1k6p////7z/t+rD////vPxf4t////+8/AFa+////7z/qIsT////vP9Bryf///+8/gDzO////7z+6n9L////vP0Wf1v///+8/B0Ta////7z8clt3////vP+Kc4P///+8/EV/j////7z/E4uX////vP4wt6P///+8/ekTq////7z8qLOz////vP8/o7f///+8/PH7v////7z/t7/D////vPwxB8v///+8/fnTz////7z/jjPT////vP6GM9f///+8/5nX2////7z+wSvf////vP84M+P///+8/5r34////7z94X/n////vP+Ty+f///+8/aXn6////7z8q9Pr////vPzBk+////+8/bsr7////7z++J/z////vP+t8/P///+8/q8r8////7z+lEf3////vP3FS/f///+8/mo39////7z+fw/3////vP/L0/f///+8//CH+////7z8fS/7////vP7Bw/v///+8/AJP+////7z9Ysv7////vP/nO/v///+8/Ien+////7z8GAf/////vP9sW/////+8/zir/////7z8IPf/////vP7FN/////+8/6lz/////7z/Uav/////vP4t3/////+8/K4P/////7z/Mjf/////vP4OX/////+8/ZaD/////7z+EqP/////vP/Gv/////+8/u7b/////7z8="},"shape":[400],"dtype":"float64","order":"little"}]]}}}],["discrete",false],["n",400],["sliders",[{"type":"object","name":"Slider","id":"p3350","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p3364","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p3259"}],["p_c",{"id":"p3291"}],["source_p",{"id":"p3325"}],["source_c",{"id":"p3328"}],["discrete",false],["n",400],["sliders",[{"id":"p3350"},{"type":"object","name":"Slider","id":"p3352","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p3364"}]]]},"width":200,"title":"\\u03c3","format":{"type":"object","name":"CustomJSTickFormatter","id":"p3351","attributes":{"code":"return tick.toPrecision(4)"}},"start":0.1,"end":1.0,"value":0.2,"step":0.01}}]],["xBoxes",[{"type":"object","name":"TextInput","id":"p3357","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p3367","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p3259"}],["p_c",{"id":"p3291"}],["source_p",{"id":"p3325"}],["source_c",{"id":"p3328"}],["discrete",false],["n",400],["sliders",[{"id":"p3350"},{"id":"p3352"}]],["xBoxes",[{"id":"p3357"},{"type":"object","name":"TextInput","id":"p3358","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p3367"}]]]},"disabled":true,"width":80,"value":"1.8076"}}]],["pBoxes",[{"type":"object","name":"TextInput","id":"p3359","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p3367"}]]]},"disabled":true,"width":80,"value":"0.0250"}},{"type":"object","name":"TextInput","id":"p3360","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p3367"}]]]},"disabled":true,"width":80,"value":"0.9750"}}]],["quantileSetterSwitch",{"id":"p3362"}],["quantileSetterDiv",{"type":"object","name":"Div","id":"p3361"}],["triggerCallbacks",{"type":"object","name":"Switch","id":"p3363","attributes":{"active":true}}],["startBoxes",[{"type":"object","name":"TextInput","id":"p3353","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p3369","attributes":{"args":{"type":"map","entries":[["minValue","-Infinity"],["maxValue","Infinity"],["slider",{"id":"p3350"}]]},"code":"\\n\\nslider.start = Math.max(minValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"-0.5"}},{"type":"object","name":"TextInput","id":"p3354","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p3371","attributes":{"args":{"type":"map","entries":[["minValue","0"],["maxValue","Infinity"],["slider",{"id":"p3352"}]]},"code":"\\n\\nslider.start = Math.max(minValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"0.1"}}]],["endBoxes",[{"type":"object","name":"TextInput","id":"p3355","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p3370","attributes":{"args":{"type":"map","entries":[["minValue","-Infinity"],["maxValue","Infinity"],["slider",{"id":"p3350"}]]},"code":"\\n\\nslider.end = Math.min(maxValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"0.5"}},{"type":"object","name":"TextInput","id":"p3356","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p3372","attributes":{"args":{"type":"map","entries":[["minValue","0"],["maxValue","Infinity"],["slider",{"id":"p3352"}]]},"code":"\\n\\nslider.end = Math.min(maxValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"1.0"}}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nfunction erf(x) {\\n  \\n  var a = [1.00002368,\\n           0.37409196,\\n           0.09678418,\\n           -0.18628806,\\n           0.27886807,\\n           -1.13520398,\\n           1.48851587,\\n           -0.82215223,\\n           0.17087277];\\n\\n  var t = 1 / (1 + Math.abs(x)/2);\\n  var expSum = -Math.pow(x, 2) - 1.26551223;\\n\\n  for (var i = 0; i &lt; a.length; i++) {\\n      expSum += a[i] * Math.pow(t, i+1);\\n  }\\n\\n  var result = 1 - t * Math.exp(expSum);\\n\\n  if (x &lt; 0) return -result;\\n  return result;\\n}\\n\\n\\nfunction erfinv(x) {\\n  \\n  let p = (x + 1.0) / 2.0;\\n\\n  \\n  if (p == 0.0) return -Infinity;\\n  if (p == 1.0) return Infinity;\\n  if (p &gt; 1.0 || p &lt; 0.0) return undefined;\\n\\n  let split1 = 0.425;\\n  let split2 = 5.0;\\n  let const1 = 0.180625;\\n  let const2 = 1.6;\\n\\n  \\n  let a0 = 3.3871327179;\\n  let a1 = 5.0434271938e1;\\n  let a2 = 1.5929113202e2;\\n  let a3 = 5.9109374720e1;\\n  let b1 = 1.7895169469e1;\\n  let b2 = 7.8757757664e1;\\n  let b3 = 6.7187563600e1;\\n\\n  \\n  let c0 = 1.4234372777;\\n  let c1 = 2.7568153900;\\n  let c2 = 1.3067284816;\\n  let c3 = 1.7023821103e-1;\\n  let d1 = 7.3700164250e-1;\\n  let d2 = 1.2021132975e-1;\\n\\n  \\n  let e0 = 6.6579051150;\\n  let e1 = 3.0812263860;\\n  let e2 = 4.2868294337e-1;\\n  let e3 = 1.7337203997e-2;\\n  let f1 = 2.4197894225e-1;\\n  let f2 = 1.2258202635e-2;\\n\\n  let r;\\n  let res;\\n  let q = p - 0.5;\\n\\n  if (Math.abs(q) &lt;= split1) {\\n    r = const1 - q * q;\\n    res = q * (((a3 * r + a2) * r + a1) * r + a0) /\\n              (((b3 * r + b2) * r + b1) * r + 1.0);\\n  } else {\\n    r = q &lt; 0 ? p : 1.0 - p;\\n\\n    r = Math.sqrt(-Math.log(r));\\n\\n    if (r &lt;= split2) {\\n      r -= const2;\\n      res = (((c3 * r + c2) * r + c1) * r + c0) /\\n             ((d2 * r + d1) * r + 1.0);\\n    } else {\\n      r -= split2;\\n      res = (((e3 * r + e2) * r + e1) * r + e0) /\\n             ((f2 * r + f1) * r + 1.0);\\n    }\\n  \\n    if (q &lt; 0) {\\n      res = -res;\\n    }\\n  }\\n\\n  \\n  return 0.7071067811865475 * res;\\n\\n}\\n\\n\\nclass LogNormalDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;LogNormal&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.locationParam = &#x27;\\u03bc&#x27;;\\n\\n    \\n    this.paramMin = [-Infinity, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds();\\n\\n    \\n    super.generateLocationParamIndex();\\n}\\n\\n  xMin(params) {\\n    return 0.0;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x &lt; 0.0) return NaN;\\n    if (x === 0) return 0.0;\\n    if (x === Infinity) return 0.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n    let expTerm = (Math.pow(Math.log(x) - mu, 2) / 2.0 / Math.pow(sigma, 2))\\n    return Math.exp(-expTerm) / x / sigma / Math.sqrt(2 * Math.PI);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x &lt;= 0) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n    return (1 + erf((Math.log(x) - mu) / sigma / Math.sqrt(2))) / 2;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return 0.0;\\n    if (p === 1) return Infinity;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return Math.exp(mu + sqrt2 * sigma * erfinv(2 * p - 1));\\n  }\\n\\n  defaultXRange(params) {\\n    \\n    let [x1, x2] = this.ppf([0.01, 0.99], params);\\n\\n    \\n    if (x1 &lt; (x2 - x1) / 10.0) x1 = 0.0;\\n\\n    return [x1, x2];\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n    let [logx1, logx2] = [Math.log(x1), Math.log(x2)];\\n\\n    let sqrt2 = 1.4142135623730951;\\n\\n    let sigmaCoeff1 = sqrt2 * erfinv(2 * p1 - 1);\\n    let sigmaCoeff2 = sqrt2 * erfinv(2 * p2 - 1);\\n\\n    let sigma = (logx2 - logx1) / (sigmaCoeff2 - sigmaCoeff1);\\n    let mu = logx2 - sigmaCoeff2 * sigma;\\n\\n    return [[mu, sigma], true];\\n  }\\n}\\n\\n\\n\\nvar dist = new LogNormalDistribution();\\n\\n\\n\\nif (quantileSetterSwitch.active) {\\n  quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p);\\n}"}}]]]},"disabled":true,"width":80,"value":"0.8253"}},{"id":"p3358"}]],["pBoxes",[{"id":"p3359"},{"id":"p3360"}]],["quantileSetterSwitch",{"id":"p3362"}],["quantileSetterDiv",{"id":"p3361"}],["triggerCallbacks",{"id":"p3363"}],["startBoxes",[{"id":"p3353"},{"id":"p3354"}]],["endBoxes",[{"id":"p3355"},{"id":"p3356"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nfunction erf(x) {\\n  \\n  var a = [1.00002368,\\n           0.37409196,\\n           0.09678418,\\n           -0.18628806,\\n           0.27886807,\\n           -1.13520398,\\n           1.48851587,\\n           -0.82215223,\\n           0.17087277];\\n\\n  var t = 1 / (1 + Math.abs(x)/2);\\n  var expSum = -Math.pow(x, 2) - 1.26551223;\\n\\n  for (var i = 0; i &lt; a.length; i++) {\\n      expSum += a[i] * Math.pow(t, i+1);\\n  }\\n\\n  var result = 1 - t * Math.exp(expSum);\\n\\n  if (x &lt; 0) return -result;\\n  return result;\\n}\\n\\n\\nfunction erfinv(x) {\\n  \\n  let p = (x + 1.0) / 2.0;\\n\\n  \\n  if (p == 0.0) return -Infinity;\\n  if (p == 1.0) return Infinity;\\n  if (p &gt; 1.0 || p &lt; 0.0) return undefined;\\n\\n  let split1 = 0.425;\\n  let split2 = 5.0;\\n  let const1 = 0.180625;\\n  let const2 = 1.6;\\n\\n  \\n  let a0 = 3.3871327179;\\n  let a1 = 5.0434271938e1;\\n  let a2 = 1.5929113202e2;\\n  let a3 = 5.9109374720e1;\\n  let b1 = 1.7895169469e1;\\n  let b2 = 7.8757757664e1;\\n  let b3 = 6.7187563600e1;\\n\\n  \\n  let c0 = 1.4234372777;\\n  let c1 = 2.7568153900;\\n  let c2 = 1.3067284816;\\n  let c3 = 1.7023821103e-1;\\n  let d1 = 7.3700164250e-1;\\n  let d2 = 1.2021132975e-1;\\n\\n  \\n  let e0 = 6.6579051150;\\n  let e1 = 3.0812263860;\\n  let e2 = 4.2868294337e-1;\\n  let e3 = 1.7337203997e-2;\\n  let f1 = 2.4197894225e-1;\\n  let f2 = 1.2258202635e-2;\\n\\n  let r;\\n  let res;\\n  let q = p - 0.5;\\n\\n  if (Math.abs(q) &lt;= split1) {\\n    r = const1 - q * q;\\n    res = q * (((a3 * r + a2) * r + a1) * r + a0) /\\n              (((b3 * r + b2) * r + b1) * r + 1.0);\\n  } else {\\n    r = q &lt; 0 ? p : 1.0 - p;\\n\\n    r = Math.sqrt(-Math.log(r));\\n\\n    if (r &lt;= split2) {\\n      r -= const2;\\n      res = (((c3 * r + c2) * r + c1) * r + c0) /\\n             ((d2 * r + d1) * r + 1.0);\\n    } else {\\n      r -= split2;\\n      res = (((e3 * r + e2) * r + e1) * r + e0) /\\n             ((f2 * r + f1) * r + 1.0);\\n    }\\n  \\n    if (q &lt; 0) {\\n      res = -res;\\n    }\\n  }\\n\\n  \\n  return 0.7071067811865475 * res;\\n\\n}\\n\\n\\nclass LogNormalDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;LogNormal&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.locationParam = &#x27;\\u03bc&#x27;;\\n\\n    \\n    this.paramMin = [-Infinity, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds();\\n\\n    \\n    super.generateLocationParamIndex();\\n}\\n\\n  xMin(params) {\\n    return 0.0;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x &lt; 0.0) return NaN;\\n    if (x === 0) return 0.0;\\n    if (x === Infinity) return 0.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n    let expTerm = (Math.pow(Math.log(x) - mu, 2) / 2.0 / Math.pow(sigma, 2))\\n    return Math.exp(-expTerm) / x / sigma / Math.sqrt(2 * Math.PI);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x &lt;= 0) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n    return (1 + erf((Math.log(x) - mu) / sigma / Math.sqrt(2))) / 2;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return 0.0;\\n    if (p === 1) return Infinity;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return Math.exp(mu + sqrt2 * sigma * erfinv(2 * p - 1));\\n  }\\n\\n  defaultXRange(params) {\\n    \\n    let [x1, x2] = this.ppf([0.01, 0.99], params);\\n\\n    \\n    if (x1 &lt; (x2 - x1) / 10.0) x1 = 0.0;\\n\\n    return [x1, x2];\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n    let [logx1, logx2] = [Math.log(x1), Math.log(x2)];\\n\\n    let sqrt2 = 1.4142135623730951;\\n\\n    let sigmaCoeff1 = sqrt2 * erfinv(2 * p1 - 1);\\n    let sigmaCoeff2 = sqrt2 * erfinv(2 * p2 - 1);\\n\\n    let sigma = (logx2 - logx1) / (sigmaCoeff2 - sigmaCoeff1);\\n    let mu = logx2 - sigmaCoeff2 * sigma;\\n\\n    return [[mu, sigma], true];\\n  }\\n}\\n\\n\\n\\nvar dist = new LogNormalDistribution();\\n\\n\\n\\nif (triggerCallbacks.active &amp;&amp; !cb_obj.disabled) {\\n\\tif (quantileSetterSwitch.active) {\\n\\t\\tquantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p);\\n\\t}\\n\\telse {\\n\\t\\tupdateData(source_p, source_c, p_p, sliders, discrete);\\n\\t\\tupdateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes);\\n\\t}\\n}"}}]]]},"width":200,"title":"\\u00b5","format":{"type":"object","name":"CustomJSTickFormatter","id":"p3349","attributes":{"code":"return tick.toPrecision(4)"}},"start":-0.5,"end":0.5,"value":0.0,"step":0.01}},{"id":"p3352"}]],["xBoxes",[{"id":"p3357"},{"id":"p3358"}]],["pBoxes",[{"id":"p3359"},{"id":"p3360"}]],["quantileSetterSwitch",{"id":"p3362"}],["quantileSetterDiv",{"id":"p3361"}],["triggerCallbacks",{"id":"p3363"}],["startBoxes",[{"id":"p3353"},{"id":"p3354"}]],["endBoxes",[{"id":"p3355"},{"id":"p3356"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nfunction erf(x) {\\n  \\n  var a = [1.00002368,\\n           0.37409196,\\n           0.09678418,\\n           -0.18628806,\\n           0.27886807,\\n           -1.13520398,\\n           1.48851587,\\n           -0.82215223,\\n           0.17087277];\\n\\n  var t = 1 / (1 + Math.abs(x)/2);\\n  var expSum = -Math.pow(x, 2) - 1.26551223;\\n\\n  for (var i = 0; i &lt; a.length; i++) {\\n      expSum += a[i] * Math.pow(t, i+1);\\n  }\\n\\n  var result = 1 - t * Math.exp(expSum);\\n\\n  if (x &lt; 0) return -result;\\n  return result;\\n}\\n\\n\\nfunction erfinv(x) {\\n  \\n  let p = (x + 1.0) / 2.0;\\n\\n  \\n  if (p == 0.0) return -Infinity;\\n  if (p == 1.0) return Infinity;\\n  if (p &gt; 1.0 || p &lt; 0.0) return undefined;\\n\\n  let split1 = 0.425;\\n  let split2 = 5.0;\\n  let const1 = 0.180625;\\n  let const2 = 1.6;\\n\\n  \\n  let a0 = 3.3871327179;\\n  let a1 = 5.0434271938e1;\\n  let a2 = 1.5929113202e2;\\n  let a3 = 5.9109374720e1;\\n  let b1 = 1.7895169469e1;\\n  let b2 = 7.8757757664e1;\\n  let b3 = 6.7187563600e1;\\n\\n  \\n  let c0 = 1.4234372777;\\n  let c1 = 2.7568153900;\\n  let c2 = 1.3067284816;\\n  let c3 = 1.7023821103e-1;\\n  let d1 = 7.3700164250e-1;\\n  let d2 = 1.2021132975e-1;\\n\\n  \\n  let e0 = 6.6579051150;\\n  let e1 = 3.0812263860;\\n  let e2 = 4.2868294337e-1;\\n  let e3 = 1.7337203997e-2;\\n  let f1 = 2.4197894225e-1;\\n  let f2 = 1.2258202635e-2;\\n\\n  let r;\\n  let res;\\n  let q = p - 0.5;\\n\\n  if (Math.abs(q) &lt;= split1) {\\n    r = const1 - q * q;\\n    res = q * (((a3 * r + a2) * r + a1) * r + a0) /\\n              (((b3 * r + b2) * r + b1) * r + 1.0);\\n  } else {\\n    r = q &lt; 0 ? p : 1.0 - p;\\n\\n    r = Math.sqrt(-Math.log(r));\\n\\n    if (r &lt;= split2) {\\n      r -= const2;\\n      res = (((c3 * r + c2) * r + c1) * r + c0) /\\n             ((d2 * r + d1) * r + 1.0);\\n    } else {\\n      r -= split2;\\n      res = (((e3 * r + e2) * r + e1) * r + e0) /\\n             ((f2 * r + f1) * r + 1.0);\\n    }\\n  \\n    if (q &lt; 0) {\\n      res = -res;\\n    }\\n  }\\n\\n  \\n  return 0.7071067811865475 * res;\\n\\n}\\n\\n\\nclass LogNormalDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;LogNormal&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.locationParam = &#x27;\\u03bc&#x27;;\\n\\n    \\n    this.paramMin = [-Infinity, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds();\\n\\n    \\n    super.generateLocationParamIndex();\\n}\\n\\n  xMin(params) {\\n    return 0.0;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x &lt; 0.0) return NaN;\\n    if (x === 0) return 0.0;\\n    if (x === Infinity) return 0.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n    let expTerm = (Math.pow(Math.log(x) - mu, 2) / 2.0 / Math.pow(sigma, 2))\\n    return Math.exp(-expTerm) / x / sigma / Math.sqrt(2 * Math.PI);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x &lt;= 0) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n    return (1 + erf((Math.log(x) - mu) / sigma / Math.sqrt(2))) / 2;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return 0.0;\\n    if (p === 1) return Infinity;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return Math.exp(mu + sqrt2 * sigma * erfinv(2 * p - 1));\\n  }\\n\\n  defaultXRange(params) {\\n    \\n    let [x1, x2] = this.ppf([0.01, 0.99], params);\\n\\n    \\n    if (x1 &lt; (x2 - x1) / 10.0) x1 = 0.0;\\n\\n    return [x1, x2];\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n    let [logx1, logx2] = [Math.log(x1), Math.log(x2)];\\n\\n    let sqrt2 = 1.4142135623730951;\\n\\n    let sigmaCoeff1 = sqrt2 * erfinv(2 * p1 - 1);\\n    let sigmaCoeff2 = sqrt2 * erfinv(2 * p2 - 1);\\n\\n    let sigma = (logx2 - logx1) / (sigmaCoeff2 - sigmaCoeff1);\\n    let mu = logx2 - sigmaCoeff2 * sigma;\\n\\n    return [[mu, sigma], true];\\n  }\\n}\\n\\n\\n\\nvar dist = new LogNormalDistribution();\\n\\n\\n\\nlet params = paramsFromSliders(sliders); \\n\\n\\nlet [x1, x2] = dist.defaultXRange(params);\\n\\n\\ntriggerCallbacks.active = false;\\n\\n\\np_p.x_range.start = x1;\\np_p.x_range.end = x2;\\n\\nupdateData(source_p, source_c, p_p, sliders, discrete);\\n\\n\\nsetYRanges(p_p, p_c, source_p);  \\n\\ntriggerCallbacks.active = true;\\n"}}]]]},"x_range":{"id":"p3323"},"y_range":{"type":"object","name":"Range1d","id":"p3324"},"x_scale":{"type":"object","name":"LinearScale","id":"p3301"},"y_scale":{"type":"object","name":"LinearScale","id":"p3302"},"title":{"type":"object","name":"Title","id":"p3294","attributes":{"text":" "}},"renderers":[{"type":"object","name":"GlyphRenderer","id":"p3337","attributes":{"data_source":{"id":"p3328"},"view":{"type":"object","name":"CDSView","id":"p3338","attributes":{"filter":{"type":"object","name":"AllIndices","id":"p3339"}}},"glyph":{"type":"object","name":"Line","id":"p3334","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_width":2}},"nonselection_glyph":{"type":"object","name":"Line","id":"p3335","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_alpha":0.1,"line_width":2}},"muted_glyph":{"type":"object","name":"Line","id":"p3336","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_alpha":0.2,"line_width":2}}}}],"toolbar":{"type":"object","name":"Toolbar","id":"p3300","attributes":{"tools":[{"type":"object","name":"PanTool","id":"p3313"},{"type":"object","name":"BoxZoomTool","id":"p3314","attributes":{"overlay":{"type":"object","name":"BoxAnnotation","id":"p3315","attributes":{"syncable":false,"level":"overlay","visible":false,"left":{"type":"number","value":"nan"},"right":{"type":"number","value":"nan"},"top":{"type":"number","value":"nan"},"bottom":{"type":"number","value":"nan"},"left_units":"canvas","right_units":"canvas","top_units":"canvas","bottom_units":"canvas","line_color":"black","line_alpha":1.0,"line_width":2,"line_dash":[4,4],"fill_color":"lightgrey","fill_alpha":0.5}}}},{"type":"object","name":"WheelZoomTool","id":"p3320","attributes":{"renderers":"auto"}},{"type":"object","name":"SaveTool","id":"p3321"},{"type":"object","name":"ResetTool","id":"p3322"}]}},"toolbar_location":null,"left":[{"type":"object","name":"LinearAxis","id":"p3308","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p3309","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p3310"},"axis_label":"CDF","axis_label_text_font_style":"normal","major_label_policy":{"type":"object","name":"AllLabels","id":"p3311"}}}],"below":[{"type":"object","name":"LinearAxis","id":"p3303","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p3304","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p3305"},"axis_label":"y","major_label_policy":{"type":"object","name":"AllLabels","id":"p3306"}}}],"center":[{"type":"object","name":"Grid","id":"p3307","attributes":{"axis":{"id":"p3303"}}},{"type":"object","name":"Grid","id":"p3312","attributes":{"dimension":1,"axis":{"id":"p3308"}}}],"frame_width":300,"frame_height":175,"background_fill_alpha":0,"border_fill_alpha":0}}],["source_p",{"id":"p3325"}],["source_c",{"id":"p3328"}],["discrete",false],["n",400],["sliders",[{"id":"p3350"},{"id":"p3352"}]],["xBoxes",[{"id":"p3357"},{"id":"p3358"}]],["pBoxes",[{"id":"p3359"},{"id":"p3360"}]],["quantileSetterSwitch",{"id":"p3362"}],["quantileSetterDiv",{"id":"p3361"}],["triggerCallbacks",{"id":"p3363"}],["startBoxes",[{"id":"p3353"},{"id":"p3354"}]],["endBoxes",[{"id":"p3355"},{"id":"p3356"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nfunction erf(x) {\\n  \\n  var a = [1.00002368,\\n           0.37409196,\\n           0.09678418,\\n           -0.18628806,\\n           0.27886807,\\n           -1.13520398,\\n           1.48851587,\\n           -0.82215223,\\n           0.17087277];\\n\\n  var t = 1 / (1 + Math.abs(x)/2);\\n  var expSum = -Math.pow(x, 2) - 1.26551223;\\n\\n  for (var i = 0; i &lt; a.length; i++) {\\n      expSum += a[i] * Math.pow(t, i+1);\\n  }\\n\\n  var result = 1 - t * Math.exp(expSum);\\n\\n  if (x &lt; 0) return -result;\\n  return result;\\n}\\n\\n\\nfunction erfinv(x) {\\n  \\n  let p = (x + 1.0) / 2.0;\\n\\n  \\n  if (p == 0.0) return -Infinity;\\n  if (p == 1.0) return Infinity;\\n  if (p &gt; 1.0 || p &lt; 0.0) return undefined;\\n\\n  let split1 = 0.425;\\n  let split2 = 5.0;\\n  let const1 = 0.180625;\\n  let const2 = 1.6;\\n\\n  \\n  let a0 = 3.3871327179;\\n  let a1 = 5.0434271938e1;\\n  let a2 = 1.5929113202e2;\\n  let a3 = 5.9109374720e1;\\n  let b1 = 1.7895169469e1;\\n  let b2 = 7.8757757664e1;\\n  let b3 = 6.7187563600e1;\\n\\n  \\n  let c0 = 1.4234372777;\\n  let c1 = 2.7568153900;\\n  let c2 = 1.3067284816;\\n  let c3 = 1.7023821103e-1;\\n  let d1 = 7.3700164250e-1;\\n  let d2 = 1.2021132975e-1;\\n\\n  \\n  let e0 = 6.6579051150;\\n  let e1 = 3.0812263860;\\n  let e2 = 4.2868294337e-1;\\n  let e3 = 1.7337203997e-2;\\n  let f1 = 2.4197894225e-1;\\n  let f2 = 1.2258202635e-2;\\n\\n  let r;\\n  let res;\\n  let q = p - 0.5;\\n\\n  if (Math.abs(q) &lt;= split1) {\\n    r = const1 - q * q;\\n    res = q * (((a3 * r + a2) * r + a1) * r + a0) /\\n              (((b3 * r + b2) * r + b1) * r + 1.0);\\n  } else {\\n    r = q &lt; 0 ? p : 1.0 - p;\\n\\n    r = Math.sqrt(-Math.log(r));\\n\\n    if (r &lt;= split2) {\\n      r -= const2;\\n      res = (((c3 * r + c2) * r + c1) * r + c0) /\\n             ((d2 * r + d1) * r + 1.0);\\n    } else {\\n      r -= split2;\\n      res = (((e3 * r + e2) * r + e1) * r + e0) /\\n             ((f2 * r + f1) * r + 1.0);\\n    }\\n  \\n    if (q &lt; 0) {\\n      res = -res;\\n    }\\n  }\\n\\n  \\n  return 0.7071067811865475 * res;\\n\\n}\\n\\n\\nclass LogNormalDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;LogNormal&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.locationParam = &#x27;\\u03bc&#x27;;\\n\\n    \\n    this.paramMin = [-Infinity, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds();\\n\\n    \\n    super.generateLocationParamIndex();\\n}\\n\\n  xMin(params) {\\n    return 0.0;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x &lt; 0.0) return NaN;\\n    if (x === 0) return 0.0;\\n    if (x === Infinity) return 0.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n    let expTerm = (Math.pow(Math.log(x) - mu, 2) / 2.0 / Math.pow(sigma, 2))\\n    return Math.exp(-expTerm) / x / sigma / Math.sqrt(2 * Math.PI);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x &lt;= 0) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n    return (1 + erf((Math.log(x) - mu) / sigma / Math.sqrt(2))) / 2;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return 0.0;\\n    if (p === 1) return Infinity;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return Math.exp(mu + sqrt2 * sigma * erfinv(2 * p - 1));\\n  }\\n\\n  defaultXRange(params) {\\n    \\n    let [x1, x2] = this.ppf([0.01, 0.99], params);\\n\\n    \\n    if (x1 &lt; (x2 - x1) / 10.0) x1 = 0.0;\\n\\n    return [x1, x2];\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n    let [logx1, logx2] = [Math.log(x1), Math.log(x2)];\\n\\n    let sqrt2 = 1.4142135623730951;\\n\\n    let sigmaCoeff1 = sqrt2 * erfinv(2 * p1 - 1);\\n    let sigmaCoeff2 = sqrt2 * erfinv(2 * p2 - 1);\\n\\n    let sigma = (logx2 - logx1) / (sigmaCoeff2 - sigmaCoeff1);\\n    let mu = logx2 - sigmaCoeff2 * sigma;\\n\\n    return [[mu, sigma], true];\\n  }\\n}\\n\\n\\n\\nvar dist = new LogNormalDistribution();\\n\\n\\nif (triggerCallbacks.active) {\\n  updateData(source_p, source_c, p_p, sliders, discrete);\\n}"}}]],["change:end",[{"id":"p3365"}]]]},"end":4}},"y_range":{"type":"object","name":"DataRange1d","id":"p3261","attributes":{"start":0.0}},"x_scale":{"type":"object","name":"LinearScale","id":"p3269"},"y_scale":{"type":"object","name":"LinearScale","id":"p3270"},"title":{"type":"object","name":"Title","id":"p3262","attributes":{"text":"Log-Normal"}},"renderers":[{"type":"object","name":"GlyphRenderer","id":"p3346","attributes":{"data_source":{"id":"p3325"},"view":{"type":"object","name":"CDSView","id":"p3347","attributes":{"filter":{"type":"object","name":"AllIndices","id":"p3348"}}},"glyph":{"type":"object","name":"Line","id":"p3343","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"line_color":"#1f77b4","line_width":2}},"nonselection_glyph":{"type":"object","name":"Line","id":"p3344","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"line_color":"#1f77b4","line_alpha":0.1,"line_width":2}},"muted_glyph":{"type":"object","name":"Line","id":"p3345","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"line_color":"#1f77b4","line_alpha":0.2,"line_width":2}}}}],"toolbar":{"type":"object","name":"Toolbar","id":"p3268","attributes":{"tools":[{"type":"object","name":"PanTool","id":"p3281"},{"type":"object","name":"BoxZoomTool","id":"p3282","attributes":{"overlay":{"type":"object","name":"BoxAnnotation","id":"p3283","attributes":{"syncable":false,"level":"overlay","visible":false,"left":{"type":"number","value":"nan"},"right":{"type":"number","value":"nan"},"top":{"type":"number","value":"nan"},"bottom":{"type":"number","value":"nan"},"left_units":"canvas","right_units":"canvas","top_units":"canvas","bottom_units":"canvas","line_color":"black","line_alpha":1.0,"line_width":2,"line_dash":[4,4],"fill_color":"lightgrey","fill_alpha":0.5}}}},{"type":"object","name":"WheelZoomTool","id":"p3288","attributes":{"renderers":"auto"}},{"type":"object","name":"SaveTool","id":"p3289"},{"type":"object","name":"ResetTool","id":"p3290"}]}},"toolbar_location":null,"left":[{"type":"object","name":"LinearAxis","id":"p3276","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p3277","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p3278"},"axis_label":"PDF","axis_label_text_font_style":"normal","major_label_policy":{"type":"object","name":"AllLabels","id":"p3279"}}}],"below":[{"type":"object","name":"LinearAxis","id":"p3271","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p3272","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p3273"},"axis_label":"y","major_label_policy":{"type":"object","name":"AllLabels","id":"p3274"}}}],"center":[{"type":"object","name":"Grid","id":"p3275","attributes":{"axis":{"id":"p3271"}}},{"type":"object","name":"Grid","id":"p3280","attributes":{"dimension":1,"axis":{"id":"p3276"}}}],"frame_width":300,"frame_height":175,"background_fill_alpha":0,"border_fill_alpha":0}}],["p_c",{"id":"p3291"}],["source_p",{"id":"p3325"}],["source_c",{"id":"p3328"}],["discrete",false],["n",400],["sliders",[{"id":"p3350"},{"id":"p3352"}]],["xBoxes",[{"id":"p3357"},{"id":"p3358"}]],["pBoxes",[{"id":"p3359"},{"id":"p3360"}]],["quantileSetterSwitch",{"id":"p3362"}],["quantileSetterDiv",{"id":"p3361"}],["triggerCallbacks",{"id":"p3363"}],["startBoxes",[{"id":"p3353"},{"id":"p3354"}]],["endBoxes",[{"id":"p3355"},{"id":"p3356"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nfunction erf(x) {\\n  \\n  var a = [1.00002368,\\n           0.37409196,\\n           0.09678418,\\n           -0.18628806,\\n           0.27886807,\\n           -1.13520398,\\n           1.48851587,\\n           -0.82215223,\\n           0.17087277];\\n\\n  var t = 1 / (1 + Math.abs(x)/2);\\n  var expSum = -Math.pow(x, 2) - 1.26551223;\\n\\n  for (var i = 0; i &lt; a.length; i++) {\\n      expSum += a[i] * Math.pow(t, i+1);\\n  }\\n\\n  var result = 1 - t * Math.exp(expSum);\\n\\n  if (x &lt; 0) return -result;\\n  return result;\\n}\\n\\n\\nfunction erfinv(x) {\\n  \\n  let p = (x + 1.0) / 2.0;\\n\\n  \\n  if (p == 0.0) return -Infinity;\\n  if (p == 1.0) return Infinity;\\n  if (p &gt; 1.0 || p &lt; 0.0) return undefined;\\n\\n  let split1 = 0.425;\\n  let split2 = 5.0;\\n  let const1 = 0.180625;\\n  let const2 = 1.6;\\n\\n  \\n  let a0 = 3.3871327179;\\n  let a1 = 5.0434271938e1;\\n  let a2 = 1.5929113202e2;\\n  let a3 = 5.9109374720e1;\\n  let b1 = 1.7895169469e1;\\n  let b2 = 7.8757757664e1;\\n  let b3 = 6.7187563600e1;\\n\\n  \\n  let c0 = 1.4234372777;\\n  let c1 = 2.7568153900;\\n  let c2 = 1.3067284816;\\n  let c3 = 1.7023821103e-1;\\n  let d1 = 7.3700164250e-1;\\n  let d2 = 1.2021132975e-1;\\n\\n  \\n  let e0 = 6.6579051150;\\n  let e1 = 3.0812263860;\\n  let e2 = 4.2868294337e-1;\\n  let e3 = 1.7337203997e-2;\\n  let f1 = 2.4197894225e-1;\\n  let f2 = 1.2258202635e-2;\\n\\n  let r;\\n  let res;\\n  let q = p - 0.5;\\n\\n  if (Math.abs(q) &lt;= split1) {\\n    r = const1 - q * q;\\n    res = q * (((a3 * r + a2) * r + a1) * r + a0) /\\n              (((b3 * r + b2) * r + b1) * r + 1.0);\\n  } else {\\n    r = q &lt; 0 ? p : 1.0 - p;\\n\\n    r = Math.sqrt(-Math.log(r));\\n\\n    if (r &lt;= split2) {\\n      r -= const2;\\n      res = (((c3 * r + c2) * r + c1) * r + c0) /\\n             ((d2 * r + d1) * r + 1.0);\\n    } else {\\n      r -= split2;\\n      res = (((e3 * r + e2) * r + e1) * r + e0) /\\n             ((f2 * r + f1) * r + 1.0);\\n    }\\n  \\n    if (q &lt; 0) {\\n      res = -res;\\n    }\\n  }\\n\\n  \\n  return 0.7071067811865475 * res;\\n\\n}\\n\\n\\nclass LogNormalDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;LogNormal&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.locationParam = &#x27;\\u03bc&#x27;;\\n\\n    \\n    this.paramMin = [-Infinity, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds();\\n\\n    \\n    super.generateLocationParamIndex();\\n}\\n\\n  xMin(params) {\\n    return 0.0;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x &lt; 0.0) return NaN;\\n    if (x === 0) return 0.0;\\n    if (x === Infinity) return 0.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n    let expTerm = (Math.pow(Math.log(x) - mu, 2) / 2.0 / Math.pow(sigma, 2))\\n    return Math.exp(-expTerm) / x / sigma / Math.sqrt(2 * Math.PI);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x &lt;= 0) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n    return (1 + erf((Math.log(x) - mu) / sigma / Math.sqrt(2))) / 2;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return 0.0;\\n    if (p === 1) return Infinity;\\n\\n    let [mu, sigma] = params.slice(0, 2);\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return Math.exp(mu + sqrt2 * sigma * erfinv(2 * p - 1));\\n  }\\n\\n  defaultXRange(params) {\\n    \\n    let [x1, x2] = this.ppf([0.01, 0.99], params);\\n\\n    \\n    if (x1 &lt; (x2 - x1) / 10.0) x1 = 0.0;\\n\\n    return [x1, x2];\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n    let [logx1, logx2] = [Math.log(x1), Math.log(x2)];\\n\\n    let sqrt2 = 1.4142135623730951;\\n\\n    let sigmaCoeff1 = sqrt2 * erfinv(2 * p1 - 1);\\n    let sigmaCoeff2 = sqrt2 * erfinv(2 * p2 - 1);\\n\\n    let sigma = (logx2 - logx1) / (sigmaCoeff2 - sigmaCoeff1);\\n    let mu = logx2 - sigmaCoeff2 * sigma;\\n\\n    return [[mu, sigma], true];\\n  }\\n}\\n\\n\\n\\nvar dist = new LogNormalDistribution();\\n\\n\\n\\nif (cb_obj.active) {\\n  for (let i = 0; i &lt; sliders.length; i++) {\\n    if (!dist.fixedParamsInds.includes(i)) {\\n      sliders[i].title = dist.paramNames[i] + &#x27; (computed)&#x27;;\\n      sliders[i].disabled = true;\\n    }\\n  }\\n  for (let xBox of xBoxes) {\\n    xBox.disabled = false;\\n  }\\n  for (let pBox of pBoxes) {\\n    pBox.disabled = false;\\n  }\\n} else {\\n  for (let i = 0; i &lt; sliders.length; i++) {\\n    if (!dist.fixedParamsInds.includes(i)) {\\n      sliders[i].title = dist.paramNames[i];\\n      sliders[i].disabled = false;\\n    }\\n  }\\n  for (let xBox of xBoxes) {\\n    xBox.disabled = true;\\n  }\\n  for (let pBox of pBoxes) {\\n    pBox.disabled = true;\\n  }\\n  quantileSetterDiv.text = &#x27;&#x27;;\\n}"}}]]]}}}]}},{"type":"object","name":"Spacer","id":"p3416","attributes":{"width":10}},{"id":"p3361"}]}},{"type":"object","name":"Spacer","id":"p3418","attributes":{"height":10}},{"type":"object","name":"Row","id":"p3420","attributes":{"children":[{"type":"object","name":"Column","id":"p3405","attributes":{"children":[{"type":"object","name":"Row","id":"p3403","attributes":{"children":[{"type":"object","name":"Column","id":"p3396","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3395","attributes":{"height":4}},{"id":"p3353"}]}},{"id":"p3350"},{"type":"object","name":"Column","id":"p3398","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3397","attributes":{"height":4}},{"id":"p3355"}]}}]}},{"type":"object","name":"Row","id":"p3404","attributes":{"children":[{"type":"object","name":"Column","id":"p3400","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3399","attributes":{"height":4}},{"id":"p3354"}]}},{"id":"p3352"},{"type":"object","name":"Column","id":"p3402","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3401","attributes":{"height":4}},{"id":"p3356"}]}}]}}]}},{"type":"object","name":"Spacer","id":"p3419","attributes":{"width":20}},{"type":"object","name":"Column","id":"p3394","attributes":{"children":[{"type":"object","name":"Row","id":"p3392","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3376","attributes":{"width":20}},{"type":"object","name":"Column","id":"p3379","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3377","attributes":{"height":7}},{"type":"object","name":"Div","id":"p3378","attributes":{"text":"&lt;p&gt;&lt;b&gt;lower y: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p3357"},{"type":"object","name":"Spacer","id":"p3380","attributes":{"width":34}},{"type":"object","name":"Column","id":"p3383","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3381","attributes":{"height":7}},{"type":"object","name":"Div","id":"p3382","attributes":{"text":"&lt;p&gt;&lt;b&gt;upper y: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p3358"}]}},{"type":"object","name":"Row","id":"p3393","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3384","attributes":{"width":16}},{"type":"object","name":"Column","id":"p3387","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3385","attributes":{"height":7}},{"type":"object","name":"Div","id":"p3386","attributes":{"text":"&lt;p&gt;&lt;b&gt;quantile: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p3359"},{"type":"object","name":"Spacer","id":"p3388","attributes":{"width":30}},{"type":"object","name":"Column","id":"p3391","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3389","attributes":{"height":7}},{"type":"object","name":"Div","id":"p3390","attributes":{"text":"&lt;p&gt;&lt;b&gt;quantile: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p3360"}]}}]}}]}},{"type":"object","name":"Spacer","id":"p3421","attributes":{"height":10}},{"type":"object","name":"GridPlot","id":"p3413","attributes":{"rows":null,"cols":null,"toolbar":{"type":"object","name":"Toolbar","id":"p3412","attributes":{"tools":[{"type":"object","name":"ToolProxy","id":"p3407","attributes":{"tools":[{"id":"p3281"},{"id":"p3313"},{"id":"p3281"},{"id":"p3313"}]}},{"type":"object","name":"ToolProxy","id":"p3408","attributes":{"tools":[{"id":"p3282"},{"id":"p3314"},{"id":"p3282"},{"id":"p3314"}]}},{"type":"object","name":"ToolProxy","id":"p3409","attributes":{"tools":[{"id":"p3288"},{"id":"p3320"},{"id":"p3288"},{"id":"p3320"}]}},{"type":"object","name":"SaveTool","id":"p3410"},{"type":"object","name":"ToolProxy","id":"p3411","attributes":{"tools":[{"id":"p3290"},{"id":"p3322"},{"id":"p3290"},{"id":"p3322"}]}}]}},"toolbar_location":"right","children":[[{"id":"p3259"},0,0],[{"type":"object","name":"Spacer","id":"p3406","attributes":{"width":30}},0,1],[{"id":"p3291"},0,2]]}}]}}]}}';
                  const render_items = [{"docid":"cebccd9a-40dc-4e60-bb9d-b421fc3e5af4","roots":{"p3422":"e61ab3fc-613f-42b6-99ea-8b30f839dc5e"},"root_ids":["p3422"]}];
                  root.Bokeh.embed.embed_items(docs_json, render_items);
                  }
                  if (root.Bokeh !== undefined) {
                    embed_document(root);
                  } else {
                    let attempts = 0;
                    const timer = setInterval(function(root) {
                      if (root.Bokeh !== undefined) {
                        clearInterval(timer);
                        embed_document(root);
                      } else {
                        attempts++;
                        if (attempts > 100) {
                          clearInterval(timer);
                          console.log("Bokeh: ERROR: Unable to run BokehJS code because BokehJS library is missing");
                        }
                      }
                    }, 10, root)
                  }
                })(window);
              });
            };
            if (document.readyState != "loading") fn();
            else document.addEventListener("DOMContentLoaded", fn);
          })();
        },
    function(Bokeh) {
        }
      ];
    
      function run_inline_js() {
        for (let i = 0; i < inline_js.length; i++) {
          inline_js[i].call(root, root.Bokeh);
        }
      }
    
      if (root._bokeh_is_loading === 0) {
        console.debug("Bokeh: BokehJS loaded, going straight to plotting");
        run_inline_js();
      } else {
        load_libs(css_urls, js_urls, function() {
          console.debug("Bokeh: BokehJS plotting callback run at", now());
          run_inline_js();
        });
      }
    }(window));
  };
  if (document.readyState != "loading") fn();
  else document.addEventListener("DOMContentLoaded", fn);
})();