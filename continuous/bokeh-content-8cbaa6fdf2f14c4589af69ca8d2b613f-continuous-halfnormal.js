(function() {
  const fn = function() {
    'use strict';
    (function(root) {
      function now() {
        return new Date();
      }
    
      const force = false;
    
      if (typeof root._bokeh_onload_callbacks === "undefined" || force === true) {
        root._bokeh_onload_callbacks = [];
        root._bokeh_is_loading = undefined;
      }
    
    
    const element = document.getElementById("ee770fb9-52eb-44d8-9ea4-476719f4e717");
        if (element == null) {
          console.warn("Bokeh: autoload.js configured with elementid 'ee770fb9-52eb-44d8-9ea4-476719f4e717' but no matching script tag was found.")
        }
      function run_callbacks() {
        try {
          root._bokeh_onload_callbacks.forEach(function(callback) {
            if (callback != null)
              callback();
          });
        } finally {
          delete root._bokeh_onload_callbacks
        }
        console.debug("Bokeh: all callbacks have finished");
      }
    
      function load_libs(css_urls, js_urls, callback) {
        if (css_urls == null) css_urls = [];
        if (js_urls == null) js_urls = [];
    
        root._bokeh_onload_callbacks.push(callback);
        if (root._bokeh_is_loading > 0) {
          console.debug("Bokeh: BokehJS is being loaded, scheduling callback at", now());
          return null;
        }
        if (js_urls == null || js_urls.length === 0) {
          run_callbacks();
          return null;
        }
        console.debug("Bokeh: BokehJS not loaded, scheduling load and callback at", now());
        root._bokeh_is_loading = css_urls.length + js_urls.length;
    
        function on_load() {
          root._bokeh_is_loading--;
          if (root._bokeh_is_loading === 0) {
            console.debug("Bokeh: all BokehJS libraries/stylesheets loaded");
            run_callbacks()
          }
        }
    
        function on_error(url) {
          console.error("failed to load " + url);
        }
    
        for (let i = 0; i < css_urls.length; i++) {
          const url = css_urls[i];
          const element = document.createElement("link");
          element.onload = on_load;
          element.onerror = on_error.bind(null, url);
          element.rel = "stylesheet";
          element.type = "text/css";
          element.href = url;
          console.debug("Bokeh: injecting link tag for BokehJS stylesheet: ", url);
          document.body.appendChild(element);
        }
    
        for (let i = 0; i < js_urls.length; i++) {
          const url = js_urls[i];
          const element = document.createElement('script');
          element.onload = on_load;
          element.onerror = on_error.bind(null, url);
          element.async = false;
          element.src = url;
          console.debug("Bokeh: injecting script tag for BokehJS library: ", url);
          document.head.appendChild(element);
        }
      };
    
      function inject_raw_css(css) {
        const element = document.createElement("style");
        element.appendChild(document.createTextNode(css));
        document.body.appendChild(element);
      }
    
      const js_urls = ["https://cdn.bokeh.org/bokeh/release/bokeh-3.4.0.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-gl-3.4.0.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-widgets-3.4.0.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-tables-3.4.0.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-mathjax-3.4.0.min.js"];
      const css_urls = [];
    
      const inline_js = [    function(Bokeh) {
          Bokeh.set_log_level("info");
        },
        function(Bokeh) {
          (function() {
            const fn = function() {
              Bokeh.safely(function() {
                (function(root) {
                  function embed_document(root) {
                  const docs_json = '{"2a1a1bda-4646-4a29-beb6-8e6c3b386297":{"version":"3.4.0","title":"Bokeh Application","roots":[{"type":"object","name":"Column","id":"p2430","attributes":{"children":[{"type":"object","name":"Row","id":"p2425","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2423","attributes":{"width":409}},{"type":"object","name":"Row","id":"p2395","attributes":{"children":[{"type":"object","name":"Div","id":"p2393","attributes":{"text":"&lt;p&gt;&lt;b&gt;Quantile setter mode&lt;/b&gt;&lt;/p&gt;"}},{"type":"object","name":"Spacer","id":"p2394","attributes":{"width":2}},{"type":"object","name":"Switch","id":"p2382","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:active",[{"type":"object","name":"CustomJS","id":"p2386","attributes":{"args":{"type":"map","entries":[["p_p",{"type":"object","name":"Figure","id":"p2297","attributes":{"x_range":{"type":"object","name":"Range1d","id":"p2345","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:start",[{"type":"object","name":"CustomJS","id":"p2385","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p2297"}],["p_c",{"type":"object","name":"Figure","id":"p2321","attributes":{"js_event_callbacks":{"type":"map","entries":[["reset",[{"type":"object","name":"CustomJS","id":"p2388","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p2297"}],["p_c",{"id":"p2321"}],["source_p",{"type":"object","name":"ColumnDataSource","id":"p2347","attributes":{"selected":{"type":"object","name":"Selection","id":"p2348","attributes":{"indices":[],"line_indices":[]}},"selection_policy":{"type":"object","name":"UnionRenderers","id":"p2349"},"data":{"type":"map","entries":[["x",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}],["y_p",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}]]}}}],["source_c",{"type":"object","name":"ColumnDataSource","id":"p2350","attributes":{"selected":{"type":"object","name":"Selection","id":"p2351","attributes":{"indices":[],"line_indices":[]}},"selection_policy":{"type":"object","name":"UnionRenderers","id":"p2352"},"data":{"type":"map","entries":[["x",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}],["y_c",{"type":"ndarray","array":{"type":"bytes","data":"AAAAAAAAAADOZ5Rd7XekP0NPAKRacbQ/pQ2jzaWZvj+JYyWgNVfEP0IJ3rKxVMk/kvlM2jtCzj9ptDRzc47RP9VAxXX08NM/VXI1AlBH1j87DoxMS5DYPyzjwI/Dyto/EMpKpq/13D/Fe5VXIRDfP4mwGSyjjOA/G/LpfTSI4T+/V5tMeHriP6fmvNAwY+M/pyybti5C5D/4OXDhUBflPyqUYw2E4uU/Py/uUsKj5j8Mf4yOElvnP/oJ7q+HCOg/t/oF9D+s6D+P1IINZEbpPxzdRD8m1+k/HpxrbMFe6j/J6YMheN3qP82ZQpqTU+s/plkNx2LB6z+teV1VOSfsP6rayL1uhew/WwA2Wl3c7D8XPnOGYSztP6b+F83Yde0/iyVEIiG57T+gN34tmPbtP4P7nqOaLu4/rw5qsYNh7j89yyd3rI/uP1niTpVrue4/xCEMyhTf7j+7oz2f+ADvPxKfRChkH+8/U3bmzqA67z9elVIu9FLvP+cOR/ufaO8/WYI5+OF77z+2QFz084zvP2VzUNQLnO8/lKNUo1up7z9BzcKrEbXvPxh9uZVYv+8/56XXilfI7z+BMgJeMtDvP6YwPLYJ1+8/hiSuO/vc7z9zCQ7GIeLvP9Etr4uV5u8/QPeWUGzq7z8LQQmVue3vPxISFMOO8O8/UIm2Wvvy7z/v2FEcDfXvP5bGJDHQ9u8/70miUU/47z8YcoLpk/nvP8qteTmm+u8/eeiNdo377z+NsArnT/zvPyzYHf3y/O8/ss8sb3v97z/fcPhN7f3vP/wvqRhM/u8/A8zgzpr+7z+6vvAA3P7vP9n5Vd4R/+8/GA2bQj7/7z/cv8HAYv/vP/uTVK2A/+8/d6c/J5n/7z8UGI8frf/vP8V6L2C9/+8/GDzLkcr/7z9V5t1A1f/vP4djFOLd/+8/ZWgP1uT/7z+zUpts6v/vP1bxbufu/+8/3euAfPL/7z/21gFY9f/vP9t1B573/+8/QDj0a/n/7z9osaTZ+v/vP8+Pa/r7/+8/7YTj3fz/7z/YkJ2Q/f/vP3lEsRz+/+8/g8Uziv7/7z/Frpnf/v/vP/BMByL//+8/kzCSVf//7z/RmHZ9///vP+HUQpz//+8/MmP6s///7z9YSjLG///vP2HoJ9T//+8/NT/T3v//7z8Cl/Xm///vP40pJe3//+8/BGnW8f//7z9KWmP1///vP29kEfj//+8/p+QV+v//7z/4xpn7///vP1xXvPz//+8/7XSV/f//7z9vSDf+///vP8yYr/7//+8/rtII////7z/500r////vP2OIe////+8/rWGf////7z+cs7n////vPyr6zP///+8/8Q7b////7z+wUeX////vP/PG7P///+8/Oy/y////7z9cGPb////vP5Pq+P///+8/RfL6////7z9NZ/z////vP2Jy/f///+8/IjH+////7z8Fuf7////vP5UZ/////+8/B17/////7z9sjv/////vP46w/////+8/kMj/////7z9q2f/////vPzXl/////+8/cu3/////7z8u8//////vPyr3/////+8/7fn/////7z/V+//////vPyb9/////+8/Dv7/////7z+t/v/////vPxr//////+8/ZP//////7z+X///////vP7n//////+8/0P//////7z/g///////vP+v//////+8/8v//////7z/2///////vP/r//////+8//P//////7z/9///////vP/7//////+8/////////7z/////////vP////////+8/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8="},"shape":[400],"dtype":"float64","order":"little"}]]}}}],["discrete",false],["n",400],["sliders",[{"type":"object","name":"Slider","id":"p2372","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p2384","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p2297"}],["p_c",{"id":"p2321"}],["source_p",{"id":"p2347"}],["source_c",{"id":"p2350"}],["discrete",false],["n",400],["sliders",[{"id":"p2372"},{"type":"object","name":"Slider","id":"p2374","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p2384"}]]]},"width":200,"title":"\\u03c3","format":{"type":"object","name":"CustomJSTickFormatter","id":"p2373","attributes":{"code":"return tick.toPrecision(4)"}},"start":0,"end":1,"value":0.2,"step":0.01}}]],["xBoxes",[{"type":"object","name":"TextInput","id":"p2379","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p2387","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p2297"}],["p_c",{"id":"p2321"}],["source_p",{"id":"p2347"}],["source_c",{"id":"p2350"}],["discrete",false],["n",400],["sliders",[{"id":"p2372"},{"id":"p2374"}]],["xBoxes",[{"id":"p2379"}]],["pBoxes",[{"type":"object","name":"TextInput","id":"p2380","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p2387"}]]]},"disabled":true,"width":80,"value":"0.9500"}}]],["quantileSetterSwitch",{"id":"p2382"}],["quantileSetterDiv",{"type":"object","name":"Div","id":"p2381"}],["triggerCallbacks",{"type":"object","name":"Switch","id":"p2383","attributes":{"active":true}}],["startBoxes",[{"type":"object","name":"TextInput","id":"p2375","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p2389","attributes":{"args":{"type":"map","entries":[["minValue","-Infinity"],["maxValue","Infinity"],["slider",{"id":"p2372"}]]},"code":"\\n\\nslider.start = Math.max(minValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"0"}},{"type":"object","name":"TextInput","id":"p2376","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p2391","attributes":{"args":{"type":"map","entries":[["minValue","0"],["maxValue","Infinity"],["slider",{"id":"p2374"}]]},"code":"\\n\\nslider.start = Math.max(minValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"0"}}]],["endBoxes",[{"type":"object","name":"TextInput","id":"p2377","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p2390","attributes":{"args":{"type":"map","entries":[["minValue","-Infinity"],["maxValue","Infinity"],["slider",{"id":"p2372"}]]},"code":"\\n\\nslider.end = Math.min(maxValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"1.0"}},{"type":"object","name":"TextInput","id":"p2378","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p2392","attributes":{"args":{"type":"map","entries":[["minValue","0"],["maxValue","Infinity"],["slider",{"id":"p2374"}]]},"code":"\\n\\nslider.end = Math.min(maxValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"1"}}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p\\\\&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nfunction erf(x) {\\n  \\n  var a = [1.00002368,\\n           0.37409196,\\n           0.09678418,\\n           -0.18628806,\\n           0.27886807,\\n           -1.13520398,\\n           1.48851587,\\n           -0.82215223,\\n           0.17087277];\\n\\n  var t = 1 / (1 + Math.abs(x)/2);\\n  var expSum = -Math.pow(x, 2) - 1.26551223;\\n\\n  for (var i = 0; i &lt; a.length; i++) {\\n      expSum += a[i] * Math.pow(t, i+1);\\n  }\\n\\n  var result = 1 - t * Math.exp(expSum);\\n\\n  if (x &lt; 0) return -result;\\n  return result;\\n}\\n\\n\\nfunction erfinv(x) {\\n  \\n  let p = (x + 1.0) / 2.0;\\n\\n  \\n  if (p == 0.0) return -Infinity;\\n  if (p == 1.0) return Infinity;\\n  if (p &gt; 1.0 || p &lt; 0.0) return undefined;\\n\\n  let split1 = 0.425;\\n  let split2 = 5.0;\\n  let const1 = 0.180625;\\n  let const2 = 1.6;\\n\\n  \\n  let a0 = 3.3871327179;\\n  let a1 = 5.0434271938e1;\\n  let a2 = 1.5929113202e2;\\n  let a3 = 5.9109374720e1;\\n  let b1 = 1.7895169469e1;\\n  let b2 = 7.8757757664e1;\\n  let b3 = 6.7187563600e1;\\n\\n  \\n  let c0 = 1.4234372777;\\n  let c1 = 2.7568153900;\\n  let c2 = 1.3067284816;\\n  let c3 = 1.7023821103e-1;\\n  let d1 = 7.3700164250e-1;\\n  let d2 = 1.2021132975e-1;\\n\\n  \\n  let e0 = 6.6579051150;\\n  let e1 = 3.0812263860;\\n  let e2 = 4.2868294337e-1;\\n  let e3 = 1.7337203997e-2;\\n  let f1 = 2.4197894225e-1;\\n  let f2 = 1.2258202635e-2;\\n\\n  let r;\\n  let res;\\n  let q = p - 0.5;\\n\\n  if (Math.abs(q) &lt;= split1) {\\n    r = const1 - q * q;\\n    res = q * (((a3 * r + a2) * r + a1) * r + a0) /\\n              (((b3 * r + b2) * r + b1) * r + 1.0);\\n  } else {\\n    r = q &lt; 0 ? p : 1.0 - p;\\n\\n    r = Math.sqrt(-Math.log(r));\\n\\n    if (r &lt;= split2) {\\n      r -= const2;\\n      res = (((c3 * r + c2) * r + c1) * r + c0) /\\n             ((d2 * r + d1) * r + 1.0);\\n    } else {\\n      r -= split2;\\n      res = (((e3 * r + e2) * r + e1) * r + e0) /\\n             ((f2 * r + f1) * r + 1.0);\\n    }\\n  \\n    if (q &lt; 0) {\\n      res = -res;\\n    }\\n  }\\n\\n  \\n  return 0.7071067811865475 * res;\\n\\n}\\n\\n\\nclass HalfNormalDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;HalfNormal&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.locationParam = &#x27;\\u03bc&#x27;;\\n\\n    \\n    this.paramMin = [-Infinity, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [&#x27;\\u03bc&#x27;];\\n\\n    \\n    super.generateActiveFixedInds();\\n\\n    \\n    super.generateLocationParamIndex();\\n  }\\n\\n  xMin(params) {\\n    return params[0];\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x &lt; mu) return NaN;\\n    if (x === Infinity) return 0.0;\\n\\n    let expTerm = (Math.pow(x - mu, 2) / 2.0 / Math.pow(sigma, 2));\\n    return Math.exp(-expTerm) / sigma * Math.sqrt(2.0 / Math.PI);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x &lt;= mu) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    return erf((x - mu) / sigma / Math.sqrt(2));\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return mu + sqrt2 * sigma * erfinv(p);\\n  }\\n\\n  defaultXRange(params) {\\n    return [params[0], this.ppf(0.999, params)];\\n  }\\n\\n  quantileSet(x, p, extraParams) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n    let mu = extraParams[0];\\n\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return [[(x1 - mu) / sqrt2 / erfinv(p1)], true];\\n  }\\n}\\n\\n\\n\\nvar dist = new HalfNormalDistribution();\\n\\n\\n\\nif (quantileSetterSwitch.active) {\\n  quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p);\\n}"}}]]]},"disabled":true,"width":80,"value":"0.3920"}}]],["pBoxes",[{"id":"p2380"}]],["quantileSetterSwitch",{"id":"p2382"}],["quantileSetterDiv",{"id":"p2381"}],["triggerCallbacks",{"id":"p2383"}],["startBoxes",[{"id":"p2375"},{"id":"p2376"}]],["endBoxes",[{"id":"p2377"},{"id":"p2378"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p\\\\&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nfunction erf(x) {\\n  \\n  var a = [1.00002368,\\n           0.37409196,\\n           0.09678418,\\n           -0.18628806,\\n           0.27886807,\\n           -1.13520398,\\n           1.48851587,\\n           -0.82215223,\\n           0.17087277];\\n\\n  var t = 1 / (1 + Math.abs(x)/2);\\n  var expSum = -Math.pow(x, 2) - 1.26551223;\\n\\n  for (var i = 0; i &lt; a.length; i++) {\\n      expSum += a[i] * Math.pow(t, i+1);\\n  }\\n\\n  var result = 1 - t * Math.exp(expSum);\\n\\n  if (x &lt; 0) return -result;\\n  return result;\\n}\\n\\n\\nfunction erfinv(x) {\\n  \\n  let p = (x + 1.0) / 2.0;\\n\\n  \\n  if (p == 0.0) return -Infinity;\\n  if (p == 1.0) return Infinity;\\n  if (p &gt; 1.0 || p &lt; 0.0) return undefined;\\n\\n  let split1 = 0.425;\\n  let split2 = 5.0;\\n  let const1 = 0.180625;\\n  let const2 = 1.6;\\n\\n  \\n  let a0 = 3.3871327179;\\n  let a1 = 5.0434271938e1;\\n  let a2 = 1.5929113202e2;\\n  let a3 = 5.9109374720e1;\\n  let b1 = 1.7895169469e1;\\n  let b2 = 7.8757757664e1;\\n  let b3 = 6.7187563600e1;\\n\\n  \\n  let c0 = 1.4234372777;\\n  let c1 = 2.7568153900;\\n  let c2 = 1.3067284816;\\n  let c3 = 1.7023821103e-1;\\n  let d1 = 7.3700164250e-1;\\n  let d2 = 1.2021132975e-1;\\n\\n  \\n  let e0 = 6.6579051150;\\n  let e1 = 3.0812263860;\\n  let e2 = 4.2868294337e-1;\\n  let e3 = 1.7337203997e-2;\\n  let f1 = 2.4197894225e-1;\\n  let f2 = 1.2258202635e-2;\\n\\n  let r;\\n  let res;\\n  let q = p - 0.5;\\n\\n  if (Math.abs(q) &lt;= split1) {\\n    r = const1 - q * q;\\n    res = q * (((a3 * r + a2) * r + a1) * r + a0) /\\n              (((b3 * r + b2) * r + b1) * r + 1.0);\\n  } else {\\n    r = q &lt; 0 ? p : 1.0 - p;\\n\\n    r = Math.sqrt(-Math.log(r));\\n\\n    if (r &lt;= split2) {\\n      r -= const2;\\n      res = (((c3 * r + c2) * r + c1) * r + c0) /\\n             ((d2 * r + d1) * r + 1.0);\\n    } else {\\n      r -= split2;\\n      res = (((e3 * r + e2) * r + e1) * r + e0) /\\n             ((f2 * r + f1) * r + 1.0);\\n    }\\n  \\n    if (q &lt; 0) {\\n      res = -res;\\n    }\\n  }\\n\\n  \\n  return 0.7071067811865475 * res;\\n\\n}\\n\\n\\nclass HalfNormalDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;HalfNormal&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.locationParam = &#x27;\\u03bc&#x27;;\\n\\n    \\n    this.paramMin = [-Infinity, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [&#x27;\\u03bc&#x27;];\\n\\n    \\n    super.generateActiveFixedInds();\\n\\n    \\n    super.generateLocationParamIndex();\\n  }\\n\\n  xMin(params) {\\n    return params[0];\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x &lt; mu) return NaN;\\n    if (x === Infinity) return 0.0;\\n\\n    let expTerm = (Math.pow(x - mu, 2) / 2.0 / Math.pow(sigma, 2));\\n    return Math.exp(-expTerm) / sigma * Math.sqrt(2.0 / Math.PI);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x &lt;= mu) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    return erf((x - mu) / sigma / Math.sqrt(2));\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return mu + sqrt2 * sigma * erfinv(p);\\n  }\\n\\n  defaultXRange(params) {\\n    return [params[0], this.ppf(0.999, params)];\\n  }\\n\\n  quantileSet(x, p, extraParams) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n    let mu = extraParams[0];\\n\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return [[(x1 - mu) / sqrt2 / erfinv(p1)], true];\\n  }\\n}\\n\\n\\n\\nvar dist = new HalfNormalDistribution();\\n\\n\\n\\nif (triggerCallbacks.active &amp;&amp; !cb_obj.disabled) {\\n\\tif (quantileSetterSwitch.active) {\\n\\t\\tquantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p);\\n\\t}\\n\\telse {\\n\\t\\tupdateData(source_p, source_c, p_p, sliders, discrete);\\n\\t\\tupdateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes);\\n\\t}\\n}"}}]]]},"width":200,"title":"\\u00b5","format":{"type":"object","name":"CustomJSTickFormatter","id":"p2371","attributes":{"code":"return tick.toPrecision(4)"}},"start":0,"end":1.0,"value":0,"step":0.01}},{"id":"p2374"}]],["xBoxes",[{"id":"p2379"}]],["pBoxes",[{"id":"p2380"}]],["quantileSetterSwitch",{"id":"p2382"}],["quantileSetterDiv",{"id":"p2381"}],["triggerCallbacks",{"id":"p2383"}],["startBoxes",[{"id":"p2375"},{"id":"p2376"}]],["endBoxes",[{"id":"p2377"},{"id":"p2378"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p\\\\&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nfunction erf(x) {\\n  \\n  var a = [1.00002368,\\n           0.37409196,\\n           0.09678418,\\n           -0.18628806,\\n           0.27886807,\\n           -1.13520398,\\n           1.48851587,\\n           -0.82215223,\\n           0.17087277];\\n\\n  var t = 1 / (1 + Math.abs(x)/2);\\n  var expSum = -Math.pow(x, 2) - 1.26551223;\\n\\n  for (var i = 0; i &lt; a.length; i++) {\\n      expSum += a[i] * Math.pow(t, i+1);\\n  }\\n\\n  var result = 1 - t * Math.exp(expSum);\\n\\n  if (x &lt; 0) return -result;\\n  return result;\\n}\\n\\n\\nfunction erfinv(x) {\\n  \\n  let p = (x + 1.0) / 2.0;\\n\\n  \\n  if (p == 0.0) return -Infinity;\\n  if (p == 1.0) return Infinity;\\n  if (p &gt; 1.0 || p &lt; 0.0) return undefined;\\n\\n  let split1 = 0.425;\\n  let split2 = 5.0;\\n  let const1 = 0.180625;\\n  let const2 = 1.6;\\n\\n  \\n  let a0 = 3.3871327179;\\n  let a1 = 5.0434271938e1;\\n  let a2 = 1.5929113202e2;\\n  let a3 = 5.9109374720e1;\\n  let b1 = 1.7895169469e1;\\n  let b2 = 7.8757757664e1;\\n  let b3 = 6.7187563600e1;\\n\\n  \\n  let c0 = 1.4234372777;\\n  let c1 = 2.7568153900;\\n  let c2 = 1.3067284816;\\n  let c3 = 1.7023821103e-1;\\n  let d1 = 7.3700164250e-1;\\n  let d2 = 1.2021132975e-1;\\n\\n  \\n  let e0 = 6.6579051150;\\n  let e1 = 3.0812263860;\\n  let e2 = 4.2868294337e-1;\\n  let e3 = 1.7337203997e-2;\\n  let f1 = 2.4197894225e-1;\\n  let f2 = 1.2258202635e-2;\\n\\n  let r;\\n  let res;\\n  let q = p - 0.5;\\n\\n  if (Math.abs(q) &lt;= split1) {\\n    r = const1 - q * q;\\n    res = q * (((a3 * r + a2) * r + a1) * r + a0) /\\n              (((b3 * r + b2) * r + b1) * r + 1.0);\\n  } else {\\n    r = q &lt; 0 ? p : 1.0 - p;\\n\\n    r = Math.sqrt(-Math.log(r));\\n\\n    if (r &lt;= split2) {\\n      r -= const2;\\n      res = (((c3 * r + c2) * r + c1) * r + c0) /\\n             ((d2 * r + d1) * r + 1.0);\\n    } else {\\n      r -= split2;\\n      res = (((e3 * r + e2) * r + e1) * r + e0) /\\n             ((f2 * r + f1) * r + 1.0);\\n    }\\n  \\n    if (q &lt; 0) {\\n      res = -res;\\n    }\\n  }\\n\\n  \\n  return 0.7071067811865475 * res;\\n\\n}\\n\\n\\nclass HalfNormalDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;HalfNormal&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.locationParam = &#x27;\\u03bc&#x27;;\\n\\n    \\n    this.paramMin = [-Infinity, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [&#x27;\\u03bc&#x27;];\\n\\n    \\n    super.generateActiveFixedInds();\\n\\n    \\n    super.generateLocationParamIndex();\\n  }\\n\\n  xMin(params) {\\n    return params[0];\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x &lt; mu) return NaN;\\n    if (x === Infinity) return 0.0;\\n\\n    let expTerm = (Math.pow(x - mu, 2) / 2.0 / Math.pow(sigma, 2));\\n    return Math.exp(-expTerm) / sigma * Math.sqrt(2.0 / Math.PI);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x &lt;= mu) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    return erf((x - mu) / sigma / Math.sqrt(2));\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return mu + sqrt2 * sigma * erfinv(p);\\n  }\\n\\n  defaultXRange(params) {\\n    return [params[0], this.ppf(0.999, params)];\\n  }\\n\\n  quantileSet(x, p, extraParams) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n    let mu = extraParams[0];\\n\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return [[(x1 - mu) / sqrt2 / erfinv(p1)], true];\\n  }\\n}\\n\\n\\n\\nvar dist = new HalfNormalDistribution();\\n\\n\\n\\nlet params = paramsFromSliders(sliders); \\n\\n\\nlet [x1, x2] = dist.defaultXRange(params);\\n\\n\\ntriggerCallbacks.active = false;\\n\\n\\np_p.x_range.start = x1;\\np_p.x_range.end = x2;\\n\\nupdateData(source_p, source_c, p_p, sliders, discrete);\\n\\n\\nsetYRanges(p_p, p_c, source_p);  \\n\\ntriggerCallbacks.active = true;\\n"}}]]]},"x_range":{"id":"p2345"},"y_range":{"type":"object","name":"Range1d","id":"p2346"},"x_scale":{"type":"object","name":"LinearScale","id":"p2331"},"y_scale":{"type":"object","name":"LinearScale","id":"p2332"},"title":{"type":"object","name":"Title","id":"p2324","attributes":{"text":" "}},"renderers":[{"type":"object","name":"GlyphRenderer","id":"p2359","attributes":{"level":"overlay","data_source":{"id":"p2350"},"view":{"type":"object","name":"CDSView","id":"p2360","attributes":{"filter":{"type":"object","name":"AllIndices","id":"p2361"}}},"glyph":{"type":"object","name":"Line","id":"p2356","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_width":2}},"nonselection_glyph":{"type":"object","name":"Line","id":"p2357","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_alpha":0.1,"line_width":2}},"muted_glyph":{"type":"object","name":"Line","id":"p2358","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_alpha":0.2,"line_width":2}}}}],"toolbar":{"type":"object","name":"Toolbar","id":"p2330","attributes":{"tools":[{"type":"object","name":"ResetTool","id":"p2343"},{"type":"object","name":"SaveTool","id":"p2344"}]}},"toolbar_location":null,"left":[{"type":"object","name":"LinearAxis","id":"p2338","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p2339","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p2340"},"axis_label":"CDF","axis_label_text_font_style":"normal","major_label_policy":{"type":"object","name":"AllLabels","id":"p2341"}}}],"below":[{"type":"object","name":"LinearAxis","id":"p2333","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p2334","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p2335"},"axis_label":"y","major_label_policy":{"type":"object","name":"AllLabels","id":"p2336"}}}],"center":[{"type":"object","name":"Grid","id":"p2337","attributes":{"axis":{"id":"p2333"}}},{"type":"object","name":"Grid","id":"p2342","attributes":{"dimension":1,"axis":{"id":"p2338"}}}],"frame_width":300,"frame_height":175,"background_fill_alpha":0,"border_fill_alpha":0}}],["source_p",{"id":"p2347"}],["source_c",{"id":"p2350"}],["discrete",false],["n",400],["sliders",[{"id":"p2372"},{"id":"p2374"}]],["xBoxes",[{"id":"p2379"}]],["pBoxes",[{"id":"p2380"}]],["quantileSetterSwitch",{"id":"p2382"}],["quantileSetterDiv",{"id":"p2381"}],["triggerCallbacks",{"id":"p2383"}],["startBoxes",[{"id":"p2375"},{"id":"p2376"}]],["endBoxes",[{"id":"p2377"},{"id":"p2378"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p\\\\&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nfunction erf(x) {\\n  \\n  var a = [1.00002368,\\n           0.37409196,\\n           0.09678418,\\n           -0.18628806,\\n           0.27886807,\\n           -1.13520398,\\n           1.48851587,\\n           -0.82215223,\\n           0.17087277];\\n\\n  var t = 1 / (1 + Math.abs(x)/2);\\n  var expSum = -Math.pow(x, 2) - 1.26551223;\\n\\n  for (var i = 0; i &lt; a.length; i++) {\\n      expSum += a[i] * Math.pow(t, i+1);\\n  }\\n\\n  var result = 1 - t * Math.exp(expSum);\\n\\n  if (x &lt; 0) return -result;\\n  return result;\\n}\\n\\n\\nfunction erfinv(x) {\\n  \\n  let p = (x + 1.0) / 2.0;\\n\\n  \\n  if (p == 0.0) return -Infinity;\\n  if (p == 1.0) return Infinity;\\n  if (p &gt; 1.0 || p &lt; 0.0) return undefined;\\n\\n  let split1 = 0.425;\\n  let split2 = 5.0;\\n  let const1 = 0.180625;\\n  let const2 = 1.6;\\n\\n  \\n  let a0 = 3.3871327179;\\n  let a1 = 5.0434271938e1;\\n  let a2 = 1.5929113202e2;\\n  let a3 = 5.9109374720e1;\\n  let b1 = 1.7895169469e1;\\n  let b2 = 7.8757757664e1;\\n  let b3 = 6.7187563600e1;\\n\\n  \\n  let c0 = 1.4234372777;\\n  let c1 = 2.7568153900;\\n  let c2 = 1.3067284816;\\n  let c3 = 1.7023821103e-1;\\n  let d1 = 7.3700164250e-1;\\n  let d2 = 1.2021132975e-1;\\n\\n  \\n  let e0 = 6.6579051150;\\n  let e1 = 3.0812263860;\\n  let e2 = 4.2868294337e-1;\\n  let e3 = 1.7337203997e-2;\\n  let f1 = 2.4197894225e-1;\\n  let f2 = 1.2258202635e-2;\\n\\n  let r;\\n  let res;\\n  let q = p - 0.5;\\n\\n  if (Math.abs(q) &lt;= split1) {\\n    r = const1 - q * q;\\n    res = q * (((a3 * r + a2) * r + a1) * r + a0) /\\n              (((b3 * r + b2) * r + b1) * r + 1.0);\\n  } else {\\n    r = q &lt; 0 ? p : 1.0 - p;\\n\\n    r = Math.sqrt(-Math.log(r));\\n\\n    if (r &lt;= split2) {\\n      r -= const2;\\n      res = (((c3 * r + c2) * r + c1) * r + c0) /\\n             ((d2 * r + d1) * r + 1.0);\\n    } else {\\n      r -= split2;\\n      res = (((e3 * r + e2) * r + e1) * r + e0) /\\n             ((f2 * r + f1) * r + 1.0);\\n    }\\n  \\n    if (q &lt; 0) {\\n      res = -res;\\n    }\\n  }\\n\\n  \\n  return 0.7071067811865475 * res;\\n\\n}\\n\\n\\nclass HalfNormalDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;HalfNormal&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.locationParam = &#x27;\\u03bc&#x27;;\\n\\n    \\n    this.paramMin = [-Infinity, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [&#x27;\\u03bc&#x27;];\\n\\n    \\n    super.generateActiveFixedInds();\\n\\n    \\n    super.generateLocationParamIndex();\\n  }\\n\\n  xMin(params) {\\n    return params[0];\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x &lt; mu) return NaN;\\n    if (x === Infinity) return 0.0;\\n\\n    let expTerm = (Math.pow(x - mu, 2) / 2.0 / Math.pow(sigma, 2));\\n    return Math.exp(-expTerm) / sigma * Math.sqrt(2.0 / Math.PI);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x &lt;= mu) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    return erf((x - mu) / sigma / Math.sqrt(2));\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return mu + sqrt2 * sigma * erfinv(p);\\n  }\\n\\n  defaultXRange(params) {\\n    return [params[0], this.ppf(0.999, params)];\\n  }\\n\\n  quantileSet(x, p, extraParams) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n    let mu = extraParams[0];\\n\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return [[(x1 - mu) / sqrt2 / erfinv(p1)], true];\\n  }\\n}\\n\\n\\n\\nvar dist = new HalfNormalDistribution();\\n\\n\\nif (triggerCallbacks.active) {\\n  updateData(source_p, source_c, p_p, sliders, discrete);\\n}"}}]],["change:end",[{"id":"p2385"}]]]},"end":4}},"y_range":{"type":"object","name":"DataRange1d","id":"p2299","attributes":{"start":0.0}},"x_scale":{"type":"object","name":"LinearScale","id":"p2307"},"y_scale":{"type":"object","name":"LinearScale","id":"p2308"},"title":{"type":"object","name":"Title","id":"p2300","attributes":{"text":"Half-Normal"}},"renderers":[{"type":"object","name":"GlyphRenderer","id":"p2368","attributes":{"level":"overlay","data_source":{"id":"p2347"},"view":{"type":"object","name":"CDSView","id":"p2369","attributes":{"filter":{"type":"object","name":"AllIndices","id":"p2370"}}},"glyph":{"type":"object","name":"Line","id":"p2365","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"line_color":"#1f77b4","line_width":2}},"nonselection_glyph":{"type":"object","name":"Line","id":"p2366","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"line_color":"#1f77b4","line_alpha":0.1,"line_width":2}},"muted_glyph":{"type":"object","name":"Line","id":"p2367","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"line_color":"#1f77b4","line_alpha":0.2,"line_width":2}}}}],"toolbar":{"type":"object","name":"Toolbar","id":"p2306","attributes":{"tools":[{"type":"object","name":"ResetTool","id":"p2319"},{"type":"object","name":"SaveTool","id":"p2320"}]}},"toolbar_location":null,"left":[{"type":"object","name":"LinearAxis","id":"p2314","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p2315","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p2316"},"axis_label":"PDF","axis_label_text_font_style":"normal","major_label_policy":{"type":"object","name":"AllLabels","id":"p2317"}}}],"below":[{"type":"object","name":"LinearAxis","id":"p2309","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p2310","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p2311"},"axis_label":"y","major_label_policy":{"type":"object","name":"AllLabels","id":"p2312"}}}],"center":[{"type":"object","name":"Grid","id":"p2313","attributes":{"axis":{"id":"p2309"}}},{"type":"object","name":"Grid","id":"p2318","attributes":{"dimension":1,"axis":{"id":"p2314"}}}],"frame_width":300,"frame_height":175,"background_fill_alpha":0,"border_fill_alpha":0}}],["p_c",{"id":"p2321"}],["source_p",{"id":"p2347"}],["source_c",{"id":"p2350"}],["discrete",false],["n",400],["sliders",[{"id":"p2372"},{"id":"p2374"}]],["xBoxes",[{"id":"p2379"}]],["pBoxes",[{"id":"p2380"}]],["quantileSetterSwitch",{"id":"p2382"}],["quantileSetterDiv",{"id":"p2381"}],["triggerCallbacks",{"id":"p2383"}],["startBoxes",[{"id":"p2375"},{"id":"p2376"}]],["endBoxes",[{"id":"p2377"},{"id":"p2378"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p\\\\&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nfunction erf(x) {\\n  \\n  var a = [1.00002368,\\n           0.37409196,\\n           0.09678418,\\n           -0.18628806,\\n           0.27886807,\\n           -1.13520398,\\n           1.48851587,\\n           -0.82215223,\\n           0.17087277];\\n\\n  var t = 1 / (1 + Math.abs(x)/2);\\n  var expSum = -Math.pow(x, 2) - 1.26551223;\\n\\n  for (var i = 0; i &lt; a.length; i++) {\\n      expSum += a[i] * Math.pow(t, i+1);\\n  }\\n\\n  var result = 1 - t * Math.exp(expSum);\\n\\n  if (x &lt; 0) return -result;\\n  return result;\\n}\\n\\n\\nfunction erfinv(x) {\\n  \\n  let p = (x + 1.0) / 2.0;\\n\\n  \\n  if (p == 0.0) return -Infinity;\\n  if (p == 1.0) return Infinity;\\n  if (p &gt; 1.0 || p &lt; 0.0) return undefined;\\n\\n  let split1 = 0.425;\\n  let split2 = 5.0;\\n  let const1 = 0.180625;\\n  let const2 = 1.6;\\n\\n  \\n  let a0 = 3.3871327179;\\n  let a1 = 5.0434271938e1;\\n  let a2 = 1.5929113202e2;\\n  let a3 = 5.9109374720e1;\\n  let b1 = 1.7895169469e1;\\n  let b2 = 7.8757757664e1;\\n  let b3 = 6.7187563600e1;\\n\\n  \\n  let c0 = 1.4234372777;\\n  let c1 = 2.7568153900;\\n  let c2 = 1.3067284816;\\n  let c3 = 1.7023821103e-1;\\n  let d1 = 7.3700164250e-1;\\n  let d2 = 1.2021132975e-1;\\n\\n  \\n  let e0 = 6.6579051150;\\n  let e1 = 3.0812263860;\\n  let e2 = 4.2868294337e-1;\\n  let e3 = 1.7337203997e-2;\\n  let f1 = 2.4197894225e-1;\\n  let f2 = 1.2258202635e-2;\\n\\n  let r;\\n  let res;\\n  let q = p - 0.5;\\n\\n  if (Math.abs(q) &lt;= split1) {\\n    r = const1 - q * q;\\n    res = q * (((a3 * r + a2) * r + a1) * r + a0) /\\n              (((b3 * r + b2) * r + b1) * r + 1.0);\\n  } else {\\n    r = q &lt; 0 ? p : 1.0 - p;\\n\\n    r = Math.sqrt(-Math.log(r));\\n\\n    if (r &lt;= split2) {\\n      r -= const2;\\n      res = (((c3 * r + c2) * r + c1) * r + c0) /\\n             ((d2 * r + d1) * r + 1.0);\\n    } else {\\n      r -= split2;\\n      res = (((e3 * r + e2) * r + e1) * r + e0) /\\n             ((f2 * r + f1) * r + 1.0);\\n    }\\n  \\n    if (q &lt; 0) {\\n      res = -res;\\n    }\\n  }\\n\\n  \\n  return 0.7071067811865475 * res;\\n\\n}\\n\\n\\nclass HalfNormalDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;HalfNormal&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.locationParam = &#x27;\\u03bc&#x27;;\\n\\n    \\n    this.paramMin = [-Infinity, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [&#x27;\\u03bc&#x27;];\\n\\n    \\n    super.generateActiveFixedInds();\\n\\n    \\n    super.generateLocationParamIndex();\\n  }\\n\\n  xMin(params) {\\n    return params[0];\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x &lt; mu) return NaN;\\n    if (x === Infinity) return 0.0;\\n\\n    let expTerm = (Math.pow(x - mu, 2) / 2.0 / Math.pow(sigma, 2));\\n    return Math.exp(-expTerm) / sigma * Math.sqrt(2.0 / Math.PI);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x &lt;= mu) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    return erf((x - mu) / sigma / Math.sqrt(2));\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let [mu, sigma] = params.slice(0, 2);\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return mu + sqrt2 * sigma * erfinv(p);\\n  }\\n\\n  defaultXRange(params) {\\n    return [params[0], this.ppf(0.999, params)];\\n  }\\n\\n  quantileSet(x, p, extraParams) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n    let mu = extraParams[0];\\n\\n    let sqrt2 = 1.4142135623730951;\\n\\n    return [[(x1 - mu) / sqrt2 / erfinv(p1)], true];\\n  }\\n}\\n\\n\\n\\nvar dist = new HalfNormalDistribution();\\n\\n\\n\\nif (cb_obj.active) {\\n  for (let i = 0; i &lt; sliders.length; i++) {\\n    if (!dist.fixedParamsInds.includes(i)) {\\n      sliders[i].title = dist.paramNames[i] + &#x27; (computed)&#x27;;\\n      sliders[i].disabled = true;\\n    }\\n  }\\n  for (let xBox of xBoxes) {\\n    xBox.disabled = false;\\n  }\\n  for (let pBox of pBoxes) {\\n    pBox.disabled = false;\\n  }\\n} else {\\n  for (let i = 0; i &lt; sliders.length; i++) {\\n    if (!dist.fixedParamsInds.includes(i)) {\\n      sliders[i].title = dist.paramNames[i];\\n      sliders[i].disabled = false;\\n    }\\n  }\\n  for (let xBox of xBoxes) {\\n    xBox.disabled = true;\\n  }\\n  for (let pBox of pBoxes) {\\n    pBox.disabled = true;\\n  }\\n  quantileSetterDiv.text = &#x27;&#x27;;\\n}"}}]]]}}}]}},{"type":"object","name":"Spacer","id":"p2424","attributes":{"width":10}},{"id":"p2381"}]}},{"type":"object","name":"Spacer","id":"p2426","attributes":{"height":10}},{"type":"object","name":"Row","id":"p2428","attributes":{"children":[{"type":"object","name":"Column","id":"p2416","attributes":{"children":[{"type":"object","name":"Row","id":"p2414","attributes":{"children":[{"type":"object","name":"Column","id":"p2407","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2406","attributes":{"height":4}},{"id":"p2375"}]}},{"id":"p2372"},{"type":"object","name":"Column","id":"p2409","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2408","attributes":{"height":4}},{"id":"p2377"}]}}]}},{"type":"object","name":"Row","id":"p2415","attributes":{"children":[{"type":"object","name":"Column","id":"p2411","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2410","attributes":{"height":4}},{"id":"p2376"}]}},{"id":"p2374"},{"type":"object","name":"Column","id":"p2413","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2412","attributes":{"height":4}},{"id":"p2378"}]}}]}}]}},{"type":"object","name":"Spacer","id":"p2427","attributes":{"width":20}},{"type":"object","name":"Column","id":"p2405","attributes":{"children":[{"type":"object","name":"Row","id":"p2404","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2396","attributes":{"width":20}},{"type":"object","name":"Column","id":"p2399","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2397","attributes":{"height":7}},{"type":"object","name":"Div","id":"p2398","attributes":{"text":"&lt;p&gt;&lt;b&gt;y: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p2379"},{"type":"object","name":"Spacer","id":"p2400","attributes":{"width":16}},{"type":"object","name":"Column","id":"p2403","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2401","attributes":{"height":7}},{"type":"object","name":"Div","id":"p2402","attributes":{"text":"&lt;p&gt;&lt;b&gt;quantile: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p2380"}]}}]}}]}},{"type":"object","name":"Spacer","id":"p2429","attributes":{"height":10}},{"type":"object","name":"GridPlot","id":"p2421","attributes":{"rows":null,"cols":null,"toolbar":{"type":"object","name":"Toolbar","id":"p2420","attributes":{"tools":[{"type":"object","name":"ToolProxy","id":"p2418","attributes":{"tools":[{"id":"p2343"},{"id":"p2319"},{"id":"p2343"},{"id":"p2319"}]}},{"type":"object","name":"SaveTool","id":"p2419"}]}},"toolbar_location":"right","children":[[{"id":"p2297"},0,0],[{"type":"object","name":"Spacer","id":"p2417","attributes":{"width":30}},0,1],[{"id":"p2321"},0,2]]}}]}}]}}';
                  const render_items = [{"docid":"2a1a1bda-4646-4a29-beb6-8e6c3b386297","roots":{"p2430":"ee770fb9-52eb-44d8-9ea4-476719f4e717"},"root_ids":["p2430"]}];
                  root.Bokeh.embed.embed_items(docs_json, render_items);
                  }
                  if (root.Bokeh !== undefined) {
                    embed_document(root);
                  } else {
                    let attempts = 0;
                    const timer = setInterval(function(root) {
                      if (root.Bokeh !== undefined) {
                        clearInterval(timer);
                        embed_document(root);
                      } else {
                        attempts++;
                        if (attempts > 100) {
                          clearInterval(timer);
                          console.log("Bokeh: ERROR: Unable to run BokehJS code because BokehJS library is missing");
                        }
                      }
                    }, 10, root)
                  }
                })(window);
              });
            };
            if (document.readyState != "loading") fn();
            else document.addEventListener("DOMContentLoaded", fn);
          })();
        },
    function(Bokeh) {
        }
      ];
    
      function run_inline_js() {
        for (let i = 0; i < inline_js.length; i++) {
          inline_js[i].call(root, root.Bokeh);
        }
      }
    
      if (root._bokeh_is_loading === 0) {
        console.debug("Bokeh: BokehJS loaded, going straight to plotting");
        run_inline_js();
      } else {
        load_libs(css_urls, js_urls, function() {
          console.debug("Bokeh: BokehJS plotting callback run at", now());
          run_inline_js();
        });
      }
    }(window));
  };
  if (document.readyState != "loading") fn();
  else document.addEventListener("DOMContentLoaded", fn);
})();