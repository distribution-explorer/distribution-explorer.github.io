(function() {
  const fn = function() {
    'use strict';
    (function(root) {
      function now() {
        return new Date();
      }
    
      const force = false;
    
      if (typeof root._bokeh_onload_callbacks === "undefined" || force === true) {
        root._bokeh_onload_callbacks = [];
        root._bokeh_is_loading = undefined;
      }
    
    
    const element = document.getElementById("d62057f0-d05d-4283-b94b-930f3260e389");
        if (element == null) {
          console.warn("Bokeh: autoload.js configured with elementid 'd62057f0-d05d-4283-b94b-930f3260e389' but no matching script tag was found.")
        }
      function run_callbacks() {
        try {
          root._bokeh_onload_callbacks.forEach(function(callback) {
            if (callback != null)
              callback();
          });
        } finally {
          delete root._bokeh_onload_callbacks
        }
        console.debug("Bokeh: all callbacks have finished");
      }
    
      function load_libs(css_urls, js_urls, callback) {
        if (css_urls == null) css_urls = [];
        if (js_urls == null) js_urls = [];
    
        root._bokeh_onload_callbacks.push(callback);
        if (root._bokeh_is_loading > 0) {
          console.debug("Bokeh: BokehJS is being loaded, scheduling callback at", now());
          return null;
        }
        if (js_urls == null || js_urls.length === 0) {
          run_callbacks();
          return null;
        }
        console.debug("Bokeh: BokehJS not loaded, scheduling load and callback at", now());
        root._bokeh_is_loading = css_urls.length + js_urls.length;
    
        function on_load() {
          root._bokeh_is_loading--;
          if (root._bokeh_is_loading === 0) {
            console.debug("Bokeh: all BokehJS libraries/stylesheets loaded");
            run_callbacks()
          }
        }
    
        function on_error(url) {
          console.error("failed to load " + url);
        }
    
        for (let i = 0; i < css_urls.length; i++) {
          const url = css_urls[i];
          const element = document.createElement("link");
          element.onload = on_load;
          element.onerror = on_error.bind(null, url);
          element.rel = "stylesheet";
          element.type = "text/css";
          element.href = url;
          console.debug("Bokeh: injecting link tag for BokehJS stylesheet: ", url);
          document.body.appendChild(element);
        }
    
        for (let i = 0; i < js_urls.length; i++) {
          const url = js_urls[i];
          const element = document.createElement('script');
          element.onload = on_load;
          element.onerror = on_error.bind(null, url);
          element.async = false;
          element.src = url;
          console.debug("Bokeh: injecting script tag for BokehJS library: ", url);
          document.head.appendChild(element);
        }
      };
    
      function inject_raw_css(css) {
        const element = document.createElement("style");
        element.appendChild(document.createTextNode(css));
        document.body.appendChild(element);
      }
    
      const js_urls = ["https://cdn.bokeh.org/bokeh/release/bokeh-3.4.1.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-gl-3.4.1.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-widgets-3.4.1.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-tables-3.4.1.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-mathjax-3.4.1.min.js"];
      const css_urls = [];
    
      const inline_js = [    function(Bokeh) {
          Bokeh.set_log_level("info");
        },
        function(Bokeh) {
          (function() {
            const fn = function() {
              Bokeh.safely(function() {
                (function(root) {
                  function embed_document(root) {
                  const docs_json = '{"6cb3378b-c11b-4922-bcba-e2a8d16dd5df":{"version":"3.4.1","title":"Bokeh Application","roots":[{"type":"object","name":"Column","id":"p3667","attributes":{"children":[{"type":"object","name":"Row","id":"p3662","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3660","attributes":{"width":409}},{"type":"object","name":"Row","id":"p3623","attributes":{"children":[{"type":"object","name":"Div","id":"p3621","attributes":{"text":"&lt;p&gt;&lt;b&gt;Quantile setter mode&lt;/b&gt;&lt;/p&gt;"}},{"type":"object","name":"Spacer","id":"p3622","attributes":{"width":2}},{"type":"object","name":"Switch","id":"p3610","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:active",[{"type":"object","name":"CustomJS","id":"p3614","attributes":{"args":{"type":"map","entries":[["p_p",{"type":"object","name":"Figure","id":"p3523","attributes":{"x_range":{"type":"object","name":"Range1d","id":"p3571","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:start",[{"type":"object","name":"CustomJS","id":"p3613","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p3523"}],["p_c",{"type":"object","name":"Figure","id":"p3547","attributes":{"js_event_callbacks":{"type":"map","entries":[["reset",[{"type":"object","name":"CustomJS","id":"p3616","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p3523"}],["p_c",{"id":"p3547"}],["source_p",{"type":"object","name":"ColumnDataSource","id":"p3573","attributes":{"selected":{"type":"object","name":"Selection","id":"p3574","attributes":{"indices":[],"line_indices":[]}},"selection_policy":{"type":"object","name":"UnionRenderers","id":"p3575"},"data":{"type":"map","entries":[["x",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}],["y_p",{"type":"ndarray","array":{"type":"bytes","data":"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACamZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/mpmZmZmZuT+amZmZmZm5P5qZmZmZmbk/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="},"shape":[400],"dtype":"float64","order":"little"}]]}}}],["source_c",{"type":"object","name":"ColumnDataSource","id":"p3576","attributes":{"selected":{"type":"object","name":"Selection","id":"p3577","attributes":{"indices":[],"line_indices":[]}},"selection_policy":{"type":"object","name":"UnionRenderers","id":"p3578"},"data":{"type":"map","entries":[["x",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}],["y_c",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}]]}}}],["discrete",false],["n",400],["sliders",[{"type":"object","name":"Slider","id":"p3598","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p3612","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p3523"}],["p_c",{"id":"p3547"}],["source_p",{"id":"p3573"}],["source_c",{"id":"p3576"}],["discrete",false],["n",400],["sliders",[{"id":"p3598"},{"type":"object","name":"Slider","id":"p3600","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p3612"}]]]},"width":200,"title":"\\u03b2","format":{"type":"object","name":"CustomJSTickFormatter","id":"p3599","attributes":{"code":"return tick.toPrecision(4)"}},"start":0,"end":10,"value":10,"step":0.01}}]],["xBoxes",[{"type":"object","name":"TextInput","id":"p3605","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p3615","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p3523"}],["p_c",{"id":"p3547"}],["source_p",{"id":"p3573"}],["source_c",{"id":"p3576"}],["discrete",false],["n",400],["sliders",[{"id":"p3598"},{"id":"p3600"}]],["xBoxes",[{"id":"p3605"},{"type":"object","name":"TextInput","id":"p3606","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p3615"}]]]},"disabled":true,"width":80,"value":"9.7500"}}]],["pBoxes",[{"type":"object","name":"TextInput","id":"p3607","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p3615"}]]]},"disabled":true,"width":80,"value":"0.0250"}},{"type":"object","name":"TextInput","id":"p3608","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p3615"}]]]},"disabled":true,"width":80,"value":"0.9750"}}]],["quantileSetterSwitch",{"id":"p3610"}],["quantileSetterDiv",{"type":"object","name":"Div","id":"p3609"}],["triggerCallbacks",{"type":"object","name":"Switch","id":"p3611","attributes":{"active":true}}],["startBoxes",[{"type":"object","name":"TextInput","id":"p3601","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p3617","attributes":{"args":{"type":"map","entries":[["minValue","-Infinity"],["maxValue","Infinity"],["slider",{"id":"p3598"}]]},"code":"\\n\\nslider.start = Math.max(minValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"0"}},{"type":"object","name":"TextInput","id":"p3602","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p3619","attributes":{"args":{"type":"map","entries":[["minValue","-Infinity"],["maxValue","Infinity"],["slider",{"id":"p3600"}]]},"code":"\\n\\nslider.start = Math.max(minValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"0"}}]],["endBoxes",[{"type":"object","name":"TextInput","id":"p3603","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p3618","attributes":{"args":{"type":"map","entries":[["minValue","-Infinity"],["maxValue","Infinity"],["slider",{"id":"p3598"}]]},"code":"\\n\\nslider.end = Math.min(maxValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"10"}},{"type":"object","name":"TextInput","id":"p3604","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p3620","attributes":{"args":{"type":"map","entries":[["minValue","-Infinity"],["maxValue","Infinity"],["slider",{"id":"p3600"}]]},"code":"\\n\\nslider.end = Math.min(maxValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"10"}}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nclass UniformDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Uniform&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03b1&#x27;, &#x27;\\u03b2&#x27;];\\n\\n    \\n    this.paramMin = [-Infinity, -Infinity];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return params[0];    \\n  }\\n\\n  xMax(params) {\\n    return params[1];    \\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let [alpha, beta] = params.slice(0, 2);\\n    \\n    if (beta &lt;= alpha || x &lt; alpha || x &gt; beta) return NaN;\\n\\n    return 1.0 / (beta - alpha);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    if (beta &lt;= alpha) return NaN;\\n\\n    if (x &lt;= alpha) return 0.0;\\n    if (x &gt;= beta) return 1.0;\\n\\n    return (x - alpha) / (beta - alpha);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    if (beta &lt;= alpha) return NaN;\\n\\n    return alpha + p * (beta - alpha);\\n  }\\n\\n  defaultXRange(params) {\\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    if (beta &lt;= alpha) return [0, 1];\\n\\n    let d = beta - alpha;\\n    \\n    return[alpha - d * 0.1, beta + d * 0.1];\\n  }\\n\\n  quantileSet(x, p, extraParams = []) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    let alpha = (p2 * x1 - p1 * x2) / (p2 - p1);\\n    let beta = alpha + (x2 - x1) / (p2 - p1);\\n\\n    return [[alpha, beta], true];\\n  }\\n}\\n\\n\\n\\nvar dist = new UniformDistribution();\\n\\n\\n\\nif (quantileSetterSwitch.active) {\\n  quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p);\\n}"}}]]]},"disabled":true,"width":80,"value":"0.2500"}},{"id":"p3606"}]],["pBoxes",[{"id":"p3607"},{"id":"p3608"}]],["quantileSetterSwitch",{"id":"p3610"}],["quantileSetterDiv",{"id":"p3609"}],["triggerCallbacks",{"id":"p3611"}],["startBoxes",[{"id":"p3601"},{"id":"p3602"}]],["endBoxes",[{"id":"p3603"},{"id":"p3604"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nclass UniformDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Uniform&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03b1&#x27;, &#x27;\\u03b2&#x27;];\\n\\n    \\n    this.paramMin = [-Infinity, -Infinity];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return params[0];    \\n  }\\n\\n  xMax(params) {\\n    return params[1];    \\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let [alpha, beta] = params.slice(0, 2);\\n    \\n    if (beta &lt;= alpha || x &lt; alpha || x &gt; beta) return NaN;\\n\\n    return 1.0 / (beta - alpha);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    if (beta &lt;= alpha) return NaN;\\n\\n    if (x &lt;= alpha) return 0.0;\\n    if (x &gt;= beta) return 1.0;\\n\\n    return (x - alpha) / (beta - alpha);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    if (beta &lt;= alpha) return NaN;\\n\\n    return alpha + p * (beta - alpha);\\n  }\\n\\n  defaultXRange(params) {\\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    if (beta &lt;= alpha) return [0, 1];\\n\\n    let d = beta - alpha;\\n    \\n    return[alpha - d * 0.1, beta + d * 0.1];\\n  }\\n\\n  quantileSet(x, p, extraParams = []) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    let alpha = (p2 * x1 - p1 * x2) / (p2 - p1);\\n    let beta = alpha + (x2 - x1) / (p2 - p1);\\n\\n    return [[alpha, beta], true];\\n  }\\n}\\n\\n\\n\\nvar dist = new UniformDistribution();\\n\\n\\n\\nif (triggerCallbacks.active &amp;&amp; !cb_obj.disabled) {\\n\\tif (quantileSetterSwitch.active) {\\n\\t\\tquantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p);\\n\\t}\\n\\telse {\\n\\t\\tupdateData(source_p, source_c, p_p, sliders, discrete);\\n\\t\\tupdateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes);\\n\\t}\\n}"}}]]]},"width":200,"title":"\\u03b1","format":{"type":"object","name":"CustomJSTickFormatter","id":"p3597","attributes":{"code":"return tick.toPrecision(4)"}},"start":0,"end":10,"value":0,"step":0.01}},{"id":"p3600"}]],["xBoxes",[{"id":"p3605"},{"id":"p3606"}]],["pBoxes",[{"id":"p3607"},{"id":"p3608"}]],["quantileSetterSwitch",{"id":"p3610"}],["quantileSetterDiv",{"id":"p3609"}],["triggerCallbacks",{"id":"p3611"}],["startBoxes",[{"id":"p3601"},{"id":"p3602"}]],["endBoxes",[{"id":"p3603"},{"id":"p3604"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nclass UniformDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Uniform&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03b1&#x27;, &#x27;\\u03b2&#x27;];\\n\\n    \\n    this.paramMin = [-Infinity, -Infinity];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return params[0];    \\n  }\\n\\n  xMax(params) {\\n    return params[1];    \\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let [alpha, beta] = params.slice(0, 2);\\n    \\n    if (beta &lt;= alpha || x &lt; alpha || x &gt; beta) return NaN;\\n\\n    return 1.0 / (beta - alpha);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    if (beta &lt;= alpha) return NaN;\\n\\n    if (x &lt;= alpha) return 0.0;\\n    if (x &gt;= beta) return 1.0;\\n\\n    return (x - alpha) / (beta - alpha);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    if (beta &lt;= alpha) return NaN;\\n\\n    return alpha + p * (beta - alpha);\\n  }\\n\\n  defaultXRange(params) {\\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    if (beta &lt;= alpha) return [0, 1];\\n\\n    let d = beta - alpha;\\n    \\n    return[alpha - d * 0.1, beta + d * 0.1];\\n  }\\n\\n  quantileSet(x, p, extraParams = []) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    let alpha = (p2 * x1 - p1 * x2) / (p2 - p1);\\n    let beta = alpha + (x2 - x1) / (p2 - p1);\\n\\n    return [[alpha, beta], true];\\n  }\\n}\\n\\n\\n\\nvar dist = new UniformDistribution();\\n\\n\\n\\nlet params = paramsFromSliders(sliders); \\n\\n\\nlet [x1, x2] = dist.defaultXRange(params);\\n\\n\\ntriggerCallbacks.active = false;\\n\\n\\np_p.x_range.start = x1;\\np_p.x_range.end = x2;\\n\\nupdateData(source_p, source_c, p_p, sliders, discrete);\\n\\n\\nsetYRanges(p_p, p_c, source_p);  \\n\\ntriggerCallbacks.active = true;\\n"}}]]]},"x_range":{"id":"p3571"},"y_range":{"type":"object","name":"Range1d","id":"p3572"},"x_scale":{"type":"object","name":"LinearScale","id":"p3557"},"y_scale":{"type":"object","name":"LinearScale","id":"p3558"},"title":{"type":"object","name":"Title","id":"p3550","attributes":{"text":" "}},"renderers":[{"type":"object","name":"GlyphRenderer","id":"p3585","attributes":{"level":"overlay","data_source":{"id":"p3576"},"view":{"type":"object","name":"CDSView","id":"p3586","attributes":{"filter":{"type":"object","name":"AllIndices","id":"p3587"}}},"glyph":{"type":"object","name":"Line","id":"p3582","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_width":2}},"nonselection_glyph":{"type":"object","name":"Line","id":"p3583","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_alpha":0.1,"line_width":2}},"muted_glyph":{"type":"object","name":"Line","id":"p3584","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_alpha":0.2,"line_width":2}}}}],"toolbar":{"type":"object","name":"Toolbar","id":"p3556","attributes":{"tools":[{"type":"object","name":"ResetTool","id":"p3569"},{"type":"object","name":"SaveTool","id":"p3570"}]}},"toolbar_location":null,"left":[{"type":"object","name":"LinearAxis","id":"p3564","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p3565","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p3566"},"axis_label":"CDF","axis_label_text_font_style":"normal","major_label_policy":{"type":"object","name":"AllLabels","id":"p3567"}}}],"below":[{"type":"object","name":"LinearAxis","id":"p3559","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p3560","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p3561"},"axis_label":"y","major_label_policy":{"type":"object","name":"AllLabels","id":"p3562"}}}],"center":[{"type":"object","name":"Grid","id":"p3563","attributes":{"axis":{"id":"p3559"}}},{"type":"object","name":"Grid","id":"p3568","attributes":{"dimension":1,"axis":{"id":"p3564"}}}],"frame_width":300,"frame_height":175,"background_fill_alpha":0,"border_fill_alpha":0}}],["source_p",{"id":"p3573"}],["source_c",{"id":"p3576"}],["discrete",false],["n",400],["sliders",[{"id":"p3598"},{"id":"p3600"}]],["xBoxes",[{"id":"p3605"},{"id":"p3606"}]],["pBoxes",[{"id":"p3607"},{"id":"p3608"}]],["quantileSetterSwitch",{"id":"p3610"}],["quantileSetterDiv",{"id":"p3609"}],["triggerCallbacks",{"id":"p3611"}],["startBoxes",[{"id":"p3601"},{"id":"p3602"}]],["endBoxes",[{"id":"p3603"},{"id":"p3604"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nclass UniformDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Uniform&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03b1&#x27;, &#x27;\\u03b2&#x27;];\\n\\n    \\n    this.paramMin = [-Infinity, -Infinity];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return params[0];    \\n  }\\n\\n  xMax(params) {\\n    return params[1];    \\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let [alpha, beta] = params.slice(0, 2);\\n    \\n    if (beta &lt;= alpha || x &lt; alpha || x &gt; beta) return NaN;\\n\\n    return 1.0 / (beta - alpha);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    if (beta &lt;= alpha) return NaN;\\n\\n    if (x &lt;= alpha) return 0.0;\\n    if (x &gt;= beta) return 1.0;\\n\\n    return (x - alpha) / (beta - alpha);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    if (beta &lt;= alpha) return NaN;\\n\\n    return alpha + p * (beta - alpha);\\n  }\\n\\n  defaultXRange(params) {\\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    if (beta &lt;= alpha) return [0, 1];\\n\\n    let d = beta - alpha;\\n    \\n    return[alpha - d * 0.1, beta + d * 0.1];\\n  }\\n\\n  quantileSet(x, p, extraParams = []) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    let alpha = (p2 * x1 - p1 * x2) / (p2 - p1);\\n    let beta = alpha + (x2 - x1) / (p2 - p1);\\n\\n    return [[alpha, beta], true];\\n  }\\n}\\n\\n\\n\\nvar dist = new UniformDistribution();\\n\\n\\nif (triggerCallbacks.active) {\\n  updateData(source_p, source_c, p_p, sliders, discrete);\\n}"}}]],["change:end",[{"id":"p3613"}]]]},"start":-1,"end":11}},"y_range":{"type":"object","name":"DataRange1d","id":"p3525","attributes":{"start":0.0}},"x_scale":{"type":"object","name":"LinearScale","id":"p3533"},"y_scale":{"type":"object","name":"LinearScale","id":"p3534"},"title":{"type":"object","name":"Title","id":"p3526","attributes":{"text":"Uniform"}},"renderers":[{"type":"object","name":"GlyphRenderer","id":"p3594","attributes":{"level":"overlay","data_source":{"id":"p3573"},"view":{"type":"object","name":"CDSView","id":"p3595","attributes":{"filter":{"type":"object","name":"AllIndices","id":"p3596"}}},"glyph":{"type":"object","name":"Line","id":"p3591","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"line_color":"#1f77b4","line_width":2}},"nonselection_glyph":{"type":"object","name":"Line","id":"p3592","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"line_color":"#1f77b4","line_alpha":0.1,"line_width":2}},"muted_glyph":{"type":"object","name":"Line","id":"p3593","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"line_color":"#1f77b4","line_alpha":0.2,"line_width":2}}}}],"toolbar":{"type":"object","name":"Toolbar","id":"p3532","attributes":{"tools":[{"type":"object","name":"ResetTool","id":"p3545"},{"type":"object","name":"SaveTool","id":"p3546"}]}},"toolbar_location":null,"left":[{"type":"object","name":"LinearAxis","id":"p3540","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p3541","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p3542"},"axis_label":"PDF","axis_label_text_font_style":"normal","major_label_policy":{"type":"object","name":"AllLabels","id":"p3543"}}}],"below":[{"type":"object","name":"LinearAxis","id":"p3535","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p3536","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p3537"},"axis_label":"y","major_label_policy":{"type":"object","name":"AllLabels","id":"p3538"}}}],"center":[{"type":"object","name":"Grid","id":"p3539","attributes":{"axis":{"id":"p3535"}}},{"type":"object","name":"Grid","id":"p3544","attributes":{"dimension":1,"axis":{"id":"p3540"}}}],"frame_width":300,"frame_height":175,"background_fill_alpha":0,"border_fill_alpha":0}}],["p_c",{"id":"p3547"}],["source_p",{"id":"p3573"}],["source_c",{"id":"p3576"}],["discrete",false],["n",400],["sliders",[{"id":"p3598"},{"id":"p3600"}]],["xBoxes",[{"id":"p3605"},{"id":"p3606"}]],["pBoxes",[{"id":"p3607"},{"id":"p3608"}]],["quantileSetterSwitch",{"id":"p3610"}],["quantileSetterDiv",{"id":"p3609"}],["triggerCallbacks",{"id":"p3611"}],["startBoxes",[{"id":"p3601"},{"id":"p3602"}]],["endBoxes",[{"id":"p3603"},{"id":"p3604"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nclass UniformDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Uniform&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03b1&#x27;, &#x27;\\u03b2&#x27;];\\n\\n    \\n    this.paramMin = [-Infinity, -Infinity];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return params[0];    \\n  }\\n\\n  xMax(params) {\\n    return params[1];    \\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let [alpha, beta] = params.slice(0, 2);\\n    \\n    if (beta &lt;= alpha || x &lt; alpha || x &gt; beta) return NaN;\\n\\n    return 1.0 / (beta - alpha);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    if (beta &lt;= alpha) return NaN;\\n\\n    if (x &lt;= alpha) return 0.0;\\n    if (x &gt;= beta) return 1.0;\\n\\n    return (x - alpha) / (beta - alpha);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    if (beta &lt;= alpha) return NaN;\\n\\n    return alpha + p * (beta - alpha);\\n  }\\n\\n  defaultXRange(params) {\\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    if (beta &lt;= alpha) return [0, 1];\\n\\n    let d = beta - alpha;\\n    \\n    return[alpha - d * 0.1, beta + d * 0.1];\\n  }\\n\\n  quantileSet(x, p, extraParams = []) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    let alpha = (p2 * x1 - p1 * x2) / (p2 - p1);\\n    let beta = alpha + (x2 - x1) / (p2 - p1);\\n\\n    return [[alpha, beta], true];\\n  }\\n}\\n\\n\\n\\nvar dist = new UniformDistribution();\\n\\n\\n\\nif (cb_obj.active) {\\n  for (let i = 0; i &lt; sliders.length; i++) {\\n    if (!dist.fixedParamsInds.includes(i)) {\\n      sliders[i].title = dist.paramNames[i] + &#x27; (computed)&#x27;;\\n      sliders[i].disabled = true;\\n    }\\n  }\\n  for (let xBox of xBoxes) {\\n    xBox.disabled = false;\\n  }\\n  for (let pBox of pBoxes) {\\n    pBox.disabled = false;\\n  }\\n} else {\\n  for (let i = 0; i &lt; sliders.length; i++) {\\n    if (!dist.fixedParamsInds.includes(i)) {\\n      sliders[i].title = dist.paramNames[i];\\n      sliders[i].disabled = false;\\n    }\\n  }\\n  for (let xBox of xBoxes) {\\n    xBox.disabled = true;\\n  }\\n  for (let pBox of pBoxes) {\\n    pBox.disabled = true;\\n  }\\n  quantileSetterDiv.text = &#x27;&#x27;;\\n}"}}]]]}}}]}},{"type":"object","name":"Spacer","id":"p3661","attributes":{"width":10}},{"id":"p3609"}]}},{"type":"object","name":"Spacer","id":"p3663","attributes":{"height":10}},{"type":"object","name":"Row","id":"p3665","attributes":{"children":[{"type":"object","name":"Column","id":"p3653","attributes":{"children":[{"type":"object","name":"Row","id":"p3651","attributes":{"children":[{"type":"object","name":"Column","id":"p3644","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3643","attributes":{"height":4}},{"id":"p3601"}]}},{"id":"p3598"},{"type":"object","name":"Column","id":"p3646","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3645","attributes":{"height":4}},{"id":"p3603"}]}}]}},{"type":"object","name":"Row","id":"p3652","attributes":{"children":[{"type":"object","name":"Column","id":"p3648","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3647","attributes":{"height":4}},{"id":"p3602"}]}},{"id":"p3600"},{"type":"object","name":"Column","id":"p3650","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3649","attributes":{"height":4}},{"id":"p3604"}]}}]}}]}},{"type":"object","name":"Spacer","id":"p3664","attributes":{"width":20}},{"type":"object","name":"Column","id":"p3642","attributes":{"children":[{"type":"object","name":"Row","id":"p3640","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3624","attributes":{"width":20}},{"type":"object","name":"Column","id":"p3627","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3625","attributes":{"height":7}},{"type":"object","name":"Div","id":"p3626","attributes":{"text":"&lt;p&gt;&lt;b&gt;lower y: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p3605"},{"type":"object","name":"Spacer","id":"p3628","attributes":{"width":34}},{"type":"object","name":"Column","id":"p3631","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3629","attributes":{"height":7}},{"type":"object","name":"Div","id":"p3630","attributes":{"text":"&lt;p&gt;&lt;b&gt;upper y: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p3606"}]}},{"type":"object","name":"Row","id":"p3641","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3632","attributes":{"width":16}},{"type":"object","name":"Column","id":"p3635","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3633","attributes":{"height":7}},{"type":"object","name":"Div","id":"p3634","attributes":{"text":"&lt;p&gt;&lt;b&gt;quantile: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p3607"},{"type":"object","name":"Spacer","id":"p3636","attributes":{"width":30}},{"type":"object","name":"Column","id":"p3639","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3637","attributes":{"height":7}},{"type":"object","name":"Div","id":"p3638","attributes":{"text":"&lt;p&gt;&lt;b&gt;quantile: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p3608"}]}}]}}]}},{"type":"object","name":"Spacer","id":"p3666","attributes":{"height":10}},{"type":"object","name":"GridPlot","id":"p3658","attributes":{"rows":null,"cols":null,"toolbar":{"type":"object","name":"Toolbar","id":"p3657","attributes":{"tools":[{"type":"object","name":"ToolProxy","id":"p3655","attributes":{"tools":[{"id":"p3569"},{"id":"p3545"},{"id":"p3569"},{"id":"p3545"}]}},{"type":"object","name":"SaveTool","id":"p3656"}]}},"toolbar_location":"right","children":[[{"id":"p3523"},0,0],[{"type":"object","name":"Spacer","id":"p3654","attributes":{"width":30}},0,1],[{"id":"p3547"},0,2]]}}]}}]}}';
                  const render_items = [{"docid":"6cb3378b-c11b-4922-bcba-e2a8d16dd5df","roots":{"p3667":"d62057f0-d05d-4283-b94b-930f3260e389"},"root_ids":["p3667"]}];
                  root.Bokeh.embed.embed_items(docs_json, render_items);
                  }
                  if (root.Bokeh !== undefined) {
                    embed_document(root);
                  } else {
                    let attempts = 0;
                    const timer = setInterval(function(root) {
                      if (root.Bokeh !== undefined) {
                        clearInterval(timer);
                        embed_document(root);
                      } else {
                        attempts++;
                        if (attempts > 100) {
                          clearInterval(timer);
                          console.log("Bokeh: ERROR: Unable to run BokehJS code because BokehJS library is missing");
                        }
                      }
                    }, 10, root)
                  }
                })(window);
              });
            };
            if (document.readyState != "loading") fn();
            else document.addEventListener("DOMContentLoaded", fn);
          })();
        },
    function(Bokeh) {
        }
      ];
    
      function run_inline_js() {
        for (let i = 0; i < inline_js.length; i++) {
          inline_js[i].call(root, root.Bokeh);
        }
      }
    
      if (root._bokeh_is_loading === 0) {
        console.debug("Bokeh: BokehJS loaded, going straight to plotting");
        run_inline_js();
      } else {
        load_libs(css_urls, js_urls, function() {
          console.debug("Bokeh: BokehJS plotting callback run at", now());
          run_inline_js();
        });
      }
    }(window));
  };
  if (document.readyState != "loading") fn();
  else document.addEventListener("DOMContentLoaded", fn);
})();