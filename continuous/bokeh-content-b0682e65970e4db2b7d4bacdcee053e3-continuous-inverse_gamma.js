(function() {
  const fn = function() {
    'use strict';
    (function(root) {
      function now() {
        return new Date();
      }
    
      const force = false;
    
      if (typeof root._bokeh_onload_callbacks === "undefined" || force === true) {
        root._bokeh_onload_callbacks = [];
        root._bokeh_is_loading = undefined;
      }
    
    
    const element = document.getElementById("c9cbdd8c-7cd0-482a-8d0c-df2d3b6999d3");
        if (element == null) {
          console.warn("Bokeh: autoload.js configured with elementid 'c9cbdd8c-7cd0-482a-8d0c-df2d3b6999d3' but no matching script tag was found.")
        }
      function run_callbacks() {
        try {
          root._bokeh_onload_callbacks.forEach(function(callback) {
            if (callback != null)
              callback();
          });
        } finally {
          delete root._bokeh_onload_callbacks
        }
        console.debug("Bokeh: all callbacks have finished");
      }
    
      function load_libs(css_urls, js_urls, callback) {
        if (css_urls == null) css_urls = [];
        if (js_urls == null) js_urls = [];
    
        root._bokeh_onload_callbacks.push(callback);
        if (root._bokeh_is_loading > 0) {
          console.debug("Bokeh: BokehJS is being loaded, scheduling callback at", now());
          return null;
        }
        if (js_urls == null || js_urls.length === 0) {
          run_callbacks();
          return null;
        }
        console.debug("Bokeh: BokehJS not loaded, scheduling load and callback at", now());
        root._bokeh_is_loading = css_urls.length + js_urls.length;
    
        function on_load() {
          root._bokeh_is_loading--;
          if (root._bokeh_is_loading === 0) {
            console.debug("Bokeh: all BokehJS libraries/stylesheets loaded");
            run_callbacks()
          }
        }
    
        function on_error(url) {
          console.error("failed to load " + url);
        }
    
        for (let i = 0; i < css_urls.length; i++) {
          const url = css_urls[i];
          const element = document.createElement("link");
          element.onload = on_load;
          element.onerror = on_error.bind(null, url);
          element.rel = "stylesheet";
          element.type = "text/css";
          element.href = url;
          console.debug("Bokeh: injecting link tag for BokehJS stylesheet: ", url);
          document.body.appendChild(element);
        }
    
        for (let i = 0; i < js_urls.length; i++) {
          const url = js_urls[i];
          const element = document.createElement('script');
          element.onload = on_load;
          element.onerror = on_error.bind(null, url);
          element.async = false;
          element.src = url;
          console.debug("Bokeh: injecting script tag for BokehJS library: ", url);
          document.head.appendChild(element);
        }
      };
    
      function inject_raw_css(css) {
        const element = document.createElement("style");
        element.appendChild(document.createTextNode(css));
        document.body.appendChild(element);
      }
    
      const js_urls = ["https://cdn.bokeh.org/bokeh/release/bokeh-3.4.1.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-gl-3.4.1.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-widgets-3.4.1.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-tables-3.4.1.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-mathjax-3.4.1.min.js"];
      const css_urls = [];
    
      const inline_js = [    function(Bokeh) {
          Bokeh.set_log_level("info");
        },
        function(Bokeh) {
          (function() {
            const fn = function() {
              Bokeh.safely(function() {
                (function(root) {
                  function embed_document(root) {
                  const docs_json = '{"150ede63-4438-4727-86f7-a9fb966fe188":{"version":"3.4.1","title":"Bokeh Application","roots":[{"type":"object","name":"Column","id":"p3086","attributes":{"children":[{"type":"object","name":"Row","id":"p3081","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3079","attributes":{"width":409}},{"type":"object","name":"Row","id":"p3039","attributes":{"children":[{"type":"object","name":"Div","id":"p3037","attributes":{"text":"&lt;p&gt;&lt;b&gt;Quantile setter mode&lt;/b&gt;&lt;/p&gt;"}},{"type":"object","name":"Spacer","id":"p3038","attributes":{"width":2}},{"type":"object","name":"Switch","id":"p3026","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:active",[{"type":"object","name":"CustomJS","id":"p3030","attributes":{"args":{"type":"map","entries":[["p_p",{"type":"object","name":"Figure","id":"p2923","attributes":{"x_range":{"type":"object","name":"Range1d","id":"p2987","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:start",[{"type":"object","name":"CustomJS","id":"p3029","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p2923"}],["p_c",{"type":"object","name":"Figure","id":"p2955","attributes":{"js_event_callbacks":{"type":"map","entries":[["reset",[{"type":"object","name":"CustomJS","id":"p3032","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p2923"}],["p_c",{"id":"p2955"}],["source_p",{"type":"object","name":"ColumnDataSource","id":"p2989","attributes":{"selected":{"type":"object","name":"Selection","id":"p2990","attributes":{"indices":[],"line_indices":[]}},"selection_policy":{"type":"object","name":"UnionRenderers","id":"p2991"},"data":{"type":"map","entries":[["x",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}],["y_p",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}]]}}}],["source_c",{"type":"object","name":"ColumnDataSource","id":"p2992","attributes":{"selected":{"type":"object","name":"Selection","id":"p2993","attributes":{"indices":[],"line_indices":[]}},"selection_policy":{"type":"object","name":"UnionRenderers","id":"p2994"},"data":{"type":"map","entries":[["x",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}],["y_c",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}]]}}}],["discrete",false],["n",400],["sliders",[{"type":"object","name":"Slider","id":"p3014","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p3028","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p2923"}],["p_c",{"id":"p2955"}],["source_p",{"id":"p2989"}],["source_c",{"id":"p2992"}],["discrete",false],["n",400],["sliders",[{"id":"p3014"},{"type":"object","name":"Slider","id":"p3016","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p3028"}]]]},"width":200,"title":"\\u03b2","format":{"type":"object","name":"CustomJSTickFormatter","id":"p3015","attributes":{"code":"return tick.toPrecision(4)"}},"start":0.1,"end":2,"value":1,"step":0.01}}]],["xBoxes",[{"type":"object","name":"TextInput","id":"p3021","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p3031","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p2923"}],["p_c",{"id":"p2955"}],["source_p",{"id":"p2989"}],["source_c",{"id":"p2992"}],["discrete",false],["n",400],["sliders",[{"id":"p3014"},{"id":"p3016"}]],["xBoxes",[{"id":"p3021"},{"type":"object","name":"TextInput","id":"p3022","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p3031"}]]]},"disabled":true,"width":80,"value":"2036.5165"}}]],["pBoxes",[{"type":"object","name":"TextInput","id":"p3023","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p3031"}]]]},"disabled":true,"width":80,"value":"0.0250"}},{"type":"object","name":"TextInput","id":"p3024","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p3031"}]]]},"disabled":true,"width":80,"value":"0.9750"}}]],["quantileSetterSwitch",{"id":"p3026"}],["quantileSetterDiv",{"type":"object","name":"Div","id":"p3025"}],["triggerCallbacks",{"type":"object","name":"Switch","id":"p3027","attributes":{"active":true}}],["startBoxes",[{"type":"object","name":"TextInput","id":"p3017","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p3033","attributes":{"args":{"type":"map","entries":[["minValue","0"],["maxValue","Infinity"],["slider",{"id":"p3014"}]]},"code":"\\n\\nslider.start = Math.max(minValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"0.01"}},{"type":"object","name":"TextInput","id":"p3018","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p3035","attributes":{"args":{"type":"map","entries":[["minValue","0"],["maxValue","Infinity"],["slider",{"id":"p3016"}]]},"code":"\\n\\nslider.start = Math.max(minValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"0.1"}}]],["endBoxes",[{"type":"object","name":"TextInput","id":"p3019","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p3034","attributes":{"args":{"type":"map","entries":[["minValue","0"],["maxValue","Infinity"],["slider",{"id":"p3014"}]]},"code":"\\n\\nslider.end = Math.min(maxValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"2"}},{"type":"object","name":"TextInput","id":"p3020","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p3036","attributes":{"args":{"type":"map","entries":[["minValue","0"],["maxValue","Infinity"],["slider",{"id":"p3016"}]]},"code":"\\n\\nslider.end = Math.min(maxValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"2"}}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nclass GammaDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Gamma&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03b1&#x27;, &#x27;\\u03b2&#x27;];\\n\\n    \\n    this.paramMin = [0.0, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0.0;   \\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x &lt; 0) return NaN;\\n    if (x == Infinity) return 0.0;\\n\\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    if (x == 0) {\\n      if (alpha == 1) {\\n        return beta;\\n      } else if (alpha &gt; 1) {\\n        return 0.0;\\n      } else {  \\n        return Infinity;\\n      }\\n    }\\n\\n    let lnProb;\\n    lnProb = alpha * Math.log(beta * x) - Math.log(x) - beta * x - lngamma(alpha);\\n\\n    return Math.exp(lnProb);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x &lt;= 0) return 0.0;\\n    if (x == Infinity) return 1.0;\\n\\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    return gammaincL(beta * x, alpha, true);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return 0.0;\\n    if (p === 1) return Infinity;\\n\\n    \\n    let rescaledParams = [params[0], 1.0];\\n\\n    let rootFun = (xi, params, p) =&gt; {\\n        let x = xi == 1.0 ? Infinity : xi / (1.0 - xi);\\n\\n        return p - this.cdfSingleValue(x, params);\\n    }\\n\\n    let xiOpt = brentSolve(rootFun, 0.0, 1.0, [rescaledParams, p]);\\n\\n    \\n    if (xiOpt === 1) {\\n      return Infinity;\\n    }\\n\\n    \\n    let xFirstPass = xiOpt / (1.0 - xiOpt);\\n\\n    let closeRootFun = (x, params, p) =&gt; {\\n      return p - this.cdfSingleValue(x, params);\\n    }\\n\\n    let xOpt = secantSolve(xFirstPass, closeRootFun, [rescaledParams, p]);\\n\\n    let retval;\\n    if (xOpt != null &amp;&amp; closeRootFun(xOpt, rescaledParams, p) &lt; closeRootFun(xFirstPass, rescaledParams, p)) {\\n      retval = xOpt;\\n    } else {\\n      retval = xFirstPass;\\n    }\\n\\n    \\n    return retval / params[1];\\n }\\n\\n  defaultXRange(params) {\\n    let [x1, x2] = this.ppf([0.001, 0.999], params);\\n\\n    \\n    if (x1 &lt; (x2 - x1) / 10.0) x1 = 0.0;\\n\\n    return [x1, x2];\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    \\n    let x1Rescaled = x1 / x2;\\n    let x2Rescaled = 1.0;\\n\\n    \\n    const quantileRootFun = (params, x1, p1, x2, p2) =&gt; {\\n      let alpha = Math.exp(params[0]);\\n      let beta = Math.exp(params[1]);\\n\\n      let r1 = this.cdfSingleValue(x1, [alpha, beta]) - p1;\\n      let r2 = this.cdfSingleValue(x2, [alpha, beta]) - p2;\\n\\n      return [r1, r2];\\n    };\\n\\n    let args = [x1Rescaled, p1, x2Rescaled, p2];\\n\\n    let guess = [0.75, 0.75];\\n\\n    let [logParams, optimSuccess] = findRootTrustRegion(quantileRootFun, guess, args=args);\\n\\n    \\n    let paramsFirstPass = [Math.exp(logParams[0]), Math.exp(logParams[1])];\\n\\n    \\n    if (!optimSuccess) {\\n      return [[paramsFirstPass[0], paramsFirstPass[1]], optimSuccess];\\n    }\\n\\n    \\n    const closeQuantileRootFun = (params, x1, p1, x2, p2) =&gt; {\\n      let r1 = this.cdfSingleValue(x1, params) - p1;\\n      let r2 = this.cdfSingleValue(x2, params) - p2;\\n\\n      return [r1, r2];\\n    };\\n\\n    let paramsOpt;\\n    [paramsOpt, optimSuccess] = findRootTrustRegion(closeQuantileRootFun, paramsFirstPass, args=args);\\n\\n    let retval;\\n    if (optimSuccess &amp;&amp; norm(closeQuantileRootFun(paramsOpt, x1, p1, x2, p2)) &lt; norm(closeQuantileRootFun(paramsFirstPass, x1, p1, x2, p2))) {\\n      retval = paramsOpt;\\n    } else {\\n      retval = paramsFirstPass;\\n    }\\n\\n    \\n    return [[retval[0], retval[1] / x2], optimSuccess];\\n  }\\n\\n}\\n\\nfunction lngamma(z) {\\n\\n    if(z &lt; 0) return Number(&#x27;0/0&#x27;);\\n\\n    if (z &lt; 0.5) return Math.log(Math.PI) - Math.log(Math.sin(Math.PI * z)) - lngamma(1-z);\\n\\n    var p = [676.5203681218851,\\n             -1259.1392167224028,\\n             771.32342877765313,\\n             -176.61502916214059,\\n             12.507343278686905,\\n             -0.13857109526572012,\\n             9.9843695780195716e-6,\\n             1.5056327351493116e-7];\\n\\n    z -= 1.0;\\n    var Ag = 0.99999999999980993;\\n    for (var i = 0; i &lt; p.length; i++) {\\n        Ag += p[i] / (z + i + 1);\\n    }\\n    var t = z + p.length - 0.5;\\n\\n    return 0.5 * Math.log(2*Math.PI) + (z + 0.5)*Math.log(t) - t + Math.log(Ag);\\n}\\n\\n\\nfunction gammaincU(x, s, regularized) {\\n\\n  var EPSILON = 1e-12;\\n\\n  if (x &lt;= 1.1 || x &lt;= s) {\\n    if (regularized !== false) {\\n      return 1 - gammaincL(x, s, regularized);\\n    } else {\\n      return Math.exp(lngamma(s)) - gammaincL(x, s, regularized);\\n    }\\n  }\\n\\n  var f = 1 + x - s,\\n    C = f,\\n    D = 0,\\n    i = 1,\\n    a, b, chg;\\n  for (i = 1; i &lt; 10000; i++) {\\n    a = i * (s - i);\\n    b = (i&lt;&lt;1) + 1 + x - s;\\n    D = b + a * D;\\n    C = b + a / C;\\n    D = 1 / D;\\n    chg = C * D;\\n    f *= chg;\\n    if (Math.abs(chg - 1) &lt; EPSILON) {\\n      break;\\n    }\\n  }\\n  if (regularized !== false) {\\n    return Math.exp(s * Math.log(x) - x - lngamma(s) - Math.log(f));\\n  } else {\\n    return Math.exp(s * Math.log(x) - x - Math.log(f));\\n  }\\n}\\n\\n\\nfunction gammaincL(x, s, regularized) {\\n\\n  var EPSILON = 1e-12;\\n\\n  if (x === 0) {\\n    return 0;\\n  }\\n  if (x &lt; 0 || s &lt;= 0) {\\n    return NaN;\\n  }\\n\\n  if (x &gt; 1.1 &amp;&amp; x &gt; s) {\\n    if (regularized !== false) {\\n      return 1 - gammaincU(x, s, regularized);\\n    } else {\\n      return Math.exp(lngamma(s)) - gammaincU(x, s, regularized);\\n    }\\n  }\\n\\n  var ft,\\n    r = s,\\n    c = 1,\\n    pws = 1;\\n\\n  if (regularized !== false) {\\n    ft = s * Math.log(x) - x - lngamma(s);\\n  } else {\\n    ft = s * Math.log(x) - x;\\n  }\\n  ft = Math.exp(ft);\\n  do {\\n    r += 1;\\n    c *= x/r;\\n    pws += c;\\n  } while (c / pws &gt; EPSILON);\\n\\n  return pws * ft / s;\\n}\\n\\n\\nfunction norm(v) {\\n  return Math.sqrt(dot(v, v));\\n}\\n\\n\\nfunction findRootTrustRegion(\\n\\t\\tf, \\n\\t\\tx0, \\n\\t\\targs=[],\\n\\t\\tjac=jacCentralDiff,\\n\\t\\ttol=0.000000001, \\n\\t\\tmaxIters=10000, \\n\\t\\tdeltaBar=1000.0, \\n\\t\\teta=0.125, \\n\\t\\tminDelta=1e-12\\n  ) {\\n\\t\\n\\tlet x = deepCopy(x0);\\n\\n\\t\\n\\tlet delta = 0.99 * deltaBar;\\n\\n\\t\\n\\tlet r = f(x, ...args);\\n\\n\\t\\n\\tlet J = jac(f, x, args);\\n\\n\\t\\n\\tlet JTJ = mmMult(transpose(J), J);\\n\\n\\t\\n\\tlet JTr = mvMult(transpose(J), r);\\n\\n\\t\\n\\tlet normJTr = norm(JTr);\\n\\n\\tlet iters = 0;\\n\\twhile (iters &lt; maxIters &amp;&amp; checkTol(r, tol) &amp;&amp; delta &gt;= minDelta) {\\n\\t\\t\\n\\t\\tlet p = doglegStep(JTJ, JTr, normJTr, delta);\\n\\n\\t\\t\\n\\t\\tlet newr = f(vectorAdd(x, p), ...args);\\n\\t\\tlet rho = computeRho(r, newr, J, p);\\n\\n\\t\\t\\n\\t\\tif  (rho &lt; 0.25) {\\n\\t\\t\\tdelta = norm(p) / 4.0;\\n\\t\\t} else if (rho &gt; 0.75 &amp;&amp; Math.abs(norm(p) - delta) &lt; 1e-12) {\\n\\t\\t\\t\\tdelta = Math.min(2 * delta, deltaBar);\\n\\t\\t}\\n\\n\\t\\t\\n\\t\\tif (rho &gt; eta) {\\n\\t\\t\\tx = vectorAdd(x, p);\\n\\n\\t\\t\\tr = newr;\\n\\t\\t\\tJ = jac(f, x, args);\\n\\t\\t\\tJTJ = mmMult(transpose(J), J);\\n\\t\\t\\tJTr = mvMult(transpose(J), r);\\n\\t\\t\\tnormJTr = norm(JTr);\\n\\t\\t}\\n\\n\\t\\titers += 1;\\n\\t}\\n\\n\\tlet success = !checkTol(r, tol);\\n\\n\\treturn [x, success];\\n\\n}\\n\\n\\nfunction secantSolve(x0, f, args=[], tol=1e-8, maxIter=200, epsilon=1e-14, h=1e-4) {\\n\\tlet x = Infinity;\\n\\tlet solved = false;\\n\\n\\tlet x1 = x0 * (1 + h);\\n\\tx1 += x1 &gt;= 0 ? h : -h;\\n\\n\\tlet q0 = f(x0, ...args);\\n\\tlet q1 = f(x1, ...args);\\n\\t\\n\\tif (Math.abs(q1) &lt; Math.abs(q0)) {\\n\\t\\t[x0, x1, q0, q1] = [x1, x0, q1, q0];\\n\\t}\\n\\n\\tfor (let i = 0; i &lt; maxIter; i++) {\\n\\t\\tif (q0 == q1) {\\n\\t\\t\\tsolved = x0 == x1;\\n\\t\\t\\tx = (x0 + x1) / 2.0;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tif (Math.abs(q1) &gt; Math.abs(q0)) {\\n\\t\\t\\t\\tx = (x0 - q0 / q1 * x1) / (1.0 - q0 / q1);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tx = (x1 - q1 / q0 * x0) / (1.0 - q1 / q0);\\n\\t\\t\\t}\\n\\t\\t\\tif (Math.abs(x - x0) &lt;= tol) {\\n\\t\\t\\t\\tsolved = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\t[x0, q0] = [x1, q1];\\n\\t\\t\\tx1 = x;\\n\\t\\t\\tq1 = f(x1, ...args);\\n\\t\\t}\\n\\t}\\n\\n  if (solved) return x;\\n  else return null;\\n}\\n\\n\\nfunction brentSolve(f, lower, upper, args=[], tol=1e-8, maxIter=1000) {\\n\\tlet a = lower;\\n\\tlet b = upper;\\n  let fa = f(a, ...args);\\n  let fb = f(b, ...args);\\n\\n  \\n  if (Math.abs(fa) &lt; tol) return a;\\n  if (Math.abs(fb) &lt; tol) return b;\\n\\n  \\n  if (fa * fb &gt;= 0) {\\n  \\treturn null;\\n\\t}\\n\\n  \\n  let c = a;\\n  let fc = fa;\\n\\n\\tlet iter = 0;\\n  while (iter++ &lt; maxIter) {\\n  \\tlet prevStep = b - a;\\n\\n    \\n    if (Math.abs(fc) &lt; Math.abs(fb)) {      \\n    \\t[a, b, c] = [b, c, b];\\n    \\t[fa, fb, fc] = [fb, fc, fb];\\n    }\\n\\n    \\n    let newStep = (c - b) / 2.0;\\n\\n    \\n    let tolAdj = 1e-15 * Math.abs(b) + tol / 2;\\n\\n    \\n  \\tif (Math.abs(newStep) &lt;= tolAdj || fb === 0 ) {\\n    \\t\\treturn b;\\n  \\t}\\n\\n    \\n    if (Math.abs(prevStep) &gt; tolAdj &amp;&amp; Math.abs(fa) &gt; Math.abs(fb)) {\\n    \\tlet p;\\n    \\tlet q;\\n    \\tlet t1;\\n    \\tlet t2;\\n    \\tlet cb = c - b;\\n    \\tif (a === c) { \\n    \\t\\tt1 = fb / fa;\\n    \\t\\tp = cb * t1;\\n    \\t\\tq = 1.0 - t1;\\n    \\t}\\n    \\telse { \\n    \\t\\tq = fa / fc;\\n    \\t\\tt1 = fb / fc;\\n    \\t\\tt2 = fb / fa;\\n    \\t\\tp = t2 * (cb * q * (q - t1) - (b - a) * (t1 - 1.0));\\n    \\t\\tq = (q - 1.0) * (t1 - 1.0) * (t2 - 1.0);\\n    \\t}\\n\\n    \\t\\n    \\tif (p &gt; 0) q = -q;\\n    \\telse p = -p;\\n\\n    \\t\\n    \\tif (p &lt; (0.75 * cb * q - Math.abs(tolAdj * q) / 2.0) \\n    \\t\\t&amp;&amp; p &lt; Math.abs(prevStep * q / 2.0)) { \\n\\t        newStep = p / q;\\n      \\t}\\n    }\\n\\n    if (Math.abs(newStep) &lt; tolAdj) {\\n      newStep = (newStep &gt; 0) ? tolAdj : -tolAdj;\\n    }\\n\\n    \\n    a = b;\\n    fa = fb;\\n\\n    \\n    b += newStep;\\n    fb = f(b, ...args);\\n\\n\\t\\n    if ((fb &gt; 0 &amp;&amp; fc &gt; 0) || (fb &lt; 0 &amp;&amp; fc &lt; 0)) {\\n      c = a; \\n      fc = fa;\\n    }\\n  }\\n\\n  \\n  return null;\\n}\\n\\n\\nfunction dot(v1, v2) {\\n  const n = v1.length;\\n  let result = 0.0;\\n  for (let i = 0; i &lt; n; i++) result += v1[i] * v2[i];\\n\\n  return result;\\n}\\n\\n\\nfunction transpose(A) {\\n    return A[0].map((_, colIndex) =&gt; A.map(row =&gt; row[colIndex]));\\n}\\n\\n\\nfunction mvMult(A, v) {\\n  return A.map(Arow =&gt; dot(Arow, v));\\n}\\n\\n\\nfunction mmMult(A, B) {\\n  let mA = A.length;\\n  let nA = A[0].length;\\n  let mB = B.length;\\n  let nB = B[0].length;\\n\\n  if (nA !== mB) {\\n      throw new Error(&#x27;Matrix dimension mismatch.&#x27;);\\n  }\\n\\n  let result = zeros(mA, nB);\\n\\n  for (let i = 0; i &lt; mA; i++) {\\n    for (let j = 0; j &lt; nB; j++) {\\n      for (let k = 0; k &lt; nA; k++) {\\n        result[i][j] += A[i][k] * B[k][j];\\n      }\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction vectorAdd() {\\n  let m = arguments.length;\\n  let n = arguments[0].length;\\n \\n  let result = new Array(n).fill(0.0);\\n \\n  for (let i = 0; i &lt; n; i++) {\\n    for (let j = 0; j &lt; m; j++) {\\n        result[i] += arguments[j][i];\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction deepCopy(x) {\\n  return JSON.parse(JSON.stringify(x));\\n}\\n\\n\\nfunction computeRho(r, newr, J, p) {\\n\\tlet r2 = norm(r) ** 2;\\n\\tlet num = r2 - norm(newr)**2;\\n\\tlet denom = r2 - norm(vectorAdd(r, mvMult(J, p))) ** 2;\\n\\n\\treturn num / denom;\\n}\\n\\n\\nfunction checkTol(r, tol) {\\n\\t\\n\\tconst n = r.length;\\n\\tfor (let i = 0; i &lt; n; i++) {\\n\\t\\tif (tol &lt; Math.abs(r[i])) return true;\\n\\t}\\n\\n\\treturn false;\\n}\\n\\n\\nfunction doglegStep(JTJ, JTr, normJTr, delta) {\\n\\t\\n\\tlet [pJ, posDef] = solvePosDef(JTJ, JTr);\\n\\tpJ = svMult(-1.0, pJ);\\n\\n\\t\\n\\tif (posDef &amp;&amp; norm(pJ) &lt;= delta) {\\n\\t\\treturn pJ;\\n\\t}\\n\\n\\t\\n\\tlet tau = Math.min(1, normJTr**3 / delta / quadForm(JTJ, JTr));\\n\\tlet pC = svMult(-tau * delta / normJTr, JTr);\\n\\n\\tlet pCnorm = norm(pC);\\n\\tif (!posDef || Math.abs(pCnorm - delta) &lt;= 1e-12) {\\n\\t\\treturn pC;\\n\\t}\\n\\n\\t\\n\\tlet pJ2 = norm(pJ) ** 2;\\n\\tlet pC2 = pCnorm**2;\\n\\tlet pJpC = dot(pJ, pC);\\n\\tlet a = pJ2 + pC2 - 2.0 * pJpC;\\n\\tlet b = 2.0 * (pJpC - pC2);\\n\\tlet c = pC2 - delta**2;\\n\\tlet q = -0.5 * (b + Math.sign(b) * Math.sqrt(b**2 - 4.0 * a * c));\\n\\n\\t\\n\\tlet beta;\\n\\tif (Math.abs(b) &lt; 1e-12) beta = Math.sqrt(-c / a);\\n\\telse if (b &lt; 0.0) beta = q / a;\\n\\telse beta = c / q;\\n\\n\\t\\n\\tif (0.0 &lt;= beta &amp;&amp; beta &lt;= 1) {\\n\\t\\treturn vectorAdd(pC, svMult(beta, vectorAdd(pJ, svMult(-1.0, pC))));\\n\\t} else { \\n\\t\\treturn pC;\\n\\t}\\n\\n}\\n\\n\\nfunction jacCentralDiff(f, x, args=[], eps=4.7e-6) {\\n\\t\\n\\tlet xPlus = deepCopy(x);\\n\\tlet xMinus = deepCopy(x);\\n\\n\\t\\n\\tlet fOfx = f(x, ...args);\\n\\tlet m = fOfx.length;\\n\\n\\t\\n\\tlet n = x.length;\\n\\n\\t\\n\\tlet J = zeros(m, n);\\n\\n\\t\\n\\tlet fOfxPlus;\\n\\tlet fOfxMinus;\\n\\n\\tfor (let j = 0; j &lt; n; j++) {\\n\\t\\txPlus[j] += eps;\\n\\t\\txMinus[j] -= eps;\\n\\t\\tfOfxPlus = f(xPlus, ...args);\\n\\t\\tfOfxMinus = f(xMinus, ...args);\\n\\t\\txPlus[j] -= eps;\\n\\t\\txMinus[j] += eps;\\n\\n\\t\\tfor (let i = 0; i &lt; m; i++) {\\n\\t\\t\\tJ[i][j] = (fOfxPlus[i] - fOfxMinus[i]) / 2.0 / eps;\\n\\t\\t}\\n\\t}\\n\\n\\treturn J;\\n}\\n\\n\\nfunction zeros(...dims) {\\n  let A = [];\\n\\n  \\n  for (let i = dims.length - 1; i &gt;= 0; i--) {\\n    let size = dims[i];\\n    if (i === dims.length - 1) {\\n      \\n      A = new Array(size).fill(0.0);\\n    } else {\\n      \\n      A = new Array(size).fill().map(() =&gt; deepCopy(A));\\n    }\\n  }\\n\\n  return A;\\n}\\n\\n\\nfunction svMult(a, v) {\\n  return v.map(x =&gt; a * x);\\n}\\n\\n\\nfunction quadForm(A, x) {\\n   return dot(x, mvMult(A, x)); \\n}\\n\\n\\nfunction solvePosDef(A, b) {\\n  let [L, p, success] = modifiedCholesky(A);\\n\\n  if (!success) {\\n    return [zeros(b.length), success];\\n  }\\n\\n  return [modifiedCholeskySolve(L, p, b), success];\\n}\\n\\n\\nfunction modifiedCholesky(A) {\\n    const floatEps = 1.0e-14;\\n    const n = A.length;\\n\\n    \\n    let L = deepCopy(A); \\n    let p = arange(0, n);\\n\\n    \\n    let success = true;\\n\\n    let xi = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        for (let j = 0; j &lt; i; j++) {\\n            let temp = Math.abs(L[i][j]);\\n            xi = Math.max(xi, temp);\\n        }\\n    }\\n\\n    let eta = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        let temp = Math.abs(L[i][i]);\\n        eta = Math.max(eta, temp);\\n    }\\n\\n    let beta;\\n    if (n &gt; 1) {\\n        beta = Math.sqrt(Math.max(eta, xi / Math.sqrt(n * n - 1)));\\n    } else {\\n        beta = Math.sqrt(eta);\\n    }\\n    beta = Math.max(beta, floatEps);\\n\\n    for (let k = 0; k &lt; n; k++) {\\n        \\n        let muVal = L[k][k];\\n        let mu = k;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            let temp = L[i][i];\\n            if (muVal &lt; temp) {\\n                mu = i;\\n                muVal = temp;\\n            }\\n        }\\n\\n        \\n        let iTemp = p[mu];\\n        p[mu] = p[k];\\n        p[k] = iTemp;\\n\\n        for (let i = 0; i &lt; k; i++) {\\n            let temp = L[k][i];\\n            L[k][i] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        let temp = L[k][k];\\n        L[k][k] = L[mu][mu];\\n        L[mu][mu] = temp;\\n        for (let i = k + 1; i &lt; mu; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        for (let i = mu + 1; i &lt; n; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[i][mu];\\n            L[i][mu] = temp;\\n        }\\n\\n        \\n        let cSum = 0;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            cSum = Math.max(cSum, Math.abs(L[i][k]));\\n        }\\n        cSum /= beta;\\n        cSum = cSum * cSum;\\n\\n        \\n        if (L[k][k] &lt; 0) {\\n            success = false;\\n        }\\n\\n        temp = Math.abs(L[k][k]);\\n        temp = Math.max(temp, floatEps * eta);\\n        temp = Math.max(temp, cSum);\\n        L[k][k] = Math.sqrt(temp);\\n\\n        \\n        for (let i = k + 1; i &lt; n; i++) {\\n            L[i][k] /= L[k][k];\\n        }\\n\\n        \\n        for (let j = k + 1; j &lt; n; j++) {\\n            for (let i = j; i &lt; n; i++) {\\n                L[i][j] -= L[i][k] * L[j][k];\\n            }\\n        }\\n\\n        \\n        for (let i = 0; i &lt; n - 1; i++) {\\n            for (let j = i + 1; j &lt; n; j++) {\\n                L[i][j] = 0.0;\\n            }\\n        }\\n    }\\n\\n    return [L, p, success];\\n}\\n\\n\\nfunction modifiedCholeskySolve(L, p, b) {\\n    const n = L.length;\\n\\n    let U = transpose(L);\\n    let xp = new Array(n).fill(0);\\n    for (let i = 0; i &lt; n; i++) {\\n        xp[i] = b[p[i]];\\n    }\\n\\n    \\n    let x = lowerTriSolve(L, xp);\\n\\n    \\n    xp = upperTriSolve(U, x);\\n\\n    for (let i = 0; i &lt; n; i++) {\\n        x[p[i]] = xp[i];\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction lowerTriSolve(L, b) {\\n    const floatEps = 1.0e-14;\\n    const n = L.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = 0; j &lt; n - 1; j++) {\\n        if (Math.abs(L[j][j]) &gt; floatEps) {\\n            x[j] /= L[j][j];\\n            for (let i = j + 1; i &lt; n; i++) {\\n                x[i] -= x[j] * L[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(L[n - 1][n - 1]) &gt; floatEps) {\\n            x[n - 1] /= L[n - 1][n - 1];\\n        } else {\\n            x[n - 1] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction upperTriSolve(U, b) {\\n    const floatEps = 1.0e-14;\\n    const n = U.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = n - 1; j &gt; 0; j--) {\\n        if (Math.abs(U[j][j]) &gt; floatEps) {\\n            x[j] /= U[j][j];\\n            for (let i = 0; i &lt; j; i++) {\\n                x[i] -= x[j] * U[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(U[0][0]) &gt; floatEps) {\\n            x[0] /= U[0][0];\\n        } else {\\n            x[0] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nclass InverseGammaDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;InverseGamma&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03b1&#x27;, &#x27;\\u03b2&#x27;];\\n\\n    \\n    this.paramMin = [0.0, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0.0;   \\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x &lt; 0) return NaN;\\n    if (x === 0 || x === Infinity) return 0.0;\\n\\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    let lnProb;\\n    lnProb = alpha * Math.log(beta) - (alpha + 1) * Math.log(x) - beta / x - lngamma(alpha);\\n\\n    return Math.exp(lnProb);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x &lt;= 0) return 0.0;\\n    if (x == Infinity) return 1.0;\\n\\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    return gammaincU(beta / x, alpha, true);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return 0.0;\\n    if (p === 1) return Infinity;\\n\\n    let gamma = new GammaDistribution();\\n    return 1.0 / gamma.ppf(1.0 - p, params);\\n  }\\n\\n  defaultXRange(params) {\\n    \\n    let [x1, x2] = this.ppf([0.001, 0.99], params);\\n\\n    \\n    if (x1 &lt; (x2 - x1) / 10.0) x1 = 0.0;\\n\\n    return [x1, x2];\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n\\n    let gamma = new GammaDistribution();\\n    return gamma.quantileSet([1.0 / x2, 1.0 / x1], p);\\n  }\\n\\n}\\n\\n\\n\\nvar dist = new InverseGammaDistribution();\\n\\n\\n\\nif (quantileSetterSwitch.active) {\\n  quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p);\\n}"}}]]]},"disabled":true,"width":80,"value":"0.3981"}},{"id":"p3022"}]],["pBoxes",[{"id":"p3023"},{"id":"p3024"}]],["quantileSetterSwitch",{"id":"p3026"}],["quantileSetterDiv",{"id":"p3025"}],["triggerCallbacks",{"id":"p3027"}],["startBoxes",[{"id":"p3017"},{"id":"p3018"}]],["endBoxes",[{"id":"p3019"},{"id":"p3020"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nclass GammaDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Gamma&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03b1&#x27;, &#x27;\\u03b2&#x27;];\\n\\n    \\n    this.paramMin = [0.0, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0.0;   \\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x &lt; 0) return NaN;\\n    if (x == Infinity) return 0.0;\\n\\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    if (x == 0) {\\n      if (alpha == 1) {\\n        return beta;\\n      } else if (alpha &gt; 1) {\\n        return 0.0;\\n      } else {  \\n        return Infinity;\\n      }\\n    }\\n\\n    let lnProb;\\n    lnProb = alpha * Math.log(beta * x) - Math.log(x) - beta * x - lngamma(alpha);\\n\\n    return Math.exp(lnProb);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x &lt;= 0) return 0.0;\\n    if (x == Infinity) return 1.0;\\n\\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    return gammaincL(beta * x, alpha, true);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return 0.0;\\n    if (p === 1) return Infinity;\\n\\n    \\n    let rescaledParams = [params[0], 1.0];\\n\\n    let rootFun = (xi, params, p) =&gt; {\\n        let x = xi == 1.0 ? Infinity : xi / (1.0 - xi);\\n\\n        return p - this.cdfSingleValue(x, params);\\n    }\\n\\n    let xiOpt = brentSolve(rootFun, 0.0, 1.0, [rescaledParams, p]);\\n\\n    \\n    if (xiOpt === 1) {\\n      return Infinity;\\n    }\\n\\n    \\n    let xFirstPass = xiOpt / (1.0 - xiOpt);\\n\\n    let closeRootFun = (x, params, p) =&gt; {\\n      return p - this.cdfSingleValue(x, params);\\n    }\\n\\n    let xOpt = secantSolve(xFirstPass, closeRootFun, [rescaledParams, p]);\\n\\n    let retval;\\n    if (xOpt != null &amp;&amp; closeRootFun(xOpt, rescaledParams, p) &lt; closeRootFun(xFirstPass, rescaledParams, p)) {\\n      retval = xOpt;\\n    } else {\\n      retval = xFirstPass;\\n    }\\n\\n    \\n    return retval / params[1];\\n }\\n\\n  defaultXRange(params) {\\n    let [x1, x2] = this.ppf([0.001, 0.999], params);\\n\\n    \\n    if (x1 &lt; (x2 - x1) / 10.0) x1 = 0.0;\\n\\n    return [x1, x2];\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    \\n    let x1Rescaled = x1 / x2;\\n    let x2Rescaled = 1.0;\\n\\n    \\n    const quantileRootFun = (params, x1, p1, x2, p2) =&gt; {\\n      let alpha = Math.exp(params[0]);\\n      let beta = Math.exp(params[1]);\\n\\n      let r1 = this.cdfSingleValue(x1, [alpha, beta]) - p1;\\n      let r2 = this.cdfSingleValue(x2, [alpha, beta]) - p2;\\n\\n      return [r1, r2];\\n    };\\n\\n    let args = [x1Rescaled, p1, x2Rescaled, p2];\\n\\n    let guess = [0.75, 0.75];\\n\\n    let [logParams, optimSuccess] = findRootTrustRegion(quantileRootFun, guess, args=args);\\n\\n    \\n    let paramsFirstPass = [Math.exp(logParams[0]), Math.exp(logParams[1])];\\n\\n    \\n    if (!optimSuccess) {\\n      return [[paramsFirstPass[0], paramsFirstPass[1]], optimSuccess];\\n    }\\n\\n    \\n    const closeQuantileRootFun = (params, x1, p1, x2, p2) =&gt; {\\n      let r1 = this.cdfSingleValue(x1, params) - p1;\\n      let r2 = this.cdfSingleValue(x2, params) - p2;\\n\\n      return [r1, r2];\\n    };\\n\\n    let paramsOpt;\\n    [paramsOpt, optimSuccess] = findRootTrustRegion(closeQuantileRootFun, paramsFirstPass, args=args);\\n\\n    let retval;\\n    if (optimSuccess &amp;&amp; norm(closeQuantileRootFun(paramsOpt, x1, p1, x2, p2)) &lt; norm(closeQuantileRootFun(paramsFirstPass, x1, p1, x2, p2))) {\\n      retval = paramsOpt;\\n    } else {\\n      retval = paramsFirstPass;\\n    }\\n\\n    \\n    return [[retval[0], retval[1] / x2], optimSuccess];\\n  }\\n\\n}\\n\\nfunction lngamma(z) {\\n\\n    if(z &lt; 0) return Number(&#x27;0/0&#x27;);\\n\\n    if (z &lt; 0.5) return Math.log(Math.PI) - Math.log(Math.sin(Math.PI * z)) - lngamma(1-z);\\n\\n    var p = [676.5203681218851,\\n             -1259.1392167224028,\\n             771.32342877765313,\\n             -176.61502916214059,\\n             12.507343278686905,\\n             -0.13857109526572012,\\n             9.9843695780195716e-6,\\n             1.5056327351493116e-7];\\n\\n    z -= 1.0;\\n    var Ag = 0.99999999999980993;\\n    for (var i = 0; i &lt; p.length; i++) {\\n        Ag += p[i] / (z + i + 1);\\n    }\\n    var t = z + p.length - 0.5;\\n\\n    return 0.5 * Math.log(2*Math.PI) + (z + 0.5)*Math.log(t) - t + Math.log(Ag);\\n}\\n\\n\\nfunction gammaincU(x, s, regularized) {\\n\\n  var EPSILON = 1e-12;\\n\\n  if (x &lt;= 1.1 || x &lt;= s) {\\n    if (regularized !== false) {\\n      return 1 - gammaincL(x, s, regularized);\\n    } else {\\n      return Math.exp(lngamma(s)) - gammaincL(x, s, regularized);\\n    }\\n  }\\n\\n  var f = 1 + x - s,\\n    C = f,\\n    D = 0,\\n    i = 1,\\n    a, b, chg;\\n  for (i = 1; i &lt; 10000; i++) {\\n    a = i * (s - i);\\n    b = (i&lt;&lt;1) + 1 + x - s;\\n    D = b + a * D;\\n    C = b + a / C;\\n    D = 1 / D;\\n    chg = C * D;\\n    f *= chg;\\n    if (Math.abs(chg - 1) &lt; EPSILON) {\\n      break;\\n    }\\n  }\\n  if (regularized !== false) {\\n    return Math.exp(s * Math.log(x) - x - lngamma(s) - Math.log(f));\\n  } else {\\n    return Math.exp(s * Math.log(x) - x - Math.log(f));\\n  }\\n}\\n\\n\\nfunction gammaincL(x, s, regularized) {\\n\\n  var EPSILON = 1e-12;\\n\\n  if (x === 0) {\\n    return 0;\\n  }\\n  if (x &lt; 0 || s &lt;= 0) {\\n    return NaN;\\n  }\\n\\n  if (x &gt; 1.1 &amp;&amp; x &gt; s) {\\n    if (regularized !== false) {\\n      return 1 - gammaincU(x, s, regularized);\\n    } else {\\n      return Math.exp(lngamma(s)) - gammaincU(x, s, regularized);\\n    }\\n  }\\n\\n  var ft,\\n    r = s,\\n    c = 1,\\n    pws = 1;\\n\\n  if (regularized !== false) {\\n    ft = s * Math.log(x) - x - lngamma(s);\\n  } else {\\n    ft = s * Math.log(x) - x;\\n  }\\n  ft = Math.exp(ft);\\n  do {\\n    r += 1;\\n    c *= x/r;\\n    pws += c;\\n  } while (c / pws &gt; EPSILON);\\n\\n  return pws * ft / s;\\n}\\n\\n\\nfunction norm(v) {\\n  return Math.sqrt(dot(v, v));\\n}\\n\\n\\nfunction findRootTrustRegion(\\n\\t\\tf, \\n\\t\\tx0, \\n\\t\\targs=[],\\n\\t\\tjac=jacCentralDiff,\\n\\t\\ttol=0.000000001, \\n\\t\\tmaxIters=10000, \\n\\t\\tdeltaBar=1000.0, \\n\\t\\teta=0.125, \\n\\t\\tminDelta=1e-12\\n  ) {\\n\\t\\n\\tlet x = deepCopy(x0);\\n\\n\\t\\n\\tlet delta = 0.99 * deltaBar;\\n\\n\\t\\n\\tlet r = f(x, ...args);\\n\\n\\t\\n\\tlet J = jac(f, x, args);\\n\\n\\t\\n\\tlet JTJ = mmMult(transpose(J), J);\\n\\n\\t\\n\\tlet JTr = mvMult(transpose(J), r);\\n\\n\\t\\n\\tlet normJTr = norm(JTr);\\n\\n\\tlet iters = 0;\\n\\twhile (iters &lt; maxIters &amp;&amp; checkTol(r, tol) &amp;&amp; delta &gt;= minDelta) {\\n\\t\\t\\n\\t\\tlet p = doglegStep(JTJ, JTr, normJTr, delta);\\n\\n\\t\\t\\n\\t\\tlet newr = f(vectorAdd(x, p), ...args);\\n\\t\\tlet rho = computeRho(r, newr, J, p);\\n\\n\\t\\t\\n\\t\\tif  (rho &lt; 0.25) {\\n\\t\\t\\tdelta = norm(p) / 4.0;\\n\\t\\t} else if (rho &gt; 0.75 &amp;&amp; Math.abs(norm(p) - delta) &lt; 1e-12) {\\n\\t\\t\\t\\tdelta = Math.min(2 * delta, deltaBar);\\n\\t\\t}\\n\\n\\t\\t\\n\\t\\tif (rho &gt; eta) {\\n\\t\\t\\tx = vectorAdd(x, p);\\n\\n\\t\\t\\tr = newr;\\n\\t\\t\\tJ = jac(f, x, args);\\n\\t\\t\\tJTJ = mmMult(transpose(J), J);\\n\\t\\t\\tJTr = mvMult(transpose(J), r);\\n\\t\\t\\tnormJTr = norm(JTr);\\n\\t\\t}\\n\\n\\t\\titers += 1;\\n\\t}\\n\\n\\tlet success = !checkTol(r, tol);\\n\\n\\treturn [x, success];\\n\\n}\\n\\n\\nfunction secantSolve(x0, f, args=[], tol=1e-8, maxIter=200, epsilon=1e-14, h=1e-4) {\\n\\tlet x = Infinity;\\n\\tlet solved = false;\\n\\n\\tlet x1 = x0 * (1 + h);\\n\\tx1 += x1 &gt;= 0 ? h : -h;\\n\\n\\tlet q0 = f(x0, ...args);\\n\\tlet q1 = f(x1, ...args);\\n\\t\\n\\tif (Math.abs(q1) &lt; Math.abs(q0)) {\\n\\t\\t[x0, x1, q0, q1] = [x1, x0, q1, q0];\\n\\t}\\n\\n\\tfor (let i = 0; i &lt; maxIter; i++) {\\n\\t\\tif (q0 == q1) {\\n\\t\\t\\tsolved = x0 == x1;\\n\\t\\t\\tx = (x0 + x1) / 2.0;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tif (Math.abs(q1) &gt; Math.abs(q0)) {\\n\\t\\t\\t\\tx = (x0 - q0 / q1 * x1) / (1.0 - q0 / q1);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tx = (x1 - q1 / q0 * x0) / (1.0 - q1 / q0);\\n\\t\\t\\t}\\n\\t\\t\\tif (Math.abs(x - x0) &lt;= tol) {\\n\\t\\t\\t\\tsolved = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\t[x0, q0] = [x1, q1];\\n\\t\\t\\tx1 = x;\\n\\t\\t\\tq1 = f(x1, ...args);\\n\\t\\t}\\n\\t}\\n\\n  if (solved) return x;\\n  else return null;\\n}\\n\\n\\nfunction brentSolve(f, lower, upper, args=[], tol=1e-8, maxIter=1000) {\\n\\tlet a = lower;\\n\\tlet b = upper;\\n  let fa = f(a, ...args);\\n  let fb = f(b, ...args);\\n\\n  \\n  if (Math.abs(fa) &lt; tol) return a;\\n  if (Math.abs(fb) &lt; tol) return b;\\n\\n  \\n  if (fa * fb &gt;= 0) {\\n  \\treturn null;\\n\\t}\\n\\n  \\n  let c = a;\\n  let fc = fa;\\n\\n\\tlet iter = 0;\\n  while (iter++ &lt; maxIter) {\\n  \\tlet prevStep = b - a;\\n\\n    \\n    if (Math.abs(fc) &lt; Math.abs(fb)) {      \\n    \\t[a, b, c] = [b, c, b];\\n    \\t[fa, fb, fc] = [fb, fc, fb];\\n    }\\n\\n    \\n    let newStep = (c - b) / 2.0;\\n\\n    \\n    let tolAdj = 1e-15 * Math.abs(b) + tol / 2;\\n\\n    \\n  \\tif (Math.abs(newStep) &lt;= tolAdj || fb === 0 ) {\\n    \\t\\treturn b;\\n  \\t}\\n\\n    \\n    if (Math.abs(prevStep) &gt; tolAdj &amp;&amp; Math.abs(fa) &gt; Math.abs(fb)) {\\n    \\tlet p;\\n    \\tlet q;\\n    \\tlet t1;\\n    \\tlet t2;\\n    \\tlet cb = c - b;\\n    \\tif (a === c) { \\n    \\t\\tt1 = fb / fa;\\n    \\t\\tp = cb * t1;\\n    \\t\\tq = 1.0 - t1;\\n    \\t}\\n    \\telse { \\n    \\t\\tq = fa / fc;\\n    \\t\\tt1 = fb / fc;\\n    \\t\\tt2 = fb / fa;\\n    \\t\\tp = t2 * (cb * q * (q - t1) - (b - a) * (t1 - 1.0));\\n    \\t\\tq = (q - 1.0) * (t1 - 1.0) * (t2 - 1.0);\\n    \\t}\\n\\n    \\t\\n    \\tif (p &gt; 0) q = -q;\\n    \\telse p = -p;\\n\\n    \\t\\n    \\tif (p &lt; (0.75 * cb * q - Math.abs(tolAdj * q) / 2.0) \\n    \\t\\t&amp;&amp; p &lt; Math.abs(prevStep * q / 2.0)) { \\n\\t        newStep = p / q;\\n      \\t}\\n    }\\n\\n    if (Math.abs(newStep) &lt; tolAdj) {\\n      newStep = (newStep &gt; 0) ? tolAdj : -tolAdj;\\n    }\\n\\n    \\n    a = b;\\n    fa = fb;\\n\\n    \\n    b += newStep;\\n    fb = f(b, ...args);\\n\\n\\t\\n    if ((fb &gt; 0 &amp;&amp; fc &gt; 0) || (fb &lt; 0 &amp;&amp; fc &lt; 0)) {\\n      c = a; \\n      fc = fa;\\n    }\\n  }\\n\\n  \\n  return null;\\n}\\n\\n\\nfunction dot(v1, v2) {\\n  const n = v1.length;\\n  let result = 0.0;\\n  for (let i = 0; i &lt; n; i++) result += v1[i] * v2[i];\\n\\n  return result;\\n}\\n\\n\\nfunction transpose(A) {\\n    return A[0].map((_, colIndex) =&gt; A.map(row =&gt; row[colIndex]));\\n}\\n\\n\\nfunction mvMult(A, v) {\\n  return A.map(Arow =&gt; dot(Arow, v));\\n}\\n\\n\\nfunction mmMult(A, B) {\\n  let mA = A.length;\\n  let nA = A[0].length;\\n  let mB = B.length;\\n  let nB = B[0].length;\\n\\n  if (nA !== mB) {\\n      throw new Error(&#x27;Matrix dimension mismatch.&#x27;);\\n  }\\n\\n  let result = zeros(mA, nB);\\n\\n  for (let i = 0; i &lt; mA; i++) {\\n    for (let j = 0; j &lt; nB; j++) {\\n      for (let k = 0; k &lt; nA; k++) {\\n        result[i][j] += A[i][k] * B[k][j];\\n      }\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction vectorAdd() {\\n  let m = arguments.length;\\n  let n = arguments[0].length;\\n \\n  let result = new Array(n).fill(0.0);\\n \\n  for (let i = 0; i &lt; n; i++) {\\n    for (let j = 0; j &lt; m; j++) {\\n        result[i] += arguments[j][i];\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction deepCopy(x) {\\n  return JSON.parse(JSON.stringify(x));\\n}\\n\\n\\nfunction computeRho(r, newr, J, p) {\\n\\tlet r2 = norm(r) ** 2;\\n\\tlet num = r2 - norm(newr)**2;\\n\\tlet denom = r2 - norm(vectorAdd(r, mvMult(J, p))) ** 2;\\n\\n\\treturn num / denom;\\n}\\n\\n\\nfunction checkTol(r, tol) {\\n\\t\\n\\tconst n = r.length;\\n\\tfor (let i = 0; i &lt; n; i++) {\\n\\t\\tif (tol &lt; Math.abs(r[i])) return true;\\n\\t}\\n\\n\\treturn false;\\n}\\n\\n\\nfunction doglegStep(JTJ, JTr, normJTr, delta) {\\n\\t\\n\\tlet [pJ, posDef] = solvePosDef(JTJ, JTr);\\n\\tpJ = svMult(-1.0, pJ);\\n\\n\\t\\n\\tif (posDef &amp;&amp; norm(pJ) &lt;= delta) {\\n\\t\\treturn pJ;\\n\\t}\\n\\n\\t\\n\\tlet tau = Math.min(1, normJTr**3 / delta / quadForm(JTJ, JTr));\\n\\tlet pC = svMult(-tau * delta / normJTr, JTr);\\n\\n\\tlet pCnorm = norm(pC);\\n\\tif (!posDef || Math.abs(pCnorm - delta) &lt;= 1e-12) {\\n\\t\\treturn pC;\\n\\t}\\n\\n\\t\\n\\tlet pJ2 = norm(pJ) ** 2;\\n\\tlet pC2 = pCnorm**2;\\n\\tlet pJpC = dot(pJ, pC);\\n\\tlet a = pJ2 + pC2 - 2.0 * pJpC;\\n\\tlet b = 2.0 * (pJpC - pC2);\\n\\tlet c = pC2 - delta**2;\\n\\tlet q = -0.5 * (b + Math.sign(b) * Math.sqrt(b**2 - 4.0 * a * c));\\n\\n\\t\\n\\tlet beta;\\n\\tif (Math.abs(b) &lt; 1e-12) beta = Math.sqrt(-c / a);\\n\\telse if (b &lt; 0.0) beta = q / a;\\n\\telse beta = c / q;\\n\\n\\t\\n\\tif (0.0 &lt;= beta &amp;&amp; beta &lt;= 1) {\\n\\t\\treturn vectorAdd(pC, svMult(beta, vectorAdd(pJ, svMult(-1.0, pC))));\\n\\t} else { \\n\\t\\treturn pC;\\n\\t}\\n\\n}\\n\\n\\nfunction jacCentralDiff(f, x, args=[], eps=4.7e-6) {\\n\\t\\n\\tlet xPlus = deepCopy(x);\\n\\tlet xMinus = deepCopy(x);\\n\\n\\t\\n\\tlet fOfx = f(x, ...args);\\n\\tlet m = fOfx.length;\\n\\n\\t\\n\\tlet n = x.length;\\n\\n\\t\\n\\tlet J = zeros(m, n);\\n\\n\\t\\n\\tlet fOfxPlus;\\n\\tlet fOfxMinus;\\n\\n\\tfor (let j = 0; j &lt; n; j++) {\\n\\t\\txPlus[j] += eps;\\n\\t\\txMinus[j] -= eps;\\n\\t\\tfOfxPlus = f(xPlus, ...args);\\n\\t\\tfOfxMinus = f(xMinus, ...args);\\n\\t\\txPlus[j] -= eps;\\n\\t\\txMinus[j] += eps;\\n\\n\\t\\tfor (let i = 0; i &lt; m; i++) {\\n\\t\\t\\tJ[i][j] = (fOfxPlus[i] - fOfxMinus[i]) / 2.0 / eps;\\n\\t\\t}\\n\\t}\\n\\n\\treturn J;\\n}\\n\\n\\nfunction zeros(...dims) {\\n  let A = [];\\n\\n  \\n  for (let i = dims.length - 1; i &gt;= 0; i--) {\\n    let size = dims[i];\\n    if (i === dims.length - 1) {\\n      \\n      A = new Array(size).fill(0.0);\\n    } else {\\n      \\n      A = new Array(size).fill().map(() =&gt; deepCopy(A));\\n    }\\n  }\\n\\n  return A;\\n}\\n\\n\\nfunction svMult(a, v) {\\n  return v.map(x =&gt; a * x);\\n}\\n\\n\\nfunction quadForm(A, x) {\\n   return dot(x, mvMult(A, x)); \\n}\\n\\n\\nfunction solvePosDef(A, b) {\\n  let [L, p, success] = modifiedCholesky(A);\\n\\n  if (!success) {\\n    return [zeros(b.length), success];\\n  }\\n\\n  return [modifiedCholeskySolve(L, p, b), success];\\n}\\n\\n\\nfunction modifiedCholesky(A) {\\n    const floatEps = 1.0e-14;\\n    const n = A.length;\\n\\n    \\n    let L = deepCopy(A); \\n    let p = arange(0, n);\\n\\n    \\n    let success = true;\\n\\n    let xi = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        for (let j = 0; j &lt; i; j++) {\\n            let temp = Math.abs(L[i][j]);\\n            xi = Math.max(xi, temp);\\n        }\\n    }\\n\\n    let eta = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        let temp = Math.abs(L[i][i]);\\n        eta = Math.max(eta, temp);\\n    }\\n\\n    let beta;\\n    if (n &gt; 1) {\\n        beta = Math.sqrt(Math.max(eta, xi / Math.sqrt(n * n - 1)));\\n    } else {\\n        beta = Math.sqrt(eta);\\n    }\\n    beta = Math.max(beta, floatEps);\\n\\n    for (let k = 0; k &lt; n; k++) {\\n        \\n        let muVal = L[k][k];\\n        let mu = k;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            let temp = L[i][i];\\n            if (muVal &lt; temp) {\\n                mu = i;\\n                muVal = temp;\\n            }\\n        }\\n\\n        \\n        let iTemp = p[mu];\\n        p[mu] = p[k];\\n        p[k] = iTemp;\\n\\n        for (let i = 0; i &lt; k; i++) {\\n            let temp = L[k][i];\\n            L[k][i] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        let temp = L[k][k];\\n        L[k][k] = L[mu][mu];\\n        L[mu][mu] = temp;\\n        for (let i = k + 1; i &lt; mu; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        for (let i = mu + 1; i &lt; n; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[i][mu];\\n            L[i][mu] = temp;\\n        }\\n\\n        \\n        let cSum = 0;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            cSum = Math.max(cSum, Math.abs(L[i][k]));\\n        }\\n        cSum /= beta;\\n        cSum = cSum * cSum;\\n\\n        \\n        if (L[k][k] &lt; 0) {\\n            success = false;\\n        }\\n\\n        temp = Math.abs(L[k][k]);\\n        temp = Math.max(temp, floatEps * eta);\\n        temp = Math.max(temp, cSum);\\n        L[k][k] = Math.sqrt(temp);\\n\\n        \\n        for (let i = k + 1; i &lt; n; i++) {\\n            L[i][k] /= L[k][k];\\n        }\\n\\n        \\n        for (let j = k + 1; j &lt; n; j++) {\\n            for (let i = j; i &lt; n; i++) {\\n                L[i][j] -= L[i][k] * L[j][k];\\n            }\\n        }\\n\\n        \\n        for (let i = 0; i &lt; n - 1; i++) {\\n            for (let j = i + 1; j &lt; n; j++) {\\n                L[i][j] = 0.0;\\n            }\\n        }\\n    }\\n\\n    return [L, p, success];\\n}\\n\\n\\nfunction modifiedCholeskySolve(L, p, b) {\\n    const n = L.length;\\n\\n    let U = transpose(L);\\n    let xp = new Array(n).fill(0);\\n    for (let i = 0; i &lt; n; i++) {\\n        xp[i] = b[p[i]];\\n    }\\n\\n    \\n    let x = lowerTriSolve(L, xp);\\n\\n    \\n    xp = upperTriSolve(U, x);\\n\\n    for (let i = 0; i &lt; n; i++) {\\n        x[p[i]] = xp[i];\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction lowerTriSolve(L, b) {\\n    const floatEps = 1.0e-14;\\n    const n = L.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = 0; j &lt; n - 1; j++) {\\n        if (Math.abs(L[j][j]) &gt; floatEps) {\\n            x[j] /= L[j][j];\\n            for (let i = j + 1; i &lt; n; i++) {\\n                x[i] -= x[j] * L[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(L[n - 1][n - 1]) &gt; floatEps) {\\n            x[n - 1] /= L[n - 1][n - 1];\\n        } else {\\n            x[n - 1] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction upperTriSolve(U, b) {\\n    const floatEps = 1.0e-14;\\n    const n = U.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = n - 1; j &gt; 0; j--) {\\n        if (Math.abs(U[j][j]) &gt; floatEps) {\\n            x[j] /= U[j][j];\\n            for (let i = 0; i &lt; j; i++) {\\n                x[i] -= x[j] * U[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(U[0][0]) &gt; floatEps) {\\n            x[0] /= U[0][0];\\n        } else {\\n            x[0] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nclass InverseGammaDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;InverseGamma&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03b1&#x27;, &#x27;\\u03b2&#x27;];\\n\\n    \\n    this.paramMin = [0.0, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0.0;   \\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x &lt; 0) return NaN;\\n    if (x === 0 || x === Infinity) return 0.0;\\n\\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    let lnProb;\\n    lnProb = alpha * Math.log(beta) - (alpha + 1) * Math.log(x) - beta / x - lngamma(alpha);\\n\\n    return Math.exp(lnProb);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x &lt;= 0) return 0.0;\\n    if (x == Infinity) return 1.0;\\n\\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    return gammaincU(beta / x, alpha, true);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return 0.0;\\n    if (p === 1) return Infinity;\\n\\n    let gamma = new GammaDistribution();\\n    return 1.0 / gamma.ppf(1.0 - p, params);\\n  }\\n\\n  defaultXRange(params) {\\n    \\n    let [x1, x2] = this.ppf([0.001, 0.99], params);\\n\\n    \\n    if (x1 &lt; (x2 - x1) / 10.0) x1 = 0.0;\\n\\n    return [x1, x2];\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n\\n    let gamma = new GammaDistribution();\\n    return gamma.quantileSet([1.0 / x2, 1.0 / x1], p);\\n  }\\n\\n}\\n\\n\\n\\nvar dist = new InverseGammaDistribution();\\n\\n\\n\\nif (triggerCallbacks.active &amp;&amp; !cb_obj.disabled) {\\n\\tif (quantileSetterSwitch.active) {\\n\\t\\tquantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p);\\n\\t}\\n\\telse {\\n\\t\\tupdateData(source_p, source_c, p_p, sliders, discrete);\\n\\t\\tupdateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes);\\n\\t}\\n}"}}]]]},"width":200,"title":"\\u03b1","format":{"type":"object","name":"CustomJSTickFormatter","id":"p3013","attributes":{"code":"return tick.toPrecision(4)"}},"start":0.01,"end":2,"value":0.5,"step":0.01}},{"id":"p3016"}]],["xBoxes",[{"id":"p3021"},{"id":"p3022"}]],["pBoxes",[{"id":"p3023"},{"id":"p3024"}]],["quantileSetterSwitch",{"id":"p3026"}],["quantileSetterDiv",{"id":"p3025"}],["triggerCallbacks",{"id":"p3027"}],["startBoxes",[{"id":"p3017"},{"id":"p3018"}]],["endBoxes",[{"id":"p3019"},{"id":"p3020"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nclass GammaDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Gamma&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03b1&#x27;, &#x27;\\u03b2&#x27;];\\n\\n    \\n    this.paramMin = [0.0, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0.0;   \\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x &lt; 0) return NaN;\\n    if (x == Infinity) return 0.0;\\n\\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    if (x == 0) {\\n      if (alpha == 1) {\\n        return beta;\\n      } else if (alpha &gt; 1) {\\n        return 0.0;\\n      } else {  \\n        return Infinity;\\n      }\\n    }\\n\\n    let lnProb;\\n    lnProb = alpha * Math.log(beta * x) - Math.log(x) - beta * x - lngamma(alpha);\\n\\n    return Math.exp(lnProb);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x &lt;= 0) return 0.0;\\n    if (x == Infinity) return 1.0;\\n\\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    return gammaincL(beta * x, alpha, true);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return 0.0;\\n    if (p === 1) return Infinity;\\n\\n    \\n    let rescaledParams = [params[0], 1.0];\\n\\n    let rootFun = (xi, params, p) =&gt; {\\n        let x = xi == 1.0 ? Infinity : xi / (1.0 - xi);\\n\\n        return p - this.cdfSingleValue(x, params);\\n    }\\n\\n    let xiOpt = brentSolve(rootFun, 0.0, 1.0, [rescaledParams, p]);\\n\\n    \\n    if (xiOpt === 1) {\\n      return Infinity;\\n    }\\n\\n    \\n    let xFirstPass = xiOpt / (1.0 - xiOpt);\\n\\n    let closeRootFun = (x, params, p) =&gt; {\\n      return p - this.cdfSingleValue(x, params);\\n    }\\n\\n    let xOpt = secantSolve(xFirstPass, closeRootFun, [rescaledParams, p]);\\n\\n    let retval;\\n    if (xOpt != null &amp;&amp; closeRootFun(xOpt, rescaledParams, p) &lt; closeRootFun(xFirstPass, rescaledParams, p)) {\\n      retval = xOpt;\\n    } else {\\n      retval = xFirstPass;\\n    }\\n\\n    \\n    return retval / params[1];\\n }\\n\\n  defaultXRange(params) {\\n    let [x1, x2] = this.ppf([0.001, 0.999], params);\\n\\n    \\n    if (x1 &lt; (x2 - x1) / 10.0) x1 = 0.0;\\n\\n    return [x1, x2];\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    \\n    let x1Rescaled = x1 / x2;\\n    let x2Rescaled = 1.0;\\n\\n    \\n    const quantileRootFun = (params, x1, p1, x2, p2) =&gt; {\\n      let alpha = Math.exp(params[0]);\\n      let beta = Math.exp(params[1]);\\n\\n      let r1 = this.cdfSingleValue(x1, [alpha, beta]) - p1;\\n      let r2 = this.cdfSingleValue(x2, [alpha, beta]) - p2;\\n\\n      return [r1, r2];\\n    };\\n\\n    let args = [x1Rescaled, p1, x2Rescaled, p2];\\n\\n    let guess = [0.75, 0.75];\\n\\n    let [logParams, optimSuccess] = findRootTrustRegion(quantileRootFun, guess, args=args);\\n\\n    \\n    let paramsFirstPass = [Math.exp(logParams[0]), Math.exp(logParams[1])];\\n\\n    \\n    if (!optimSuccess) {\\n      return [[paramsFirstPass[0], paramsFirstPass[1]], optimSuccess];\\n    }\\n\\n    \\n    const closeQuantileRootFun = (params, x1, p1, x2, p2) =&gt; {\\n      let r1 = this.cdfSingleValue(x1, params) - p1;\\n      let r2 = this.cdfSingleValue(x2, params) - p2;\\n\\n      return [r1, r2];\\n    };\\n\\n    let paramsOpt;\\n    [paramsOpt, optimSuccess] = findRootTrustRegion(closeQuantileRootFun, paramsFirstPass, args=args);\\n\\n    let retval;\\n    if (optimSuccess &amp;&amp; norm(closeQuantileRootFun(paramsOpt, x1, p1, x2, p2)) &lt; norm(closeQuantileRootFun(paramsFirstPass, x1, p1, x2, p2))) {\\n      retval = paramsOpt;\\n    } else {\\n      retval = paramsFirstPass;\\n    }\\n\\n    \\n    return [[retval[0], retval[1] / x2], optimSuccess];\\n  }\\n\\n}\\n\\nfunction lngamma(z) {\\n\\n    if(z &lt; 0) return Number(&#x27;0/0&#x27;);\\n\\n    if (z &lt; 0.5) return Math.log(Math.PI) - Math.log(Math.sin(Math.PI * z)) - lngamma(1-z);\\n\\n    var p = [676.5203681218851,\\n             -1259.1392167224028,\\n             771.32342877765313,\\n             -176.61502916214059,\\n             12.507343278686905,\\n             -0.13857109526572012,\\n             9.9843695780195716e-6,\\n             1.5056327351493116e-7];\\n\\n    z -= 1.0;\\n    var Ag = 0.99999999999980993;\\n    for (var i = 0; i &lt; p.length; i++) {\\n        Ag += p[i] / (z + i + 1);\\n    }\\n    var t = z + p.length - 0.5;\\n\\n    return 0.5 * Math.log(2*Math.PI) + (z + 0.5)*Math.log(t) - t + Math.log(Ag);\\n}\\n\\n\\nfunction gammaincU(x, s, regularized) {\\n\\n  var EPSILON = 1e-12;\\n\\n  if (x &lt;= 1.1 || x &lt;= s) {\\n    if (regularized !== false) {\\n      return 1 - gammaincL(x, s, regularized);\\n    } else {\\n      return Math.exp(lngamma(s)) - gammaincL(x, s, regularized);\\n    }\\n  }\\n\\n  var f = 1 + x - s,\\n    C = f,\\n    D = 0,\\n    i = 1,\\n    a, b, chg;\\n  for (i = 1; i &lt; 10000; i++) {\\n    a = i * (s - i);\\n    b = (i&lt;&lt;1) + 1 + x - s;\\n    D = b + a * D;\\n    C = b + a / C;\\n    D = 1 / D;\\n    chg = C * D;\\n    f *= chg;\\n    if (Math.abs(chg - 1) &lt; EPSILON) {\\n      break;\\n    }\\n  }\\n  if (regularized !== false) {\\n    return Math.exp(s * Math.log(x) - x - lngamma(s) - Math.log(f));\\n  } else {\\n    return Math.exp(s * Math.log(x) - x - Math.log(f));\\n  }\\n}\\n\\n\\nfunction gammaincL(x, s, regularized) {\\n\\n  var EPSILON = 1e-12;\\n\\n  if (x === 0) {\\n    return 0;\\n  }\\n  if (x &lt; 0 || s &lt;= 0) {\\n    return NaN;\\n  }\\n\\n  if (x &gt; 1.1 &amp;&amp; x &gt; s) {\\n    if (regularized !== false) {\\n      return 1 - gammaincU(x, s, regularized);\\n    } else {\\n      return Math.exp(lngamma(s)) - gammaincU(x, s, regularized);\\n    }\\n  }\\n\\n  var ft,\\n    r = s,\\n    c = 1,\\n    pws = 1;\\n\\n  if (regularized !== false) {\\n    ft = s * Math.log(x) - x - lngamma(s);\\n  } else {\\n    ft = s * Math.log(x) - x;\\n  }\\n  ft = Math.exp(ft);\\n  do {\\n    r += 1;\\n    c *= x/r;\\n    pws += c;\\n  } while (c / pws &gt; EPSILON);\\n\\n  return pws * ft / s;\\n}\\n\\n\\nfunction norm(v) {\\n  return Math.sqrt(dot(v, v));\\n}\\n\\n\\nfunction findRootTrustRegion(\\n\\t\\tf, \\n\\t\\tx0, \\n\\t\\targs=[],\\n\\t\\tjac=jacCentralDiff,\\n\\t\\ttol=0.000000001, \\n\\t\\tmaxIters=10000, \\n\\t\\tdeltaBar=1000.0, \\n\\t\\teta=0.125, \\n\\t\\tminDelta=1e-12\\n  ) {\\n\\t\\n\\tlet x = deepCopy(x0);\\n\\n\\t\\n\\tlet delta = 0.99 * deltaBar;\\n\\n\\t\\n\\tlet r = f(x, ...args);\\n\\n\\t\\n\\tlet J = jac(f, x, args);\\n\\n\\t\\n\\tlet JTJ = mmMult(transpose(J), J);\\n\\n\\t\\n\\tlet JTr = mvMult(transpose(J), r);\\n\\n\\t\\n\\tlet normJTr = norm(JTr);\\n\\n\\tlet iters = 0;\\n\\twhile (iters &lt; maxIters &amp;&amp; checkTol(r, tol) &amp;&amp; delta &gt;= minDelta) {\\n\\t\\t\\n\\t\\tlet p = doglegStep(JTJ, JTr, normJTr, delta);\\n\\n\\t\\t\\n\\t\\tlet newr = f(vectorAdd(x, p), ...args);\\n\\t\\tlet rho = computeRho(r, newr, J, p);\\n\\n\\t\\t\\n\\t\\tif  (rho &lt; 0.25) {\\n\\t\\t\\tdelta = norm(p) / 4.0;\\n\\t\\t} else if (rho &gt; 0.75 &amp;&amp; Math.abs(norm(p) - delta) &lt; 1e-12) {\\n\\t\\t\\t\\tdelta = Math.min(2 * delta, deltaBar);\\n\\t\\t}\\n\\n\\t\\t\\n\\t\\tif (rho &gt; eta) {\\n\\t\\t\\tx = vectorAdd(x, p);\\n\\n\\t\\t\\tr = newr;\\n\\t\\t\\tJ = jac(f, x, args);\\n\\t\\t\\tJTJ = mmMult(transpose(J), J);\\n\\t\\t\\tJTr = mvMult(transpose(J), r);\\n\\t\\t\\tnormJTr = norm(JTr);\\n\\t\\t}\\n\\n\\t\\titers += 1;\\n\\t}\\n\\n\\tlet success = !checkTol(r, tol);\\n\\n\\treturn [x, success];\\n\\n}\\n\\n\\nfunction secantSolve(x0, f, args=[], tol=1e-8, maxIter=200, epsilon=1e-14, h=1e-4) {\\n\\tlet x = Infinity;\\n\\tlet solved = false;\\n\\n\\tlet x1 = x0 * (1 + h);\\n\\tx1 += x1 &gt;= 0 ? h : -h;\\n\\n\\tlet q0 = f(x0, ...args);\\n\\tlet q1 = f(x1, ...args);\\n\\t\\n\\tif (Math.abs(q1) &lt; Math.abs(q0)) {\\n\\t\\t[x0, x1, q0, q1] = [x1, x0, q1, q0];\\n\\t}\\n\\n\\tfor (let i = 0; i &lt; maxIter; i++) {\\n\\t\\tif (q0 == q1) {\\n\\t\\t\\tsolved = x0 == x1;\\n\\t\\t\\tx = (x0 + x1) / 2.0;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tif (Math.abs(q1) &gt; Math.abs(q0)) {\\n\\t\\t\\t\\tx = (x0 - q0 / q1 * x1) / (1.0 - q0 / q1);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tx = (x1 - q1 / q0 * x0) / (1.0 - q1 / q0);\\n\\t\\t\\t}\\n\\t\\t\\tif (Math.abs(x - x0) &lt;= tol) {\\n\\t\\t\\t\\tsolved = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\t[x0, q0] = [x1, q1];\\n\\t\\t\\tx1 = x;\\n\\t\\t\\tq1 = f(x1, ...args);\\n\\t\\t}\\n\\t}\\n\\n  if (solved) return x;\\n  else return null;\\n}\\n\\n\\nfunction brentSolve(f, lower, upper, args=[], tol=1e-8, maxIter=1000) {\\n\\tlet a = lower;\\n\\tlet b = upper;\\n  let fa = f(a, ...args);\\n  let fb = f(b, ...args);\\n\\n  \\n  if (Math.abs(fa) &lt; tol) return a;\\n  if (Math.abs(fb) &lt; tol) return b;\\n\\n  \\n  if (fa * fb &gt;= 0) {\\n  \\treturn null;\\n\\t}\\n\\n  \\n  let c = a;\\n  let fc = fa;\\n\\n\\tlet iter = 0;\\n  while (iter++ &lt; maxIter) {\\n  \\tlet prevStep = b - a;\\n\\n    \\n    if (Math.abs(fc) &lt; Math.abs(fb)) {      \\n    \\t[a, b, c] = [b, c, b];\\n    \\t[fa, fb, fc] = [fb, fc, fb];\\n    }\\n\\n    \\n    let newStep = (c - b) / 2.0;\\n\\n    \\n    let tolAdj = 1e-15 * Math.abs(b) + tol / 2;\\n\\n    \\n  \\tif (Math.abs(newStep) &lt;= tolAdj || fb === 0 ) {\\n    \\t\\treturn b;\\n  \\t}\\n\\n    \\n    if (Math.abs(prevStep) &gt; tolAdj &amp;&amp; Math.abs(fa) &gt; Math.abs(fb)) {\\n    \\tlet p;\\n    \\tlet q;\\n    \\tlet t1;\\n    \\tlet t2;\\n    \\tlet cb = c - b;\\n    \\tif (a === c) { \\n    \\t\\tt1 = fb / fa;\\n    \\t\\tp = cb * t1;\\n    \\t\\tq = 1.0 - t1;\\n    \\t}\\n    \\telse { \\n    \\t\\tq = fa / fc;\\n    \\t\\tt1 = fb / fc;\\n    \\t\\tt2 = fb / fa;\\n    \\t\\tp = t2 * (cb * q * (q - t1) - (b - a) * (t1 - 1.0));\\n    \\t\\tq = (q - 1.0) * (t1 - 1.0) * (t2 - 1.0);\\n    \\t}\\n\\n    \\t\\n    \\tif (p &gt; 0) q = -q;\\n    \\telse p = -p;\\n\\n    \\t\\n    \\tif (p &lt; (0.75 * cb * q - Math.abs(tolAdj * q) / 2.0) \\n    \\t\\t&amp;&amp; p &lt; Math.abs(prevStep * q / 2.0)) { \\n\\t        newStep = p / q;\\n      \\t}\\n    }\\n\\n    if (Math.abs(newStep) &lt; tolAdj) {\\n      newStep = (newStep &gt; 0) ? tolAdj : -tolAdj;\\n    }\\n\\n    \\n    a = b;\\n    fa = fb;\\n\\n    \\n    b += newStep;\\n    fb = f(b, ...args);\\n\\n\\t\\n    if ((fb &gt; 0 &amp;&amp; fc &gt; 0) || (fb &lt; 0 &amp;&amp; fc &lt; 0)) {\\n      c = a; \\n      fc = fa;\\n    }\\n  }\\n\\n  \\n  return null;\\n}\\n\\n\\nfunction dot(v1, v2) {\\n  const n = v1.length;\\n  let result = 0.0;\\n  for (let i = 0; i &lt; n; i++) result += v1[i] * v2[i];\\n\\n  return result;\\n}\\n\\n\\nfunction transpose(A) {\\n    return A[0].map((_, colIndex) =&gt; A.map(row =&gt; row[colIndex]));\\n}\\n\\n\\nfunction mvMult(A, v) {\\n  return A.map(Arow =&gt; dot(Arow, v));\\n}\\n\\n\\nfunction mmMult(A, B) {\\n  let mA = A.length;\\n  let nA = A[0].length;\\n  let mB = B.length;\\n  let nB = B[0].length;\\n\\n  if (nA !== mB) {\\n      throw new Error(&#x27;Matrix dimension mismatch.&#x27;);\\n  }\\n\\n  let result = zeros(mA, nB);\\n\\n  for (let i = 0; i &lt; mA; i++) {\\n    for (let j = 0; j &lt; nB; j++) {\\n      for (let k = 0; k &lt; nA; k++) {\\n        result[i][j] += A[i][k] * B[k][j];\\n      }\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction vectorAdd() {\\n  let m = arguments.length;\\n  let n = arguments[0].length;\\n \\n  let result = new Array(n).fill(0.0);\\n \\n  for (let i = 0; i &lt; n; i++) {\\n    for (let j = 0; j &lt; m; j++) {\\n        result[i] += arguments[j][i];\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction deepCopy(x) {\\n  return JSON.parse(JSON.stringify(x));\\n}\\n\\n\\nfunction computeRho(r, newr, J, p) {\\n\\tlet r2 = norm(r) ** 2;\\n\\tlet num = r2 - norm(newr)**2;\\n\\tlet denom = r2 - norm(vectorAdd(r, mvMult(J, p))) ** 2;\\n\\n\\treturn num / denom;\\n}\\n\\n\\nfunction checkTol(r, tol) {\\n\\t\\n\\tconst n = r.length;\\n\\tfor (let i = 0; i &lt; n; i++) {\\n\\t\\tif (tol &lt; Math.abs(r[i])) return true;\\n\\t}\\n\\n\\treturn false;\\n}\\n\\n\\nfunction doglegStep(JTJ, JTr, normJTr, delta) {\\n\\t\\n\\tlet [pJ, posDef] = solvePosDef(JTJ, JTr);\\n\\tpJ = svMult(-1.0, pJ);\\n\\n\\t\\n\\tif (posDef &amp;&amp; norm(pJ) &lt;= delta) {\\n\\t\\treturn pJ;\\n\\t}\\n\\n\\t\\n\\tlet tau = Math.min(1, normJTr**3 / delta / quadForm(JTJ, JTr));\\n\\tlet pC = svMult(-tau * delta / normJTr, JTr);\\n\\n\\tlet pCnorm = norm(pC);\\n\\tif (!posDef || Math.abs(pCnorm - delta) &lt;= 1e-12) {\\n\\t\\treturn pC;\\n\\t}\\n\\n\\t\\n\\tlet pJ2 = norm(pJ) ** 2;\\n\\tlet pC2 = pCnorm**2;\\n\\tlet pJpC = dot(pJ, pC);\\n\\tlet a = pJ2 + pC2 - 2.0 * pJpC;\\n\\tlet b = 2.0 * (pJpC - pC2);\\n\\tlet c = pC2 - delta**2;\\n\\tlet q = -0.5 * (b + Math.sign(b) * Math.sqrt(b**2 - 4.0 * a * c));\\n\\n\\t\\n\\tlet beta;\\n\\tif (Math.abs(b) &lt; 1e-12) beta = Math.sqrt(-c / a);\\n\\telse if (b &lt; 0.0) beta = q / a;\\n\\telse beta = c / q;\\n\\n\\t\\n\\tif (0.0 &lt;= beta &amp;&amp; beta &lt;= 1) {\\n\\t\\treturn vectorAdd(pC, svMult(beta, vectorAdd(pJ, svMult(-1.0, pC))));\\n\\t} else { \\n\\t\\treturn pC;\\n\\t}\\n\\n}\\n\\n\\nfunction jacCentralDiff(f, x, args=[], eps=4.7e-6) {\\n\\t\\n\\tlet xPlus = deepCopy(x);\\n\\tlet xMinus = deepCopy(x);\\n\\n\\t\\n\\tlet fOfx = f(x, ...args);\\n\\tlet m = fOfx.length;\\n\\n\\t\\n\\tlet n = x.length;\\n\\n\\t\\n\\tlet J = zeros(m, n);\\n\\n\\t\\n\\tlet fOfxPlus;\\n\\tlet fOfxMinus;\\n\\n\\tfor (let j = 0; j &lt; n; j++) {\\n\\t\\txPlus[j] += eps;\\n\\t\\txMinus[j] -= eps;\\n\\t\\tfOfxPlus = f(xPlus, ...args);\\n\\t\\tfOfxMinus = f(xMinus, ...args);\\n\\t\\txPlus[j] -= eps;\\n\\t\\txMinus[j] += eps;\\n\\n\\t\\tfor (let i = 0; i &lt; m; i++) {\\n\\t\\t\\tJ[i][j] = (fOfxPlus[i] - fOfxMinus[i]) / 2.0 / eps;\\n\\t\\t}\\n\\t}\\n\\n\\treturn J;\\n}\\n\\n\\nfunction zeros(...dims) {\\n  let A = [];\\n\\n  \\n  for (let i = dims.length - 1; i &gt;= 0; i--) {\\n    let size = dims[i];\\n    if (i === dims.length - 1) {\\n      \\n      A = new Array(size).fill(0.0);\\n    } else {\\n      \\n      A = new Array(size).fill().map(() =&gt; deepCopy(A));\\n    }\\n  }\\n\\n  return A;\\n}\\n\\n\\nfunction svMult(a, v) {\\n  return v.map(x =&gt; a * x);\\n}\\n\\n\\nfunction quadForm(A, x) {\\n   return dot(x, mvMult(A, x)); \\n}\\n\\n\\nfunction solvePosDef(A, b) {\\n  let [L, p, success] = modifiedCholesky(A);\\n\\n  if (!success) {\\n    return [zeros(b.length), success];\\n  }\\n\\n  return [modifiedCholeskySolve(L, p, b), success];\\n}\\n\\n\\nfunction modifiedCholesky(A) {\\n    const floatEps = 1.0e-14;\\n    const n = A.length;\\n\\n    \\n    let L = deepCopy(A); \\n    let p = arange(0, n);\\n\\n    \\n    let success = true;\\n\\n    let xi = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        for (let j = 0; j &lt; i; j++) {\\n            let temp = Math.abs(L[i][j]);\\n            xi = Math.max(xi, temp);\\n        }\\n    }\\n\\n    let eta = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        let temp = Math.abs(L[i][i]);\\n        eta = Math.max(eta, temp);\\n    }\\n\\n    let beta;\\n    if (n &gt; 1) {\\n        beta = Math.sqrt(Math.max(eta, xi / Math.sqrt(n * n - 1)));\\n    } else {\\n        beta = Math.sqrt(eta);\\n    }\\n    beta = Math.max(beta, floatEps);\\n\\n    for (let k = 0; k &lt; n; k++) {\\n        \\n        let muVal = L[k][k];\\n        let mu = k;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            let temp = L[i][i];\\n            if (muVal &lt; temp) {\\n                mu = i;\\n                muVal = temp;\\n            }\\n        }\\n\\n        \\n        let iTemp = p[mu];\\n        p[mu] = p[k];\\n        p[k] = iTemp;\\n\\n        for (let i = 0; i &lt; k; i++) {\\n            let temp = L[k][i];\\n            L[k][i] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        let temp = L[k][k];\\n        L[k][k] = L[mu][mu];\\n        L[mu][mu] = temp;\\n        for (let i = k + 1; i &lt; mu; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        for (let i = mu + 1; i &lt; n; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[i][mu];\\n            L[i][mu] = temp;\\n        }\\n\\n        \\n        let cSum = 0;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            cSum = Math.max(cSum, Math.abs(L[i][k]));\\n        }\\n        cSum /= beta;\\n        cSum = cSum * cSum;\\n\\n        \\n        if (L[k][k] &lt; 0) {\\n            success = false;\\n        }\\n\\n        temp = Math.abs(L[k][k]);\\n        temp = Math.max(temp, floatEps * eta);\\n        temp = Math.max(temp, cSum);\\n        L[k][k] = Math.sqrt(temp);\\n\\n        \\n        for (let i = k + 1; i &lt; n; i++) {\\n            L[i][k] /= L[k][k];\\n        }\\n\\n        \\n        for (let j = k + 1; j &lt; n; j++) {\\n            for (let i = j; i &lt; n; i++) {\\n                L[i][j] -= L[i][k] * L[j][k];\\n            }\\n        }\\n\\n        \\n        for (let i = 0; i &lt; n - 1; i++) {\\n            for (let j = i + 1; j &lt; n; j++) {\\n                L[i][j] = 0.0;\\n            }\\n        }\\n    }\\n\\n    return [L, p, success];\\n}\\n\\n\\nfunction modifiedCholeskySolve(L, p, b) {\\n    const n = L.length;\\n\\n    let U = transpose(L);\\n    let xp = new Array(n).fill(0);\\n    for (let i = 0; i &lt; n; i++) {\\n        xp[i] = b[p[i]];\\n    }\\n\\n    \\n    let x = lowerTriSolve(L, xp);\\n\\n    \\n    xp = upperTriSolve(U, x);\\n\\n    for (let i = 0; i &lt; n; i++) {\\n        x[p[i]] = xp[i];\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction lowerTriSolve(L, b) {\\n    const floatEps = 1.0e-14;\\n    const n = L.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = 0; j &lt; n - 1; j++) {\\n        if (Math.abs(L[j][j]) &gt; floatEps) {\\n            x[j] /= L[j][j];\\n            for (let i = j + 1; i &lt; n; i++) {\\n                x[i] -= x[j] * L[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(L[n - 1][n - 1]) &gt; floatEps) {\\n            x[n - 1] /= L[n - 1][n - 1];\\n        } else {\\n            x[n - 1] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction upperTriSolve(U, b) {\\n    const floatEps = 1.0e-14;\\n    const n = U.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = n - 1; j &gt; 0; j--) {\\n        if (Math.abs(U[j][j]) &gt; floatEps) {\\n            x[j] /= U[j][j];\\n            for (let i = 0; i &lt; j; i++) {\\n                x[i] -= x[j] * U[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(U[0][0]) &gt; floatEps) {\\n            x[0] /= U[0][0];\\n        } else {\\n            x[0] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nclass InverseGammaDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;InverseGamma&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03b1&#x27;, &#x27;\\u03b2&#x27;];\\n\\n    \\n    this.paramMin = [0.0, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0.0;   \\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x &lt; 0) return NaN;\\n    if (x === 0 || x === Infinity) return 0.0;\\n\\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    let lnProb;\\n    lnProb = alpha * Math.log(beta) - (alpha + 1) * Math.log(x) - beta / x - lngamma(alpha);\\n\\n    return Math.exp(lnProb);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x &lt;= 0) return 0.0;\\n    if (x == Infinity) return 1.0;\\n\\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    return gammaincU(beta / x, alpha, true);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return 0.0;\\n    if (p === 1) return Infinity;\\n\\n    let gamma = new GammaDistribution();\\n    return 1.0 / gamma.ppf(1.0 - p, params);\\n  }\\n\\n  defaultXRange(params) {\\n    \\n    let [x1, x2] = this.ppf([0.001, 0.99], params);\\n\\n    \\n    if (x1 &lt; (x2 - x1) / 10.0) x1 = 0.0;\\n\\n    return [x1, x2];\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n\\n    let gamma = new GammaDistribution();\\n    return gamma.quantileSet([1.0 / x2, 1.0 / x1], p);\\n  }\\n\\n}\\n\\n\\n\\nvar dist = new InverseGammaDistribution();\\n\\n\\n\\nlet params = paramsFromSliders(sliders); \\n\\n\\nlet [x1, x2] = dist.defaultXRange(params);\\n\\n\\ntriggerCallbacks.active = false;\\n\\n\\np_p.x_range.start = x1;\\np_p.x_range.end = x2;\\n\\nupdateData(source_p, source_c, p_p, sliders, discrete);\\n\\n\\nsetYRanges(p_p, p_c, source_p);  \\n\\ntriggerCallbacks.active = true;\\n"}}]]]},"x_range":{"id":"p2987"},"y_range":{"type":"object","name":"Range1d","id":"p2988"},"x_scale":{"type":"object","name":"LinearScale","id":"p2965"},"y_scale":{"type":"object","name":"LinearScale","id":"p2966"},"title":{"type":"object","name":"Title","id":"p2958","attributes":{"text":" "}},"renderers":[{"type":"object","name":"GlyphRenderer","id":"p3001","attributes":{"data_source":{"id":"p2992"},"view":{"type":"object","name":"CDSView","id":"p3002","attributes":{"filter":{"type":"object","name":"AllIndices","id":"p3003"}}},"glyph":{"type":"object","name":"Line","id":"p2998","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_width":2}},"nonselection_glyph":{"type":"object","name":"Line","id":"p2999","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_alpha":0.1,"line_width":2}},"muted_glyph":{"type":"object","name":"Line","id":"p3000","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_alpha":0.2,"line_width":2}}}}],"toolbar":{"type":"object","name":"Toolbar","id":"p2964","attributes":{"tools":[{"type":"object","name":"PanTool","id":"p2977"},{"type":"object","name":"BoxZoomTool","id":"p2978","attributes":{"overlay":{"type":"object","name":"BoxAnnotation","id":"p2979","attributes":{"syncable":false,"level":"overlay","visible":false,"left":{"type":"number","value":"nan"},"right":{"type":"number","value":"nan"},"top":{"type":"number","value":"nan"},"bottom":{"type":"number","value":"nan"},"left_units":"canvas","right_units":"canvas","top_units":"canvas","bottom_units":"canvas","line_color":"black","line_alpha":1.0,"line_width":2,"line_dash":[4,4],"fill_color":"lightgrey","fill_alpha":0.5}}}},{"type":"object","name":"WheelZoomTool","id":"p2984","attributes":{"renderers":"auto"}},{"type":"object","name":"SaveTool","id":"p2985"},{"type":"object","name":"ResetTool","id":"p2986"}]}},"toolbar_location":null,"left":[{"type":"object","name":"LinearAxis","id":"p2972","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p2973","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p2974"},"axis_label":"CDF","axis_label_text_font_style":"normal","major_label_policy":{"type":"object","name":"AllLabels","id":"p2975"}}}],"below":[{"type":"object","name":"LinearAxis","id":"p2967","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p2968","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p2969"},"axis_label":"y","major_label_policy":{"type":"object","name":"AllLabels","id":"p2970"}}}],"center":[{"type":"object","name":"Grid","id":"p2971","attributes":{"axis":{"id":"p2967"}}},{"type":"object","name":"Grid","id":"p2976","attributes":{"dimension":1,"axis":{"id":"p2972"}}}],"frame_width":300,"frame_height":175,"background_fill_alpha":0,"border_fill_alpha":0}}],["source_p",{"id":"p2989"}],["source_c",{"id":"p2992"}],["discrete",false],["n",400],["sliders",[{"id":"p3014"},{"id":"p3016"}]],["xBoxes",[{"id":"p3021"},{"id":"p3022"}]],["pBoxes",[{"id":"p3023"},{"id":"p3024"}]],["quantileSetterSwitch",{"id":"p3026"}],["quantileSetterDiv",{"id":"p3025"}],["triggerCallbacks",{"id":"p3027"}],["startBoxes",[{"id":"p3017"},{"id":"p3018"}]],["endBoxes",[{"id":"p3019"},{"id":"p3020"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nclass GammaDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Gamma&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03b1&#x27;, &#x27;\\u03b2&#x27;];\\n\\n    \\n    this.paramMin = [0.0, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0.0;   \\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x &lt; 0) return NaN;\\n    if (x == Infinity) return 0.0;\\n\\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    if (x == 0) {\\n      if (alpha == 1) {\\n        return beta;\\n      } else if (alpha &gt; 1) {\\n        return 0.0;\\n      } else {  \\n        return Infinity;\\n      }\\n    }\\n\\n    let lnProb;\\n    lnProb = alpha * Math.log(beta * x) - Math.log(x) - beta * x - lngamma(alpha);\\n\\n    return Math.exp(lnProb);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x &lt;= 0) return 0.0;\\n    if (x == Infinity) return 1.0;\\n\\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    return gammaincL(beta * x, alpha, true);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return 0.0;\\n    if (p === 1) return Infinity;\\n\\n    \\n    let rescaledParams = [params[0], 1.0];\\n\\n    let rootFun = (xi, params, p) =&gt; {\\n        let x = xi == 1.0 ? Infinity : xi / (1.0 - xi);\\n\\n        return p - this.cdfSingleValue(x, params);\\n    }\\n\\n    let xiOpt = brentSolve(rootFun, 0.0, 1.0, [rescaledParams, p]);\\n\\n    \\n    if (xiOpt === 1) {\\n      return Infinity;\\n    }\\n\\n    \\n    let xFirstPass = xiOpt / (1.0 - xiOpt);\\n\\n    let closeRootFun = (x, params, p) =&gt; {\\n      return p - this.cdfSingleValue(x, params);\\n    }\\n\\n    let xOpt = secantSolve(xFirstPass, closeRootFun, [rescaledParams, p]);\\n\\n    let retval;\\n    if (xOpt != null &amp;&amp; closeRootFun(xOpt, rescaledParams, p) &lt; closeRootFun(xFirstPass, rescaledParams, p)) {\\n      retval = xOpt;\\n    } else {\\n      retval = xFirstPass;\\n    }\\n\\n    \\n    return retval / params[1];\\n }\\n\\n  defaultXRange(params) {\\n    let [x1, x2] = this.ppf([0.001, 0.999], params);\\n\\n    \\n    if (x1 &lt; (x2 - x1) / 10.0) x1 = 0.0;\\n\\n    return [x1, x2];\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    \\n    let x1Rescaled = x1 / x2;\\n    let x2Rescaled = 1.0;\\n\\n    \\n    const quantileRootFun = (params, x1, p1, x2, p2) =&gt; {\\n      let alpha = Math.exp(params[0]);\\n      let beta = Math.exp(params[1]);\\n\\n      let r1 = this.cdfSingleValue(x1, [alpha, beta]) - p1;\\n      let r2 = this.cdfSingleValue(x2, [alpha, beta]) - p2;\\n\\n      return [r1, r2];\\n    };\\n\\n    let args = [x1Rescaled, p1, x2Rescaled, p2];\\n\\n    let guess = [0.75, 0.75];\\n\\n    let [logParams, optimSuccess] = findRootTrustRegion(quantileRootFun, guess, args=args);\\n\\n    \\n    let paramsFirstPass = [Math.exp(logParams[0]), Math.exp(logParams[1])];\\n\\n    \\n    if (!optimSuccess) {\\n      return [[paramsFirstPass[0], paramsFirstPass[1]], optimSuccess];\\n    }\\n\\n    \\n    const closeQuantileRootFun = (params, x1, p1, x2, p2) =&gt; {\\n      let r1 = this.cdfSingleValue(x1, params) - p1;\\n      let r2 = this.cdfSingleValue(x2, params) - p2;\\n\\n      return [r1, r2];\\n    };\\n\\n    let paramsOpt;\\n    [paramsOpt, optimSuccess] = findRootTrustRegion(closeQuantileRootFun, paramsFirstPass, args=args);\\n\\n    let retval;\\n    if (optimSuccess &amp;&amp; norm(closeQuantileRootFun(paramsOpt, x1, p1, x2, p2)) &lt; norm(closeQuantileRootFun(paramsFirstPass, x1, p1, x2, p2))) {\\n      retval = paramsOpt;\\n    } else {\\n      retval = paramsFirstPass;\\n    }\\n\\n    \\n    return [[retval[0], retval[1] / x2], optimSuccess];\\n  }\\n\\n}\\n\\nfunction lngamma(z) {\\n\\n    if(z &lt; 0) return Number(&#x27;0/0&#x27;);\\n\\n    if (z &lt; 0.5) return Math.log(Math.PI) - Math.log(Math.sin(Math.PI * z)) - lngamma(1-z);\\n\\n    var p = [676.5203681218851,\\n             -1259.1392167224028,\\n             771.32342877765313,\\n             -176.61502916214059,\\n             12.507343278686905,\\n             -0.13857109526572012,\\n             9.9843695780195716e-6,\\n             1.5056327351493116e-7];\\n\\n    z -= 1.0;\\n    var Ag = 0.99999999999980993;\\n    for (var i = 0; i &lt; p.length; i++) {\\n        Ag += p[i] / (z + i + 1);\\n    }\\n    var t = z + p.length - 0.5;\\n\\n    return 0.5 * Math.log(2*Math.PI) + (z + 0.5)*Math.log(t) - t + Math.log(Ag);\\n}\\n\\n\\nfunction gammaincU(x, s, regularized) {\\n\\n  var EPSILON = 1e-12;\\n\\n  if (x &lt;= 1.1 || x &lt;= s) {\\n    if (regularized !== false) {\\n      return 1 - gammaincL(x, s, regularized);\\n    } else {\\n      return Math.exp(lngamma(s)) - gammaincL(x, s, regularized);\\n    }\\n  }\\n\\n  var f = 1 + x - s,\\n    C = f,\\n    D = 0,\\n    i = 1,\\n    a, b, chg;\\n  for (i = 1; i &lt; 10000; i++) {\\n    a = i * (s - i);\\n    b = (i&lt;&lt;1) + 1 + x - s;\\n    D = b + a * D;\\n    C = b + a / C;\\n    D = 1 / D;\\n    chg = C * D;\\n    f *= chg;\\n    if (Math.abs(chg - 1) &lt; EPSILON) {\\n      break;\\n    }\\n  }\\n  if (regularized !== false) {\\n    return Math.exp(s * Math.log(x) - x - lngamma(s) - Math.log(f));\\n  } else {\\n    return Math.exp(s * Math.log(x) - x - Math.log(f));\\n  }\\n}\\n\\n\\nfunction gammaincL(x, s, regularized) {\\n\\n  var EPSILON = 1e-12;\\n\\n  if (x === 0) {\\n    return 0;\\n  }\\n  if (x &lt; 0 || s &lt;= 0) {\\n    return NaN;\\n  }\\n\\n  if (x &gt; 1.1 &amp;&amp; x &gt; s) {\\n    if (regularized !== false) {\\n      return 1 - gammaincU(x, s, regularized);\\n    } else {\\n      return Math.exp(lngamma(s)) - gammaincU(x, s, regularized);\\n    }\\n  }\\n\\n  var ft,\\n    r = s,\\n    c = 1,\\n    pws = 1;\\n\\n  if (regularized !== false) {\\n    ft = s * Math.log(x) - x - lngamma(s);\\n  } else {\\n    ft = s * Math.log(x) - x;\\n  }\\n  ft = Math.exp(ft);\\n  do {\\n    r += 1;\\n    c *= x/r;\\n    pws += c;\\n  } while (c / pws &gt; EPSILON);\\n\\n  return pws * ft / s;\\n}\\n\\n\\nfunction norm(v) {\\n  return Math.sqrt(dot(v, v));\\n}\\n\\n\\nfunction findRootTrustRegion(\\n\\t\\tf, \\n\\t\\tx0, \\n\\t\\targs=[],\\n\\t\\tjac=jacCentralDiff,\\n\\t\\ttol=0.000000001, \\n\\t\\tmaxIters=10000, \\n\\t\\tdeltaBar=1000.0, \\n\\t\\teta=0.125, \\n\\t\\tminDelta=1e-12\\n  ) {\\n\\t\\n\\tlet x = deepCopy(x0);\\n\\n\\t\\n\\tlet delta = 0.99 * deltaBar;\\n\\n\\t\\n\\tlet r = f(x, ...args);\\n\\n\\t\\n\\tlet J = jac(f, x, args);\\n\\n\\t\\n\\tlet JTJ = mmMult(transpose(J), J);\\n\\n\\t\\n\\tlet JTr = mvMult(transpose(J), r);\\n\\n\\t\\n\\tlet normJTr = norm(JTr);\\n\\n\\tlet iters = 0;\\n\\twhile (iters &lt; maxIters &amp;&amp; checkTol(r, tol) &amp;&amp; delta &gt;= minDelta) {\\n\\t\\t\\n\\t\\tlet p = doglegStep(JTJ, JTr, normJTr, delta);\\n\\n\\t\\t\\n\\t\\tlet newr = f(vectorAdd(x, p), ...args);\\n\\t\\tlet rho = computeRho(r, newr, J, p);\\n\\n\\t\\t\\n\\t\\tif  (rho &lt; 0.25) {\\n\\t\\t\\tdelta = norm(p) / 4.0;\\n\\t\\t} else if (rho &gt; 0.75 &amp;&amp; Math.abs(norm(p) - delta) &lt; 1e-12) {\\n\\t\\t\\t\\tdelta = Math.min(2 * delta, deltaBar);\\n\\t\\t}\\n\\n\\t\\t\\n\\t\\tif (rho &gt; eta) {\\n\\t\\t\\tx = vectorAdd(x, p);\\n\\n\\t\\t\\tr = newr;\\n\\t\\t\\tJ = jac(f, x, args);\\n\\t\\t\\tJTJ = mmMult(transpose(J), J);\\n\\t\\t\\tJTr = mvMult(transpose(J), r);\\n\\t\\t\\tnormJTr = norm(JTr);\\n\\t\\t}\\n\\n\\t\\titers += 1;\\n\\t}\\n\\n\\tlet success = !checkTol(r, tol);\\n\\n\\treturn [x, success];\\n\\n}\\n\\n\\nfunction secantSolve(x0, f, args=[], tol=1e-8, maxIter=200, epsilon=1e-14, h=1e-4) {\\n\\tlet x = Infinity;\\n\\tlet solved = false;\\n\\n\\tlet x1 = x0 * (1 + h);\\n\\tx1 += x1 &gt;= 0 ? h : -h;\\n\\n\\tlet q0 = f(x0, ...args);\\n\\tlet q1 = f(x1, ...args);\\n\\t\\n\\tif (Math.abs(q1) &lt; Math.abs(q0)) {\\n\\t\\t[x0, x1, q0, q1] = [x1, x0, q1, q0];\\n\\t}\\n\\n\\tfor (let i = 0; i &lt; maxIter; i++) {\\n\\t\\tif (q0 == q1) {\\n\\t\\t\\tsolved = x0 == x1;\\n\\t\\t\\tx = (x0 + x1) / 2.0;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tif (Math.abs(q1) &gt; Math.abs(q0)) {\\n\\t\\t\\t\\tx = (x0 - q0 / q1 * x1) / (1.0 - q0 / q1);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tx = (x1 - q1 / q0 * x0) / (1.0 - q1 / q0);\\n\\t\\t\\t}\\n\\t\\t\\tif (Math.abs(x - x0) &lt;= tol) {\\n\\t\\t\\t\\tsolved = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\t[x0, q0] = [x1, q1];\\n\\t\\t\\tx1 = x;\\n\\t\\t\\tq1 = f(x1, ...args);\\n\\t\\t}\\n\\t}\\n\\n  if (solved) return x;\\n  else return null;\\n}\\n\\n\\nfunction brentSolve(f, lower, upper, args=[], tol=1e-8, maxIter=1000) {\\n\\tlet a = lower;\\n\\tlet b = upper;\\n  let fa = f(a, ...args);\\n  let fb = f(b, ...args);\\n\\n  \\n  if (Math.abs(fa) &lt; tol) return a;\\n  if (Math.abs(fb) &lt; tol) return b;\\n\\n  \\n  if (fa * fb &gt;= 0) {\\n  \\treturn null;\\n\\t}\\n\\n  \\n  let c = a;\\n  let fc = fa;\\n\\n\\tlet iter = 0;\\n  while (iter++ &lt; maxIter) {\\n  \\tlet prevStep = b - a;\\n\\n    \\n    if (Math.abs(fc) &lt; Math.abs(fb)) {      \\n    \\t[a, b, c] = [b, c, b];\\n    \\t[fa, fb, fc] = [fb, fc, fb];\\n    }\\n\\n    \\n    let newStep = (c - b) / 2.0;\\n\\n    \\n    let tolAdj = 1e-15 * Math.abs(b) + tol / 2;\\n\\n    \\n  \\tif (Math.abs(newStep) &lt;= tolAdj || fb === 0 ) {\\n    \\t\\treturn b;\\n  \\t}\\n\\n    \\n    if (Math.abs(prevStep) &gt; tolAdj &amp;&amp; Math.abs(fa) &gt; Math.abs(fb)) {\\n    \\tlet p;\\n    \\tlet q;\\n    \\tlet t1;\\n    \\tlet t2;\\n    \\tlet cb = c - b;\\n    \\tif (a === c) { \\n    \\t\\tt1 = fb / fa;\\n    \\t\\tp = cb * t1;\\n    \\t\\tq = 1.0 - t1;\\n    \\t}\\n    \\telse { \\n    \\t\\tq = fa / fc;\\n    \\t\\tt1 = fb / fc;\\n    \\t\\tt2 = fb / fa;\\n    \\t\\tp = t2 * (cb * q * (q - t1) - (b - a) * (t1 - 1.0));\\n    \\t\\tq = (q - 1.0) * (t1 - 1.0) * (t2 - 1.0);\\n    \\t}\\n\\n    \\t\\n    \\tif (p &gt; 0) q = -q;\\n    \\telse p = -p;\\n\\n    \\t\\n    \\tif (p &lt; (0.75 * cb * q - Math.abs(tolAdj * q) / 2.0) \\n    \\t\\t&amp;&amp; p &lt; Math.abs(prevStep * q / 2.0)) { \\n\\t        newStep = p / q;\\n      \\t}\\n    }\\n\\n    if (Math.abs(newStep) &lt; tolAdj) {\\n      newStep = (newStep &gt; 0) ? tolAdj : -tolAdj;\\n    }\\n\\n    \\n    a = b;\\n    fa = fb;\\n\\n    \\n    b += newStep;\\n    fb = f(b, ...args);\\n\\n\\t\\n    if ((fb &gt; 0 &amp;&amp; fc &gt; 0) || (fb &lt; 0 &amp;&amp; fc &lt; 0)) {\\n      c = a; \\n      fc = fa;\\n    }\\n  }\\n\\n  \\n  return null;\\n}\\n\\n\\nfunction dot(v1, v2) {\\n  const n = v1.length;\\n  let result = 0.0;\\n  for (let i = 0; i &lt; n; i++) result += v1[i] * v2[i];\\n\\n  return result;\\n}\\n\\n\\nfunction transpose(A) {\\n    return A[0].map((_, colIndex) =&gt; A.map(row =&gt; row[colIndex]));\\n}\\n\\n\\nfunction mvMult(A, v) {\\n  return A.map(Arow =&gt; dot(Arow, v));\\n}\\n\\n\\nfunction mmMult(A, B) {\\n  let mA = A.length;\\n  let nA = A[0].length;\\n  let mB = B.length;\\n  let nB = B[0].length;\\n\\n  if (nA !== mB) {\\n      throw new Error(&#x27;Matrix dimension mismatch.&#x27;);\\n  }\\n\\n  let result = zeros(mA, nB);\\n\\n  for (let i = 0; i &lt; mA; i++) {\\n    for (let j = 0; j &lt; nB; j++) {\\n      for (let k = 0; k &lt; nA; k++) {\\n        result[i][j] += A[i][k] * B[k][j];\\n      }\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction vectorAdd() {\\n  let m = arguments.length;\\n  let n = arguments[0].length;\\n \\n  let result = new Array(n).fill(0.0);\\n \\n  for (let i = 0; i &lt; n; i++) {\\n    for (let j = 0; j &lt; m; j++) {\\n        result[i] += arguments[j][i];\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction deepCopy(x) {\\n  return JSON.parse(JSON.stringify(x));\\n}\\n\\n\\nfunction computeRho(r, newr, J, p) {\\n\\tlet r2 = norm(r) ** 2;\\n\\tlet num = r2 - norm(newr)**2;\\n\\tlet denom = r2 - norm(vectorAdd(r, mvMult(J, p))) ** 2;\\n\\n\\treturn num / denom;\\n}\\n\\n\\nfunction checkTol(r, tol) {\\n\\t\\n\\tconst n = r.length;\\n\\tfor (let i = 0; i &lt; n; i++) {\\n\\t\\tif (tol &lt; Math.abs(r[i])) return true;\\n\\t}\\n\\n\\treturn false;\\n}\\n\\n\\nfunction doglegStep(JTJ, JTr, normJTr, delta) {\\n\\t\\n\\tlet [pJ, posDef] = solvePosDef(JTJ, JTr);\\n\\tpJ = svMult(-1.0, pJ);\\n\\n\\t\\n\\tif (posDef &amp;&amp; norm(pJ) &lt;= delta) {\\n\\t\\treturn pJ;\\n\\t}\\n\\n\\t\\n\\tlet tau = Math.min(1, normJTr**3 / delta / quadForm(JTJ, JTr));\\n\\tlet pC = svMult(-tau * delta / normJTr, JTr);\\n\\n\\tlet pCnorm = norm(pC);\\n\\tif (!posDef || Math.abs(pCnorm - delta) &lt;= 1e-12) {\\n\\t\\treturn pC;\\n\\t}\\n\\n\\t\\n\\tlet pJ2 = norm(pJ) ** 2;\\n\\tlet pC2 = pCnorm**2;\\n\\tlet pJpC = dot(pJ, pC);\\n\\tlet a = pJ2 + pC2 - 2.0 * pJpC;\\n\\tlet b = 2.0 * (pJpC - pC2);\\n\\tlet c = pC2 - delta**2;\\n\\tlet q = -0.5 * (b + Math.sign(b) * Math.sqrt(b**2 - 4.0 * a * c));\\n\\n\\t\\n\\tlet beta;\\n\\tif (Math.abs(b) &lt; 1e-12) beta = Math.sqrt(-c / a);\\n\\telse if (b &lt; 0.0) beta = q / a;\\n\\telse beta = c / q;\\n\\n\\t\\n\\tif (0.0 &lt;= beta &amp;&amp; beta &lt;= 1) {\\n\\t\\treturn vectorAdd(pC, svMult(beta, vectorAdd(pJ, svMult(-1.0, pC))));\\n\\t} else { \\n\\t\\treturn pC;\\n\\t}\\n\\n}\\n\\n\\nfunction jacCentralDiff(f, x, args=[], eps=4.7e-6) {\\n\\t\\n\\tlet xPlus = deepCopy(x);\\n\\tlet xMinus = deepCopy(x);\\n\\n\\t\\n\\tlet fOfx = f(x, ...args);\\n\\tlet m = fOfx.length;\\n\\n\\t\\n\\tlet n = x.length;\\n\\n\\t\\n\\tlet J = zeros(m, n);\\n\\n\\t\\n\\tlet fOfxPlus;\\n\\tlet fOfxMinus;\\n\\n\\tfor (let j = 0; j &lt; n; j++) {\\n\\t\\txPlus[j] += eps;\\n\\t\\txMinus[j] -= eps;\\n\\t\\tfOfxPlus = f(xPlus, ...args);\\n\\t\\tfOfxMinus = f(xMinus, ...args);\\n\\t\\txPlus[j] -= eps;\\n\\t\\txMinus[j] += eps;\\n\\n\\t\\tfor (let i = 0; i &lt; m; i++) {\\n\\t\\t\\tJ[i][j] = (fOfxPlus[i] - fOfxMinus[i]) / 2.0 / eps;\\n\\t\\t}\\n\\t}\\n\\n\\treturn J;\\n}\\n\\n\\nfunction zeros(...dims) {\\n  let A = [];\\n\\n  \\n  for (let i = dims.length - 1; i &gt;= 0; i--) {\\n    let size = dims[i];\\n    if (i === dims.length - 1) {\\n      \\n      A = new Array(size).fill(0.0);\\n    } else {\\n      \\n      A = new Array(size).fill().map(() =&gt; deepCopy(A));\\n    }\\n  }\\n\\n  return A;\\n}\\n\\n\\nfunction svMult(a, v) {\\n  return v.map(x =&gt; a * x);\\n}\\n\\n\\nfunction quadForm(A, x) {\\n   return dot(x, mvMult(A, x)); \\n}\\n\\n\\nfunction solvePosDef(A, b) {\\n  let [L, p, success] = modifiedCholesky(A);\\n\\n  if (!success) {\\n    return [zeros(b.length), success];\\n  }\\n\\n  return [modifiedCholeskySolve(L, p, b), success];\\n}\\n\\n\\nfunction modifiedCholesky(A) {\\n    const floatEps = 1.0e-14;\\n    const n = A.length;\\n\\n    \\n    let L = deepCopy(A); \\n    let p = arange(0, n);\\n\\n    \\n    let success = true;\\n\\n    let xi = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        for (let j = 0; j &lt; i; j++) {\\n            let temp = Math.abs(L[i][j]);\\n            xi = Math.max(xi, temp);\\n        }\\n    }\\n\\n    let eta = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        let temp = Math.abs(L[i][i]);\\n        eta = Math.max(eta, temp);\\n    }\\n\\n    let beta;\\n    if (n &gt; 1) {\\n        beta = Math.sqrt(Math.max(eta, xi / Math.sqrt(n * n - 1)));\\n    } else {\\n        beta = Math.sqrt(eta);\\n    }\\n    beta = Math.max(beta, floatEps);\\n\\n    for (let k = 0; k &lt; n; k++) {\\n        \\n        let muVal = L[k][k];\\n        let mu = k;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            let temp = L[i][i];\\n            if (muVal &lt; temp) {\\n                mu = i;\\n                muVal = temp;\\n            }\\n        }\\n\\n        \\n        let iTemp = p[mu];\\n        p[mu] = p[k];\\n        p[k] = iTemp;\\n\\n        for (let i = 0; i &lt; k; i++) {\\n            let temp = L[k][i];\\n            L[k][i] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        let temp = L[k][k];\\n        L[k][k] = L[mu][mu];\\n        L[mu][mu] = temp;\\n        for (let i = k + 1; i &lt; mu; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        for (let i = mu + 1; i &lt; n; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[i][mu];\\n            L[i][mu] = temp;\\n        }\\n\\n        \\n        let cSum = 0;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            cSum = Math.max(cSum, Math.abs(L[i][k]));\\n        }\\n        cSum /= beta;\\n        cSum = cSum * cSum;\\n\\n        \\n        if (L[k][k] &lt; 0) {\\n            success = false;\\n        }\\n\\n        temp = Math.abs(L[k][k]);\\n        temp = Math.max(temp, floatEps * eta);\\n        temp = Math.max(temp, cSum);\\n        L[k][k] = Math.sqrt(temp);\\n\\n        \\n        for (let i = k + 1; i &lt; n; i++) {\\n            L[i][k] /= L[k][k];\\n        }\\n\\n        \\n        for (let j = k + 1; j &lt; n; j++) {\\n            for (let i = j; i &lt; n; i++) {\\n                L[i][j] -= L[i][k] * L[j][k];\\n            }\\n        }\\n\\n        \\n        for (let i = 0; i &lt; n - 1; i++) {\\n            for (let j = i + 1; j &lt; n; j++) {\\n                L[i][j] = 0.0;\\n            }\\n        }\\n    }\\n\\n    return [L, p, success];\\n}\\n\\n\\nfunction modifiedCholeskySolve(L, p, b) {\\n    const n = L.length;\\n\\n    let U = transpose(L);\\n    let xp = new Array(n).fill(0);\\n    for (let i = 0; i &lt; n; i++) {\\n        xp[i] = b[p[i]];\\n    }\\n\\n    \\n    let x = lowerTriSolve(L, xp);\\n\\n    \\n    xp = upperTriSolve(U, x);\\n\\n    for (let i = 0; i &lt; n; i++) {\\n        x[p[i]] = xp[i];\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction lowerTriSolve(L, b) {\\n    const floatEps = 1.0e-14;\\n    const n = L.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = 0; j &lt; n - 1; j++) {\\n        if (Math.abs(L[j][j]) &gt; floatEps) {\\n            x[j] /= L[j][j];\\n            for (let i = j + 1; i &lt; n; i++) {\\n                x[i] -= x[j] * L[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(L[n - 1][n - 1]) &gt; floatEps) {\\n            x[n - 1] /= L[n - 1][n - 1];\\n        } else {\\n            x[n - 1] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction upperTriSolve(U, b) {\\n    const floatEps = 1.0e-14;\\n    const n = U.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = n - 1; j &gt; 0; j--) {\\n        if (Math.abs(U[j][j]) &gt; floatEps) {\\n            x[j] /= U[j][j];\\n            for (let i = 0; i &lt; j; i++) {\\n                x[i] -= x[j] * U[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(U[0][0]) &gt; floatEps) {\\n            x[0] /= U[0][0];\\n        } else {\\n            x[0] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nclass InverseGammaDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;InverseGamma&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03b1&#x27;, &#x27;\\u03b2&#x27;];\\n\\n    \\n    this.paramMin = [0.0, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0.0;   \\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x &lt; 0) return NaN;\\n    if (x === 0 || x === Infinity) return 0.0;\\n\\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    let lnProb;\\n    lnProb = alpha * Math.log(beta) - (alpha + 1) * Math.log(x) - beta / x - lngamma(alpha);\\n\\n    return Math.exp(lnProb);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x &lt;= 0) return 0.0;\\n    if (x == Infinity) return 1.0;\\n\\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    return gammaincU(beta / x, alpha, true);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return 0.0;\\n    if (p === 1) return Infinity;\\n\\n    let gamma = new GammaDistribution();\\n    return 1.0 / gamma.ppf(1.0 - p, params);\\n  }\\n\\n  defaultXRange(params) {\\n    \\n    let [x1, x2] = this.ppf([0.001, 0.99], params);\\n\\n    \\n    if (x1 &lt; (x2 - x1) / 10.0) x1 = 0.0;\\n\\n    return [x1, x2];\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n\\n    let gamma = new GammaDistribution();\\n    return gamma.quantileSet([1.0 / x2, 1.0 / x1], p);\\n  }\\n\\n}\\n\\n\\n\\nvar dist = new InverseGammaDistribution();\\n\\n\\nif (triggerCallbacks.active) {\\n  updateData(source_p, source_c, p_p, sliders, discrete);\\n}"}}]],["change:end",[{"id":"p3029"}]]]},"end":20}},"y_range":{"type":"object","name":"DataRange1d","id":"p2925","attributes":{"start":0.0}},"x_scale":{"type":"object","name":"LinearScale","id":"p2933"},"y_scale":{"type":"object","name":"LinearScale","id":"p2934"},"title":{"type":"object","name":"Title","id":"p2926","attributes":{"text":"Inverse Gamma"}},"renderers":[{"type":"object","name":"GlyphRenderer","id":"p3010","attributes":{"data_source":{"id":"p2989"},"view":{"type":"object","name":"CDSView","id":"p3011","attributes":{"filter":{"type":"object","name":"AllIndices","id":"p3012"}}},"glyph":{"type":"object","name":"Line","id":"p3007","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"line_color":"#1f77b4","line_width":2}},"nonselection_glyph":{"type":"object","name":"Line","id":"p3008","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"line_color":"#1f77b4","line_alpha":0.1,"line_width":2}},"muted_glyph":{"type":"object","name":"Line","id":"p3009","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"line_color":"#1f77b4","line_alpha":0.2,"line_width":2}}}}],"toolbar":{"type":"object","name":"Toolbar","id":"p2932","attributes":{"tools":[{"type":"object","name":"PanTool","id":"p2945"},{"type":"object","name":"BoxZoomTool","id":"p2946","attributes":{"overlay":{"type":"object","name":"BoxAnnotation","id":"p2947","attributes":{"syncable":false,"level":"overlay","visible":false,"left":{"type":"number","value":"nan"},"right":{"type":"number","value":"nan"},"top":{"type":"number","value":"nan"},"bottom":{"type":"number","value":"nan"},"left_units":"canvas","right_units":"canvas","top_units":"canvas","bottom_units":"canvas","line_color":"black","line_alpha":1.0,"line_width":2,"line_dash":[4,4],"fill_color":"lightgrey","fill_alpha":0.5}}}},{"type":"object","name":"WheelZoomTool","id":"p2952","attributes":{"renderers":"auto"}},{"type":"object","name":"SaveTool","id":"p2953"},{"type":"object","name":"ResetTool","id":"p2954"}]}},"toolbar_location":null,"left":[{"type":"object","name":"LinearAxis","id":"p2940","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p2941","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p2942"},"axis_label":"PDF","axis_label_text_font_style":"normal","major_label_policy":{"type":"object","name":"AllLabels","id":"p2943"}}}],"below":[{"type":"object","name":"LinearAxis","id":"p2935","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p2936","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p2937"},"axis_label":"y","major_label_policy":{"type":"object","name":"AllLabels","id":"p2938"}}}],"center":[{"type":"object","name":"Grid","id":"p2939","attributes":{"axis":{"id":"p2935"}}},{"type":"object","name":"Grid","id":"p2944","attributes":{"dimension":1,"axis":{"id":"p2940"}}}],"frame_width":300,"frame_height":175,"background_fill_alpha":0,"border_fill_alpha":0}}],["p_c",{"id":"p2955"}],["source_p",{"id":"p2989"}],["source_c",{"id":"p2992"}],["discrete",false],["n",400],["sliders",[{"id":"p3014"},{"id":"p3016"}]],["xBoxes",[{"id":"p3021"},{"id":"p3022"}]],["pBoxes",[{"id":"p3023"},{"id":"p3024"}]],["quantileSetterSwitch",{"id":"p3026"}],["quantileSetterDiv",{"id":"p3025"}],["triggerCallbacks",{"id":"p3027"}],["startBoxes",[{"id":"p3017"},{"id":"p3018"}]],["endBoxes",[{"id":"p3019"},{"id":"p3020"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nclass GammaDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Gamma&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03b1&#x27;, &#x27;\\u03b2&#x27;];\\n\\n    \\n    this.paramMin = [0.0, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0.0;   \\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x &lt; 0) return NaN;\\n    if (x == Infinity) return 0.0;\\n\\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    if (x == 0) {\\n      if (alpha == 1) {\\n        return beta;\\n      } else if (alpha &gt; 1) {\\n        return 0.0;\\n      } else {  \\n        return Infinity;\\n      }\\n    }\\n\\n    let lnProb;\\n    lnProb = alpha * Math.log(beta * x) - Math.log(x) - beta * x - lngamma(alpha);\\n\\n    return Math.exp(lnProb);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x &lt;= 0) return 0.0;\\n    if (x == Infinity) return 1.0;\\n\\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    return gammaincL(beta * x, alpha, true);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return 0.0;\\n    if (p === 1) return Infinity;\\n\\n    \\n    let rescaledParams = [params[0], 1.0];\\n\\n    let rootFun = (xi, params, p) =&gt; {\\n        let x = xi == 1.0 ? Infinity : xi / (1.0 - xi);\\n\\n        return p - this.cdfSingleValue(x, params);\\n    }\\n\\n    let xiOpt = brentSolve(rootFun, 0.0, 1.0, [rescaledParams, p]);\\n\\n    \\n    if (xiOpt === 1) {\\n      return Infinity;\\n    }\\n\\n    \\n    let xFirstPass = xiOpt / (1.0 - xiOpt);\\n\\n    let closeRootFun = (x, params, p) =&gt; {\\n      return p - this.cdfSingleValue(x, params);\\n    }\\n\\n    let xOpt = secantSolve(xFirstPass, closeRootFun, [rescaledParams, p]);\\n\\n    let retval;\\n    if (xOpt != null &amp;&amp; closeRootFun(xOpt, rescaledParams, p) &lt; closeRootFun(xFirstPass, rescaledParams, p)) {\\n      retval = xOpt;\\n    } else {\\n      retval = xFirstPass;\\n    }\\n\\n    \\n    return retval / params[1];\\n }\\n\\n  defaultXRange(params) {\\n    let [x1, x2] = this.ppf([0.001, 0.999], params);\\n\\n    \\n    if (x1 &lt; (x2 - x1) / 10.0) x1 = 0.0;\\n\\n    return [x1, x2];\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    \\n    let x1Rescaled = x1 / x2;\\n    let x2Rescaled = 1.0;\\n\\n    \\n    const quantileRootFun = (params, x1, p1, x2, p2) =&gt; {\\n      let alpha = Math.exp(params[0]);\\n      let beta = Math.exp(params[1]);\\n\\n      let r1 = this.cdfSingleValue(x1, [alpha, beta]) - p1;\\n      let r2 = this.cdfSingleValue(x2, [alpha, beta]) - p2;\\n\\n      return [r1, r2];\\n    };\\n\\n    let args = [x1Rescaled, p1, x2Rescaled, p2];\\n\\n    let guess = [0.75, 0.75];\\n\\n    let [logParams, optimSuccess] = findRootTrustRegion(quantileRootFun, guess, args=args);\\n\\n    \\n    let paramsFirstPass = [Math.exp(logParams[0]), Math.exp(logParams[1])];\\n\\n    \\n    if (!optimSuccess) {\\n      return [[paramsFirstPass[0], paramsFirstPass[1]], optimSuccess];\\n    }\\n\\n    \\n    const closeQuantileRootFun = (params, x1, p1, x2, p2) =&gt; {\\n      let r1 = this.cdfSingleValue(x1, params) - p1;\\n      let r2 = this.cdfSingleValue(x2, params) - p2;\\n\\n      return [r1, r2];\\n    };\\n\\n    let paramsOpt;\\n    [paramsOpt, optimSuccess] = findRootTrustRegion(closeQuantileRootFun, paramsFirstPass, args=args);\\n\\n    let retval;\\n    if (optimSuccess &amp;&amp; norm(closeQuantileRootFun(paramsOpt, x1, p1, x2, p2)) &lt; norm(closeQuantileRootFun(paramsFirstPass, x1, p1, x2, p2))) {\\n      retval = paramsOpt;\\n    } else {\\n      retval = paramsFirstPass;\\n    }\\n\\n    \\n    return [[retval[0], retval[1] / x2], optimSuccess];\\n  }\\n\\n}\\n\\nfunction lngamma(z) {\\n\\n    if(z &lt; 0) return Number(&#x27;0/0&#x27;);\\n\\n    if (z &lt; 0.5) return Math.log(Math.PI) - Math.log(Math.sin(Math.PI * z)) - lngamma(1-z);\\n\\n    var p = [676.5203681218851,\\n             -1259.1392167224028,\\n             771.32342877765313,\\n             -176.61502916214059,\\n             12.507343278686905,\\n             -0.13857109526572012,\\n             9.9843695780195716e-6,\\n             1.5056327351493116e-7];\\n\\n    z -= 1.0;\\n    var Ag = 0.99999999999980993;\\n    for (var i = 0; i &lt; p.length; i++) {\\n        Ag += p[i] / (z + i + 1);\\n    }\\n    var t = z + p.length - 0.5;\\n\\n    return 0.5 * Math.log(2*Math.PI) + (z + 0.5)*Math.log(t) - t + Math.log(Ag);\\n}\\n\\n\\nfunction gammaincU(x, s, regularized) {\\n\\n  var EPSILON = 1e-12;\\n\\n  if (x &lt;= 1.1 || x &lt;= s) {\\n    if (regularized !== false) {\\n      return 1 - gammaincL(x, s, regularized);\\n    } else {\\n      return Math.exp(lngamma(s)) - gammaincL(x, s, regularized);\\n    }\\n  }\\n\\n  var f = 1 + x - s,\\n    C = f,\\n    D = 0,\\n    i = 1,\\n    a, b, chg;\\n  for (i = 1; i &lt; 10000; i++) {\\n    a = i * (s - i);\\n    b = (i&lt;&lt;1) + 1 + x - s;\\n    D = b + a * D;\\n    C = b + a / C;\\n    D = 1 / D;\\n    chg = C * D;\\n    f *= chg;\\n    if (Math.abs(chg - 1) &lt; EPSILON) {\\n      break;\\n    }\\n  }\\n  if (regularized !== false) {\\n    return Math.exp(s * Math.log(x) - x - lngamma(s) - Math.log(f));\\n  } else {\\n    return Math.exp(s * Math.log(x) - x - Math.log(f));\\n  }\\n}\\n\\n\\nfunction gammaincL(x, s, regularized) {\\n\\n  var EPSILON = 1e-12;\\n\\n  if (x === 0) {\\n    return 0;\\n  }\\n  if (x &lt; 0 || s &lt;= 0) {\\n    return NaN;\\n  }\\n\\n  if (x &gt; 1.1 &amp;&amp; x &gt; s) {\\n    if (regularized !== false) {\\n      return 1 - gammaincU(x, s, regularized);\\n    } else {\\n      return Math.exp(lngamma(s)) - gammaincU(x, s, regularized);\\n    }\\n  }\\n\\n  var ft,\\n    r = s,\\n    c = 1,\\n    pws = 1;\\n\\n  if (regularized !== false) {\\n    ft = s * Math.log(x) - x - lngamma(s);\\n  } else {\\n    ft = s * Math.log(x) - x;\\n  }\\n  ft = Math.exp(ft);\\n  do {\\n    r += 1;\\n    c *= x/r;\\n    pws += c;\\n  } while (c / pws &gt; EPSILON);\\n\\n  return pws * ft / s;\\n}\\n\\n\\nfunction norm(v) {\\n  return Math.sqrt(dot(v, v));\\n}\\n\\n\\nfunction findRootTrustRegion(\\n\\t\\tf, \\n\\t\\tx0, \\n\\t\\targs=[],\\n\\t\\tjac=jacCentralDiff,\\n\\t\\ttol=0.000000001, \\n\\t\\tmaxIters=10000, \\n\\t\\tdeltaBar=1000.0, \\n\\t\\teta=0.125, \\n\\t\\tminDelta=1e-12\\n  ) {\\n\\t\\n\\tlet x = deepCopy(x0);\\n\\n\\t\\n\\tlet delta = 0.99 * deltaBar;\\n\\n\\t\\n\\tlet r = f(x, ...args);\\n\\n\\t\\n\\tlet J = jac(f, x, args);\\n\\n\\t\\n\\tlet JTJ = mmMult(transpose(J), J);\\n\\n\\t\\n\\tlet JTr = mvMult(transpose(J), r);\\n\\n\\t\\n\\tlet normJTr = norm(JTr);\\n\\n\\tlet iters = 0;\\n\\twhile (iters &lt; maxIters &amp;&amp; checkTol(r, tol) &amp;&amp; delta &gt;= minDelta) {\\n\\t\\t\\n\\t\\tlet p = doglegStep(JTJ, JTr, normJTr, delta);\\n\\n\\t\\t\\n\\t\\tlet newr = f(vectorAdd(x, p), ...args);\\n\\t\\tlet rho = computeRho(r, newr, J, p);\\n\\n\\t\\t\\n\\t\\tif  (rho &lt; 0.25) {\\n\\t\\t\\tdelta = norm(p) / 4.0;\\n\\t\\t} else if (rho &gt; 0.75 &amp;&amp; Math.abs(norm(p) - delta) &lt; 1e-12) {\\n\\t\\t\\t\\tdelta = Math.min(2 * delta, deltaBar);\\n\\t\\t}\\n\\n\\t\\t\\n\\t\\tif (rho &gt; eta) {\\n\\t\\t\\tx = vectorAdd(x, p);\\n\\n\\t\\t\\tr = newr;\\n\\t\\t\\tJ = jac(f, x, args);\\n\\t\\t\\tJTJ = mmMult(transpose(J), J);\\n\\t\\t\\tJTr = mvMult(transpose(J), r);\\n\\t\\t\\tnormJTr = norm(JTr);\\n\\t\\t}\\n\\n\\t\\titers += 1;\\n\\t}\\n\\n\\tlet success = !checkTol(r, tol);\\n\\n\\treturn [x, success];\\n\\n}\\n\\n\\nfunction secantSolve(x0, f, args=[], tol=1e-8, maxIter=200, epsilon=1e-14, h=1e-4) {\\n\\tlet x = Infinity;\\n\\tlet solved = false;\\n\\n\\tlet x1 = x0 * (1 + h);\\n\\tx1 += x1 &gt;= 0 ? h : -h;\\n\\n\\tlet q0 = f(x0, ...args);\\n\\tlet q1 = f(x1, ...args);\\n\\t\\n\\tif (Math.abs(q1) &lt; Math.abs(q0)) {\\n\\t\\t[x0, x1, q0, q1] = [x1, x0, q1, q0];\\n\\t}\\n\\n\\tfor (let i = 0; i &lt; maxIter; i++) {\\n\\t\\tif (q0 == q1) {\\n\\t\\t\\tsolved = x0 == x1;\\n\\t\\t\\tx = (x0 + x1) / 2.0;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tif (Math.abs(q1) &gt; Math.abs(q0)) {\\n\\t\\t\\t\\tx = (x0 - q0 / q1 * x1) / (1.0 - q0 / q1);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tx = (x1 - q1 / q0 * x0) / (1.0 - q1 / q0);\\n\\t\\t\\t}\\n\\t\\t\\tif (Math.abs(x - x0) &lt;= tol) {\\n\\t\\t\\t\\tsolved = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\t[x0, q0] = [x1, q1];\\n\\t\\t\\tx1 = x;\\n\\t\\t\\tq1 = f(x1, ...args);\\n\\t\\t}\\n\\t}\\n\\n  if (solved) return x;\\n  else return null;\\n}\\n\\n\\nfunction brentSolve(f, lower, upper, args=[], tol=1e-8, maxIter=1000) {\\n\\tlet a = lower;\\n\\tlet b = upper;\\n  let fa = f(a, ...args);\\n  let fb = f(b, ...args);\\n\\n  \\n  if (Math.abs(fa) &lt; tol) return a;\\n  if (Math.abs(fb) &lt; tol) return b;\\n\\n  \\n  if (fa * fb &gt;= 0) {\\n  \\treturn null;\\n\\t}\\n\\n  \\n  let c = a;\\n  let fc = fa;\\n\\n\\tlet iter = 0;\\n  while (iter++ &lt; maxIter) {\\n  \\tlet prevStep = b - a;\\n\\n    \\n    if (Math.abs(fc) &lt; Math.abs(fb)) {      \\n    \\t[a, b, c] = [b, c, b];\\n    \\t[fa, fb, fc] = [fb, fc, fb];\\n    }\\n\\n    \\n    let newStep = (c - b) / 2.0;\\n\\n    \\n    let tolAdj = 1e-15 * Math.abs(b) + tol / 2;\\n\\n    \\n  \\tif (Math.abs(newStep) &lt;= tolAdj || fb === 0 ) {\\n    \\t\\treturn b;\\n  \\t}\\n\\n    \\n    if (Math.abs(prevStep) &gt; tolAdj &amp;&amp; Math.abs(fa) &gt; Math.abs(fb)) {\\n    \\tlet p;\\n    \\tlet q;\\n    \\tlet t1;\\n    \\tlet t2;\\n    \\tlet cb = c - b;\\n    \\tif (a === c) { \\n    \\t\\tt1 = fb / fa;\\n    \\t\\tp = cb * t1;\\n    \\t\\tq = 1.0 - t1;\\n    \\t}\\n    \\telse { \\n    \\t\\tq = fa / fc;\\n    \\t\\tt1 = fb / fc;\\n    \\t\\tt2 = fb / fa;\\n    \\t\\tp = t2 * (cb * q * (q - t1) - (b - a) * (t1 - 1.0));\\n    \\t\\tq = (q - 1.0) * (t1 - 1.0) * (t2 - 1.0);\\n    \\t}\\n\\n    \\t\\n    \\tif (p &gt; 0) q = -q;\\n    \\telse p = -p;\\n\\n    \\t\\n    \\tif (p &lt; (0.75 * cb * q - Math.abs(tolAdj * q) / 2.0) \\n    \\t\\t&amp;&amp; p &lt; Math.abs(prevStep * q / 2.0)) { \\n\\t        newStep = p / q;\\n      \\t}\\n    }\\n\\n    if (Math.abs(newStep) &lt; tolAdj) {\\n      newStep = (newStep &gt; 0) ? tolAdj : -tolAdj;\\n    }\\n\\n    \\n    a = b;\\n    fa = fb;\\n\\n    \\n    b += newStep;\\n    fb = f(b, ...args);\\n\\n\\t\\n    if ((fb &gt; 0 &amp;&amp; fc &gt; 0) || (fb &lt; 0 &amp;&amp; fc &lt; 0)) {\\n      c = a; \\n      fc = fa;\\n    }\\n  }\\n\\n  \\n  return null;\\n}\\n\\n\\nfunction dot(v1, v2) {\\n  const n = v1.length;\\n  let result = 0.0;\\n  for (let i = 0; i &lt; n; i++) result += v1[i] * v2[i];\\n\\n  return result;\\n}\\n\\n\\nfunction transpose(A) {\\n    return A[0].map((_, colIndex) =&gt; A.map(row =&gt; row[colIndex]));\\n}\\n\\n\\nfunction mvMult(A, v) {\\n  return A.map(Arow =&gt; dot(Arow, v));\\n}\\n\\n\\nfunction mmMult(A, B) {\\n  let mA = A.length;\\n  let nA = A[0].length;\\n  let mB = B.length;\\n  let nB = B[0].length;\\n\\n  if (nA !== mB) {\\n      throw new Error(&#x27;Matrix dimension mismatch.&#x27;);\\n  }\\n\\n  let result = zeros(mA, nB);\\n\\n  for (let i = 0; i &lt; mA; i++) {\\n    for (let j = 0; j &lt; nB; j++) {\\n      for (let k = 0; k &lt; nA; k++) {\\n        result[i][j] += A[i][k] * B[k][j];\\n      }\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction vectorAdd() {\\n  let m = arguments.length;\\n  let n = arguments[0].length;\\n \\n  let result = new Array(n).fill(0.0);\\n \\n  for (let i = 0; i &lt; n; i++) {\\n    for (let j = 0; j &lt; m; j++) {\\n        result[i] += arguments[j][i];\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction deepCopy(x) {\\n  return JSON.parse(JSON.stringify(x));\\n}\\n\\n\\nfunction computeRho(r, newr, J, p) {\\n\\tlet r2 = norm(r) ** 2;\\n\\tlet num = r2 - norm(newr)**2;\\n\\tlet denom = r2 - norm(vectorAdd(r, mvMult(J, p))) ** 2;\\n\\n\\treturn num / denom;\\n}\\n\\n\\nfunction checkTol(r, tol) {\\n\\t\\n\\tconst n = r.length;\\n\\tfor (let i = 0; i &lt; n; i++) {\\n\\t\\tif (tol &lt; Math.abs(r[i])) return true;\\n\\t}\\n\\n\\treturn false;\\n}\\n\\n\\nfunction doglegStep(JTJ, JTr, normJTr, delta) {\\n\\t\\n\\tlet [pJ, posDef] = solvePosDef(JTJ, JTr);\\n\\tpJ = svMult(-1.0, pJ);\\n\\n\\t\\n\\tif (posDef &amp;&amp; norm(pJ) &lt;= delta) {\\n\\t\\treturn pJ;\\n\\t}\\n\\n\\t\\n\\tlet tau = Math.min(1, normJTr**3 / delta / quadForm(JTJ, JTr));\\n\\tlet pC = svMult(-tau * delta / normJTr, JTr);\\n\\n\\tlet pCnorm = norm(pC);\\n\\tif (!posDef || Math.abs(pCnorm - delta) &lt;= 1e-12) {\\n\\t\\treturn pC;\\n\\t}\\n\\n\\t\\n\\tlet pJ2 = norm(pJ) ** 2;\\n\\tlet pC2 = pCnorm**2;\\n\\tlet pJpC = dot(pJ, pC);\\n\\tlet a = pJ2 + pC2 - 2.0 * pJpC;\\n\\tlet b = 2.0 * (pJpC - pC2);\\n\\tlet c = pC2 - delta**2;\\n\\tlet q = -0.5 * (b + Math.sign(b) * Math.sqrt(b**2 - 4.0 * a * c));\\n\\n\\t\\n\\tlet beta;\\n\\tif (Math.abs(b) &lt; 1e-12) beta = Math.sqrt(-c / a);\\n\\telse if (b &lt; 0.0) beta = q / a;\\n\\telse beta = c / q;\\n\\n\\t\\n\\tif (0.0 &lt;= beta &amp;&amp; beta &lt;= 1) {\\n\\t\\treturn vectorAdd(pC, svMult(beta, vectorAdd(pJ, svMult(-1.0, pC))));\\n\\t} else { \\n\\t\\treturn pC;\\n\\t}\\n\\n}\\n\\n\\nfunction jacCentralDiff(f, x, args=[], eps=4.7e-6) {\\n\\t\\n\\tlet xPlus = deepCopy(x);\\n\\tlet xMinus = deepCopy(x);\\n\\n\\t\\n\\tlet fOfx = f(x, ...args);\\n\\tlet m = fOfx.length;\\n\\n\\t\\n\\tlet n = x.length;\\n\\n\\t\\n\\tlet J = zeros(m, n);\\n\\n\\t\\n\\tlet fOfxPlus;\\n\\tlet fOfxMinus;\\n\\n\\tfor (let j = 0; j &lt; n; j++) {\\n\\t\\txPlus[j] += eps;\\n\\t\\txMinus[j] -= eps;\\n\\t\\tfOfxPlus = f(xPlus, ...args);\\n\\t\\tfOfxMinus = f(xMinus, ...args);\\n\\t\\txPlus[j] -= eps;\\n\\t\\txMinus[j] += eps;\\n\\n\\t\\tfor (let i = 0; i &lt; m; i++) {\\n\\t\\t\\tJ[i][j] = (fOfxPlus[i] - fOfxMinus[i]) / 2.0 / eps;\\n\\t\\t}\\n\\t}\\n\\n\\treturn J;\\n}\\n\\n\\nfunction zeros(...dims) {\\n  let A = [];\\n\\n  \\n  for (let i = dims.length - 1; i &gt;= 0; i--) {\\n    let size = dims[i];\\n    if (i === dims.length - 1) {\\n      \\n      A = new Array(size).fill(0.0);\\n    } else {\\n      \\n      A = new Array(size).fill().map(() =&gt; deepCopy(A));\\n    }\\n  }\\n\\n  return A;\\n}\\n\\n\\nfunction svMult(a, v) {\\n  return v.map(x =&gt; a * x);\\n}\\n\\n\\nfunction quadForm(A, x) {\\n   return dot(x, mvMult(A, x)); \\n}\\n\\n\\nfunction solvePosDef(A, b) {\\n  let [L, p, success] = modifiedCholesky(A);\\n\\n  if (!success) {\\n    return [zeros(b.length), success];\\n  }\\n\\n  return [modifiedCholeskySolve(L, p, b), success];\\n}\\n\\n\\nfunction modifiedCholesky(A) {\\n    const floatEps = 1.0e-14;\\n    const n = A.length;\\n\\n    \\n    let L = deepCopy(A); \\n    let p = arange(0, n);\\n\\n    \\n    let success = true;\\n\\n    let xi = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        for (let j = 0; j &lt; i; j++) {\\n            let temp = Math.abs(L[i][j]);\\n            xi = Math.max(xi, temp);\\n        }\\n    }\\n\\n    let eta = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        let temp = Math.abs(L[i][i]);\\n        eta = Math.max(eta, temp);\\n    }\\n\\n    let beta;\\n    if (n &gt; 1) {\\n        beta = Math.sqrt(Math.max(eta, xi / Math.sqrt(n * n - 1)));\\n    } else {\\n        beta = Math.sqrt(eta);\\n    }\\n    beta = Math.max(beta, floatEps);\\n\\n    for (let k = 0; k &lt; n; k++) {\\n        \\n        let muVal = L[k][k];\\n        let mu = k;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            let temp = L[i][i];\\n            if (muVal &lt; temp) {\\n                mu = i;\\n                muVal = temp;\\n            }\\n        }\\n\\n        \\n        let iTemp = p[mu];\\n        p[mu] = p[k];\\n        p[k] = iTemp;\\n\\n        for (let i = 0; i &lt; k; i++) {\\n            let temp = L[k][i];\\n            L[k][i] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        let temp = L[k][k];\\n        L[k][k] = L[mu][mu];\\n        L[mu][mu] = temp;\\n        for (let i = k + 1; i &lt; mu; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        for (let i = mu + 1; i &lt; n; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[i][mu];\\n            L[i][mu] = temp;\\n        }\\n\\n        \\n        let cSum = 0;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            cSum = Math.max(cSum, Math.abs(L[i][k]));\\n        }\\n        cSum /= beta;\\n        cSum = cSum * cSum;\\n\\n        \\n        if (L[k][k] &lt; 0) {\\n            success = false;\\n        }\\n\\n        temp = Math.abs(L[k][k]);\\n        temp = Math.max(temp, floatEps * eta);\\n        temp = Math.max(temp, cSum);\\n        L[k][k] = Math.sqrt(temp);\\n\\n        \\n        for (let i = k + 1; i &lt; n; i++) {\\n            L[i][k] /= L[k][k];\\n        }\\n\\n        \\n        for (let j = k + 1; j &lt; n; j++) {\\n            for (let i = j; i &lt; n; i++) {\\n                L[i][j] -= L[i][k] * L[j][k];\\n            }\\n        }\\n\\n        \\n        for (let i = 0; i &lt; n - 1; i++) {\\n            for (let j = i + 1; j &lt; n; j++) {\\n                L[i][j] = 0.0;\\n            }\\n        }\\n    }\\n\\n    return [L, p, success];\\n}\\n\\n\\nfunction modifiedCholeskySolve(L, p, b) {\\n    const n = L.length;\\n\\n    let U = transpose(L);\\n    let xp = new Array(n).fill(0);\\n    for (let i = 0; i &lt; n; i++) {\\n        xp[i] = b[p[i]];\\n    }\\n\\n    \\n    let x = lowerTriSolve(L, xp);\\n\\n    \\n    xp = upperTriSolve(U, x);\\n\\n    for (let i = 0; i &lt; n; i++) {\\n        x[p[i]] = xp[i];\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction lowerTriSolve(L, b) {\\n    const floatEps = 1.0e-14;\\n    const n = L.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = 0; j &lt; n - 1; j++) {\\n        if (Math.abs(L[j][j]) &gt; floatEps) {\\n            x[j] /= L[j][j];\\n            for (let i = j + 1; i &lt; n; i++) {\\n                x[i] -= x[j] * L[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(L[n - 1][n - 1]) &gt; floatEps) {\\n            x[n - 1] /= L[n - 1][n - 1];\\n        } else {\\n            x[n - 1] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction upperTriSolve(U, b) {\\n    const floatEps = 1.0e-14;\\n    const n = U.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = n - 1; j &gt; 0; j--) {\\n        if (Math.abs(U[j][j]) &gt; floatEps) {\\n            x[j] /= U[j][j];\\n            for (let i = 0; i &lt; j; i++) {\\n                x[i] -= x[j] * U[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(U[0][0]) &gt; floatEps) {\\n            x[0] /= U[0][0];\\n        } else {\\n            x[0] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nclass InverseGammaDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;InverseGamma&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03b1&#x27;, &#x27;\\u03b2&#x27;];\\n\\n    \\n    this.paramMin = [0.0, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0.0;   \\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x &lt; 0) return NaN;\\n    if (x === 0 || x === Infinity) return 0.0;\\n\\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    let lnProb;\\n    lnProb = alpha * Math.log(beta) - (alpha + 1) * Math.log(x) - beta / x - lngamma(alpha);\\n\\n    return Math.exp(lnProb);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x &lt;= 0) return 0.0;\\n    if (x == Infinity) return 1.0;\\n\\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    return gammaincU(beta / x, alpha, true);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return 0.0;\\n    if (p === 1) return Infinity;\\n\\n    let gamma = new GammaDistribution();\\n    return 1.0 / gamma.ppf(1.0 - p, params);\\n  }\\n\\n  defaultXRange(params) {\\n    \\n    let [x1, x2] = this.ppf([0.001, 0.99], params);\\n\\n    \\n    if (x1 &lt; (x2 - x1) / 10.0) x1 = 0.0;\\n\\n    return [x1, x2];\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n\\n    let gamma = new GammaDistribution();\\n    return gamma.quantileSet([1.0 / x2, 1.0 / x1], p);\\n  }\\n\\n}\\n\\n\\n\\nvar dist = new InverseGammaDistribution();\\n\\n\\n\\nif (cb_obj.active) {\\n  for (let i = 0; i &lt; sliders.length; i++) {\\n    if (!dist.fixedParamsInds.includes(i)) {\\n      sliders[i].title = dist.paramNames[i] + &#x27; (computed)&#x27;;\\n      sliders[i].disabled = true;\\n    }\\n  }\\n  for (let xBox of xBoxes) {\\n    xBox.disabled = false;\\n  }\\n  for (let pBox of pBoxes) {\\n    pBox.disabled = false;\\n  }\\n} else {\\n  for (let i = 0; i &lt; sliders.length; i++) {\\n    if (!dist.fixedParamsInds.includes(i)) {\\n      sliders[i].title = dist.paramNames[i];\\n      sliders[i].disabled = false;\\n    }\\n  }\\n  for (let xBox of xBoxes) {\\n    xBox.disabled = true;\\n  }\\n  for (let pBox of pBoxes) {\\n    pBox.disabled = true;\\n  }\\n  quantileSetterDiv.text = &#x27;&#x27;;\\n}"}}]]]}}}]}},{"type":"object","name":"Spacer","id":"p3080","attributes":{"width":10}},{"id":"p3025"}]}},{"type":"object","name":"Spacer","id":"p3082","attributes":{"height":10}},{"type":"object","name":"Row","id":"p3084","attributes":{"children":[{"type":"object","name":"Column","id":"p3069","attributes":{"children":[{"type":"object","name":"Row","id":"p3067","attributes":{"children":[{"type":"object","name":"Column","id":"p3060","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3059","attributes":{"height":4}},{"id":"p3017"}]}},{"id":"p3014"},{"type":"object","name":"Column","id":"p3062","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3061","attributes":{"height":4}},{"id":"p3019"}]}}]}},{"type":"object","name":"Row","id":"p3068","attributes":{"children":[{"type":"object","name":"Column","id":"p3064","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3063","attributes":{"height":4}},{"id":"p3018"}]}},{"id":"p3016"},{"type":"object","name":"Column","id":"p3066","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3065","attributes":{"height":4}},{"id":"p3020"}]}}]}}]}},{"type":"object","name":"Spacer","id":"p3083","attributes":{"width":20}},{"type":"object","name":"Column","id":"p3058","attributes":{"children":[{"type":"object","name":"Row","id":"p3056","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3040","attributes":{"width":20}},{"type":"object","name":"Column","id":"p3043","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3041","attributes":{"height":7}},{"type":"object","name":"Div","id":"p3042","attributes":{"text":"&lt;p&gt;&lt;b&gt;lower y: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p3021"},{"type":"object","name":"Spacer","id":"p3044","attributes":{"width":34}},{"type":"object","name":"Column","id":"p3047","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3045","attributes":{"height":7}},{"type":"object","name":"Div","id":"p3046","attributes":{"text":"&lt;p&gt;&lt;b&gt;upper y: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p3022"}]}},{"type":"object","name":"Row","id":"p3057","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3048","attributes":{"width":16}},{"type":"object","name":"Column","id":"p3051","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3049","attributes":{"height":7}},{"type":"object","name":"Div","id":"p3050","attributes":{"text":"&lt;p&gt;&lt;b&gt;quantile: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p3023"},{"type":"object","name":"Spacer","id":"p3052","attributes":{"width":30}},{"type":"object","name":"Column","id":"p3055","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3053","attributes":{"height":7}},{"type":"object","name":"Div","id":"p3054","attributes":{"text":"&lt;p&gt;&lt;b&gt;quantile: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p3024"}]}}]}}]}},{"type":"object","name":"Spacer","id":"p3085","attributes":{"height":10}},{"type":"object","name":"GridPlot","id":"p3077","attributes":{"rows":null,"cols":null,"toolbar":{"type":"object","name":"Toolbar","id":"p3076","attributes":{"tools":[{"type":"object","name":"ToolProxy","id":"p3071","attributes":{"tools":[{"id":"p2945"},{"id":"p2977"},{"id":"p2945"},{"id":"p2977"}]}},{"type":"object","name":"ToolProxy","id":"p3072","attributes":{"tools":[{"id":"p2946"},{"id":"p2978"},{"id":"p2946"},{"id":"p2978"}]}},{"type":"object","name":"ToolProxy","id":"p3073","attributes":{"tools":[{"id":"p2952"},{"id":"p2984"},{"id":"p2952"},{"id":"p2984"}]}},{"type":"object","name":"SaveTool","id":"p3074"},{"type":"object","name":"ToolProxy","id":"p3075","attributes":{"tools":[{"id":"p2954"},{"id":"p2986"},{"id":"p2954"},{"id":"p2986"}]}}]}},"toolbar_location":"right","children":[[{"id":"p2923"},0,0],[{"type":"object","name":"Spacer","id":"p3070","attributes":{"width":30}},0,1],[{"id":"p2955"},0,2]]}}]}}]}}';
                  const render_items = [{"docid":"150ede63-4438-4727-86f7-a9fb966fe188","roots":{"p3086":"c9cbdd8c-7cd0-482a-8d0c-df2d3b6999d3"},"root_ids":["p3086"]}];
                  root.Bokeh.embed.embed_items(docs_json, render_items);
                  }
                  if (root.Bokeh !== undefined) {
                    embed_document(root);
                  } else {
                    let attempts = 0;
                    const timer = setInterval(function(root) {
                      if (root.Bokeh !== undefined) {
                        clearInterval(timer);
                        embed_document(root);
                      } else {
                        attempts++;
                        if (attempts > 100) {
                          clearInterval(timer);
                          console.log("Bokeh: ERROR: Unable to run BokehJS code because BokehJS library is missing");
                        }
                      }
                    }, 10, root)
                  }
                })(window);
              });
            };
            if (document.readyState != "loading") fn();
            else document.addEventListener("DOMContentLoaded", fn);
          })();
        },
    function(Bokeh) {
        }
      ];
    
      function run_inline_js() {
        for (let i = 0; i < inline_js.length; i++) {
          inline_js[i].call(root, root.Bokeh);
        }
      }
    
      if (root._bokeh_is_loading === 0) {
        console.debug("Bokeh: BokehJS loaded, going straight to plotting");
        run_inline_js();
      } else {
        load_libs(css_urls, js_urls, function() {
          console.debug("Bokeh: BokehJS plotting callback run at", now());
          run_inline_js();
        });
      }
    }(window));
  };
  if (document.readyState != "loading") fn();
  else document.addEventListener("DOMContentLoaded", fn);
})();