(function() {
  const fn = function() {
    'use strict';
    (function(root) {
      function now() {
        return new Date();
      }
    
      const force = false;
    
      if (typeof root._bokeh_onload_callbacks === "undefined" || force === true) {
        root._bokeh_onload_callbacks = [];
        root._bokeh_is_loading = undefined;
      }
    
    
    const element = document.getElementById("d79c6121-8c03-4313-8403-147969e859eb");
        if (element == null) {
          console.warn("Bokeh: autoload.js configured with elementid 'd79c6121-8c03-4313-8403-147969e859eb' but no matching script tag was found.")
        }
      function run_callbacks() {
        try {
          root._bokeh_onload_callbacks.forEach(function(callback) {
            if (callback != null)
              callback();
          });
        } finally {
          delete root._bokeh_onload_callbacks
        }
        console.debug("Bokeh: all callbacks have finished");
      }
    
      function load_libs(css_urls, js_urls, callback) {
        if (css_urls == null) css_urls = [];
        if (js_urls == null) js_urls = [];
    
        root._bokeh_onload_callbacks.push(callback);
        if (root._bokeh_is_loading > 0) {
          console.debug("Bokeh: BokehJS is being loaded, scheduling callback at", now());
          return null;
        }
        if (js_urls == null || js_urls.length === 0) {
          run_callbacks();
          return null;
        }
        console.debug("Bokeh: BokehJS not loaded, scheduling load and callback at", now());
        root._bokeh_is_loading = css_urls.length + js_urls.length;
    
        function on_load() {
          root._bokeh_is_loading--;
          if (root._bokeh_is_loading === 0) {
            console.debug("Bokeh: all BokehJS libraries/stylesheets loaded");
            run_callbacks()
          }
        }
    
        function on_error(url) {
          console.error("failed to load " + url);
        }
    
        for (let i = 0; i < css_urls.length; i++) {
          const url = css_urls[i];
          const element = document.createElement("link");
          element.onload = on_load;
          element.onerror = on_error.bind(null, url);
          element.rel = "stylesheet";
          element.type = "text/css";
          element.href = url;
          console.debug("Bokeh: injecting link tag for BokehJS stylesheet: ", url);
          document.body.appendChild(element);
        }
    
        for (let i = 0; i < js_urls.length; i++) {
          const url = js_urls[i];
          const element = document.createElement('script');
          element.onload = on_load;
          element.onerror = on_error.bind(null, url);
          element.async = false;
          element.src = url;
          console.debug("Bokeh: injecting script tag for BokehJS library: ", url);
          document.head.appendChild(element);
        }
      };
    
      function inject_raw_css(css) {
        const element = document.createElement("style");
        element.appendChild(document.createTextNode(css));
        document.body.appendChild(element);
      }
    
      const js_urls = ["https://cdn.bokeh.org/bokeh/release/bokeh-3.7.3.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-gl-3.7.3.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-widgets-3.7.3.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-tables-3.7.3.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-mathjax-3.7.3.min.js"];
      const css_urls = [];
    
      const inline_js = [    function(Bokeh) {
          Bokeh.set_log_level("info");
        },
        function(Bokeh) {
          (function() {
            const fn = function() {
              Bokeh.safely(function() {
                (function(root) {
                  function embed_document(root) {
                  const docs_json = '{"6d26697c-a44b-4b1a-ae39-f8a8c12b73e9":{"version":"3.7.3","title":"Bokeh Application","roots":[{"type":"object","name":"Column","id":"p2122","attributes":{"children":[{"type":"object","name":"Row","id":"p2117","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2115","attributes":{"width":409}},{"type":"object","name":"Row","id":"p2089","attributes":{"children":[{"type":"object","name":"Div","id":"p2087","attributes":{"text":"&lt;p&gt;&lt;b&gt;Quantile setter mode&lt;/b&gt;&lt;/p&gt;"}},{"type":"object","name":"Spacer","id":"p2088","attributes":{"width":2}},{"type":"object","name":"Switch","id":"p2078","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:active",[{"type":"object","name":"CustomJS","id":"p2082","attributes":{"args":{"type":"map","entries":[["p_p",{"type":"object","name":"Figure","id":"p1977","attributes":{"x_range":{"type":"object","name":"Range1d","id":"p2045","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:start",[{"type":"object","name":"CustomJS","id":"p2081","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p1977"}],["p_c",{"type":"object","name":"Figure","id":"p2011","attributes":{"js_event_callbacks":{"type":"map","entries":[["reset",[{"type":"object","name":"CustomJS","id":"p2084","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p1977"}],["p_c",{"id":"p2011"}],["source_p",{"type":"object","name":"ColumnDataSource","id":"p2047","attributes":{"selected":{"type":"object","name":"Selection","id":"p2048","attributes":{"indices":[],"line_indices":[]}},"selection_policy":{"type":"object","name":"UnionRenderers","id":"p2049"},"data":{"type":"map","entries":[["x",{"type":"ndarray","array":{"type":"bytes","data":"AAAAAAAAAACgmoFqBqqZP6CagWoGqqk/+DPhz4Q/sz+gmoFqBqq5P6QAkQJECsA/+DPhz4Q/wz9MZzGdxXTGP6CagWoGqsk/9M3RN0ffzD+kAJECRArQP04aOWnkpNE/+DPhz4Q/0z+iTYk2JdrUP0xnMZ3FdNY/9oDZA2YP2D+gmoFqBqrZP0q0KdGmRNs/9M3RN0ff3D+e53me53neP6QAkQJECuA/eQ3lNZTX4D9OGjlp5KThPyMnjZw0cuI/+DPhz4Q/4z/NQDUD1QzkP6JNiTYl2uQ/d1rdaXWn5T9MZzGdxXTmPyF0hdAVQuc/9oDZA2YP6D/LjS03ttzoP6CagWoGquk/dafVnVZ36j9KtCnRpkTrPx/BfQT3Eew/9M3RN0ff7D/J2iVrl6ztP57neZ7nee4/c/TN0TdH7z+kAJECRArwPw4HOxzscPA/eQ3lNZTX8D/kE49PPD7xP04aOWnkpPE/uCDjgowL8j8jJ42cNHLyP44tN7bc2PI/+DPhz4Q/8z9iOovpLKbzP81ANQPVDPQ/OEffHH1z9D+iTYk2Jdr0PwxUM1DNQPU/d1rdaXWn9T/iYIeDHQ72P0xnMZ3FdPY/tm3btm3b9j8hdIXQFUL3P4x6L+q9qPc/9oDZA2YP+D9gh4MdDnb4P8uNLTe23Pg/NpTXUF5D+T+gmoFqBqr5PwqhK4SuEPo/dafVnVZ3+j/grX+3/t36P0q0KdGmRPs/tLrT6k6r+z8fwX0E9xH8P4rHJx6fePw/9M3RN0ff/D9e1HtR70X9P8naJWuXrP0/NOHPhD8T/j+e53me53n+PwjuI7iP4P4/c/TN0TdH/z/e+nfr363/P6QAkQJECgBA2QNmD5g9AEAOBzsc7HAAQEQKEClApABAeQ3lNZTXAECuELpC6AoBQOQTj088PgFAGRdkXJBxAUBOGjlp5KQBQIMdDnY42AFAuCDjgowLAkDuI7iP4D4CQCMnjZw0cgJAWCpiqYilAkCOLTe23NgCQMMwDMMwDANA+DPhz4Q/A0AtN7bc2HIDQGI6i+kspgNAmD1g9oDZA0DNQDUD1QwEQAJEChApQARAOEffHH1zBEBtSrQp0aYEQKJNiTYl2gRA11BeQ3kNBUAMVDNQzUAFQEJXCF0hdAVAd1rdaXWnBUCsXbJ2ydoFQOJgh4MdDgZAF2RckHFBBkBMZzGdxXQGQIFqBqoZqAZAtm3btm3bBkDscLDDwQ4HQCF0hdAVQgdAVnda3Wl1B0CMei/qvagHQMF9BPcR3AdA9oDZA2YPCEArhK4QukIIQGCHgx0OdghAlopYKmKpCEDLjS03ttwIQACRAkQKEAlANpTXUF5DCUBrl6xdsnYJQKCagWoGqglA1Z1Wd1rdCUAKoSuErhAKQECkAJECRApAdafVnVZ3CkCqqqqqqqoKQOCtf7f+3QpAFbFUxFIRC0BKtCnRpkQLQH+3/t36dwtAtLrT6k6rC0Dqvaj3ot4LQB/BfQT3EQxAVMRSEUtFDECKxycen3gMQL/K/CrzqwxA9M3RN0ffDEAp0aZEmxINQF7Ue1HvRQ1AlNdQXkN5DUDJ2iVrl6wNQP7d+nfr3w1ANOHPhD8TDkBp5KSRk0YOQJ7neZ7neQ5A0+pOqzutDkAI7iO4j+AOQD7x+MTjEw9Ac/TN0TdHD0Co96Lei3oPQN76d+vfrQ9AE/5M+DPhD0CkAJECRAoQQD+C+wjuIxBA2QNmD5g9EEB0hdAVQlcQQA4HOxzscBBAqYilIpaKEEBEChApQKQQQN6Lei/qvRBAeQ3lNZTXEEAUj088PvEQQK4QukLoChFASZIkSZIkEUDkE49PPD4RQH6V+VXmVxFAGRdkXJBxEUCzmM5iOosRQE4aOWnkpBFA6Zujb46+EUCDHQ52ONgRQB6feHzi8RFAuCDjgowLEkBTok2JNiUSQO4juI/gPhJAiKUilopYEkAjJ42cNHISQL6o96LeixJAWCpiqYilEkDzq8yvMr8SQI4tN7bc2BJAKK+hvIbyEkDDMAzDMAwTQF2ydsnaJRNA+DPhz4Q/E0CTtUvWLlkTQC03ttzYchNAyLgg44KME0BiOovpLKYTQP279e/WvxNAmD1g9oDZE0Ayv8r8KvMTQM1ANQPVDBRAaMKfCX8mFEACRAoQKUAUQJ3FdBbTWRRAOEffHH1zFEDSyEkjJ40UQG1KtCnRphRAB8weMHvAFECiTYk2JdoUQD3P8zzP8xRA11BeQ3kNFUBy0shJIycVQAxUM1DNQBVAp9WdVndaFUBCVwhdIXQVQNzYcmPLjRVAd1rdaXWnFUAS3EdwH8EVQKxdsnbJ2hVAR98cfXP0FUDiYIeDHQ4WQHzi8YnHJxZAF2RckHFBFkCx5caWG1sWQExnMZ3FdBZA5+ibo2+OFkCBagaqGagWQBzscLDDwRZAtm3btm3bFkBR70W9F/UWQOxwsMPBDhdAhvIaymsoF0AhdIXQFUIXQLz179a/WxdAVnda3Wl1F0Dx+MTjE48XQIx6L+q9qBdAJvyZ8GfCF0DBfQT3EdwXQFv/bv279RdA9oDZA2YPGECRAkQKECkYQCuErhC6QhhAxgUZF2RcGEBgh4MdDnYYQPsI7iO4jxhAlopYKmKpGEAwDMMwDMMYQMuNLTe23BhAZg+YPWD2GEAAkQJEChAZQJsSbUq0KRlANpTXUF5DGUDQFUJXCF0ZQGuXrF2ydhlABRkXZFyQGUCgmoFqBqoZQDsc7HCwwxlA1Z1Wd1rdGUBwH8F9BPcZQAqhK4SuEBpApSKWilgqGkBApACRAkQaQNola5esXRpAdafVnVZ3GkAQKUCkAJEaQKqqqqqqqhpARSwVsVTEGkDgrX+3/t0aQHov6r2o9xpAFbFUxFIRG0CvMr/K/CobQEq0KdGmRBtA5TWU11BeG0B/t/7d+ncbQBo5aeSkkRtAtLrT6k6rG0BPPD7x+MQbQOq9qPei3htAhD8T/kz4G0AfwX0E9xEcQLpC6AqhKxxAVMRSEUtFHEDvRb0X9V4cQIrHJx6feBxAJEmSJEmSHEC/yvwq86scQFlMZzGdxRxA9M3RN0ffHECPTzw+8fgcQCnRpkSbEh1AxFIRS0UsHUBe1HtR70UdQPlV5leZXx1AlNdQXkN5HUAuWbtk7ZIdQMnaJWuXrB1AZFyQcUHGHUD+3fp3698dQJlfZX6V+R1ANOHPhD8THkDOYjqL6SweQGnkpJGTRh5AA2YPmD1gHkCe53me53keQDlp5KSRkx5A0+pOqzutHkBubLmx5cYeQAjuI7iP4B5Ao2+Ovjn6HkA+8fjE4xMfQNhyY8uNLR9Ac/TN0TdHH0AOdjjY4WAfQKj3ot6Leh9AQ3kN5TWUH0De+nfr360fQHh84vGJxx9AE/5M+DPhH0Ctf7f+3fofQKQAkQJECiBAcUHGBRkXIEA/gvsI7iMgQAzDMAzDMCBA2QNmD5g9IECnRJsSbUogQHSF0BVCVyBAQcYFGRdkIEAOBzsc7HAgQNxHcB/BfSBAqYilIpaKIEB2ydola5cgQEQKEClApCBAEUtFLBWxIEDei3ov6r0gQKzMrzK/yiBAeQ3lNZTXIEBGTho5aeQgQBSPTzw+8SBA4c+EPxP+IECuELpC6AohQHxR70W9FyFASZIkSZIkIUAW01lMZzEhQOQTj088PiFAsVTEUhFLIUB+lflV5lchQEvWLlm7ZCFAGRdkXJBxIUDmV5lfZX4hQLOYzmI6iyFAgdkDZg+YIUBOGjlp5KQhQBtbbmy5sSFA6Zujb46+IUC23NhyY8shQIMdDnY42CFAUV5DeQ3lIUAen3h84vEhQOvfrX+3/iFAuCDjgowLIkCGYRiGYRgiQFOiTYk2JSJAIOOCjAsyIkDuI7iP4D4iQLtk7ZK1SyJAiKUilopYIkBW5leZX2UiQCMnjZw0ciJA8GfCnwl/IkC+qPei3osiQIvpLKazmCJAWCpiqYilIkAma5esXbIiQPOrzK8yvyJAwOwBswfMIkCOLTe23NgiQFtubLmx5SJAKK+hvIbyIkD179a/W/8iQMMwDMMwDCNAkHFBxgUZI0BdsnbJ2iUjQCvzq8yvMiNA+DPhz4Q/I0DFdBbTWUwjQJO1S9YuWSNAYPaA2QNmI0AtN7bc2HIjQPt369+tfyNAyLgg44KMI0CV+VXmV5kjQGI6i+kspiNAMHvA7AGzI0D9u/Xv1r8jQMr8KvOrzCNAmD1g9oDZI0BlfpX5VeYjQDK/yvwq8yNAAAAAAAAAJEA="},"shape":[400],"dtype":"float64","order":"little"}],["y_p",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}]]}}}],["source_c",{"type":"object","name":"ColumnDataSource","id":"p2050","attributes":{"selected":{"type":"object","name":"Selection","id":"p2051","attributes":{"indices":[],"line_indices":[]}},"selection_policy":{"type":"object","name":"UnionRenderers","id":"p2052"},"data":{"type":"map","entries":[["x",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}],["y_c",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}]]}}}],["discrete",false],["n",400],["sliders",[{"type":"object","name":"Slider","id":"p2072","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p2080","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p1977"}],["p_c",{"id":"p2011"}],["source_p",{"id":"p2047"}],["source_c",{"id":"p2050"}],["discrete",false],["n",400],["sliders",[{"id":"p2072"}]],["xBoxes",[{"type":"object","name":"TextInput","id":"p2075","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p2083","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p1977"}],["p_c",{"id":"p2011"}],["source_p",{"id":"p2047"}],["source_c",{"id":"p2050"}],["discrete",false],["n",400],["sliders",[{"id":"p2072"}]],["xBoxes",[{"id":"p2075"}]],["pBoxes",[{"type":"object","name":"TextInput","id":"p2076","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p2083"}]]]},"disabled":true,"width":80,"value":"0.5000"}}]],["quantileSetterSwitch",{"id":"p2078"}],["quantileSetterDiv",{"type":"object","name":"Div","id":"p2077"}],["triggerCallbacks",{"type":"object","name":"Switch","id":"p2079","attributes":{"active":true}}],["startBoxes",[{"type":"object","name":"TextInput","id":"p2073","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p2085","attributes":{"args":{"type":"map","entries":[["minValue","0"],["maxValue","Infinity"],["slider",{"id":"p2072"}]]},"code":"\\n\\nslider.start = Math.max(minValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"1.0"}}]],["endBoxes",[{"type":"object","name":"TextInput","id":"p2074","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p2086","attributes":{"args":{"type":"map","entries":[["minValue","0"],["maxValue","Infinity"],["slider",{"id":"p2072"}]]},"code":"\\n\\nslider.end = Math.min(maxValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"10.0"}}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nfunction erfinv(x) {\\n  \\n  let p = (x + 1.0) / 2.0;\\n\\n  \\n  if (p == 0.0) return -Infinity;\\n  if (p == 1.0) return Infinity;\\n  if (p &gt; 1.0 || p &lt; 0.0) return undefined;\\n\\n  let split1 = 0.425;\\n  let split2 = 5.0;\\n  let const1 = 0.180625;\\n  let const2 = 1.6;\\n\\n  \\n  let a0 = 3.3871327179;\\n  let a1 = 5.0434271938e1;\\n  let a2 = 1.5929113202e2;\\n  let a3 = 5.9109374720e1;\\n  let b1 = 1.7895169469e1;\\n  let b2 = 7.8757757664e1;\\n  let b3 = 6.7187563600e1;\\n\\n  \\n  let c0 = 1.4234372777;\\n  let c1 = 2.7568153900;\\n  let c2 = 1.3067284816;\\n  let c3 = 1.7023821103e-1;\\n  let d1 = 7.3700164250e-1;\\n  let d2 = 1.2021132975e-1;\\n\\n  \\n  let e0 = 6.6579051150;\\n  let e1 = 3.0812263860;\\n  let e2 = 4.2868294337e-1;\\n  let e3 = 1.7337203997e-2;\\n  let f1 = 2.4197894225e-1;\\n  let f2 = 1.2258202635e-2;\\n\\n  let r;\\n  let res;\\n  let q = p - 0.5;\\n\\n  if (Math.abs(q) &lt;= split1) {\\n    r = const1 - q * q;\\n    res = q * (((a3 * r + a2) * r + a1) * r + a0) /\\n              (((b3 * r + b2) * r + b1) * r + 1.0);\\n  } else {\\n    r = q &lt; 0 ? p : 1.0 - p;\\n\\n    r = Math.sqrt(-Math.log(r));\\n\\n    if (r &lt;= split2) {\\n      r -= const2;\\n      res = (((c3 * r + c2) * r + c1) * r + c0) /\\n             ((d2 * r + d1) * r + 1.0);\\n    } else {\\n      r -= split2;\\n      res = (((e3 * r + e2) * r + e1) * r + e0) /\\n             ((f2 * r + f1) * r + 1.0);\\n    }\\n  \\n    if (q &lt; 0) {\\n      res = -res;\\n    }\\n  }\\n\\n  \\n  return 0.7071067811865475 * res;\\n\\n}\\n\\n\\nfunction lngamma(z) {\\n\\n    if(z &lt; 0) return Number(&#x27;0/0&#x27;);\\n\\n    if (z &lt; 0.5) return Math.log(Math.PI) - Math.log(Math.sin(Math.PI * z)) - lngamma(1-z);\\n\\n    var p = [676.5203681218851,\\n             -1259.1392167224028,\\n             771.32342877765313,\\n             -176.61502916214059,\\n             12.507343278686905,\\n             -0.13857109526572012,\\n             9.9843695780195716e-6,\\n             1.5056327351493116e-7];\\n\\n    z -= 1.0;\\n    var Ag = 0.99999999999980993;\\n    for (var i = 0; i &lt; p.length; i++) {\\n        Ag += p[i] / (z + i + 1);\\n    }\\n    var t = z + p.length - 0.5;\\n\\n    return 0.5 * Math.log(2*Math.PI) + (z + 0.5)*Math.log(t) - t + Math.log(Ag);\\n}\\n\\n\\nfunction gammaincL(x, s, regularized) {\\n\\n  var EPSILON = 1e-12;\\n\\n  if (x === 0) {\\n    return 0;\\n  }\\n  if (x &lt; 0 || s &lt;= 0) {\\n    return NaN;\\n  }\\n\\n  if (x &gt; 1.1 &amp;&amp; x &gt; s) {\\n    if (regularized !== false) {\\n      return 1 - gammaincU(x, s, regularized);\\n    } else {\\n      return Math.exp(lngamma(s)) - gammaincU(x, s, regularized);\\n    }\\n  }\\n\\n  var ft,\\n    r = s,\\n    c = 1,\\n    pws = 1;\\n\\n  if (regularized !== false) {\\n    ft = s * Math.log(x) - x - lngamma(s);\\n  } else {\\n    ft = s * Math.log(x) - x;\\n  }\\n  ft = Math.exp(ft);\\n  do {\\n    r += 1;\\n    c *= x/r;\\n    pws += c;\\n  } while (c / pws &gt; EPSILON);\\n\\n  return pws * ft / s;\\n}\\n\\n\\nfunction secantSolve(x0, f, args=[], tol=1e-8, maxIter=200, epsilon=1e-14, h=1e-4) {\\n\\tlet x = Infinity;\\n\\tlet solved = false;\\n\\n\\tlet x1 = x0 * (1 + h);\\n\\tx1 += x1 &gt;= 0 ? h : -h;\\n\\n\\tlet q0 = f(x0, ...args);\\n\\tlet q1 = f(x1, ...args);\\n\\t\\n\\tif (Math.abs(q1) &lt; Math.abs(q0)) {\\n\\t\\t[x0, x1, q0, q1] = [x1, x0, q1, q0];\\n\\t}\\n\\n\\tfor (let i = 0; i &lt; maxIter; i++) {\\n\\t\\tif (q0 == q1) {\\n\\t\\t\\tsolved = x0 == x1;\\n\\t\\t\\tx = (x0 + x1) / 2.0;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tif (Math.abs(q1) &gt; Math.abs(q0)) {\\n\\t\\t\\t\\tx = (x0 - q0 / q1 * x1) / (1.0 - q0 / q1);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tx = (x1 - q1 / q0 * x0) / (1.0 - q1 / q0);\\n\\t\\t\\t}\\n\\t\\t\\tif (Math.abs(x - x0) &lt;= tol) {\\n\\t\\t\\t\\tsolved = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\t[x0, q0] = [x1, q1];\\n\\t\\t\\tx1 = x;\\n\\t\\t\\tq1 = f(x1, ...args);\\n\\t\\t}\\n\\t}\\n\\n  if (solved) return x;\\n  else return null;\\n}\\n\\n\\nfunction brentSolve(f, lower, upper, args=[], tol=1e-8, maxIter=1000) {\\n\\tlet a = lower;\\n\\tlet b = upper;\\n  let fa = f(a, ...args);\\n  let fb = f(b, ...args);\\n\\n  \\n  if (Math.abs(fa) &lt; tol) return a;\\n  if (Math.abs(fb) &lt; tol) return b;\\n\\n  \\n  if (fa * fb &gt;= 0) {\\n  \\treturn null;\\n\\t}\\n\\n  \\n  let c = a;\\n  let fc = fa;\\n\\n\\tlet iter = 0;\\n  while (iter++ &lt; maxIter) {\\n  \\tlet prevStep = b - a;\\n\\n    \\n    if (Math.abs(fc) &lt; Math.abs(fb)) {      \\n    \\t[a, b, c] = [b, c, b];\\n    \\t[fa, fb, fc] = [fb, fc, fb];\\n    }\\n\\n    \\n    let newStep = (c - b) / 2.0;\\n\\n    \\n    let tolAdj = 1e-15 * Math.abs(b) + tol / 2;\\n\\n    \\n  \\tif (Math.abs(newStep) &lt;= tolAdj || fb === 0 ) {\\n    \\t\\treturn b;\\n  \\t}\\n\\n    \\n    if (Math.abs(prevStep) &gt; tolAdj &amp;&amp; Math.abs(fa) &gt; Math.abs(fb)) {\\n    \\tlet p;\\n    \\tlet q;\\n    \\tlet t1;\\n    \\tlet t2;\\n    \\tlet cb = c - b;\\n    \\tif (a === c) { \\n    \\t\\tt1 = fb / fa;\\n    \\t\\tp = cb * t1;\\n    \\t\\tq = 1.0 - t1;\\n    \\t}\\n    \\telse { \\n    \\t\\tq = fa / fc;\\n    \\t\\tt1 = fb / fc;\\n    \\t\\tt2 = fb / fa;\\n    \\t\\tp = t2 * (cb * q * (q - t1) - (b - a) * (t1 - 1.0));\\n    \\t\\tq = (q - 1.0) * (t1 - 1.0) * (t2 - 1.0);\\n    \\t}\\n\\n    \\t\\n    \\tif (p &gt; 0) q = -q;\\n    \\telse p = -p;\\n\\n    \\t\\n    \\tif (p &lt; (0.75 * cb * q - Math.abs(tolAdj * q) / 2.0) \\n    \\t\\t&amp;&amp; p &lt; Math.abs(prevStep * q / 2.0)) { \\n\\t        newStep = p / q;\\n      \\t}\\n    }\\n\\n    if (Math.abs(newStep) &lt; tolAdj) {\\n      newStep = (newStep &gt; 0) ? tolAdj : -tolAdj;\\n    }\\n\\n    \\n    a = b;\\n    fa = fb;\\n\\n    \\n    b += newStep;\\n    fb = f(b, ...args);\\n\\n\\t\\n    if ((fb &gt; 0 &amp;&amp; fc &gt; 0) || (fb &lt; 0 &amp;&amp; fc &lt; 0)) {\\n      c = a; \\n      fc = fa;\\n    }\\n  }\\n\\n  \\n  return null;\\n}\\n\\n\\nfunction gammaincU(x, s, regularized) {\\n\\n  var EPSILON = 1e-12;\\n\\n  if (x &lt;= 1.1 || x &lt;= s) {\\n    if (regularized !== false) {\\n      return 1 - gammaincL(x, s, regularized);\\n    } else {\\n      return Math.exp(lngamma(s)) - gammaincL(x, s, regularized);\\n    }\\n  }\\n\\n  var f = 1 + x - s,\\n    C = f,\\n    D = 0,\\n    i = 1,\\n    a, b, chg;\\n  for (i = 1; i &lt; 10000; i++) {\\n    a = i * (s - i);\\n    b = (i&lt;&lt;1) + 1 + x - s;\\n    D = b + a * D;\\n    C = b + a / C;\\n    D = 1 / D;\\n    chg = C * D;\\n    f *= chg;\\n    if (Math.abs(chg - 1) &lt; EPSILON) {\\n      break;\\n    }\\n  }\\n  if (regularized !== false) {\\n    return Math.exp(s * Math.log(x) - x - lngamma(s) - Math.log(f));\\n  } else {\\n    return Math.exp(s * Math.log(x) - x - Math.log(f));\\n  }\\n}\\n\\n\\nclass ChiSquareDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Chi-square&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bd&#x27;];\\n\\n    \\n    this.paramMin = [0.0];\\n\\n    \\n    this.paramMax = [Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0.0;   \\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x &lt; 0) return NaN;\\n    if (x == Infinity) return 0.0;\\n\\n    let nu = params[0];\\n    let alpha = nu / 2;\\n    let beta = 0.5;\\n\\n    if (x == 0) {\\n      if (alpha == 1) {\\n        return beta;\\n      } else if (alpha &gt; 1) {\\n        return 0.0;\\n      } else {  \\n        return Infinity;\\n      }\\n    }\\n\\n    let lnProb;\\n    lnProb = alpha * Math.log(beta * x) - Math.log(x) - beta * x - lngamma(alpha);\\n\\n    return Math.exp(lnProb);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x &lt;= 0) return 0.0;\\n    if (x == Infinity) return 1.0;\\n\\n    let nu = params[0];\\n\\n    if (nu == Infinity) return 0.0;\\n    if (nu == 0) return 1.0\\n\\n    let alpha = nu / 2;\\n    let beta = 0.5;\\n\\n    return gammaincL(beta * x, alpha, true);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return 0.0;\\n    if (p === 1) return Infinity;\\n\\n    let rootFun = (xi, params, p) =&gt; {\\n        let x = xi == 1.0 ? Infinity : xi / (1.0 - xi);\\n\\n        return p - this.cdfSingleValue(x, params);\\n    }\\n\\n    let xiOpt = brentSolve(rootFun, 0.0, 1.0, [params, p]);\\n\\n    \\n    if (xiOpt === 1) {\\n      return Infinity;\\n    }\\n\\n    \\n    let xFirstPass = xiOpt / (1.0 - xiOpt);\\n\\n    let closeRootFun = (x, params, p) =&gt; {\\n      return p - this.cdfSingleValue(x, params);\\n    }\\n\\n    let xOpt = secantSolve(xFirstPass, closeRootFun, [params, p]);\\n\\n    let retval;\\n    if (xOpt != null &amp;&amp; closeRootFun(xOpt, params, p) &lt; closeRootFun(xFirstPass, params, p)) {\\n      retval = xOpt;\\n    } else {\\n      retval = xFirstPass;\\n    }\\n\\n    return retval;\\n  }\\n\\n  defaultXRange(params) {\\n    let [x1, x2] = this.ppf([0.001, 0.999], params);\\n\\n    \\n    if (x1 &lt; (x2 - x1) / 10.0) x1 = 0.0;\\n\\n    return [x1, x2];\\n  }\\n\\n  quantileSet(x, p) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n\\n    let rootFun = (xi, x, p) =&gt; {\\n        let nu = xi == 1.0 ? Infinity : xi / (1.0 - xi);\\n\\n        return p - this.cdfSingleValue(x, [nu]);\\n    }\\n\\n    let xiOpt = brentSolve(rootFun, 0.0, 1.0, [x1, p1]);\\n\\n    if (xiOpt === 1) {\\n      if (p1 == 0.5) {\\n        return [[x1], true];\\n      }\\n      else {\\n        let invErf2 = Math.pow(erfinv(2 * p1 - 1), 2);\\n        let invErf4 = Math.pow(invErf2, 2);\\n\\n        term1 = x1 + 2 * invErf2;\\n        term2 = 2 * Math.sqrt(x1 * invErf2 + invErf4);\\n\\n        if (p1 &lt; 0.5) return [[term1 - term2], true];\\n        else return [[term1 + term2] , true];\\n      }\\n    }\\n\\n    \\n    let nuFirstPass = xiOpt / (1.0 - xiOpt);\\n\\n    let closeRootFun = (nu, x, p) =&gt; {\\n      return p - this.cdfSingleValue(x, [nu]);\\n    }\\n\\n    let nuOpt = secantSolve(nuFirstPass, closeRootFun, [x1, p1]);\\n\\n    let retval;\\n    if (nuOpt != null &amp;&amp; closeRootFun(nuOpt, x1, p1) &lt; closeRootFun(nuFirstPass, x, p)) {\\n      retval = nuOpt;\\n    } else {\\n      retval = nuFirstPass;\\n    }\\n\\n    return [[retval], true];\\n  }\\n\\n}\\n\\n\\n\\nvar dist = new ChiSquareDistribution();\\n\\n\\n\\nif (quantileSetterSwitch.active) {\\n  quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p);\\n}"}}]]]},"disabled":true,"width":80,"value":"1.3863"}}]],["pBoxes",[{"id":"p2076"}]],["quantileSetterSwitch",{"id":"p2078"}],["quantileSetterDiv",{"id":"p2077"}],["triggerCallbacks",{"id":"p2079"}],["startBoxes",[{"id":"p2073"}]],["endBoxes",[{"id":"p2074"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nfunction erfinv(x) {\\n  \\n  let p = (x + 1.0) / 2.0;\\n\\n  \\n  if (p == 0.0) return -Infinity;\\n  if (p == 1.0) return Infinity;\\n  if (p &gt; 1.0 || p &lt; 0.0) return undefined;\\n\\n  let split1 = 0.425;\\n  let split2 = 5.0;\\n  let const1 = 0.180625;\\n  let const2 = 1.6;\\n\\n  \\n  let a0 = 3.3871327179;\\n  let a1 = 5.0434271938e1;\\n  let a2 = 1.5929113202e2;\\n  let a3 = 5.9109374720e1;\\n  let b1 = 1.7895169469e1;\\n  let b2 = 7.8757757664e1;\\n  let b3 = 6.7187563600e1;\\n\\n  \\n  let c0 = 1.4234372777;\\n  let c1 = 2.7568153900;\\n  let c2 = 1.3067284816;\\n  let c3 = 1.7023821103e-1;\\n  let d1 = 7.3700164250e-1;\\n  let d2 = 1.2021132975e-1;\\n\\n  \\n  let e0 = 6.6579051150;\\n  let e1 = 3.0812263860;\\n  let e2 = 4.2868294337e-1;\\n  let e3 = 1.7337203997e-2;\\n  let f1 = 2.4197894225e-1;\\n  let f2 = 1.2258202635e-2;\\n\\n  let r;\\n  let res;\\n  let q = p - 0.5;\\n\\n  if (Math.abs(q) &lt;= split1) {\\n    r = const1 - q * q;\\n    res = q * (((a3 * r + a2) * r + a1) * r + a0) /\\n              (((b3 * r + b2) * r + b1) * r + 1.0);\\n  } else {\\n    r = q &lt; 0 ? p : 1.0 - p;\\n\\n    r = Math.sqrt(-Math.log(r));\\n\\n    if (r &lt;= split2) {\\n      r -= const2;\\n      res = (((c3 * r + c2) * r + c1) * r + c0) /\\n             ((d2 * r + d1) * r + 1.0);\\n    } else {\\n      r -= split2;\\n      res = (((e3 * r + e2) * r + e1) * r + e0) /\\n             ((f2 * r + f1) * r + 1.0);\\n    }\\n  \\n    if (q &lt; 0) {\\n      res = -res;\\n    }\\n  }\\n\\n  \\n  return 0.7071067811865475 * res;\\n\\n}\\n\\n\\nfunction lngamma(z) {\\n\\n    if(z &lt; 0) return Number(&#x27;0/0&#x27;);\\n\\n    if (z &lt; 0.5) return Math.log(Math.PI) - Math.log(Math.sin(Math.PI * z)) - lngamma(1-z);\\n\\n    var p = [676.5203681218851,\\n             -1259.1392167224028,\\n             771.32342877765313,\\n             -176.61502916214059,\\n             12.507343278686905,\\n             -0.13857109526572012,\\n             9.9843695780195716e-6,\\n             1.5056327351493116e-7];\\n\\n    z -= 1.0;\\n    var Ag = 0.99999999999980993;\\n    for (var i = 0; i &lt; p.length; i++) {\\n        Ag += p[i] / (z + i + 1);\\n    }\\n    var t = z + p.length - 0.5;\\n\\n    return 0.5 * Math.log(2*Math.PI) + (z + 0.5)*Math.log(t) - t + Math.log(Ag);\\n}\\n\\n\\nfunction gammaincL(x, s, regularized) {\\n\\n  var EPSILON = 1e-12;\\n\\n  if (x === 0) {\\n    return 0;\\n  }\\n  if (x &lt; 0 || s &lt;= 0) {\\n    return NaN;\\n  }\\n\\n  if (x &gt; 1.1 &amp;&amp; x &gt; s) {\\n    if (regularized !== false) {\\n      return 1 - gammaincU(x, s, regularized);\\n    } else {\\n      return Math.exp(lngamma(s)) - gammaincU(x, s, regularized);\\n    }\\n  }\\n\\n  var ft,\\n    r = s,\\n    c = 1,\\n    pws = 1;\\n\\n  if (regularized !== false) {\\n    ft = s * Math.log(x) - x - lngamma(s);\\n  } else {\\n    ft = s * Math.log(x) - x;\\n  }\\n  ft = Math.exp(ft);\\n  do {\\n    r += 1;\\n    c *= x/r;\\n    pws += c;\\n  } while (c / pws &gt; EPSILON);\\n\\n  return pws * ft / s;\\n}\\n\\n\\nfunction secantSolve(x0, f, args=[], tol=1e-8, maxIter=200, epsilon=1e-14, h=1e-4) {\\n\\tlet x = Infinity;\\n\\tlet solved = false;\\n\\n\\tlet x1 = x0 * (1 + h);\\n\\tx1 += x1 &gt;= 0 ? h : -h;\\n\\n\\tlet q0 = f(x0, ...args);\\n\\tlet q1 = f(x1, ...args);\\n\\t\\n\\tif (Math.abs(q1) &lt; Math.abs(q0)) {\\n\\t\\t[x0, x1, q0, q1] = [x1, x0, q1, q0];\\n\\t}\\n\\n\\tfor (let i = 0; i &lt; maxIter; i++) {\\n\\t\\tif (q0 == q1) {\\n\\t\\t\\tsolved = x0 == x1;\\n\\t\\t\\tx = (x0 + x1) / 2.0;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tif (Math.abs(q1) &gt; Math.abs(q0)) {\\n\\t\\t\\t\\tx = (x0 - q0 / q1 * x1) / (1.0 - q0 / q1);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tx = (x1 - q1 / q0 * x0) / (1.0 - q1 / q0);\\n\\t\\t\\t}\\n\\t\\t\\tif (Math.abs(x - x0) &lt;= tol) {\\n\\t\\t\\t\\tsolved = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\t[x0, q0] = [x1, q1];\\n\\t\\t\\tx1 = x;\\n\\t\\t\\tq1 = f(x1, ...args);\\n\\t\\t}\\n\\t}\\n\\n  if (solved) return x;\\n  else return null;\\n}\\n\\n\\nfunction brentSolve(f, lower, upper, args=[], tol=1e-8, maxIter=1000) {\\n\\tlet a = lower;\\n\\tlet b = upper;\\n  let fa = f(a, ...args);\\n  let fb = f(b, ...args);\\n\\n  \\n  if (Math.abs(fa) &lt; tol) return a;\\n  if (Math.abs(fb) &lt; tol) return b;\\n\\n  \\n  if (fa * fb &gt;= 0) {\\n  \\treturn null;\\n\\t}\\n\\n  \\n  let c = a;\\n  let fc = fa;\\n\\n\\tlet iter = 0;\\n  while (iter++ &lt; maxIter) {\\n  \\tlet prevStep = b - a;\\n\\n    \\n    if (Math.abs(fc) &lt; Math.abs(fb)) {      \\n    \\t[a, b, c] = [b, c, b];\\n    \\t[fa, fb, fc] = [fb, fc, fb];\\n    }\\n\\n    \\n    let newStep = (c - b) / 2.0;\\n\\n    \\n    let tolAdj = 1e-15 * Math.abs(b) + tol / 2;\\n\\n    \\n  \\tif (Math.abs(newStep) &lt;= tolAdj || fb === 0 ) {\\n    \\t\\treturn b;\\n  \\t}\\n\\n    \\n    if (Math.abs(prevStep) &gt; tolAdj &amp;&amp; Math.abs(fa) &gt; Math.abs(fb)) {\\n    \\tlet p;\\n    \\tlet q;\\n    \\tlet t1;\\n    \\tlet t2;\\n    \\tlet cb = c - b;\\n    \\tif (a === c) { \\n    \\t\\tt1 = fb / fa;\\n    \\t\\tp = cb * t1;\\n    \\t\\tq = 1.0 - t1;\\n    \\t}\\n    \\telse { \\n    \\t\\tq = fa / fc;\\n    \\t\\tt1 = fb / fc;\\n    \\t\\tt2 = fb / fa;\\n    \\t\\tp = t2 * (cb * q * (q - t1) - (b - a) * (t1 - 1.0));\\n    \\t\\tq = (q - 1.0) * (t1 - 1.0) * (t2 - 1.0);\\n    \\t}\\n\\n    \\t\\n    \\tif (p &gt; 0) q = -q;\\n    \\telse p = -p;\\n\\n    \\t\\n    \\tif (p &lt; (0.75 * cb * q - Math.abs(tolAdj * q) / 2.0) \\n    \\t\\t&amp;&amp; p &lt; Math.abs(prevStep * q / 2.0)) { \\n\\t        newStep = p / q;\\n      \\t}\\n    }\\n\\n    if (Math.abs(newStep) &lt; tolAdj) {\\n      newStep = (newStep &gt; 0) ? tolAdj : -tolAdj;\\n    }\\n\\n    \\n    a = b;\\n    fa = fb;\\n\\n    \\n    b += newStep;\\n    fb = f(b, ...args);\\n\\n\\t\\n    if ((fb &gt; 0 &amp;&amp; fc &gt; 0) || (fb &lt; 0 &amp;&amp; fc &lt; 0)) {\\n      c = a; \\n      fc = fa;\\n    }\\n  }\\n\\n  \\n  return null;\\n}\\n\\n\\nfunction gammaincU(x, s, regularized) {\\n\\n  var EPSILON = 1e-12;\\n\\n  if (x &lt;= 1.1 || x &lt;= s) {\\n    if (regularized !== false) {\\n      return 1 - gammaincL(x, s, regularized);\\n    } else {\\n      return Math.exp(lngamma(s)) - gammaincL(x, s, regularized);\\n    }\\n  }\\n\\n  var f = 1 + x - s,\\n    C = f,\\n    D = 0,\\n    i = 1,\\n    a, b, chg;\\n  for (i = 1; i &lt; 10000; i++) {\\n    a = i * (s - i);\\n    b = (i&lt;&lt;1) + 1 + x - s;\\n    D = b + a * D;\\n    C = b + a / C;\\n    D = 1 / D;\\n    chg = C * D;\\n    f *= chg;\\n    if (Math.abs(chg - 1) &lt; EPSILON) {\\n      break;\\n    }\\n  }\\n  if (regularized !== false) {\\n    return Math.exp(s * Math.log(x) - x - lngamma(s) - Math.log(f));\\n  } else {\\n    return Math.exp(s * Math.log(x) - x - Math.log(f));\\n  }\\n}\\n\\n\\nclass ChiSquareDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Chi-square&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bd&#x27;];\\n\\n    \\n    this.paramMin = [0.0];\\n\\n    \\n    this.paramMax = [Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0.0;   \\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x &lt; 0) return NaN;\\n    if (x == Infinity) return 0.0;\\n\\n    let nu = params[0];\\n    let alpha = nu / 2;\\n    let beta = 0.5;\\n\\n    if (x == 0) {\\n      if (alpha == 1) {\\n        return beta;\\n      } else if (alpha &gt; 1) {\\n        return 0.0;\\n      } else {  \\n        return Infinity;\\n      }\\n    }\\n\\n    let lnProb;\\n    lnProb = alpha * Math.log(beta * x) - Math.log(x) - beta * x - lngamma(alpha);\\n\\n    return Math.exp(lnProb);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x &lt;= 0) return 0.0;\\n    if (x == Infinity) return 1.0;\\n\\n    let nu = params[0];\\n\\n    if (nu == Infinity) return 0.0;\\n    if (nu == 0) return 1.0\\n\\n    let alpha = nu / 2;\\n    let beta = 0.5;\\n\\n    return gammaincL(beta * x, alpha, true);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return 0.0;\\n    if (p === 1) return Infinity;\\n\\n    let rootFun = (xi, params, p) =&gt; {\\n        let x = xi == 1.0 ? Infinity : xi / (1.0 - xi);\\n\\n        return p - this.cdfSingleValue(x, params);\\n    }\\n\\n    let xiOpt = brentSolve(rootFun, 0.0, 1.0, [params, p]);\\n\\n    \\n    if (xiOpt === 1) {\\n      return Infinity;\\n    }\\n\\n    \\n    let xFirstPass = xiOpt / (1.0 - xiOpt);\\n\\n    let closeRootFun = (x, params, p) =&gt; {\\n      return p - this.cdfSingleValue(x, params);\\n    }\\n\\n    let xOpt = secantSolve(xFirstPass, closeRootFun, [params, p]);\\n\\n    let retval;\\n    if (xOpt != null &amp;&amp; closeRootFun(xOpt, params, p) &lt; closeRootFun(xFirstPass, params, p)) {\\n      retval = xOpt;\\n    } else {\\n      retval = xFirstPass;\\n    }\\n\\n    return retval;\\n  }\\n\\n  defaultXRange(params) {\\n    let [x1, x2] = this.ppf([0.001, 0.999], params);\\n\\n    \\n    if (x1 &lt; (x2 - x1) / 10.0) x1 = 0.0;\\n\\n    return [x1, x2];\\n  }\\n\\n  quantileSet(x, p) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n\\n    let rootFun = (xi, x, p) =&gt; {\\n        let nu = xi == 1.0 ? Infinity : xi / (1.0 - xi);\\n\\n        return p - this.cdfSingleValue(x, [nu]);\\n    }\\n\\n    let xiOpt = brentSolve(rootFun, 0.0, 1.0, [x1, p1]);\\n\\n    if (xiOpt === 1) {\\n      if (p1 == 0.5) {\\n        return [[x1], true];\\n      }\\n      else {\\n        let invErf2 = Math.pow(erfinv(2 * p1 - 1), 2);\\n        let invErf4 = Math.pow(invErf2, 2);\\n\\n        term1 = x1 + 2 * invErf2;\\n        term2 = 2 * Math.sqrt(x1 * invErf2 + invErf4);\\n\\n        if (p1 &lt; 0.5) return [[term1 - term2], true];\\n        else return [[term1 + term2] , true];\\n      }\\n    }\\n\\n    \\n    let nuFirstPass = xiOpt / (1.0 - xiOpt);\\n\\n    let closeRootFun = (nu, x, p) =&gt; {\\n      return p - this.cdfSingleValue(x, [nu]);\\n    }\\n\\n    let nuOpt = secantSolve(nuFirstPass, closeRootFun, [x1, p1]);\\n\\n    let retval;\\n    if (nuOpt != null &amp;&amp; closeRootFun(nuOpt, x1, p1) &lt; closeRootFun(nuFirstPass, x, p)) {\\n      retval = nuOpt;\\n    } else {\\n      retval = nuFirstPass;\\n    }\\n\\n    return [[retval], true];\\n  }\\n\\n}\\n\\n\\n\\nvar dist = new ChiSquareDistribution();\\n\\n\\n\\nif (triggerCallbacks.active &amp;&amp; !cb_obj.disabled) {\\n\\tif (quantileSetterSwitch.active) {\\n\\t\\tquantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p);\\n\\t}\\n\\telse {\\n\\t\\tupdateData(source_p, source_c, p_p, sliders, discrete);\\n\\t\\tupdateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes);\\n\\t}\\n}"}}]]]},"width":200,"title":"\\u03bd","format":{"type":"object","name":"CustomJSTickFormatter","id":"p2071","attributes":{"code":"return tick.toPrecision(4)"}},"start":1.0,"end":10.0,"value":2.0,"step":0.01}}]],["xBoxes",[{"id":"p2075"}]],["pBoxes",[{"id":"p2076"}]],["quantileSetterSwitch",{"id":"p2078"}],["quantileSetterDiv",{"id":"p2077"}],["triggerCallbacks",{"id":"p2079"}],["startBoxes",[{"id":"p2073"}]],["endBoxes",[{"id":"p2074"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nfunction erfinv(x) {\\n  \\n  let p = (x + 1.0) / 2.0;\\n\\n  \\n  if (p == 0.0) return -Infinity;\\n  if (p == 1.0) return Infinity;\\n  if (p &gt; 1.0 || p &lt; 0.0) return undefined;\\n\\n  let split1 = 0.425;\\n  let split2 = 5.0;\\n  let const1 = 0.180625;\\n  let const2 = 1.6;\\n\\n  \\n  let a0 = 3.3871327179;\\n  let a1 = 5.0434271938e1;\\n  let a2 = 1.5929113202e2;\\n  let a3 = 5.9109374720e1;\\n  let b1 = 1.7895169469e1;\\n  let b2 = 7.8757757664e1;\\n  let b3 = 6.7187563600e1;\\n\\n  \\n  let c0 = 1.4234372777;\\n  let c1 = 2.7568153900;\\n  let c2 = 1.3067284816;\\n  let c3 = 1.7023821103e-1;\\n  let d1 = 7.3700164250e-1;\\n  let d2 = 1.2021132975e-1;\\n\\n  \\n  let e0 = 6.6579051150;\\n  let e1 = 3.0812263860;\\n  let e2 = 4.2868294337e-1;\\n  let e3 = 1.7337203997e-2;\\n  let f1 = 2.4197894225e-1;\\n  let f2 = 1.2258202635e-2;\\n\\n  let r;\\n  let res;\\n  let q = p - 0.5;\\n\\n  if (Math.abs(q) &lt;= split1) {\\n    r = const1 - q * q;\\n    res = q * (((a3 * r + a2) * r + a1) * r + a0) /\\n              (((b3 * r + b2) * r + b1) * r + 1.0);\\n  } else {\\n    r = q &lt; 0 ? p : 1.0 - p;\\n\\n    r = Math.sqrt(-Math.log(r));\\n\\n    if (r &lt;= split2) {\\n      r -= const2;\\n      res = (((c3 * r + c2) * r + c1) * r + c0) /\\n             ((d2 * r + d1) * r + 1.0);\\n    } else {\\n      r -= split2;\\n      res = (((e3 * r + e2) * r + e1) * r + e0) /\\n             ((f2 * r + f1) * r + 1.0);\\n    }\\n  \\n    if (q &lt; 0) {\\n      res = -res;\\n    }\\n  }\\n\\n  \\n  return 0.7071067811865475 * res;\\n\\n}\\n\\n\\nfunction lngamma(z) {\\n\\n    if(z &lt; 0) return Number(&#x27;0/0&#x27;);\\n\\n    if (z &lt; 0.5) return Math.log(Math.PI) - Math.log(Math.sin(Math.PI * z)) - lngamma(1-z);\\n\\n    var p = [676.5203681218851,\\n             -1259.1392167224028,\\n             771.32342877765313,\\n             -176.61502916214059,\\n             12.507343278686905,\\n             -0.13857109526572012,\\n             9.9843695780195716e-6,\\n             1.5056327351493116e-7];\\n\\n    z -= 1.0;\\n    var Ag = 0.99999999999980993;\\n    for (var i = 0; i &lt; p.length; i++) {\\n        Ag += p[i] / (z + i + 1);\\n    }\\n    var t = z + p.length - 0.5;\\n\\n    return 0.5 * Math.log(2*Math.PI) + (z + 0.5)*Math.log(t) - t + Math.log(Ag);\\n}\\n\\n\\nfunction gammaincL(x, s, regularized) {\\n\\n  var EPSILON = 1e-12;\\n\\n  if (x === 0) {\\n    return 0;\\n  }\\n  if (x &lt; 0 || s &lt;= 0) {\\n    return NaN;\\n  }\\n\\n  if (x &gt; 1.1 &amp;&amp; x &gt; s) {\\n    if (regularized !== false) {\\n      return 1 - gammaincU(x, s, regularized);\\n    } else {\\n      return Math.exp(lngamma(s)) - gammaincU(x, s, regularized);\\n    }\\n  }\\n\\n  var ft,\\n    r = s,\\n    c = 1,\\n    pws = 1;\\n\\n  if (regularized !== false) {\\n    ft = s * Math.log(x) - x - lngamma(s);\\n  } else {\\n    ft = s * Math.log(x) - x;\\n  }\\n  ft = Math.exp(ft);\\n  do {\\n    r += 1;\\n    c *= x/r;\\n    pws += c;\\n  } while (c / pws &gt; EPSILON);\\n\\n  return pws * ft / s;\\n}\\n\\n\\nfunction secantSolve(x0, f, args=[], tol=1e-8, maxIter=200, epsilon=1e-14, h=1e-4) {\\n\\tlet x = Infinity;\\n\\tlet solved = false;\\n\\n\\tlet x1 = x0 * (1 + h);\\n\\tx1 += x1 &gt;= 0 ? h : -h;\\n\\n\\tlet q0 = f(x0, ...args);\\n\\tlet q1 = f(x1, ...args);\\n\\t\\n\\tif (Math.abs(q1) &lt; Math.abs(q0)) {\\n\\t\\t[x0, x1, q0, q1] = [x1, x0, q1, q0];\\n\\t}\\n\\n\\tfor (let i = 0; i &lt; maxIter; i++) {\\n\\t\\tif (q0 == q1) {\\n\\t\\t\\tsolved = x0 == x1;\\n\\t\\t\\tx = (x0 + x1) / 2.0;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tif (Math.abs(q1) &gt; Math.abs(q0)) {\\n\\t\\t\\t\\tx = (x0 - q0 / q1 * x1) / (1.0 - q0 / q1);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tx = (x1 - q1 / q0 * x0) / (1.0 - q1 / q0);\\n\\t\\t\\t}\\n\\t\\t\\tif (Math.abs(x - x0) &lt;= tol) {\\n\\t\\t\\t\\tsolved = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\t[x0, q0] = [x1, q1];\\n\\t\\t\\tx1 = x;\\n\\t\\t\\tq1 = f(x1, ...args);\\n\\t\\t}\\n\\t}\\n\\n  if (solved) return x;\\n  else return null;\\n}\\n\\n\\nfunction brentSolve(f, lower, upper, args=[], tol=1e-8, maxIter=1000) {\\n\\tlet a = lower;\\n\\tlet b = upper;\\n  let fa = f(a, ...args);\\n  let fb = f(b, ...args);\\n\\n  \\n  if (Math.abs(fa) &lt; tol) return a;\\n  if (Math.abs(fb) &lt; tol) return b;\\n\\n  \\n  if (fa * fb &gt;= 0) {\\n  \\treturn null;\\n\\t}\\n\\n  \\n  let c = a;\\n  let fc = fa;\\n\\n\\tlet iter = 0;\\n  while (iter++ &lt; maxIter) {\\n  \\tlet prevStep = b - a;\\n\\n    \\n    if (Math.abs(fc) &lt; Math.abs(fb)) {      \\n    \\t[a, b, c] = [b, c, b];\\n    \\t[fa, fb, fc] = [fb, fc, fb];\\n    }\\n\\n    \\n    let newStep = (c - b) / 2.0;\\n\\n    \\n    let tolAdj = 1e-15 * Math.abs(b) + tol / 2;\\n\\n    \\n  \\tif (Math.abs(newStep) &lt;= tolAdj || fb === 0 ) {\\n    \\t\\treturn b;\\n  \\t}\\n\\n    \\n    if (Math.abs(prevStep) &gt; tolAdj &amp;&amp; Math.abs(fa) &gt; Math.abs(fb)) {\\n    \\tlet p;\\n    \\tlet q;\\n    \\tlet t1;\\n    \\tlet t2;\\n    \\tlet cb = c - b;\\n    \\tif (a === c) { \\n    \\t\\tt1 = fb / fa;\\n    \\t\\tp = cb * t1;\\n    \\t\\tq = 1.0 - t1;\\n    \\t}\\n    \\telse { \\n    \\t\\tq = fa / fc;\\n    \\t\\tt1 = fb / fc;\\n    \\t\\tt2 = fb / fa;\\n    \\t\\tp = t2 * (cb * q * (q - t1) - (b - a) * (t1 - 1.0));\\n    \\t\\tq = (q - 1.0) * (t1 - 1.0) * (t2 - 1.0);\\n    \\t}\\n\\n    \\t\\n    \\tif (p &gt; 0) q = -q;\\n    \\telse p = -p;\\n\\n    \\t\\n    \\tif (p &lt; (0.75 * cb * q - Math.abs(tolAdj * q) / 2.0) \\n    \\t\\t&amp;&amp; p &lt; Math.abs(prevStep * q / 2.0)) { \\n\\t        newStep = p / q;\\n      \\t}\\n    }\\n\\n    if (Math.abs(newStep) &lt; tolAdj) {\\n      newStep = (newStep &gt; 0) ? tolAdj : -tolAdj;\\n    }\\n\\n    \\n    a = b;\\n    fa = fb;\\n\\n    \\n    b += newStep;\\n    fb = f(b, ...args);\\n\\n\\t\\n    if ((fb &gt; 0 &amp;&amp; fc &gt; 0) || (fb &lt; 0 &amp;&amp; fc &lt; 0)) {\\n      c = a; \\n      fc = fa;\\n    }\\n  }\\n\\n  \\n  return null;\\n}\\n\\n\\nfunction gammaincU(x, s, regularized) {\\n\\n  var EPSILON = 1e-12;\\n\\n  if (x &lt;= 1.1 || x &lt;= s) {\\n    if (regularized !== false) {\\n      return 1 - gammaincL(x, s, regularized);\\n    } else {\\n      return Math.exp(lngamma(s)) - gammaincL(x, s, regularized);\\n    }\\n  }\\n\\n  var f = 1 + x - s,\\n    C = f,\\n    D = 0,\\n    i = 1,\\n    a, b, chg;\\n  for (i = 1; i &lt; 10000; i++) {\\n    a = i * (s - i);\\n    b = (i&lt;&lt;1) + 1 + x - s;\\n    D = b + a * D;\\n    C = b + a / C;\\n    D = 1 / D;\\n    chg = C * D;\\n    f *= chg;\\n    if (Math.abs(chg - 1) &lt; EPSILON) {\\n      break;\\n    }\\n  }\\n  if (regularized !== false) {\\n    return Math.exp(s * Math.log(x) - x - lngamma(s) - Math.log(f));\\n  } else {\\n    return Math.exp(s * Math.log(x) - x - Math.log(f));\\n  }\\n}\\n\\n\\nclass ChiSquareDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Chi-square&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bd&#x27;];\\n\\n    \\n    this.paramMin = [0.0];\\n\\n    \\n    this.paramMax = [Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0.0;   \\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x &lt; 0) return NaN;\\n    if (x == Infinity) return 0.0;\\n\\n    let nu = params[0];\\n    let alpha = nu / 2;\\n    let beta = 0.5;\\n\\n    if (x == 0) {\\n      if (alpha == 1) {\\n        return beta;\\n      } else if (alpha &gt; 1) {\\n        return 0.0;\\n      } else {  \\n        return Infinity;\\n      }\\n    }\\n\\n    let lnProb;\\n    lnProb = alpha * Math.log(beta * x) - Math.log(x) - beta * x - lngamma(alpha);\\n\\n    return Math.exp(lnProb);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x &lt;= 0) return 0.0;\\n    if (x == Infinity) return 1.0;\\n\\n    let nu = params[0];\\n\\n    if (nu == Infinity) return 0.0;\\n    if (nu == 0) return 1.0\\n\\n    let alpha = nu / 2;\\n    let beta = 0.5;\\n\\n    return gammaincL(beta * x, alpha, true);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return 0.0;\\n    if (p === 1) return Infinity;\\n\\n    let rootFun = (xi, params, p) =&gt; {\\n        let x = xi == 1.0 ? Infinity : xi / (1.0 - xi);\\n\\n        return p - this.cdfSingleValue(x, params);\\n    }\\n\\n    let xiOpt = brentSolve(rootFun, 0.0, 1.0, [params, p]);\\n\\n    \\n    if (xiOpt === 1) {\\n      return Infinity;\\n    }\\n\\n    \\n    let xFirstPass = xiOpt / (1.0 - xiOpt);\\n\\n    let closeRootFun = (x, params, p) =&gt; {\\n      return p - this.cdfSingleValue(x, params);\\n    }\\n\\n    let xOpt = secantSolve(xFirstPass, closeRootFun, [params, p]);\\n\\n    let retval;\\n    if (xOpt != null &amp;&amp; closeRootFun(xOpt, params, p) &lt; closeRootFun(xFirstPass, params, p)) {\\n      retval = xOpt;\\n    } else {\\n      retval = xFirstPass;\\n    }\\n\\n    return retval;\\n  }\\n\\n  defaultXRange(params) {\\n    let [x1, x2] = this.ppf([0.001, 0.999], params);\\n\\n    \\n    if (x1 &lt; (x2 - x1) / 10.0) x1 = 0.0;\\n\\n    return [x1, x2];\\n  }\\n\\n  quantileSet(x, p) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n\\n    let rootFun = (xi, x, p) =&gt; {\\n        let nu = xi == 1.0 ? Infinity : xi / (1.0 - xi);\\n\\n        return p - this.cdfSingleValue(x, [nu]);\\n    }\\n\\n    let xiOpt = brentSolve(rootFun, 0.0, 1.0, [x1, p1]);\\n\\n    if (xiOpt === 1) {\\n      if (p1 == 0.5) {\\n        return [[x1], true];\\n      }\\n      else {\\n        let invErf2 = Math.pow(erfinv(2 * p1 - 1), 2);\\n        let invErf4 = Math.pow(invErf2, 2);\\n\\n        term1 = x1 + 2 * invErf2;\\n        term2 = 2 * Math.sqrt(x1 * invErf2 + invErf4);\\n\\n        if (p1 &lt; 0.5) return [[term1 - term2], true];\\n        else return [[term1 + term2] , true];\\n      }\\n    }\\n\\n    \\n    let nuFirstPass = xiOpt / (1.0 - xiOpt);\\n\\n    let closeRootFun = (nu, x, p) =&gt; {\\n      return p - this.cdfSingleValue(x, [nu]);\\n    }\\n\\n    let nuOpt = secantSolve(nuFirstPass, closeRootFun, [x1, p1]);\\n\\n    let retval;\\n    if (nuOpt != null &amp;&amp; closeRootFun(nuOpt, x1, p1) &lt; closeRootFun(nuFirstPass, x, p)) {\\n      retval = nuOpt;\\n    } else {\\n      retval = nuFirstPass;\\n    }\\n\\n    return [[retval], true];\\n  }\\n\\n}\\n\\n\\n\\nvar dist = new ChiSquareDistribution();\\n\\n\\n\\nlet params = paramsFromSliders(sliders); \\n\\n\\nlet [x1, x2] = dist.defaultXRange(params);\\n\\n\\ntriggerCallbacks.active = false;\\n\\n\\np_p.x_range.start = x1;\\np_p.x_range.end = x2;\\n\\nupdateData(source_p, source_c, p_p, sliders, discrete);\\n\\n\\nsetYRanges(p_p, p_c, source_p);  \\n\\ntriggerCallbacks.active = true;\\n"}}]]]},"x_range":{"id":"p2045"},"y_range":{"type":"object","name":"Range1d","id":"p2046"},"x_scale":{"type":"object","name":"LinearScale","id":"p2021"},"y_scale":{"type":"object","name":"LinearScale","id":"p2022"},"title":{"type":"object","name":"Title","id":"p2014","attributes":{"text":" "}},"renderers":[{"type":"object","name":"GlyphRenderer","id":"p2059","attributes":{"data_source":{"id":"p2050"},"view":{"type":"object","name":"CDSView","id":"p2060","attributes":{"filter":{"type":"object","name":"AllIndices","id":"p2061"}}},"glyph":{"type":"object","name":"Line","id":"p2056","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_width":2}},"nonselection_glyph":{"type":"object","name":"Line","id":"p2057","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_alpha":0.1,"line_width":2}},"muted_glyph":{"type":"object","name":"Line","id":"p2058","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_alpha":0.2,"line_width":2}}}}],"toolbar":{"type":"object","name":"Toolbar","id":"p2020","attributes":{"tools":[{"type":"object","name":"PanTool","id":"p2033"},{"type":"object","name":"BoxZoomTool","id":"p2034","attributes":{"dimensions":"both","overlay":{"type":"object","name":"BoxAnnotation","id":"p2035","attributes":{"syncable":false,"line_color":"black","line_alpha":1.0,"line_width":2,"line_dash":[4,4],"fill_color":"lightgrey","fill_alpha":0.5,"level":"overlay","visible":false,"left":{"type":"number","value":"nan"},"right":{"type":"number","value":"nan"},"top":{"type":"number","value":"nan"},"bottom":{"type":"number","value":"nan"},"left_units":"canvas","right_units":"canvas","top_units":"canvas","bottom_units":"canvas","handles":{"type":"object","name":"BoxInteractionHandles","id":"p2041","attributes":{"all":{"type":"object","name":"AreaVisuals","id":"p2040","attributes":{"fill_color":"white","hover_fill_color":"lightgray"}}}}}}}},{"type":"object","name":"WheelZoomTool","id":"p2042","attributes":{"renderers":"auto"}},{"type":"object","name":"SaveTool","id":"p2043"},{"type":"object","name":"ResetTool","id":"p2044"}]}},"toolbar_location":null,"left":[{"type":"object","name":"LinearAxis","id":"p2028","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p2029","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p2030"},"axis_label":"CDF","axis_label_text_font_style":"normal","major_label_policy":{"type":"object","name":"AllLabels","id":"p2031"}}}],"below":[{"type":"object","name":"LinearAxis","id":"p2023","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p2024","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p2025"},"axis_label":"y","major_label_policy":{"type":"object","name":"AllLabels","id":"p2026"}}}],"center":[{"type":"object","name":"Grid","id":"p2027","attributes":{"axis":{"id":"p2023"}}},{"type":"object","name":"Grid","id":"p2032","attributes":{"dimension":1,"axis":{"id":"p2028"}}}],"frame_width":300,"frame_height":175,"background_fill_alpha":0,"border_fill_alpha":0}}],["source_p",{"id":"p2047"}],["source_c",{"id":"p2050"}],["discrete",false],["n",400],["sliders",[{"id":"p2072"}]],["xBoxes",[{"id":"p2075"}]],["pBoxes",[{"id":"p2076"}]],["quantileSetterSwitch",{"id":"p2078"}],["quantileSetterDiv",{"id":"p2077"}],["triggerCallbacks",{"id":"p2079"}],["startBoxes",[{"id":"p2073"}]],["endBoxes",[{"id":"p2074"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nfunction erfinv(x) {\\n  \\n  let p = (x + 1.0) / 2.0;\\n\\n  \\n  if (p == 0.0) return -Infinity;\\n  if (p == 1.0) return Infinity;\\n  if (p &gt; 1.0 || p &lt; 0.0) return undefined;\\n\\n  let split1 = 0.425;\\n  let split2 = 5.0;\\n  let const1 = 0.180625;\\n  let const2 = 1.6;\\n\\n  \\n  let a0 = 3.3871327179;\\n  let a1 = 5.0434271938e1;\\n  let a2 = 1.5929113202e2;\\n  let a3 = 5.9109374720e1;\\n  let b1 = 1.7895169469e1;\\n  let b2 = 7.8757757664e1;\\n  let b3 = 6.7187563600e1;\\n\\n  \\n  let c0 = 1.4234372777;\\n  let c1 = 2.7568153900;\\n  let c2 = 1.3067284816;\\n  let c3 = 1.7023821103e-1;\\n  let d1 = 7.3700164250e-1;\\n  let d2 = 1.2021132975e-1;\\n\\n  \\n  let e0 = 6.6579051150;\\n  let e1 = 3.0812263860;\\n  let e2 = 4.2868294337e-1;\\n  let e3 = 1.7337203997e-2;\\n  let f1 = 2.4197894225e-1;\\n  let f2 = 1.2258202635e-2;\\n\\n  let r;\\n  let res;\\n  let q = p - 0.5;\\n\\n  if (Math.abs(q) &lt;= split1) {\\n    r = const1 - q * q;\\n    res = q * (((a3 * r + a2) * r + a1) * r + a0) /\\n              (((b3 * r + b2) * r + b1) * r + 1.0);\\n  } else {\\n    r = q &lt; 0 ? p : 1.0 - p;\\n\\n    r = Math.sqrt(-Math.log(r));\\n\\n    if (r &lt;= split2) {\\n      r -= const2;\\n      res = (((c3 * r + c2) * r + c1) * r + c0) /\\n             ((d2 * r + d1) * r + 1.0);\\n    } else {\\n      r -= split2;\\n      res = (((e3 * r + e2) * r + e1) * r + e0) /\\n             ((f2 * r + f1) * r + 1.0);\\n    }\\n  \\n    if (q &lt; 0) {\\n      res = -res;\\n    }\\n  }\\n\\n  \\n  return 0.7071067811865475 * res;\\n\\n}\\n\\n\\nfunction lngamma(z) {\\n\\n    if(z &lt; 0) return Number(&#x27;0/0&#x27;);\\n\\n    if (z &lt; 0.5) return Math.log(Math.PI) - Math.log(Math.sin(Math.PI * z)) - lngamma(1-z);\\n\\n    var p = [676.5203681218851,\\n             -1259.1392167224028,\\n             771.32342877765313,\\n             -176.61502916214059,\\n             12.507343278686905,\\n             -0.13857109526572012,\\n             9.9843695780195716e-6,\\n             1.5056327351493116e-7];\\n\\n    z -= 1.0;\\n    var Ag = 0.99999999999980993;\\n    for (var i = 0; i &lt; p.length; i++) {\\n        Ag += p[i] / (z + i + 1);\\n    }\\n    var t = z + p.length - 0.5;\\n\\n    return 0.5 * Math.log(2*Math.PI) + (z + 0.5)*Math.log(t) - t + Math.log(Ag);\\n}\\n\\n\\nfunction gammaincL(x, s, regularized) {\\n\\n  var EPSILON = 1e-12;\\n\\n  if (x === 0) {\\n    return 0;\\n  }\\n  if (x &lt; 0 || s &lt;= 0) {\\n    return NaN;\\n  }\\n\\n  if (x &gt; 1.1 &amp;&amp; x &gt; s) {\\n    if (regularized !== false) {\\n      return 1 - gammaincU(x, s, regularized);\\n    } else {\\n      return Math.exp(lngamma(s)) - gammaincU(x, s, regularized);\\n    }\\n  }\\n\\n  var ft,\\n    r = s,\\n    c = 1,\\n    pws = 1;\\n\\n  if (regularized !== false) {\\n    ft = s * Math.log(x) - x - lngamma(s);\\n  } else {\\n    ft = s * Math.log(x) - x;\\n  }\\n  ft = Math.exp(ft);\\n  do {\\n    r += 1;\\n    c *= x/r;\\n    pws += c;\\n  } while (c / pws &gt; EPSILON);\\n\\n  return pws * ft / s;\\n}\\n\\n\\nfunction secantSolve(x0, f, args=[], tol=1e-8, maxIter=200, epsilon=1e-14, h=1e-4) {\\n\\tlet x = Infinity;\\n\\tlet solved = false;\\n\\n\\tlet x1 = x0 * (1 + h);\\n\\tx1 += x1 &gt;= 0 ? h : -h;\\n\\n\\tlet q0 = f(x0, ...args);\\n\\tlet q1 = f(x1, ...args);\\n\\t\\n\\tif (Math.abs(q1) &lt; Math.abs(q0)) {\\n\\t\\t[x0, x1, q0, q1] = [x1, x0, q1, q0];\\n\\t}\\n\\n\\tfor (let i = 0; i &lt; maxIter; i++) {\\n\\t\\tif (q0 == q1) {\\n\\t\\t\\tsolved = x0 == x1;\\n\\t\\t\\tx = (x0 + x1) / 2.0;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tif (Math.abs(q1) &gt; Math.abs(q0)) {\\n\\t\\t\\t\\tx = (x0 - q0 / q1 * x1) / (1.0 - q0 / q1);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tx = (x1 - q1 / q0 * x0) / (1.0 - q1 / q0);\\n\\t\\t\\t}\\n\\t\\t\\tif (Math.abs(x - x0) &lt;= tol) {\\n\\t\\t\\t\\tsolved = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\t[x0, q0] = [x1, q1];\\n\\t\\t\\tx1 = x;\\n\\t\\t\\tq1 = f(x1, ...args);\\n\\t\\t}\\n\\t}\\n\\n  if (solved) return x;\\n  else return null;\\n}\\n\\n\\nfunction brentSolve(f, lower, upper, args=[], tol=1e-8, maxIter=1000) {\\n\\tlet a = lower;\\n\\tlet b = upper;\\n  let fa = f(a, ...args);\\n  let fb = f(b, ...args);\\n\\n  \\n  if (Math.abs(fa) &lt; tol) return a;\\n  if (Math.abs(fb) &lt; tol) return b;\\n\\n  \\n  if (fa * fb &gt;= 0) {\\n  \\treturn null;\\n\\t}\\n\\n  \\n  let c = a;\\n  let fc = fa;\\n\\n\\tlet iter = 0;\\n  while (iter++ &lt; maxIter) {\\n  \\tlet prevStep = b - a;\\n\\n    \\n    if (Math.abs(fc) &lt; Math.abs(fb)) {      \\n    \\t[a, b, c] = [b, c, b];\\n    \\t[fa, fb, fc] = [fb, fc, fb];\\n    }\\n\\n    \\n    let newStep = (c - b) / 2.0;\\n\\n    \\n    let tolAdj = 1e-15 * Math.abs(b) + tol / 2;\\n\\n    \\n  \\tif (Math.abs(newStep) &lt;= tolAdj || fb === 0 ) {\\n    \\t\\treturn b;\\n  \\t}\\n\\n    \\n    if (Math.abs(prevStep) &gt; tolAdj &amp;&amp; Math.abs(fa) &gt; Math.abs(fb)) {\\n    \\tlet p;\\n    \\tlet q;\\n    \\tlet t1;\\n    \\tlet t2;\\n    \\tlet cb = c - b;\\n    \\tif (a === c) { \\n    \\t\\tt1 = fb / fa;\\n    \\t\\tp = cb * t1;\\n    \\t\\tq = 1.0 - t1;\\n    \\t}\\n    \\telse { \\n    \\t\\tq = fa / fc;\\n    \\t\\tt1 = fb / fc;\\n    \\t\\tt2 = fb / fa;\\n    \\t\\tp = t2 * (cb * q * (q - t1) - (b - a) * (t1 - 1.0));\\n    \\t\\tq = (q - 1.0) * (t1 - 1.0) * (t2 - 1.0);\\n    \\t}\\n\\n    \\t\\n    \\tif (p &gt; 0) q = -q;\\n    \\telse p = -p;\\n\\n    \\t\\n    \\tif (p &lt; (0.75 * cb * q - Math.abs(tolAdj * q) / 2.0) \\n    \\t\\t&amp;&amp; p &lt; Math.abs(prevStep * q / 2.0)) { \\n\\t        newStep = p / q;\\n      \\t}\\n    }\\n\\n    if (Math.abs(newStep) &lt; tolAdj) {\\n      newStep = (newStep &gt; 0) ? tolAdj : -tolAdj;\\n    }\\n\\n    \\n    a = b;\\n    fa = fb;\\n\\n    \\n    b += newStep;\\n    fb = f(b, ...args);\\n\\n\\t\\n    if ((fb &gt; 0 &amp;&amp; fc &gt; 0) || (fb &lt; 0 &amp;&amp; fc &lt; 0)) {\\n      c = a; \\n      fc = fa;\\n    }\\n  }\\n\\n  \\n  return null;\\n}\\n\\n\\nfunction gammaincU(x, s, regularized) {\\n\\n  var EPSILON = 1e-12;\\n\\n  if (x &lt;= 1.1 || x &lt;= s) {\\n    if (regularized !== false) {\\n      return 1 - gammaincL(x, s, regularized);\\n    } else {\\n      return Math.exp(lngamma(s)) - gammaincL(x, s, regularized);\\n    }\\n  }\\n\\n  var f = 1 + x - s,\\n    C = f,\\n    D = 0,\\n    i = 1,\\n    a, b, chg;\\n  for (i = 1; i &lt; 10000; i++) {\\n    a = i * (s - i);\\n    b = (i&lt;&lt;1) + 1 + x - s;\\n    D = b + a * D;\\n    C = b + a / C;\\n    D = 1 / D;\\n    chg = C * D;\\n    f *= chg;\\n    if (Math.abs(chg - 1) &lt; EPSILON) {\\n      break;\\n    }\\n  }\\n  if (regularized !== false) {\\n    return Math.exp(s * Math.log(x) - x - lngamma(s) - Math.log(f));\\n  } else {\\n    return Math.exp(s * Math.log(x) - x - Math.log(f));\\n  }\\n}\\n\\n\\nclass ChiSquareDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Chi-square&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bd&#x27;];\\n\\n    \\n    this.paramMin = [0.0];\\n\\n    \\n    this.paramMax = [Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0.0;   \\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x &lt; 0) return NaN;\\n    if (x == Infinity) return 0.0;\\n\\n    let nu = params[0];\\n    let alpha = nu / 2;\\n    let beta = 0.5;\\n\\n    if (x == 0) {\\n      if (alpha == 1) {\\n        return beta;\\n      } else if (alpha &gt; 1) {\\n        return 0.0;\\n      } else {  \\n        return Infinity;\\n      }\\n    }\\n\\n    let lnProb;\\n    lnProb = alpha * Math.log(beta * x) - Math.log(x) - beta * x - lngamma(alpha);\\n\\n    return Math.exp(lnProb);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x &lt;= 0) return 0.0;\\n    if (x == Infinity) return 1.0;\\n\\n    let nu = params[0];\\n\\n    if (nu == Infinity) return 0.0;\\n    if (nu == 0) return 1.0\\n\\n    let alpha = nu / 2;\\n    let beta = 0.5;\\n\\n    return gammaincL(beta * x, alpha, true);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return 0.0;\\n    if (p === 1) return Infinity;\\n\\n    let rootFun = (xi, params, p) =&gt; {\\n        let x = xi == 1.0 ? Infinity : xi / (1.0 - xi);\\n\\n        return p - this.cdfSingleValue(x, params);\\n    }\\n\\n    let xiOpt = brentSolve(rootFun, 0.0, 1.0, [params, p]);\\n\\n    \\n    if (xiOpt === 1) {\\n      return Infinity;\\n    }\\n\\n    \\n    let xFirstPass = xiOpt / (1.0 - xiOpt);\\n\\n    let closeRootFun = (x, params, p) =&gt; {\\n      return p - this.cdfSingleValue(x, params);\\n    }\\n\\n    let xOpt = secantSolve(xFirstPass, closeRootFun, [params, p]);\\n\\n    let retval;\\n    if (xOpt != null &amp;&amp; closeRootFun(xOpt, params, p) &lt; closeRootFun(xFirstPass, params, p)) {\\n      retval = xOpt;\\n    } else {\\n      retval = xFirstPass;\\n    }\\n\\n    return retval;\\n  }\\n\\n  defaultXRange(params) {\\n    let [x1, x2] = this.ppf([0.001, 0.999], params);\\n\\n    \\n    if (x1 &lt; (x2 - x1) / 10.0) x1 = 0.0;\\n\\n    return [x1, x2];\\n  }\\n\\n  quantileSet(x, p) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n\\n    let rootFun = (xi, x, p) =&gt; {\\n        let nu = xi == 1.0 ? Infinity : xi / (1.0 - xi);\\n\\n        return p - this.cdfSingleValue(x, [nu]);\\n    }\\n\\n    let xiOpt = brentSolve(rootFun, 0.0, 1.0, [x1, p1]);\\n\\n    if (xiOpt === 1) {\\n      if (p1 == 0.5) {\\n        return [[x1], true];\\n      }\\n      else {\\n        let invErf2 = Math.pow(erfinv(2 * p1 - 1), 2);\\n        let invErf4 = Math.pow(invErf2, 2);\\n\\n        term1 = x1 + 2 * invErf2;\\n        term2 = 2 * Math.sqrt(x1 * invErf2 + invErf4);\\n\\n        if (p1 &lt; 0.5) return [[term1 - term2], true];\\n        else return [[term1 + term2] , true];\\n      }\\n    }\\n\\n    \\n    let nuFirstPass = xiOpt / (1.0 - xiOpt);\\n\\n    let closeRootFun = (nu, x, p) =&gt; {\\n      return p - this.cdfSingleValue(x, [nu]);\\n    }\\n\\n    let nuOpt = secantSolve(nuFirstPass, closeRootFun, [x1, p1]);\\n\\n    let retval;\\n    if (nuOpt != null &amp;&amp; closeRootFun(nuOpt, x1, p1) &lt; closeRootFun(nuFirstPass, x, p)) {\\n      retval = nuOpt;\\n    } else {\\n      retval = nuFirstPass;\\n    }\\n\\n    return [[retval], true];\\n  }\\n\\n}\\n\\n\\n\\nvar dist = new ChiSquareDistribution();\\n\\n\\nif (triggerCallbacks.active) {\\n  updateData(source_p, source_c, p_p, sliders, discrete);\\n}"}}]],["change:end",[{"id":"p2081"}]]]},"end":10}},"y_range":{"type":"object","name":"DataRange1d","id":"p1979","attributes":{"start":0.0}},"x_scale":{"type":"object","name":"LinearScale","id":"p1987"},"y_scale":{"type":"object","name":"LinearScale","id":"p1988"},"title":{"type":"object","name":"Title","id":"p1980","attributes":{"text":"Chi-square"}},"renderers":[{"type":"object","name":"GlyphRenderer","id":"p2068","attributes":{"data_source":{"id":"p2047"},"view":{"type":"object","name":"CDSView","id":"p2069","attributes":{"filter":{"type":"object","name":"AllIndices","id":"p2070"}}},"glyph":{"type":"object","name":"Line","id":"p2065","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"line_color":"#1f77b4","line_width":2}},"nonselection_glyph":{"type":"object","name":"Line","id":"p2066","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"line_color":"#1f77b4","line_alpha":0.1,"line_width":2}},"muted_glyph":{"type":"object","name":"Line","id":"p2067","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"line_color":"#1f77b4","line_alpha":0.2,"line_width":2}}}}],"toolbar":{"type":"object","name":"Toolbar","id":"p1986","attributes":{"tools":[{"type":"object","name":"PanTool","id":"p1999"},{"type":"object","name":"BoxZoomTool","id":"p2000","attributes":{"dimensions":"both","overlay":{"type":"object","name":"BoxAnnotation","id":"p2001","attributes":{"syncable":false,"line_color":"black","line_alpha":1.0,"line_width":2,"line_dash":[4,4],"fill_color":"lightgrey","fill_alpha":0.5,"level":"overlay","visible":false,"left":{"type":"number","value":"nan"},"right":{"type":"number","value":"nan"},"top":{"type":"number","value":"nan"},"bottom":{"type":"number","value":"nan"},"left_units":"canvas","right_units":"canvas","top_units":"canvas","bottom_units":"canvas","handles":{"type":"object","name":"BoxInteractionHandles","id":"p2007","attributes":{"all":{"type":"object","name":"AreaVisuals","id":"p2006","attributes":{"fill_color":"white","hover_fill_color":"lightgray"}}}}}}}},{"type":"object","name":"WheelZoomTool","id":"p2008","attributes":{"renderers":"auto"}},{"type":"object","name":"SaveTool","id":"p2009"},{"type":"object","name":"ResetTool","id":"p2010"}]}},"toolbar_location":null,"left":[{"type":"object","name":"LinearAxis","id":"p1994","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p1995","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p1996"},"axis_label":"PDF","axis_label_text_font_style":"normal","major_label_policy":{"type":"object","name":"AllLabels","id":"p1997"}}}],"below":[{"type":"object","name":"LinearAxis","id":"p1989","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p1990","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p1991"},"axis_label":"y","major_label_policy":{"type":"object","name":"AllLabels","id":"p1992"}}}],"center":[{"type":"object","name":"Grid","id":"p1993","attributes":{"axis":{"id":"p1989"}}},{"type":"object","name":"Grid","id":"p1998","attributes":{"dimension":1,"axis":{"id":"p1994"}}}],"frame_width":300,"frame_height":175,"background_fill_alpha":0,"border_fill_alpha":0}}],["p_c",{"id":"p2011"}],["source_p",{"id":"p2047"}],["source_c",{"id":"p2050"}],["discrete",false],["n",400],["sliders",[{"id":"p2072"}]],["xBoxes",[{"id":"p2075"}]],["pBoxes",[{"id":"p2076"}]],["quantileSetterSwitch",{"id":"p2078"}],["quantileSetterDiv",{"id":"p2077"}],["triggerCallbacks",{"id":"p2079"}],["startBoxes",[{"id":"p2073"}]],["endBoxes",[{"id":"p2074"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nfunction erfinv(x) {\\n  \\n  let p = (x + 1.0) / 2.0;\\n\\n  \\n  if (p == 0.0) return -Infinity;\\n  if (p == 1.0) return Infinity;\\n  if (p &gt; 1.0 || p &lt; 0.0) return undefined;\\n\\n  let split1 = 0.425;\\n  let split2 = 5.0;\\n  let const1 = 0.180625;\\n  let const2 = 1.6;\\n\\n  \\n  let a0 = 3.3871327179;\\n  let a1 = 5.0434271938e1;\\n  let a2 = 1.5929113202e2;\\n  let a3 = 5.9109374720e1;\\n  let b1 = 1.7895169469e1;\\n  let b2 = 7.8757757664e1;\\n  let b3 = 6.7187563600e1;\\n\\n  \\n  let c0 = 1.4234372777;\\n  let c1 = 2.7568153900;\\n  let c2 = 1.3067284816;\\n  let c3 = 1.7023821103e-1;\\n  let d1 = 7.3700164250e-1;\\n  let d2 = 1.2021132975e-1;\\n\\n  \\n  let e0 = 6.6579051150;\\n  let e1 = 3.0812263860;\\n  let e2 = 4.2868294337e-1;\\n  let e3 = 1.7337203997e-2;\\n  let f1 = 2.4197894225e-1;\\n  let f2 = 1.2258202635e-2;\\n\\n  let r;\\n  let res;\\n  let q = p - 0.5;\\n\\n  if (Math.abs(q) &lt;= split1) {\\n    r = const1 - q * q;\\n    res = q * (((a3 * r + a2) * r + a1) * r + a0) /\\n              (((b3 * r + b2) * r + b1) * r + 1.0);\\n  } else {\\n    r = q &lt; 0 ? p : 1.0 - p;\\n\\n    r = Math.sqrt(-Math.log(r));\\n\\n    if (r &lt;= split2) {\\n      r -= const2;\\n      res = (((c3 * r + c2) * r + c1) * r + c0) /\\n             ((d2 * r + d1) * r + 1.0);\\n    } else {\\n      r -= split2;\\n      res = (((e3 * r + e2) * r + e1) * r + e0) /\\n             ((f2 * r + f1) * r + 1.0);\\n    }\\n  \\n    if (q &lt; 0) {\\n      res = -res;\\n    }\\n  }\\n\\n  \\n  return 0.7071067811865475 * res;\\n\\n}\\n\\n\\nfunction lngamma(z) {\\n\\n    if(z &lt; 0) return Number(&#x27;0/0&#x27;);\\n\\n    if (z &lt; 0.5) return Math.log(Math.PI) - Math.log(Math.sin(Math.PI * z)) - lngamma(1-z);\\n\\n    var p = [676.5203681218851,\\n             -1259.1392167224028,\\n             771.32342877765313,\\n             -176.61502916214059,\\n             12.507343278686905,\\n             -0.13857109526572012,\\n             9.9843695780195716e-6,\\n             1.5056327351493116e-7];\\n\\n    z -= 1.0;\\n    var Ag = 0.99999999999980993;\\n    for (var i = 0; i &lt; p.length; i++) {\\n        Ag += p[i] / (z + i + 1);\\n    }\\n    var t = z + p.length - 0.5;\\n\\n    return 0.5 * Math.log(2*Math.PI) + (z + 0.5)*Math.log(t) - t + Math.log(Ag);\\n}\\n\\n\\nfunction gammaincL(x, s, regularized) {\\n\\n  var EPSILON = 1e-12;\\n\\n  if (x === 0) {\\n    return 0;\\n  }\\n  if (x &lt; 0 || s &lt;= 0) {\\n    return NaN;\\n  }\\n\\n  if (x &gt; 1.1 &amp;&amp; x &gt; s) {\\n    if (regularized !== false) {\\n      return 1 - gammaincU(x, s, regularized);\\n    } else {\\n      return Math.exp(lngamma(s)) - gammaincU(x, s, regularized);\\n    }\\n  }\\n\\n  var ft,\\n    r = s,\\n    c = 1,\\n    pws = 1;\\n\\n  if (regularized !== false) {\\n    ft = s * Math.log(x) - x - lngamma(s);\\n  } else {\\n    ft = s * Math.log(x) - x;\\n  }\\n  ft = Math.exp(ft);\\n  do {\\n    r += 1;\\n    c *= x/r;\\n    pws += c;\\n  } while (c / pws &gt; EPSILON);\\n\\n  return pws * ft / s;\\n}\\n\\n\\nfunction secantSolve(x0, f, args=[], tol=1e-8, maxIter=200, epsilon=1e-14, h=1e-4) {\\n\\tlet x = Infinity;\\n\\tlet solved = false;\\n\\n\\tlet x1 = x0 * (1 + h);\\n\\tx1 += x1 &gt;= 0 ? h : -h;\\n\\n\\tlet q0 = f(x0, ...args);\\n\\tlet q1 = f(x1, ...args);\\n\\t\\n\\tif (Math.abs(q1) &lt; Math.abs(q0)) {\\n\\t\\t[x0, x1, q0, q1] = [x1, x0, q1, q0];\\n\\t}\\n\\n\\tfor (let i = 0; i &lt; maxIter; i++) {\\n\\t\\tif (q0 == q1) {\\n\\t\\t\\tsolved = x0 == x1;\\n\\t\\t\\tx = (x0 + x1) / 2.0;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tif (Math.abs(q1) &gt; Math.abs(q0)) {\\n\\t\\t\\t\\tx = (x0 - q0 / q1 * x1) / (1.0 - q0 / q1);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tx = (x1 - q1 / q0 * x0) / (1.0 - q1 / q0);\\n\\t\\t\\t}\\n\\t\\t\\tif (Math.abs(x - x0) &lt;= tol) {\\n\\t\\t\\t\\tsolved = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\t[x0, q0] = [x1, q1];\\n\\t\\t\\tx1 = x;\\n\\t\\t\\tq1 = f(x1, ...args);\\n\\t\\t}\\n\\t}\\n\\n  if (solved) return x;\\n  else return null;\\n}\\n\\n\\nfunction brentSolve(f, lower, upper, args=[], tol=1e-8, maxIter=1000) {\\n\\tlet a = lower;\\n\\tlet b = upper;\\n  let fa = f(a, ...args);\\n  let fb = f(b, ...args);\\n\\n  \\n  if (Math.abs(fa) &lt; tol) return a;\\n  if (Math.abs(fb) &lt; tol) return b;\\n\\n  \\n  if (fa * fb &gt;= 0) {\\n  \\treturn null;\\n\\t}\\n\\n  \\n  let c = a;\\n  let fc = fa;\\n\\n\\tlet iter = 0;\\n  while (iter++ &lt; maxIter) {\\n  \\tlet prevStep = b - a;\\n\\n    \\n    if (Math.abs(fc) &lt; Math.abs(fb)) {      \\n    \\t[a, b, c] = [b, c, b];\\n    \\t[fa, fb, fc] = [fb, fc, fb];\\n    }\\n\\n    \\n    let newStep = (c - b) / 2.0;\\n\\n    \\n    let tolAdj = 1e-15 * Math.abs(b) + tol / 2;\\n\\n    \\n  \\tif (Math.abs(newStep) &lt;= tolAdj || fb === 0 ) {\\n    \\t\\treturn b;\\n  \\t}\\n\\n    \\n    if (Math.abs(prevStep) &gt; tolAdj &amp;&amp; Math.abs(fa) &gt; Math.abs(fb)) {\\n    \\tlet p;\\n    \\tlet q;\\n    \\tlet t1;\\n    \\tlet t2;\\n    \\tlet cb = c - b;\\n    \\tif (a === c) { \\n    \\t\\tt1 = fb / fa;\\n    \\t\\tp = cb * t1;\\n    \\t\\tq = 1.0 - t1;\\n    \\t}\\n    \\telse { \\n    \\t\\tq = fa / fc;\\n    \\t\\tt1 = fb / fc;\\n    \\t\\tt2 = fb / fa;\\n    \\t\\tp = t2 * (cb * q * (q - t1) - (b - a) * (t1 - 1.0));\\n    \\t\\tq = (q - 1.0) * (t1 - 1.0) * (t2 - 1.0);\\n    \\t}\\n\\n    \\t\\n    \\tif (p &gt; 0) q = -q;\\n    \\telse p = -p;\\n\\n    \\t\\n    \\tif (p &lt; (0.75 * cb * q - Math.abs(tolAdj * q) / 2.0) \\n    \\t\\t&amp;&amp; p &lt; Math.abs(prevStep * q / 2.0)) { \\n\\t        newStep = p / q;\\n      \\t}\\n    }\\n\\n    if (Math.abs(newStep) &lt; tolAdj) {\\n      newStep = (newStep &gt; 0) ? tolAdj : -tolAdj;\\n    }\\n\\n    \\n    a = b;\\n    fa = fb;\\n\\n    \\n    b += newStep;\\n    fb = f(b, ...args);\\n\\n\\t\\n    if ((fb &gt; 0 &amp;&amp; fc &gt; 0) || (fb &lt; 0 &amp;&amp; fc &lt; 0)) {\\n      c = a; \\n      fc = fa;\\n    }\\n  }\\n\\n  \\n  return null;\\n}\\n\\n\\nfunction gammaincU(x, s, regularized) {\\n\\n  var EPSILON = 1e-12;\\n\\n  if (x &lt;= 1.1 || x &lt;= s) {\\n    if (regularized !== false) {\\n      return 1 - gammaincL(x, s, regularized);\\n    } else {\\n      return Math.exp(lngamma(s)) - gammaincL(x, s, regularized);\\n    }\\n  }\\n\\n  var f = 1 + x - s,\\n    C = f,\\n    D = 0,\\n    i = 1,\\n    a, b, chg;\\n  for (i = 1; i &lt; 10000; i++) {\\n    a = i * (s - i);\\n    b = (i&lt;&lt;1) + 1 + x - s;\\n    D = b + a * D;\\n    C = b + a / C;\\n    D = 1 / D;\\n    chg = C * D;\\n    f *= chg;\\n    if (Math.abs(chg - 1) &lt; EPSILON) {\\n      break;\\n    }\\n  }\\n  if (regularized !== false) {\\n    return Math.exp(s * Math.log(x) - x - lngamma(s) - Math.log(f));\\n  } else {\\n    return Math.exp(s * Math.log(x) - x - Math.log(f));\\n  }\\n}\\n\\n\\nclass ChiSquareDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Chi-square&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bd&#x27;];\\n\\n    \\n    this.paramMin = [0.0];\\n\\n    \\n    this.paramMax = [Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0.0;   \\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x &lt; 0) return NaN;\\n    if (x == Infinity) return 0.0;\\n\\n    let nu = params[0];\\n    let alpha = nu / 2;\\n    let beta = 0.5;\\n\\n    if (x == 0) {\\n      if (alpha == 1) {\\n        return beta;\\n      } else if (alpha &gt; 1) {\\n        return 0.0;\\n      } else {  \\n        return Infinity;\\n      }\\n    }\\n\\n    let lnProb;\\n    lnProb = alpha * Math.log(beta * x) - Math.log(x) - beta * x - lngamma(alpha);\\n\\n    return Math.exp(lnProb);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x &lt;= 0) return 0.0;\\n    if (x == Infinity) return 1.0;\\n\\n    let nu = params[0];\\n\\n    if (nu == Infinity) return 0.0;\\n    if (nu == 0) return 1.0\\n\\n    let alpha = nu / 2;\\n    let beta = 0.5;\\n\\n    return gammaincL(beta * x, alpha, true);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return 0.0;\\n    if (p === 1) return Infinity;\\n\\n    let rootFun = (xi, params, p) =&gt; {\\n        let x = xi == 1.0 ? Infinity : xi / (1.0 - xi);\\n\\n        return p - this.cdfSingleValue(x, params);\\n    }\\n\\n    let xiOpt = brentSolve(rootFun, 0.0, 1.0, [params, p]);\\n\\n    \\n    if (xiOpt === 1) {\\n      return Infinity;\\n    }\\n\\n    \\n    let xFirstPass = xiOpt / (1.0 - xiOpt);\\n\\n    let closeRootFun = (x, params, p) =&gt; {\\n      return p - this.cdfSingleValue(x, params);\\n    }\\n\\n    let xOpt = secantSolve(xFirstPass, closeRootFun, [params, p]);\\n\\n    let retval;\\n    if (xOpt != null &amp;&amp; closeRootFun(xOpt, params, p) &lt; closeRootFun(xFirstPass, params, p)) {\\n      retval = xOpt;\\n    } else {\\n      retval = xFirstPass;\\n    }\\n\\n    return retval;\\n  }\\n\\n  defaultXRange(params) {\\n    let [x1, x2] = this.ppf([0.001, 0.999], params);\\n\\n    \\n    if (x1 &lt; (x2 - x1) / 10.0) x1 = 0.0;\\n\\n    return [x1, x2];\\n  }\\n\\n  quantileSet(x, p) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n\\n    let rootFun = (xi, x, p) =&gt; {\\n        let nu = xi == 1.0 ? Infinity : xi / (1.0 - xi);\\n\\n        return p - this.cdfSingleValue(x, [nu]);\\n    }\\n\\n    let xiOpt = brentSolve(rootFun, 0.0, 1.0, [x1, p1]);\\n\\n    if (xiOpt === 1) {\\n      if (p1 == 0.5) {\\n        return [[x1], true];\\n      }\\n      else {\\n        let invErf2 = Math.pow(erfinv(2 * p1 - 1), 2);\\n        let invErf4 = Math.pow(invErf2, 2);\\n\\n        term1 = x1 + 2 * invErf2;\\n        term2 = 2 * Math.sqrt(x1 * invErf2 + invErf4);\\n\\n        if (p1 &lt; 0.5) return [[term1 - term2], true];\\n        else return [[term1 + term2] , true];\\n      }\\n    }\\n\\n    \\n    let nuFirstPass = xiOpt / (1.0 - xiOpt);\\n\\n    let closeRootFun = (nu, x, p) =&gt; {\\n      return p - this.cdfSingleValue(x, [nu]);\\n    }\\n\\n    let nuOpt = secantSolve(nuFirstPass, closeRootFun, [x1, p1]);\\n\\n    let retval;\\n    if (nuOpt != null &amp;&amp; closeRootFun(nuOpt, x1, p1) &lt; closeRootFun(nuFirstPass, x, p)) {\\n      retval = nuOpt;\\n    } else {\\n      retval = nuFirstPass;\\n    }\\n\\n    return [[retval], true];\\n  }\\n\\n}\\n\\n\\n\\nvar dist = new ChiSquareDistribution();\\n\\n\\n\\nif (cb_obj.active) {\\n  for (let i = 0; i &lt; sliders.length; i++) {\\n    if (!dist.fixedParamsInds.includes(i)) {\\n      sliders[i].title = dist.paramNames[i] + &#x27; (computed)&#x27;;\\n      sliders[i].disabled = true;\\n    }\\n  }\\n  for (let xBox of xBoxes) {\\n    xBox.disabled = false;\\n  }\\n  for (let pBox of pBoxes) {\\n    pBox.disabled = false;\\n  }\\n} else {\\n  for (let i = 0; i &lt; sliders.length; i++) {\\n    if (!dist.fixedParamsInds.includes(i)) {\\n      sliders[i].title = dist.paramNames[i];\\n      sliders[i].disabled = false;\\n    }\\n  }\\n  for (let xBox of xBoxes) {\\n    xBox.disabled = true;\\n  }\\n  for (let pBox of pBoxes) {\\n    pBox.disabled = true;\\n  }\\n  quantileSetterDiv.text = &#x27;&#x27;;\\n}"}}]]]}}}]}},{"type":"object","name":"Spacer","id":"p2116","attributes":{"width":10}},{"id":"p2077"}]}},{"type":"object","name":"Spacer","id":"p2118","attributes":{"height":10}},{"type":"object","name":"Row","id":"p2120","attributes":{"children":[{"type":"object","name":"Column","id":"p2105","attributes":{"children":[{"type":"object","name":"Row","id":"p2104","attributes":{"children":[{"type":"object","name":"Column","id":"p2101","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2100","attributes":{"height":4}},{"id":"p2073"}]}},{"id":"p2072"},{"type":"object","name":"Column","id":"p2103","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2102","attributes":{"height":4}},{"id":"p2074"}]}}]}}]}},{"type":"object","name":"Spacer","id":"p2119","attributes":{"width":20}},{"type":"object","name":"Column","id":"p2099","attributes":{"children":[{"type":"object","name":"Row","id":"p2098","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2090","attributes":{"width":20}},{"type":"object","name":"Column","id":"p2093","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2091","attributes":{"height":7}},{"type":"object","name":"Div","id":"p2092","attributes":{"text":"&lt;p&gt;&lt;b&gt;y: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p2075"},{"type":"object","name":"Spacer","id":"p2094","attributes":{"width":16}},{"type":"object","name":"Column","id":"p2097","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2095","attributes":{"height":7}},{"type":"object","name":"Div","id":"p2096","attributes":{"text":"&lt;p&gt;&lt;b&gt;quantile: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p2076"}]}}]}}]}},{"type":"object","name":"Spacer","id":"p2121","attributes":{"height":10}},{"type":"object","name":"GridPlot","id":"p2113","attributes":{"rows":null,"cols":null,"toolbar":{"type":"object","name":"Toolbar","id":"p2112","attributes":{"tools":[{"type":"object","name":"ToolProxy","id":"p2107","attributes":{"tools":[{"id":"p1999"},{"id":"p2033"},{"id":"p1999"},{"id":"p2033"}]}},{"type":"object","name":"ToolProxy","id":"p2108","attributes":{"tools":[{"id":"p2000"},{"id":"p2034"},{"id":"p2000"},{"id":"p2034"}]}},{"type":"object","name":"ToolProxy","id":"p2109","attributes":{"tools":[{"id":"p2008"},{"id":"p2042"},{"id":"p2008"},{"id":"p2042"}]}},{"type":"object","name":"SaveTool","id":"p2110"},{"type":"object","name":"ToolProxy","id":"p2111","attributes":{"tools":[{"id":"p2010"},{"id":"p2044"},{"id":"p2010"},{"id":"p2044"}]}}]}},"toolbar_location":"right","children":[[{"id":"p1977"},0,0],[{"type":"object","name":"Spacer","id":"p2106","attributes":{"width":30}},0,1],[{"id":"p2011"},0,2]]}}]}}]}}';
                  const render_items = [{"docid":"6d26697c-a44b-4b1a-ae39-f8a8c12b73e9","roots":{"p2122":"d79c6121-8c03-4313-8403-147969e859eb"},"root_ids":["p2122"]}];
                  root.Bokeh.embed.embed_items(docs_json, render_items);
                  }
                  if (root.Bokeh !== undefined) {
                    embed_document(root);
                  } else {
                    let attempts = 0;
                    const timer = setInterval(function(root) {
                      if (root.Bokeh !== undefined) {
                        clearInterval(timer);
                        embed_document(root);
                      } else {
                        attempts++;
                        if (attempts > 100) {
                          clearInterval(timer);
                          console.log("Bokeh: ERROR: Unable to run BokehJS code because BokehJS library is missing");
                        }
                      }
                    }, 10, root)
                  }
                })(window);
              });
            };
            if (document.readyState != "loading") fn();
            else document.addEventListener("DOMContentLoaded", fn);
          })();
        },
    function(Bokeh) {
        }
      ];
    
      function run_inline_js() {
        for (let i = 0; i < inline_js.length; i++) {
          inline_js[i].call(root, root.Bokeh);
        }
      }
    
      if (root._bokeh_is_loading === 0) {
        console.debug("Bokeh: BokehJS loaded, going straight to plotting");
        run_inline_js();
      } else {
        load_libs(css_urls, js_urls, function() {
          console.debug("Bokeh: BokehJS plotting callback run at", now());
          run_inline_js();
        });
      }
    }(window));
  };
  if (document.readyState != "loading") fn();
  else document.addEventListener("DOMContentLoaded", fn);
})();