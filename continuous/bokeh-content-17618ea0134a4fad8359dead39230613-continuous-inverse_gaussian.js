(function() {
  const fn = function() {
    'use strict';
    (function(root) {
      function now() {
        return new Date();
      }
    
      const force = false;
    
      if (typeof root._bokeh_onload_callbacks === "undefined" || force === true) {
        root._bokeh_onload_callbacks = [];
        root._bokeh_is_loading = undefined;
      }
    
    
    const element = document.getElementById("dede0e30-7dda-4311-ab3d-0d128ee2a430");
        if (element == null) {
          console.warn("Bokeh: autoload.js configured with elementid 'dede0e30-7dda-4311-ab3d-0d128ee2a430' but no matching script tag was found.")
        }
      function run_callbacks() {
        try {
          root._bokeh_onload_callbacks.forEach(function(callback) {
            if (callback != null)
              callback();
          });
        } finally {
          delete root._bokeh_onload_callbacks
        }
        console.debug("Bokeh: all callbacks have finished");
      }
    
      function load_libs(css_urls, js_urls, callback) {
        if (css_urls == null) css_urls = [];
        if (js_urls == null) js_urls = [];
    
        root._bokeh_onload_callbacks.push(callback);
        if (root._bokeh_is_loading > 0) {
          console.debug("Bokeh: BokehJS is being loaded, scheduling callback at", now());
          return null;
        }
        if (js_urls == null || js_urls.length === 0) {
          run_callbacks();
          return null;
        }
        console.debug("Bokeh: BokehJS not loaded, scheduling load and callback at", now());
        root._bokeh_is_loading = css_urls.length + js_urls.length;
    
        function on_load() {
          root._bokeh_is_loading--;
          if (root._bokeh_is_loading === 0) {
            console.debug("Bokeh: all BokehJS libraries/stylesheets loaded");
            run_callbacks()
          }
        }
    
        function on_error(url) {
          console.error("failed to load " + url);
        }
    
        for (let i = 0; i < css_urls.length; i++) {
          const url = css_urls[i];
          const element = document.createElement("link");
          element.onload = on_load;
          element.onerror = on_error.bind(null, url);
          element.rel = "stylesheet";
          element.type = "text/css";
          element.href = url;
          console.debug("Bokeh: injecting link tag for BokehJS stylesheet: ", url);
          document.body.appendChild(element);
        }
    
        for (let i = 0; i < js_urls.length; i++) {
          const url = js_urls[i];
          const element = document.createElement('script');
          element.onload = on_load;
          element.onerror = on_error.bind(null, url);
          element.async = false;
          element.src = url;
          console.debug("Bokeh: injecting script tag for BokehJS library: ", url);
          document.head.appendChild(element);
        }
      };
    
      function inject_raw_css(css) {
        const element = document.createElement("style");
        element.appendChild(document.createTextNode(css));
        document.body.appendChild(element);
      }
    
      const js_urls = ["https://cdn.bokeh.org/bokeh/release/bokeh-3.4.1.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-gl-3.4.1.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-widgets-3.4.1.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-tables-3.4.1.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-mathjax-3.4.1.min.js"];
      const css_urls = [];
    
      const inline_js = [    function(Bokeh) {
          Bokeh.set_log_level("info");
        },
        function(Bokeh) {
          (function() {
            const fn = function() {
              Bokeh.safely(function() {
                (function(root) {
                  function embed_document(root) {
                  const docs_json = '{"e5cf8f90-7512-4519-b807-40da6ab2b7e8":{"version":"3.4.1","title":"Bokeh Application","roots":[{"type":"object","name":"Column","id":"p2877","attributes":{"children":[{"type":"object","name":"Row","id":"p2872","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2870","attributes":{"width":409}},{"type":"object","name":"Row","id":"p2833","attributes":{"children":[{"type":"object","name":"Div","id":"p2831","attributes":{"text":"&lt;p&gt;&lt;b&gt;Quantile setter mode&lt;/b&gt;&lt;/p&gt;"}},{"type":"object","name":"Spacer","id":"p2832","attributes":{"width":2}},{"type":"object","name":"Switch","id":"p2820","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:active",[{"type":"object","name":"CustomJS","id":"p2824","attributes":{"args":{"type":"map","entries":[["p_p",{"type":"object","name":"Figure","id":"p2733","attributes":{"x_range":{"type":"object","name":"Range1d","id":"p2781","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:start",[{"type":"object","name":"CustomJS","id":"p2823","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p2733"}],["p_c",{"type":"object","name":"Figure","id":"p2757","attributes":{"js_event_callbacks":{"type":"map","entries":[["reset",[{"type":"object","name":"CustomJS","id":"p2826","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p2733"}],["p_c",{"id":"p2757"}],["source_p",{"type":"object","name":"ColumnDataSource","id":"p2783","attributes":{"selected":{"type":"object","name":"Selection","id":"p2784","attributes":{"indices":[],"line_indices":[]}},"selection_policy":{"type":"object","name":"UnionRenderers","id":"p2785"},"data":{"type":"map","entries":[["x",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}],["y_p",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}]]}}}],["source_c",{"type":"object","name":"ColumnDataSource","id":"p2786","attributes":{"selected":{"type":"object","name":"Selection","id":"p2787","attributes":{"indices":[],"line_indices":[]}},"selection_policy":{"type":"object","name":"UnionRenderers","id":"p2788"},"data":{"type":"map","entries":[["x",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}],["y_c",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}]]}}}],["discrete",false],["n",400],["sliders",[{"type":"object","name":"Slider","id":"p2808","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p2822","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p2733"}],["p_c",{"id":"p2757"}],["source_p",{"id":"p2783"}],["source_c",{"id":"p2786"}],["discrete",false],["n",400],["sliders",[{"id":"p2808"},{"type":"object","name":"Slider","id":"p2810","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p2822"}]]]},"width":200,"title":"\\u03bb","format":{"type":"object","name":"CustomJSTickFormatter","id":"p2809","attributes":{"code":"return tick.toPrecision(4)"}},"start":0.1,"end":20,"value":10,"step":0.01}}]],["xBoxes",[{"type":"object","name":"TextInput","id":"p2815","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p2825","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p2733"}],["p_c",{"id":"p2757"}],["source_p",{"id":"p2783"}],["source_c",{"id":"p2786"}],["discrete",false],["n",400],["sliders",[{"id":"p2808"},{"id":"p2810"}]],["xBoxes",[{"id":"p2815"},{"type":"object","name":"TextInput","id":"p2816","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p2825"}]]]},"disabled":true,"width":80,"value":"37.7184"}}]],["pBoxes",[{"type":"object","name":"TextInput","id":"p2817","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p2825"}]]]},"disabled":true,"width":80,"value":"0.0250"}},{"type":"object","name":"TextInput","id":"p2818","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p2825"}]]]},"disabled":true,"width":80,"value":"0.9750"}}]],["quantileSetterSwitch",{"id":"p2820"}],["quantileSetterDiv",{"type":"object","name":"Div","id":"p2819"}],["triggerCallbacks",{"type":"object","name":"Switch","id":"p2821","attributes":{"active":true}}],["startBoxes",[{"type":"object","name":"TextInput","id":"p2811","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p2827","attributes":{"args":{"type":"map","entries":[["minValue","0"],["maxValue","Infinity"],["slider",{"id":"p2808"}]]},"code":"\\n\\nslider.start = Math.max(minValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"0.1"}},{"type":"object","name":"TextInput","id":"p2812","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p2829","attributes":{"args":{"type":"map","entries":[["minValue","0"],["maxValue","Infinity"],["slider",{"id":"p2810"}]]},"code":"\\n\\nslider.start = Math.max(minValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"0.1"}}]],["endBoxes",[{"type":"object","name":"TextInput","id":"p2813","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p2828","attributes":{"args":{"type":"map","entries":[["minValue","0"],["maxValue","Infinity"],["slider",{"id":"p2808"}]]},"code":"\\n\\nslider.end = Math.min(maxValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"20"}},{"type":"object","name":"TextInput","id":"p2814","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p2830","attributes":{"args":{"type":"map","entries":[["minValue","0"],["maxValue","Infinity"],["slider",{"id":"p2810"}]]},"code":"\\n\\nslider.end = Math.min(maxValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"20"}}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nfunction logSumExp(x1, x2) {\\n  if (x1 &gt; x2) {\\n    return x1 + log1p(Math.exp(x2 - x1));\\n  }\\n  else {\\n    return x2 + log1p(Math.exp(x1 - x2));\\n  }\\n}\\n\\n\\nfunction lnStdNormCdf(x) {\\n  \\n  let y = x / 1.4142135623730950488016887;\\n\\n  let res;\\n  \\n  if (y &gt; 0.0) {\\n    res = log1p(-0.5 * erfc(y));\\n  } \\n  else if (y &gt; -20.0) {\\n    \\n    res = Math.log(erfc(-y)) - 0.6931471805599453;\\n  }\\n  else {\\n    \\n    const y2 = Math.pow(y, 2);\\n    const y4 = Math.pow(y, 4);\\n    const y6 = Math.pow(y, 6);\\n    const y8 = Math.pow(y, 8);\\n    const y10 = Math.pow(y, 10);\\n    const temp_p = 0.000658749161529837803157 + 0.0160837851487422766278 / y2\\n                 + 0.125781726111229246204 / y4 + 0.360344899949804439429 / y6\\n                 + 0.305326634961232344035 / y8 + 0.0163153871373020978498 / y10;\\n    const temp_q = -0.00233520497626869185443 - 0.0605183413124413191178 / y2\\n                   - 0.527905102951428412248 / y4 - 1.87295284992346047209 / y6\\n                   - 2.56852019228982242072 / y8 - 1.0 / y10;\\n    res = -0.6931471805599453 + Math.log(0.5641895835477563 + (temp_p / temp_q) / y2) - Math.log(-y) - y2;\\n  }\\n\\n  if (isNaN(res)) {\\n    return -Infinity;\\n  }\\n  else {\\n    return res;\\n  }\\n}\\n\\n\\nfunction findRootTrustRegion(\\n\\t\\tf, \\n\\t\\tx0, \\n\\t\\targs=[],\\n\\t\\tjac=jacCentralDiff,\\n\\t\\ttol=0.000000001, \\n\\t\\tmaxIters=10000, \\n\\t\\tdeltaBar=1000.0, \\n\\t\\teta=0.125, \\n\\t\\tminDelta=1e-12\\n  ) {\\n\\t\\n\\tlet x = deepCopy(x0);\\n\\n\\t\\n\\tlet delta = 0.99 * deltaBar;\\n\\n\\t\\n\\tlet r = f(x, ...args);\\n\\n\\t\\n\\tlet J = jac(f, x, args);\\n\\n\\t\\n\\tlet JTJ = mmMult(transpose(J), J);\\n\\n\\t\\n\\tlet JTr = mvMult(transpose(J), r);\\n\\n\\t\\n\\tlet normJTr = norm(JTr);\\n\\n\\tlet iters = 0;\\n\\twhile (iters &lt; maxIters &amp;&amp; checkTol(r, tol) &amp;&amp; delta &gt;= minDelta) {\\n\\t\\t\\n\\t\\tlet p = doglegStep(JTJ, JTr, normJTr, delta);\\n\\n\\t\\t\\n\\t\\tlet newr = f(vectorAdd(x, p), ...args);\\n\\t\\tlet rho = computeRho(r, newr, J, p);\\n\\n\\t\\t\\n\\t\\tif  (rho &lt; 0.25) {\\n\\t\\t\\tdelta = norm(p) / 4.0;\\n\\t\\t} else if (rho &gt; 0.75 &amp;&amp; Math.abs(norm(p) - delta) &lt; 1e-12) {\\n\\t\\t\\t\\tdelta = Math.min(2 * delta, deltaBar);\\n\\t\\t}\\n\\n\\t\\t\\n\\t\\tif (rho &gt; eta) {\\n\\t\\t\\tx = vectorAdd(x, p);\\n\\n\\t\\t\\tr = newr;\\n\\t\\t\\tJ = jac(f, x, args);\\n\\t\\t\\tJTJ = mmMult(transpose(J), J);\\n\\t\\t\\tJTr = mvMult(transpose(J), r);\\n\\t\\t\\tnormJTr = norm(JTr);\\n\\t\\t}\\n\\n\\t\\titers += 1;\\n\\t}\\n\\n\\tlet success = !checkTol(r, tol);\\n\\n\\treturn [x, success];\\n\\n}\\n\\n\\nfunction newtonSolve(x0, f, df, args=[], tol=1e-8, maxIter=200, epsilon=1e-14) {\\n\\tlet x = Infinity;\\n\\tlet solved = false;\\n\\n  for (let i = 0; i &lt; maxIter; i++) {\\n      let y = f(x0, ...args);\\n      let yprime = df(x0, ...args);\\n\\n      if (Math.abs(yprime) &lt; epsilon) {\\n      \\tbreak;\\n\\t\\t\\t}\\n\\n      x = x0 - y / yprime;\\n\\n      if (Math.abs(x - x0) &lt;= tol) {\\n      \\tsolved = true;\\n      \\tbreak;\\n      }\\n\\n      x0 = x;\\n  }\\n\\n  if (solved) return x;\\n  else return null;\\n}\\n\\n\\nfunction log1p(x) {\\n  \\n  \\n  if (x &lt;= -1.0) {\\n    throw new RangeError(&#x27;Argument must be greater than -1.0&#x27;);\\n  }\\n\\n  \\n  else if (Math.abs(x) &gt; 1e-4) {\\n    return Math.log(1.0 + x);\\n  }\\n\\n  else {\\n    return (-0.5*x + 1.0)*x;\\n  }\\n}\\n\\n\\nfunction erfc(x) {\\n  let y2 = Math.pow(x, 2);\\n  let y = x &lt; 0 ? -x : x;\\n  const term1 = 0.56418958354775629 / (y + 2.06955023132914151);\\n  \\n  const term2 = (y**2 + 2.71078540045147805 * y + 5.80755613130301624) / \\n                (y**2 + 3.47954057099518960 * y + 12.06166887286239555);\\n\\n  const term3 = (y**2 + 3.47469513777439592 * y + 12.07402036406381411) / \\n                (y**2 + 3.72068443960225092 * y + 8.44319781003968454);\\n\\n  const term4 = (y**2 + 4.00561509202259545 * y + 9.30596659485887898) / \\n                (y**2 + 3.90225704029924078 * y + 6.36161630953880464);\\n\\n  const term5 = (y**2 + 5.16722705817812584 * y + 9.12661617673673262) / \\n                (y**2 + 4.03296893109262491 * y + 5.13578530585681539);\\n\\n  const term6 = (y**2 + 5.95908795446633271 * y + 9.19435612886969243) / \\n                (y**2 + 4.11240942957450885 * y + 4.48640329523408675);\\n\\n  const expTerm = Math.exp(-Math.pow(x,2));\\n\\n  let res = term1 * term2 * term3 * term4 * term5 * term6 * expTerm;\\n\\n  return x &lt; 0 ? 2.0 - res : res;\\n}\\n\\n\\nfunction transpose(A) {\\n    return A[0].map((_, colIndex) =&gt; A.map(row =&gt; row[colIndex]));\\n}\\n\\n\\nfunction mvMult(A, v) {\\n  return A.map(Arow =&gt; dot(Arow, v));\\n}\\n\\n\\nfunction mmMult(A, B) {\\n  let mA = A.length;\\n  let nA = A[0].length;\\n  let mB = B.length;\\n  let nB = B[0].length;\\n\\n  if (nA !== mB) {\\n      throw new Error(&#x27;Matrix dimension mismatch.&#x27;);\\n  }\\n\\n  let result = zeros(mA, nB);\\n\\n  for (let i = 0; i &lt; mA; i++) {\\n    for (let j = 0; j &lt; nB; j++) {\\n      for (let k = 0; k &lt; nA; k++) {\\n        result[i][j] += A[i][k] * B[k][j];\\n      }\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction vectorAdd() {\\n  let m = arguments.length;\\n  let n = arguments[0].length;\\n \\n  let result = new Array(n).fill(0.0);\\n \\n  for (let i = 0; i &lt; n; i++) {\\n    for (let j = 0; j &lt; m; j++) {\\n        result[i] += arguments[j][i];\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction norm(v) {\\n  return Math.sqrt(dot(v, v));\\n}\\n\\n\\nfunction deepCopy(x) {\\n  return JSON.parse(JSON.stringify(x));\\n}\\n\\n\\nfunction computeRho(r, newr, J, p) {\\n\\tlet r2 = norm(r) ** 2;\\n\\tlet num = r2 - norm(newr)**2;\\n\\tlet denom = r2 - norm(vectorAdd(r, mvMult(J, p))) ** 2;\\n\\n\\treturn num / denom;\\n}\\n\\n\\nfunction checkTol(r, tol) {\\n\\t\\n\\tconst n = r.length;\\n\\tfor (let i = 0; i &lt; n; i++) {\\n\\t\\tif (tol &lt; Math.abs(r[i])) return true;\\n\\t}\\n\\n\\treturn false;\\n}\\n\\n\\nfunction doglegStep(JTJ, JTr, normJTr, delta) {\\n\\t\\n\\tlet [pJ, posDef] = solvePosDef(JTJ, JTr);\\n\\tpJ = svMult(-1.0, pJ);\\n\\n\\t\\n\\tif (posDef &amp;&amp; norm(pJ) &lt;= delta) {\\n\\t\\treturn pJ;\\n\\t}\\n\\n\\t\\n\\tlet tau = Math.min(1, normJTr**3 / delta / quadForm(JTJ, JTr));\\n\\tlet pC = svMult(-tau * delta / normJTr, JTr);\\n\\n\\tlet pCnorm = norm(pC);\\n\\tif (!posDef || Math.abs(pCnorm - delta) &lt;= 1e-12) {\\n\\t\\treturn pC;\\n\\t}\\n\\n\\t\\n\\tlet pJ2 = norm(pJ) ** 2;\\n\\tlet pC2 = pCnorm**2;\\n\\tlet pJpC = dot(pJ, pC);\\n\\tlet a = pJ2 + pC2 - 2.0 * pJpC;\\n\\tlet b = 2.0 * (pJpC - pC2);\\n\\tlet c = pC2 - delta**2;\\n\\tlet q = -0.5 * (b + Math.sign(b) * Math.sqrt(b**2 - 4.0 * a * c));\\n\\n\\t\\n\\tlet beta;\\n\\tif (Math.abs(b) &lt; 1e-12) beta = Math.sqrt(-c / a);\\n\\telse if (b &lt; 0.0) beta = q / a;\\n\\telse beta = c / q;\\n\\n\\t\\n\\tif (0.0 &lt;= beta &amp;&amp; beta &lt;= 1) {\\n\\t\\treturn vectorAdd(pC, svMult(beta, vectorAdd(pJ, svMult(-1.0, pC))));\\n\\t} else { \\n\\t\\treturn pC;\\n\\t}\\n\\n}\\n\\n\\nfunction jacCentralDiff(f, x, args=[], eps=4.7e-6) {\\n\\t\\n\\tlet xPlus = deepCopy(x);\\n\\tlet xMinus = deepCopy(x);\\n\\n\\t\\n\\tlet fOfx = f(x, ...args);\\n\\tlet m = fOfx.length;\\n\\n\\t\\n\\tlet n = x.length;\\n\\n\\t\\n\\tlet J = zeros(m, n);\\n\\n\\t\\n\\tlet fOfxPlus;\\n\\tlet fOfxMinus;\\n\\n\\tfor (let j = 0; j &lt; n; j++) {\\n\\t\\txPlus[j] += eps;\\n\\t\\txMinus[j] -= eps;\\n\\t\\tfOfxPlus = f(xPlus, ...args);\\n\\t\\tfOfxMinus = f(xMinus, ...args);\\n\\t\\txPlus[j] -= eps;\\n\\t\\txMinus[j] += eps;\\n\\n\\t\\tfor (let i = 0; i &lt; m; i++) {\\n\\t\\t\\tJ[i][j] = (fOfxPlus[i] - fOfxMinus[i]) / 2.0 / eps;\\n\\t\\t}\\n\\t}\\n\\n\\treturn J;\\n}\\n\\n\\nfunction dot(v1, v2) {\\n  const n = v1.length;\\n  let result = 0.0;\\n  for (let i = 0; i &lt; n; i++) result += v1[i] * v2[i];\\n\\n  return result;\\n}\\n\\n\\nfunction zeros(...dims) {\\n  let A = [];\\n\\n  \\n  for (let i = dims.length - 1; i &gt;= 0; i--) {\\n    let size = dims[i];\\n    if (i === dims.length - 1) {\\n      \\n      A = new Array(size).fill(0.0);\\n    } else {\\n      \\n      A = new Array(size).fill().map(() =&gt; deepCopy(A));\\n    }\\n  }\\n\\n  return A;\\n}\\n\\n\\nfunction svMult(a, v) {\\n  return v.map(x =&gt; a * x);\\n}\\n\\n\\nfunction quadForm(A, x) {\\n   return dot(x, mvMult(A, x)); \\n}\\n\\n\\nfunction solvePosDef(A, b) {\\n  let [L, p, success] = modifiedCholesky(A);\\n\\n  if (!success) {\\n    return [zeros(b.length), success];\\n  }\\n\\n  return [modifiedCholeskySolve(L, p, b), success];\\n}\\n\\n\\nfunction modifiedCholesky(A) {\\n    const floatEps = 1.0e-14;\\n    const n = A.length;\\n\\n    \\n    let L = deepCopy(A); \\n    let p = arange(0, n);\\n\\n    \\n    let success = true;\\n\\n    let xi = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        for (let j = 0; j &lt; i; j++) {\\n            let temp = Math.abs(L[i][j]);\\n            xi = Math.max(xi, temp);\\n        }\\n    }\\n\\n    let eta = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        let temp = Math.abs(L[i][i]);\\n        eta = Math.max(eta, temp);\\n    }\\n\\n    let beta;\\n    if (n &gt; 1) {\\n        beta = Math.sqrt(Math.max(eta, xi / Math.sqrt(n * n - 1)));\\n    } else {\\n        beta = Math.sqrt(eta);\\n    }\\n    beta = Math.max(beta, floatEps);\\n\\n    for (let k = 0; k &lt; n; k++) {\\n        \\n        let muVal = L[k][k];\\n        let mu = k;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            let temp = L[i][i];\\n            if (muVal &lt; temp) {\\n                mu = i;\\n                muVal = temp;\\n            }\\n        }\\n\\n        \\n        let iTemp = p[mu];\\n        p[mu] = p[k];\\n        p[k] = iTemp;\\n\\n        for (let i = 0; i &lt; k; i++) {\\n            let temp = L[k][i];\\n            L[k][i] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        let temp = L[k][k];\\n        L[k][k] = L[mu][mu];\\n        L[mu][mu] = temp;\\n        for (let i = k + 1; i &lt; mu; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        for (let i = mu + 1; i &lt; n; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[i][mu];\\n            L[i][mu] = temp;\\n        }\\n\\n        \\n        let cSum = 0;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            cSum = Math.max(cSum, Math.abs(L[i][k]));\\n        }\\n        cSum /= beta;\\n        cSum = cSum * cSum;\\n\\n        \\n        if (L[k][k] &lt; 0) {\\n            success = false;\\n        }\\n\\n        temp = Math.abs(L[k][k]);\\n        temp = Math.max(temp, floatEps * eta);\\n        temp = Math.max(temp, cSum);\\n        L[k][k] = Math.sqrt(temp);\\n\\n        \\n        for (let i = k + 1; i &lt; n; i++) {\\n            L[i][k] /= L[k][k];\\n        }\\n\\n        \\n        for (let j = k + 1; j &lt; n; j++) {\\n            for (let i = j; i &lt; n; i++) {\\n                L[i][j] -= L[i][k] * L[j][k];\\n            }\\n        }\\n\\n        \\n        for (let i = 0; i &lt; n - 1; i++) {\\n            for (let j = i + 1; j &lt; n; j++) {\\n                L[i][j] = 0.0;\\n            }\\n        }\\n    }\\n\\n    return [L, p, success];\\n}\\n\\n\\nfunction modifiedCholeskySolve(L, p, b) {\\n    const n = L.length;\\n\\n    let U = transpose(L);\\n    let xp = new Array(n).fill(0);\\n    for (let i = 0; i &lt; n; i++) {\\n        xp[i] = b[p[i]];\\n    }\\n\\n    \\n    let x = lowerTriSolve(L, xp);\\n\\n    \\n    xp = upperTriSolve(U, x);\\n\\n    for (let i = 0; i &lt; n; i++) {\\n        x[p[i]] = xp[i];\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction lowerTriSolve(L, b) {\\n    const floatEps = 1.0e-14;\\n    const n = L.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = 0; j &lt; n - 1; j++) {\\n        if (Math.abs(L[j][j]) &gt; floatEps) {\\n            x[j] /= L[j][j];\\n            for (let i = j + 1; i &lt; n; i++) {\\n                x[i] -= x[j] * L[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(L[n - 1][n - 1]) &gt; floatEps) {\\n            x[n - 1] /= L[n - 1][n - 1];\\n        } else {\\n            x[n - 1] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction upperTriSolve(U, b) {\\n    const floatEps = 1.0e-14;\\n    const n = U.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = n - 1; j &gt; 0; j--) {\\n        if (Math.abs(U[j][j]) &gt; floatEps) {\\n            x[j] /= U[j][j];\\n            for (let i = 0; i &lt; j; i++) {\\n                x[i] -= x[j] * U[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(U[0][0]) &gt; floatEps) {\\n            x[0] /= U[0][0];\\n        } else {\\n            x[0] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nclass InverseGaussianDistribution extends ContinuousUnivariateDistribution {\\n  \\n  \\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;InverseGaussian&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0.0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u00b5&#x27;, &#x27;\\u03bb&#x27;];\\n\\n    \\n    this.locationParam = undefined;\\n\\n    \\n    this.paramMin = [0.0, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds();\\n\\n    \\n    super.generateLocationParamIndex();\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    return 0.0;    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    if (x &lt; 0) return NaN;\\n    if (x === 0 || x === Infinity) return 0.0;  \\n\\n    let [mu, lambda] = params.slice(0, 2);\\n\\n    let lnProb;\\n    lnProb = -Math.log(2.0 * Math.PI) / 2.0 + (Math.log(lambda) - 3.0 * Math.log(x)) / 2.0\\n             - lambda * Math.pow(x - mu, 2) / (2.0 * Math.pow(mu, 2) * x);\\n\\n    return Math.exp(lnProb);\\n  }\\n\\n  cdfSingleValue(x, params, parametrization = this.parametrization) {\\n    if (x &lt;= 0) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let [mu, lambda] = params.slice(0, 2);\\n\\n    let term1 = lnStdNormCdf(Math.sqrt(lambda / x) * (x / mu - 1.0));\\n    let term2 = 2.0 * lambda / mu + lnStdNormCdf(-Math.sqrt(lambda / x) * (x / mu + 1.0));\\n\\n    return Math.exp(logSumExp(term1, term2));\\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n    if (p == 0) return 0.0;\\n    if (p == 1) return Infinity;\\n\\n    let [mu, lambda] = params.slice(0, 2);\\n\\n    \\n    let xMode = mu * (Math.sqrt(1.0 + 2.25 * Math.pow(mu, 2) / Math.pow(lambda, 2)) - 1.5 * mu / lambda);\\n\\n    \\n    let f;\\n    let df;\\n    if (p &lt; this.cdfSingleValue(xMode, params, parametrization)) {\\n      f = (x, params, p) =&gt; this.cdfSingleValue(x, params, parametrization) - p;\\n      df = (x, params, p) =&gt; this.pdfSingleValue(x, params, parametrization);\\n    }\\n    else {\\n      f = (x, params, p) =&gt; p - this.cdfSingleValue(x, params, parametrization);\\n      df = (x, params, p) =&gt; -this.pdfSingleValue(x, params, parametrization);\\n    }\\n\\n    return newtonSolve(xMode, f, df, [params, p]);\\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n    let [x1, x2] = this.ppf([0.01, 0.99], params);\\n\\n    \\n    if (x1 &lt; (x2 - x1) / 10.0) x1 = 0.0;\\n\\n    return [x1, x2];    \\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    \\n    let x1Rescaled = x1 / x2;\\n    let x2Rescaled = 1.0;\\n\\n    \\n    const quantileRootFun = (params, x1, p1, x2, p2) =&gt; {\\n      let mu = Math.exp(params[0]);\\n      let lambda = Math.exp(params[1]);\\n\\n      let r1 = this.cdfSingleValue(x1, [mu, lambda]) - p1;\\n      let r2 = this.cdfSingleValue(x2, [mu, lambda]) - p2;\\n\\n      return [r1, r2];\\n    };\\n\\n    let args = [x1Rescaled, p1, x2Rescaled, p2];\\n\\n    let guess = [2, 2];\\n\\n    let [logParams, optimSuccess] = findRootTrustRegion(quantileRootFun, guess, args=args);\\n\\n    \\n    let paramsOpt = [Math.exp(logParams[0]), Math.exp(logParams[1])];\\n\\n    \\n    return [[x2 * paramsOpt[0], x2 * paramsOpt[1]], optimSuccess];\\n  }\\n}\\n\\n\\n\\nvar dist = new InverseGaussianDistribution();\\n\\n\\n\\nif (quantileSetterSwitch.active) {\\n  quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p);\\n}"}}]]]},"disabled":true,"width":80,"value":"1.4980"}},{"id":"p2816"}]],["pBoxes",[{"id":"p2817"},{"id":"p2818"}]],["quantileSetterSwitch",{"id":"p2820"}],["quantileSetterDiv",{"id":"p2819"}],["triggerCallbacks",{"id":"p2821"}],["startBoxes",[{"id":"p2811"},{"id":"p2812"}]],["endBoxes",[{"id":"p2813"},{"id":"p2814"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nfunction logSumExp(x1, x2) {\\n  if (x1 &gt; x2) {\\n    return x1 + log1p(Math.exp(x2 - x1));\\n  }\\n  else {\\n    return x2 + log1p(Math.exp(x1 - x2));\\n  }\\n}\\n\\n\\nfunction lnStdNormCdf(x) {\\n  \\n  let y = x / 1.4142135623730950488016887;\\n\\n  let res;\\n  \\n  if (y &gt; 0.0) {\\n    res = log1p(-0.5 * erfc(y));\\n  } \\n  else if (y &gt; -20.0) {\\n    \\n    res = Math.log(erfc(-y)) - 0.6931471805599453;\\n  }\\n  else {\\n    \\n    const y2 = Math.pow(y, 2);\\n    const y4 = Math.pow(y, 4);\\n    const y6 = Math.pow(y, 6);\\n    const y8 = Math.pow(y, 8);\\n    const y10 = Math.pow(y, 10);\\n    const temp_p = 0.000658749161529837803157 + 0.0160837851487422766278 / y2\\n                 + 0.125781726111229246204 / y4 + 0.360344899949804439429 / y6\\n                 + 0.305326634961232344035 / y8 + 0.0163153871373020978498 / y10;\\n    const temp_q = -0.00233520497626869185443 - 0.0605183413124413191178 / y2\\n                   - 0.527905102951428412248 / y4 - 1.87295284992346047209 / y6\\n                   - 2.56852019228982242072 / y8 - 1.0 / y10;\\n    res = -0.6931471805599453 + Math.log(0.5641895835477563 + (temp_p / temp_q) / y2) - Math.log(-y) - y2;\\n  }\\n\\n  if (isNaN(res)) {\\n    return -Infinity;\\n  }\\n  else {\\n    return res;\\n  }\\n}\\n\\n\\nfunction findRootTrustRegion(\\n\\t\\tf, \\n\\t\\tx0, \\n\\t\\targs=[],\\n\\t\\tjac=jacCentralDiff,\\n\\t\\ttol=0.000000001, \\n\\t\\tmaxIters=10000, \\n\\t\\tdeltaBar=1000.0, \\n\\t\\teta=0.125, \\n\\t\\tminDelta=1e-12\\n  ) {\\n\\t\\n\\tlet x = deepCopy(x0);\\n\\n\\t\\n\\tlet delta = 0.99 * deltaBar;\\n\\n\\t\\n\\tlet r = f(x, ...args);\\n\\n\\t\\n\\tlet J = jac(f, x, args);\\n\\n\\t\\n\\tlet JTJ = mmMult(transpose(J), J);\\n\\n\\t\\n\\tlet JTr = mvMult(transpose(J), r);\\n\\n\\t\\n\\tlet normJTr = norm(JTr);\\n\\n\\tlet iters = 0;\\n\\twhile (iters &lt; maxIters &amp;&amp; checkTol(r, tol) &amp;&amp; delta &gt;= minDelta) {\\n\\t\\t\\n\\t\\tlet p = doglegStep(JTJ, JTr, normJTr, delta);\\n\\n\\t\\t\\n\\t\\tlet newr = f(vectorAdd(x, p), ...args);\\n\\t\\tlet rho = computeRho(r, newr, J, p);\\n\\n\\t\\t\\n\\t\\tif  (rho &lt; 0.25) {\\n\\t\\t\\tdelta = norm(p) / 4.0;\\n\\t\\t} else if (rho &gt; 0.75 &amp;&amp; Math.abs(norm(p) - delta) &lt; 1e-12) {\\n\\t\\t\\t\\tdelta = Math.min(2 * delta, deltaBar);\\n\\t\\t}\\n\\n\\t\\t\\n\\t\\tif (rho &gt; eta) {\\n\\t\\t\\tx = vectorAdd(x, p);\\n\\n\\t\\t\\tr = newr;\\n\\t\\t\\tJ = jac(f, x, args);\\n\\t\\t\\tJTJ = mmMult(transpose(J), J);\\n\\t\\t\\tJTr = mvMult(transpose(J), r);\\n\\t\\t\\tnormJTr = norm(JTr);\\n\\t\\t}\\n\\n\\t\\titers += 1;\\n\\t}\\n\\n\\tlet success = !checkTol(r, tol);\\n\\n\\treturn [x, success];\\n\\n}\\n\\n\\nfunction newtonSolve(x0, f, df, args=[], tol=1e-8, maxIter=200, epsilon=1e-14) {\\n\\tlet x = Infinity;\\n\\tlet solved = false;\\n\\n  for (let i = 0; i &lt; maxIter; i++) {\\n      let y = f(x0, ...args);\\n      let yprime = df(x0, ...args);\\n\\n      if (Math.abs(yprime) &lt; epsilon) {\\n      \\tbreak;\\n\\t\\t\\t}\\n\\n      x = x0 - y / yprime;\\n\\n      if (Math.abs(x - x0) &lt;= tol) {\\n      \\tsolved = true;\\n      \\tbreak;\\n      }\\n\\n      x0 = x;\\n  }\\n\\n  if (solved) return x;\\n  else return null;\\n}\\n\\n\\nfunction log1p(x) {\\n  \\n  \\n  if (x &lt;= -1.0) {\\n    throw new RangeError(&#x27;Argument must be greater than -1.0&#x27;);\\n  }\\n\\n  \\n  else if (Math.abs(x) &gt; 1e-4) {\\n    return Math.log(1.0 + x);\\n  }\\n\\n  else {\\n    return (-0.5*x + 1.0)*x;\\n  }\\n}\\n\\n\\nfunction erfc(x) {\\n  let y2 = Math.pow(x, 2);\\n  let y = x &lt; 0 ? -x : x;\\n  const term1 = 0.56418958354775629 / (y + 2.06955023132914151);\\n  \\n  const term2 = (y**2 + 2.71078540045147805 * y + 5.80755613130301624) / \\n                (y**2 + 3.47954057099518960 * y + 12.06166887286239555);\\n\\n  const term3 = (y**2 + 3.47469513777439592 * y + 12.07402036406381411) / \\n                (y**2 + 3.72068443960225092 * y + 8.44319781003968454);\\n\\n  const term4 = (y**2 + 4.00561509202259545 * y + 9.30596659485887898) / \\n                (y**2 + 3.90225704029924078 * y + 6.36161630953880464);\\n\\n  const term5 = (y**2 + 5.16722705817812584 * y + 9.12661617673673262) / \\n                (y**2 + 4.03296893109262491 * y + 5.13578530585681539);\\n\\n  const term6 = (y**2 + 5.95908795446633271 * y + 9.19435612886969243) / \\n                (y**2 + 4.11240942957450885 * y + 4.48640329523408675);\\n\\n  const expTerm = Math.exp(-Math.pow(x,2));\\n\\n  let res = term1 * term2 * term3 * term4 * term5 * term6 * expTerm;\\n\\n  return x &lt; 0 ? 2.0 - res : res;\\n}\\n\\n\\nfunction transpose(A) {\\n    return A[0].map((_, colIndex) =&gt; A.map(row =&gt; row[colIndex]));\\n}\\n\\n\\nfunction mvMult(A, v) {\\n  return A.map(Arow =&gt; dot(Arow, v));\\n}\\n\\n\\nfunction mmMult(A, B) {\\n  let mA = A.length;\\n  let nA = A[0].length;\\n  let mB = B.length;\\n  let nB = B[0].length;\\n\\n  if (nA !== mB) {\\n      throw new Error(&#x27;Matrix dimension mismatch.&#x27;);\\n  }\\n\\n  let result = zeros(mA, nB);\\n\\n  for (let i = 0; i &lt; mA; i++) {\\n    for (let j = 0; j &lt; nB; j++) {\\n      for (let k = 0; k &lt; nA; k++) {\\n        result[i][j] += A[i][k] * B[k][j];\\n      }\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction vectorAdd() {\\n  let m = arguments.length;\\n  let n = arguments[0].length;\\n \\n  let result = new Array(n).fill(0.0);\\n \\n  for (let i = 0; i &lt; n; i++) {\\n    for (let j = 0; j &lt; m; j++) {\\n        result[i] += arguments[j][i];\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction norm(v) {\\n  return Math.sqrt(dot(v, v));\\n}\\n\\n\\nfunction deepCopy(x) {\\n  return JSON.parse(JSON.stringify(x));\\n}\\n\\n\\nfunction computeRho(r, newr, J, p) {\\n\\tlet r2 = norm(r) ** 2;\\n\\tlet num = r2 - norm(newr)**2;\\n\\tlet denom = r2 - norm(vectorAdd(r, mvMult(J, p))) ** 2;\\n\\n\\treturn num / denom;\\n}\\n\\n\\nfunction checkTol(r, tol) {\\n\\t\\n\\tconst n = r.length;\\n\\tfor (let i = 0; i &lt; n; i++) {\\n\\t\\tif (tol &lt; Math.abs(r[i])) return true;\\n\\t}\\n\\n\\treturn false;\\n}\\n\\n\\nfunction doglegStep(JTJ, JTr, normJTr, delta) {\\n\\t\\n\\tlet [pJ, posDef] = solvePosDef(JTJ, JTr);\\n\\tpJ = svMult(-1.0, pJ);\\n\\n\\t\\n\\tif (posDef &amp;&amp; norm(pJ) &lt;= delta) {\\n\\t\\treturn pJ;\\n\\t}\\n\\n\\t\\n\\tlet tau = Math.min(1, normJTr**3 / delta / quadForm(JTJ, JTr));\\n\\tlet pC = svMult(-tau * delta / normJTr, JTr);\\n\\n\\tlet pCnorm = norm(pC);\\n\\tif (!posDef || Math.abs(pCnorm - delta) &lt;= 1e-12) {\\n\\t\\treturn pC;\\n\\t}\\n\\n\\t\\n\\tlet pJ2 = norm(pJ) ** 2;\\n\\tlet pC2 = pCnorm**2;\\n\\tlet pJpC = dot(pJ, pC);\\n\\tlet a = pJ2 + pC2 - 2.0 * pJpC;\\n\\tlet b = 2.0 * (pJpC - pC2);\\n\\tlet c = pC2 - delta**2;\\n\\tlet q = -0.5 * (b + Math.sign(b) * Math.sqrt(b**2 - 4.0 * a * c));\\n\\n\\t\\n\\tlet beta;\\n\\tif (Math.abs(b) &lt; 1e-12) beta = Math.sqrt(-c / a);\\n\\telse if (b &lt; 0.0) beta = q / a;\\n\\telse beta = c / q;\\n\\n\\t\\n\\tif (0.0 &lt;= beta &amp;&amp; beta &lt;= 1) {\\n\\t\\treturn vectorAdd(pC, svMult(beta, vectorAdd(pJ, svMult(-1.0, pC))));\\n\\t} else { \\n\\t\\treturn pC;\\n\\t}\\n\\n}\\n\\n\\nfunction jacCentralDiff(f, x, args=[], eps=4.7e-6) {\\n\\t\\n\\tlet xPlus = deepCopy(x);\\n\\tlet xMinus = deepCopy(x);\\n\\n\\t\\n\\tlet fOfx = f(x, ...args);\\n\\tlet m = fOfx.length;\\n\\n\\t\\n\\tlet n = x.length;\\n\\n\\t\\n\\tlet J = zeros(m, n);\\n\\n\\t\\n\\tlet fOfxPlus;\\n\\tlet fOfxMinus;\\n\\n\\tfor (let j = 0; j &lt; n; j++) {\\n\\t\\txPlus[j] += eps;\\n\\t\\txMinus[j] -= eps;\\n\\t\\tfOfxPlus = f(xPlus, ...args);\\n\\t\\tfOfxMinus = f(xMinus, ...args);\\n\\t\\txPlus[j] -= eps;\\n\\t\\txMinus[j] += eps;\\n\\n\\t\\tfor (let i = 0; i &lt; m; i++) {\\n\\t\\t\\tJ[i][j] = (fOfxPlus[i] - fOfxMinus[i]) / 2.0 / eps;\\n\\t\\t}\\n\\t}\\n\\n\\treturn J;\\n}\\n\\n\\nfunction dot(v1, v2) {\\n  const n = v1.length;\\n  let result = 0.0;\\n  for (let i = 0; i &lt; n; i++) result += v1[i] * v2[i];\\n\\n  return result;\\n}\\n\\n\\nfunction zeros(...dims) {\\n  let A = [];\\n\\n  \\n  for (let i = dims.length - 1; i &gt;= 0; i--) {\\n    let size = dims[i];\\n    if (i === dims.length - 1) {\\n      \\n      A = new Array(size).fill(0.0);\\n    } else {\\n      \\n      A = new Array(size).fill().map(() =&gt; deepCopy(A));\\n    }\\n  }\\n\\n  return A;\\n}\\n\\n\\nfunction svMult(a, v) {\\n  return v.map(x =&gt; a * x);\\n}\\n\\n\\nfunction quadForm(A, x) {\\n   return dot(x, mvMult(A, x)); \\n}\\n\\n\\nfunction solvePosDef(A, b) {\\n  let [L, p, success] = modifiedCholesky(A);\\n\\n  if (!success) {\\n    return [zeros(b.length), success];\\n  }\\n\\n  return [modifiedCholeskySolve(L, p, b), success];\\n}\\n\\n\\nfunction modifiedCholesky(A) {\\n    const floatEps = 1.0e-14;\\n    const n = A.length;\\n\\n    \\n    let L = deepCopy(A); \\n    let p = arange(0, n);\\n\\n    \\n    let success = true;\\n\\n    let xi = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        for (let j = 0; j &lt; i; j++) {\\n            let temp = Math.abs(L[i][j]);\\n            xi = Math.max(xi, temp);\\n        }\\n    }\\n\\n    let eta = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        let temp = Math.abs(L[i][i]);\\n        eta = Math.max(eta, temp);\\n    }\\n\\n    let beta;\\n    if (n &gt; 1) {\\n        beta = Math.sqrt(Math.max(eta, xi / Math.sqrt(n * n - 1)));\\n    } else {\\n        beta = Math.sqrt(eta);\\n    }\\n    beta = Math.max(beta, floatEps);\\n\\n    for (let k = 0; k &lt; n; k++) {\\n        \\n        let muVal = L[k][k];\\n        let mu = k;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            let temp = L[i][i];\\n            if (muVal &lt; temp) {\\n                mu = i;\\n                muVal = temp;\\n            }\\n        }\\n\\n        \\n        let iTemp = p[mu];\\n        p[mu] = p[k];\\n        p[k] = iTemp;\\n\\n        for (let i = 0; i &lt; k; i++) {\\n            let temp = L[k][i];\\n            L[k][i] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        let temp = L[k][k];\\n        L[k][k] = L[mu][mu];\\n        L[mu][mu] = temp;\\n        for (let i = k + 1; i &lt; mu; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        for (let i = mu + 1; i &lt; n; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[i][mu];\\n            L[i][mu] = temp;\\n        }\\n\\n        \\n        let cSum = 0;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            cSum = Math.max(cSum, Math.abs(L[i][k]));\\n        }\\n        cSum /= beta;\\n        cSum = cSum * cSum;\\n\\n        \\n        if (L[k][k] &lt; 0) {\\n            success = false;\\n        }\\n\\n        temp = Math.abs(L[k][k]);\\n        temp = Math.max(temp, floatEps * eta);\\n        temp = Math.max(temp, cSum);\\n        L[k][k] = Math.sqrt(temp);\\n\\n        \\n        for (let i = k + 1; i &lt; n; i++) {\\n            L[i][k] /= L[k][k];\\n        }\\n\\n        \\n        for (let j = k + 1; j &lt; n; j++) {\\n            for (let i = j; i &lt; n; i++) {\\n                L[i][j] -= L[i][k] * L[j][k];\\n            }\\n        }\\n\\n        \\n        for (let i = 0; i &lt; n - 1; i++) {\\n            for (let j = i + 1; j &lt; n; j++) {\\n                L[i][j] = 0.0;\\n            }\\n        }\\n    }\\n\\n    return [L, p, success];\\n}\\n\\n\\nfunction modifiedCholeskySolve(L, p, b) {\\n    const n = L.length;\\n\\n    let U = transpose(L);\\n    let xp = new Array(n).fill(0);\\n    for (let i = 0; i &lt; n; i++) {\\n        xp[i] = b[p[i]];\\n    }\\n\\n    \\n    let x = lowerTriSolve(L, xp);\\n\\n    \\n    xp = upperTriSolve(U, x);\\n\\n    for (let i = 0; i &lt; n; i++) {\\n        x[p[i]] = xp[i];\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction lowerTriSolve(L, b) {\\n    const floatEps = 1.0e-14;\\n    const n = L.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = 0; j &lt; n - 1; j++) {\\n        if (Math.abs(L[j][j]) &gt; floatEps) {\\n            x[j] /= L[j][j];\\n            for (let i = j + 1; i &lt; n; i++) {\\n                x[i] -= x[j] * L[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(L[n - 1][n - 1]) &gt; floatEps) {\\n            x[n - 1] /= L[n - 1][n - 1];\\n        } else {\\n            x[n - 1] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction upperTriSolve(U, b) {\\n    const floatEps = 1.0e-14;\\n    const n = U.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = n - 1; j &gt; 0; j--) {\\n        if (Math.abs(U[j][j]) &gt; floatEps) {\\n            x[j] /= U[j][j];\\n            for (let i = 0; i &lt; j; i++) {\\n                x[i] -= x[j] * U[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(U[0][0]) &gt; floatEps) {\\n            x[0] /= U[0][0];\\n        } else {\\n            x[0] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nclass InverseGaussianDistribution extends ContinuousUnivariateDistribution {\\n  \\n  \\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;InverseGaussian&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0.0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u00b5&#x27;, &#x27;\\u03bb&#x27;];\\n\\n    \\n    this.locationParam = undefined;\\n\\n    \\n    this.paramMin = [0.0, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds();\\n\\n    \\n    super.generateLocationParamIndex();\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    return 0.0;    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    if (x &lt; 0) return NaN;\\n    if (x === 0 || x === Infinity) return 0.0;  \\n\\n    let [mu, lambda] = params.slice(0, 2);\\n\\n    let lnProb;\\n    lnProb = -Math.log(2.0 * Math.PI) / 2.0 + (Math.log(lambda) - 3.0 * Math.log(x)) / 2.0\\n             - lambda * Math.pow(x - mu, 2) / (2.0 * Math.pow(mu, 2) * x);\\n\\n    return Math.exp(lnProb);\\n  }\\n\\n  cdfSingleValue(x, params, parametrization = this.parametrization) {\\n    if (x &lt;= 0) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let [mu, lambda] = params.slice(0, 2);\\n\\n    let term1 = lnStdNormCdf(Math.sqrt(lambda / x) * (x / mu - 1.0));\\n    let term2 = 2.0 * lambda / mu + lnStdNormCdf(-Math.sqrt(lambda / x) * (x / mu + 1.0));\\n\\n    return Math.exp(logSumExp(term1, term2));\\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n    if (p == 0) return 0.0;\\n    if (p == 1) return Infinity;\\n\\n    let [mu, lambda] = params.slice(0, 2);\\n\\n    \\n    let xMode = mu * (Math.sqrt(1.0 + 2.25 * Math.pow(mu, 2) / Math.pow(lambda, 2)) - 1.5 * mu / lambda);\\n\\n    \\n    let f;\\n    let df;\\n    if (p &lt; this.cdfSingleValue(xMode, params, parametrization)) {\\n      f = (x, params, p) =&gt; this.cdfSingleValue(x, params, parametrization) - p;\\n      df = (x, params, p) =&gt; this.pdfSingleValue(x, params, parametrization);\\n    }\\n    else {\\n      f = (x, params, p) =&gt; p - this.cdfSingleValue(x, params, parametrization);\\n      df = (x, params, p) =&gt; -this.pdfSingleValue(x, params, parametrization);\\n    }\\n\\n    return newtonSolve(xMode, f, df, [params, p]);\\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n    let [x1, x2] = this.ppf([0.01, 0.99], params);\\n\\n    \\n    if (x1 &lt; (x2 - x1) / 10.0) x1 = 0.0;\\n\\n    return [x1, x2];    \\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    \\n    let x1Rescaled = x1 / x2;\\n    let x2Rescaled = 1.0;\\n\\n    \\n    const quantileRootFun = (params, x1, p1, x2, p2) =&gt; {\\n      let mu = Math.exp(params[0]);\\n      let lambda = Math.exp(params[1]);\\n\\n      let r1 = this.cdfSingleValue(x1, [mu, lambda]) - p1;\\n      let r2 = this.cdfSingleValue(x2, [mu, lambda]) - p2;\\n\\n      return [r1, r2];\\n    };\\n\\n    let args = [x1Rescaled, p1, x2Rescaled, p2];\\n\\n    let guess = [2, 2];\\n\\n    let [logParams, optimSuccess] = findRootTrustRegion(quantileRootFun, guess, args=args);\\n\\n    \\n    let paramsOpt = [Math.exp(logParams[0]), Math.exp(logParams[1])];\\n\\n    \\n    return [[x2 * paramsOpt[0], x2 * paramsOpt[1]], optimSuccess];\\n  }\\n}\\n\\n\\n\\nvar dist = new InverseGaussianDistribution();\\n\\n\\n\\nif (triggerCallbacks.active &amp;&amp; !cb_obj.disabled) {\\n\\tif (quantileSetterSwitch.active) {\\n\\t\\tquantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p);\\n\\t}\\n\\telse {\\n\\t\\tupdateData(source_p, source_c, p_p, sliders, discrete);\\n\\t\\tupdateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes);\\n\\t}\\n}"}}]]]},"width":200,"title":"\\u00b5","format":{"type":"object","name":"CustomJSTickFormatter","id":"p2807","attributes":{"code":"return tick.toPrecision(4)"}},"start":0.1,"end":20,"value":10,"step":0.01}},{"id":"p2810"}]],["xBoxes",[{"id":"p2815"},{"id":"p2816"}]],["pBoxes",[{"id":"p2817"},{"id":"p2818"}]],["quantileSetterSwitch",{"id":"p2820"}],["quantileSetterDiv",{"id":"p2819"}],["triggerCallbacks",{"id":"p2821"}],["startBoxes",[{"id":"p2811"},{"id":"p2812"}]],["endBoxes",[{"id":"p2813"},{"id":"p2814"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nfunction logSumExp(x1, x2) {\\n  if (x1 &gt; x2) {\\n    return x1 + log1p(Math.exp(x2 - x1));\\n  }\\n  else {\\n    return x2 + log1p(Math.exp(x1 - x2));\\n  }\\n}\\n\\n\\nfunction lnStdNormCdf(x) {\\n  \\n  let y = x / 1.4142135623730950488016887;\\n\\n  let res;\\n  \\n  if (y &gt; 0.0) {\\n    res = log1p(-0.5 * erfc(y));\\n  } \\n  else if (y &gt; -20.0) {\\n    \\n    res = Math.log(erfc(-y)) - 0.6931471805599453;\\n  }\\n  else {\\n    \\n    const y2 = Math.pow(y, 2);\\n    const y4 = Math.pow(y, 4);\\n    const y6 = Math.pow(y, 6);\\n    const y8 = Math.pow(y, 8);\\n    const y10 = Math.pow(y, 10);\\n    const temp_p = 0.000658749161529837803157 + 0.0160837851487422766278 / y2\\n                 + 0.125781726111229246204 / y4 + 0.360344899949804439429 / y6\\n                 + 0.305326634961232344035 / y8 + 0.0163153871373020978498 / y10;\\n    const temp_q = -0.00233520497626869185443 - 0.0605183413124413191178 / y2\\n                   - 0.527905102951428412248 / y4 - 1.87295284992346047209 / y6\\n                   - 2.56852019228982242072 / y8 - 1.0 / y10;\\n    res = -0.6931471805599453 + Math.log(0.5641895835477563 + (temp_p / temp_q) / y2) - Math.log(-y) - y2;\\n  }\\n\\n  if (isNaN(res)) {\\n    return -Infinity;\\n  }\\n  else {\\n    return res;\\n  }\\n}\\n\\n\\nfunction findRootTrustRegion(\\n\\t\\tf, \\n\\t\\tx0, \\n\\t\\targs=[],\\n\\t\\tjac=jacCentralDiff,\\n\\t\\ttol=0.000000001, \\n\\t\\tmaxIters=10000, \\n\\t\\tdeltaBar=1000.0, \\n\\t\\teta=0.125, \\n\\t\\tminDelta=1e-12\\n  ) {\\n\\t\\n\\tlet x = deepCopy(x0);\\n\\n\\t\\n\\tlet delta = 0.99 * deltaBar;\\n\\n\\t\\n\\tlet r = f(x, ...args);\\n\\n\\t\\n\\tlet J = jac(f, x, args);\\n\\n\\t\\n\\tlet JTJ = mmMult(transpose(J), J);\\n\\n\\t\\n\\tlet JTr = mvMult(transpose(J), r);\\n\\n\\t\\n\\tlet normJTr = norm(JTr);\\n\\n\\tlet iters = 0;\\n\\twhile (iters &lt; maxIters &amp;&amp; checkTol(r, tol) &amp;&amp; delta &gt;= minDelta) {\\n\\t\\t\\n\\t\\tlet p = doglegStep(JTJ, JTr, normJTr, delta);\\n\\n\\t\\t\\n\\t\\tlet newr = f(vectorAdd(x, p), ...args);\\n\\t\\tlet rho = computeRho(r, newr, J, p);\\n\\n\\t\\t\\n\\t\\tif  (rho &lt; 0.25) {\\n\\t\\t\\tdelta = norm(p) / 4.0;\\n\\t\\t} else if (rho &gt; 0.75 &amp;&amp; Math.abs(norm(p) - delta) &lt; 1e-12) {\\n\\t\\t\\t\\tdelta = Math.min(2 * delta, deltaBar);\\n\\t\\t}\\n\\n\\t\\t\\n\\t\\tif (rho &gt; eta) {\\n\\t\\t\\tx = vectorAdd(x, p);\\n\\n\\t\\t\\tr = newr;\\n\\t\\t\\tJ = jac(f, x, args);\\n\\t\\t\\tJTJ = mmMult(transpose(J), J);\\n\\t\\t\\tJTr = mvMult(transpose(J), r);\\n\\t\\t\\tnormJTr = norm(JTr);\\n\\t\\t}\\n\\n\\t\\titers += 1;\\n\\t}\\n\\n\\tlet success = !checkTol(r, tol);\\n\\n\\treturn [x, success];\\n\\n}\\n\\n\\nfunction newtonSolve(x0, f, df, args=[], tol=1e-8, maxIter=200, epsilon=1e-14) {\\n\\tlet x = Infinity;\\n\\tlet solved = false;\\n\\n  for (let i = 0; i &lt; maxIter; i++) {\\n      let y = f(x0, ...args);\\n      let yprime = df(x0, ...args);\\n\\n      if (Math.abs(yprime) &lt; epsilon) {\\n      \\tbreak;\\n\\t\\t\\t}\\n\\n      x = x0 - y / yprime;\\n\\n      if (Math.abs(x - x0) &lt;= tol) {\\n      \\tsolved = true;\\n      \\tbreak;\\n      }\\n\\n      x0 = x;\\n  }\\n\\n  if (solved) return x;\\n  else return null;\\n}\\n\\n\\nfunction log1p(x) {\\n  \\n  \\n  if (x &lt;= -1.0) {\\n    throw new RangeError(&#x27;Argument must be greater than -1.0&#x27;);\\n  }\\n\\n  \\n  else if (Math.abs(x) &gt; 1e-4) {\\n    return Math.log(1.0 + x);\\n  }\\n\\n  else {\\n    return (-0.5*x + 1.0)*x;\\n  }\\n}\\n\\n\\nfunction erfc(x) {\\n  let y2 = Math.pow(x, 2);\\n  let y = x &lt; 0 ? -x : x;\\n  const term1 = 0.56418958354775629 / (y + 2.06955023132914151);\\n  \\n  const term2 = (y**2 + 2.71078540045147805 * y + 5.80755613130301624) / \\n                (y**2 + 3.47954057099518960 * y + 12.06166887286239555);\\n\\n  const term3 = (y**2 + 3.47469513777439592 * y + 12.07402036406381411) / \\n                (y**2 + 3.72068443960225092 * y + 8.44319781003968454);\\n\\n  const term4 = (y**2 + 4.00561509202259545 * y + 9.30596659485887898) / \\n                (y**2 + 3.90225704029924078 * y + 6.36161630953880464);\\n\\n  const term5 = (y**2 + 5.16722705817812584 * y + 9.12661617673673262) / \\n                (y**2 + 4.03296893109262491 * y + 5.13578530585681539);\\n\\n  const term6 = (y**2 + 5.95908795446633271 * y + 9.19435612886969243) / \\n                (y**2 + 4.11240942957450885 * y + 4.48640329523408675);\\n\\n  const expTerm = Math.exp(-Math.pow(x,2));\\n\\n  let res = term1 * term2 * term3 * term4 * term5 * term6 * expTerm;\\n\\n  return x &lt; 0 ? 2.0 - res : res;\\n}\\n\\n\\nfunction transpose(A) {\\n    return A[0].map((_, colIndex) =&gt; A.map(row =&gt; row[colIndex]));\\n}\\n\\n\\nfunction mvMult(A, v) {\\n  return A.map(Arow =&gt; dot(Arow, v));\\n}\\n\\n\\nfunction mmMult(A, B) {\\n  let mA = A.length;\\n  let nA = A[0].length;\\n  let mB = B.length;\\n  let nB = B[0].length;\\n\\n  if (nA !== mB) {\\n      throw new Error(&#x27;Matrix dimension mismatch.&#x27;);\\n  }\\n\\n  let result = zeros(mA, nB);\\n\\n  for (let i = 0; i &lt; mA; i++) {\\n    for (let j = 0; j &lt; nB; j++) {\\n      for (let k = 0; k &lt; nA; k++) {\\n        result[i][j] += A[i][k] * B[k][j];\\n      }\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction vectorAdd() {\\n  let m = arguments.length;\\n  let n = arguments[0].length;\\n \\n  let result = new Array(n).fill(0.0);\\n \\n  for (let i = 0; i &lt; n; i++) {\\n    for (let j = 0; j &lt; m; j++) {\\n        result[i] += arguments[j][i];\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction norm(v) {\\n  return Math.sqrt(dot(v, v));\\n}\\n\\n\\nfunction deepCopy(x) {\\n  return JSON.parse(JSON.stringify(x));\\n}\\n\\n\\nfunction computeRho(r, newr, J, p) {\\n\\tlet r2 = norm(r) ** 2;\\n\\tlet num = r2 - norm(newr)**2;\\n\\tlet denom = r2 - norm(vectorAdd(r, mvMult(J, p))) ** 2;\\n\\n\\treturn num / denom;\\n}\\n\\n\\nfunction checkTol(r, tol) {\\n\\t\\n\\tconst n = r.length;\\n\\tfor (let i = 0; i &lt; n; i++) {\\n\\t\\tif (tol &lt; Math.abs(r[i])) return true;\\n\\t}\\n\\n\\treturn false;\\n}\\n\\n\\nfunction doglegStep(JTJ, JTr, normJTr, delta) {\\n\\t\\n\\tlet [pJ, posDef] = solvePosDef(JTJ, JTr);\\n\\tpJ = svMult(-1.0, pJ);\\n\\n\\t\\n\\tif (posDef &amp;&amp; norm(pJ) &lt;= delta) {\\n\\t\\treturn pJ;\\n\\t}\\n\\n\\t\\n\\tlet tau = Math.min(1, normJTr**3 / delta / quadForm(JTJ, JTr));\\n\\tlet pC = svMult(-tau * delta / normJTr, JTr);\\n\\n\\tlet pCnorm = norm(pC);\\n\\tif (!posDef || Math.abs(pCnorm - delta) &lt;= 1e-12) {\\n\\t\\treturn pC;\\n\\t}\\n\\n\\t\\n\\tlet pJ2 = norm(pJ) ** 2;\\n\\tlet pC2 = pCnorm**2;\\n\\tlet pJpC = dot(pJ, pC);\\n\\tlet a = pJ2 + pC2 - 2.0 * pJpC;\\n\\tlet b = 2.0 * (pJpC - pC2);\\n\\tlet c = pC2 - delta**2;\\n\\tlet q = -0.5 * (b + Math.sign(b) * Math.sqrt(b**2 - 4.0 * a * c));\\n\\n\\t\\n\\tlet beta;\\n\\tif (Math.abs(b) &lt; 1e-12) beta = Math.sqrt(-c / a);\\n\\telse if (b &lt; 0.0) beta = q / a;\\n\\telse beta = c / q;\\n\\n\\t\\n\\tif (0.0 &lt;= beta &amp;&amp; beta &lt;= 1) {\\n\\t\\treturn vectorAdd(pC, svMult(beta, vectorAdd(pJ, svMult(-1.0, pC))));\\n\\t} else { \\n\\t\\treturn pC;\\n\\t}\\n\\n}\\n\\n\\nfunction jacCentralDiff(f, x, args=[], eps=4.7e-6) {\\n\\t\\n\\tlet xPlus = deepCopy(x);\\n\\tlet xMinus = deepCopy(x);\\n\\n\\t\\n\\tlet fOfx = f(x, ...args);\\n\\tlet m = fOfx.length;\\n\\n\\t\\n\\tlet n = x.length;\\n\\n\\t\\n\\tlet J = zeros(m, n);\\n\\n\\t\\n\\tlet fOfxPlus;\\n\\tlet fOfxMinus;\\n\\n\\tfor (let j = 0; j &lt; n; j++) {\\n\\t\\txPlus[j] += eps;\\n\\t\\txMinus[j] -= eps;\\n\\t\\tfOfxPlus = f(xPlus, ...args);\\n\\t\\tfOfxMinus = f(xMinus, ...args);\\n\\t\\txPlus[j] -= eps;\\n\\t\\txMinus[j] += eps;\\n\\n\\t\\tfor (let i = 0; i &lt; m; i++) {\\n\\t\\t\\tJ[i][j] = (fOfxPlus[i] - fOfxMinus[i]) / 2.0 / eps;\\n\\t\\t}\\n\\t}\\n\\n\\treturn J;\\n}\\n\\n\\nfunction dot(v1, v2) {\\n  const n = v1.length;\\n  let result = 0.0;\\n  for (let i = 0; i &lt; n; i++) result += v1[i] * v2[i];\\n\\n  return result;\\n}\\n\\n\\nfunction zeros(...dims) {\\n  let A = [];\\n\\n  \\n  for (let i = dims.length - 1; i &gt;= 0; i--) {\\n    let size = dims[i];\\n    if (i === dims.length - 1) {\\n      \\n      A = new Array(size).fill(0.0);\\n    } else {\\n      \\n      A = new Array(size).fill().map(() =&gt; deepCopy(A));\\n    }\\n  }\\n\\n  return A;\\n}\\n\\n\\nfunction svMult(a, v) {\\n  return v.map(x =&gt; a * x);\\n}\\n\\n\\nfunction quadForm(A, x) {\\n   return dot(x, mvMult(A, x)); \\n}\\n\\n\\nfunction solvePosDef(A, b) {\\n  let [L, p, success] = modifiedCholesky(A);\\n\\n  if (!success) {\\n    return [zeros(b.length), success];\\n  }\\n\\n  return [modifiedCholeskySolve(L, p, b), success];\\n}\\n\\n\\nfunction modifiedCholesky(A) {\\n    const floatEps = 1.0e-14;\\n    const n = A.length;\\n\\n    \\n    let L = deepCopy(A); \\n    let p = arange(0, n);\\n\\n    \\n    let success = true;\\n\\n    let xi = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        for (let j = 0; j &lt; i; j++) {\\n            let temp = Math.abs(L[i][j]);\\n            xi = Math.max(xi, temp);\\n        }\\n    }\\n\\n    let eta = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        let temp = Math.abs(L[i][i]);\\n        eta = Math.max(eta, temp);\\n    }\\n\\n    let beta;\\n    if (n &gt; 1) {\\n        beta = Math.sqrt(Math.max(eta, xi / Math.sqrt(n * n - 1)));\\n    } else {\\n        beta = Math.sqrt(eta);\\n    }\\n    beta = Math.max(beta, floatEps);\\n\\n    for (let k = 0; k &lt; n; k++) {\\n        \\n        let muVal = L[k][k];\\n        let mu = k;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            let temp = L[i][i];\\n            if (muVal &lt; temp) {\\n                mu = i;\\n                muVal = temp;\\n            }\\n        }\\n\\n        \\n        let iTemp = p[mu];\\n        p[mu] = p[k];\\n        p[k] = iTemp;\\n\\n        for (let i = 0; i &lt; k; i++) {\\n            let temp = L[k][i];\\n            L[k][i] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        let temp = L[k][k];\\n        L[k][k] = L[mu][mu];\\n        L[mu][mu] = temp;\\n        for (let i = k + 1; i &lt; mu; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        for (let i = mu + 1; i &lt; n; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[i][mu];\\n            L[i][mu] = temp;\\n        }\\n\\n        \\n        let cSum = 0;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            cSum = Math.max(cSum, Math.abs(L[i][k]));\\n        }\\n        cSum /= beta;\\n        cSum = cSum * cSum;\\n\\n        \\n        if (L[k][k] &lt; 0) {\\n            success = false;\\n        }\\n\\n        temp = Math.abs(L[k][k]);\\n        temp = Math.max(temp, floatEps * eta);\\n        temp = Math.max(temp, cSum);\\n        L[k][k] = Math.sqrt(temp);\\n\\n        \\n        for (let i = k + 1; i &lt; n; i++) {\\n            L[i][k] /= L[k][k];\\n        }\\n\\n        \\n        for (let j = k + 1; j &lt; n; j++) {\\n            for (let i = j; i &lt; n; i++) {\\n                L[i][j] -= L[i][k] * L[j][k];\\n            }\\n        }\\n\\n        \\n        for (let i = 0; i &lt; n - 1; i++) {\\n            for (let j = i + 1; j &lt; n; j++) {\\n                L[i][j] = 0.0;\\n            }\\n        }\\n    }\\n\\n    return [L, p, success];\\n}\\n\\n\\nfunction modifiedCholeskySolve(L, p, b) {\\n    const n = L.length;\\n\\n    let U = transpose(L);\\n    let xp = new Array(n).fill(0);\\n    for (let i = 0; i &lt; n; i++) {\\n        xp[i] = b[p[i]];\\n    }\\n\\n    \\n    let x = lowerTriSolve(L, xp);\\n\\n    \\n    xp = upperTriSolve(U, x);\\n\\n    for (let i = 0; i &lt; n; i++) {\\n        x[p[i]] = xp[i];\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction lowerTriSolve(L, b) {\\n    const floatEps = 1.0e-14;\\n    const n = L.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = 0; j &lt; n - 1; j++) {\\n        if (Math.abs(L[j][j]) &gt; floatEps) {\\n            x[j] /= L[j][j];\\n            for (let i = j + 1; i &lt; n; i++) {\\n                x[i] -= x[j] * L[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(L[n - 1][n - 1]) &gt; floatEps) {\\n            x[n - 1] /= L[n - 1][n - 1];\\n        } else {\\n            x[n - 1] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction upperTriSolve(U, b) {\\n    const floatEps = 1.0e-14;\\n    const n = U.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = n - 1; j &gt; 0; j--) {\\n        if (Math.abs(U[j][j]) &gt; floatEps) {\\n            x[j] /= U[j][j];\\n            for (let i = 0; i &lt; j; i++) {\\n                x[i] -= x[j] * U[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(U[0][0]) &gt; floatEps) {\\n            x[0] /= U[0][0];\\n        } else {\\n            x[0] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nclass InverseGaussianDistribution extends ContinuousUnivariateDistribution {\\n  \\n  \\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;InverseGaussian&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0.0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u00b5&#x27;, &#x27;\\u03bb&#x27;];\\n\\n    \\n    this.locationParam = undefined;\\n\\n    \\n    this.paramMin = [0.0, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds();\\n\\n    \\n    super.generateLocationParamIndex();\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    return 0.0;    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    if (x &lt; 0) return NaN;\\n    if (x === 0 || x === Infinity) return 0.0;  \\n\\n    let [mu, lambda] = params.slice(0, 2);\\n\\n    let lnProb;\\n    lnProb = -Math.log(2.0 * Math.PI) / 2.0 + (Math.log(lambda) - 3.0 * Math.log(x)) / 2.0\\n             - lambda * Math.pow(x - mu, 2) / (2.0 * Math.pow(mu, 2) * x);\\n\\n    return Math.exp(lnProb);\\n  }\\n\\n  cdfSingleValue(x, params, parametrization = this.parametrization) {\\n    if (x &lt;= 0) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let [mu, lambda] = params.slice(0, 2);\\n\\n    let term1 = lnStdNormCdf(Math.sqrt(lambda / x) * (x / mu - 1.0));\\n    let term2 = 2.0 * lambda / mu + lnStdNormCdf(-Math.sqrt(lambda / x) * (x / mu + 1.0));\\n\\n    return Math.exp(logSumExp(term1, term2));\\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n    if (p == 0) return 0.0;\\n    if (p == 1) return Infinity;\\n\\n    let [mu, lambda] = params.slice(0, 2);\\n\\n    \\n    let xMode = mu * (Math.sqrt(1.0 + 2.25 * Math.pow(mu, 2) / Math.pow(lambda, 2)) - 1.5 * mu / lambda);\\n\\n    \\n    let f;\\n    let df;\\n    if (p &lt; this.cdfSingleValue(xMode, params, parametrization)) {\\n      f = (x, params, p) =&gt; this.cdfSingleValue(x, params, parametrization) - p;\\n      df = (x, params, p) =&gt; this.pdfSingleValue(x, params, parametrization);\\n    }\\n    else {\\n      f = (x, params, p) =&gt; p - this.cdfSingleValue(x, params, parametrization);\\n      df = (x, params, p) =&gt; -this.pdfSingleValue(x, params, parametrization);\\n    }\\n\\n    return newtonSolve(xMode, f, df, [params, p]);\\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n    let [x1, x2] = this.ppf([0.01, 0.99], params);\\n\\n    \\n    if (x1 &lt; (x2 - x1) / 10.0) x1 = 0.0;\\n\\n    return [x1, x2];    \\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    \\n    let x1Rescaled = x1 / x2;\\n    let x2Rescaled = 1.0;\\n\\n    \\n    const quantileRootFun = (params, x1, p1, x2, p2) =&gt; {\\n      let mu = Math.exp(params[0]);\\n      let lambda = Math.exp(params[1]);\\n\\n      let r1 = this.cdfSingleValue(x1, [mu, lambda]) - p1;\\n      let r2 = this.cdfSingleValue(x2, [mu, lambda]) - p2;\\n\\n      return [r1, r2];\\n    };\\n\\n    let args = [x1Rescaled, p1, x2Rescaled, p2];\\n\\n    let guess = [2, 2];\\n\\n    let [logParams, optimSuccess] = findRootTrustRegion(quantileRootFun, guess, args=args);\\n\\n    \\n    let paramsOpt = [Math.exp(logParams[0]), Math.exp(logParams[1])];\\n\\n    \\n    return [[x2 * paramsOpt[0], x2 * paramsOpt[1]], optimSuccess];\\n  }\\n}\\n\\n\\n\\nvar dist = new InverseGaussianDistribution();\\n\\n\\n\\nlet params = paramsFromSliders(sliders); \\n\\n\\nlet [x1, x2] = dist.defaultXRange(params);\\n\\n\\ntriggerCallbacks.active = false;\\n\\n\\np_p.x_range.start = x1;\\np_p.x_range.end = x2;\\n\\nupdateData(source_p, source_c, p_p, sliders, discrete);\\n\\n\\nsetYRanges(p_p, p_c, source_p);  \\n\\ntriggerCallbacks.active = true;\\n"}}]]]},"x_range":{"id":"p2781"},"y_range":{"type":"object","name":"Range1d","id":"p2782"},"x_scale":{"type":"object","name":"LinearScale","id":"p2767"},"y_scale":{"type":"object","name":"LinearScale","id":"p2768"},"title":{"type":"object","name":"Title","id":"p2760","attributes":{"text":" "}},"renderers":[{"type":"object","name":"GlyphRenderer","id":"p2795","attributes":{"level":"overlay","data_source":{"id":"p2786"},"view":{"type":"object","name":"CDSView","id":"p2796","attributes":{"filter":{"type":"object","name":"AllIndices","id":"p2797"}}},"glyph":{"type":"object","name":"Line","id":"p2792","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_width":2}},"nonselection_glyph":{"type":"object","name":"Line","id":"p2793","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_alpha":0.1,"line_width":2}},"muted_glyph":{"type":"object","name":"Line","id":"p2794","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_alpha":0.2,"line_width":2}}}}],"toolbar":{"type":"object","name":"Toolbar","id":"p2766","attributes":{"tools":[{"type":"object","name":"ResetTool","id":"p2779"},{"type":"object","name":"SaveTool","id":"p2780"}]}},"toolbar_location":null,"left":[{"type":"object","name":"LinearAxis","id":"p2774","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p2775","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p2776"},"axis_label":"CDF","axis_label_text_font_style":"normal","major_label_policy":{"type":"object","name":"AllLabels","id":"p2777"}}}],"below":[{"type":"object","name":"LinearAxis","id":"p2769","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p2770","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p2771"},"axis_label":"y","major_label_policy":{"type":"object","name":"AllLabels","id":"p2772"}}}],"center":[{"type":"object","name":"Grid","id":"p2773","attributes":{"axis":{"id":"p2769"}}},{"type":"object","name":"Grid","id":"p2778","attributes":{"dimension":1,"axis":{"id":"p2774"}}}],"frame_width":300,"frame_height":175,"background_fill_alpha":0,"border_fill_alpha":0}}],["source_p",{"id":"p2783"}],["source_c",{"id":"p2786"}],["discrete",false],["n",400],["sliders",[{"id":"p2808"},{"id":"p2810"}]],["xBoxes",[{"id":"p2815"},{"id":"p2816"}]],["pBoxes",[{"id":"p2817"},{"id":"p2818"}]],["quantileSetterSwitch",{"id":"p2820"}],["quantileSetterDiv",{"id":"p2819"}],["triggerCallbacks",{"id":"p2821"}],["startBoxes",[{"id":"p2811"},{"id":"p2812"}]],["endBoxes",[{"id":"p2813"},{"id":"p2814"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nfunction logSumExp(x1, x2) {\\n  if (x1 &gt; x2) {\\n    return x1 + log1p(Math.exp(x2 - x1));\\n  }\\n  else {\\n    return x2 + log1p(Math.exp(x1 - x2));\\n  }\\n}\\n\\n\\nfunction lnStdNormCdf(x) {\\n  \\n  let y = x / 1.4142135623730950488016887;\\n\\n  let res;\\n  \\n  if (y &gt; 0.0) {\\n    res = log1p(-0.5 * erfc(y));\\n  } \\n  else if (y &gt; -20.0) {\\n    \\n    res = Math.log(erfc(-y)) - 0.6931471805599453;\\n  }\\n  else {\\n    \\n    const y2 = Math.pow(y, 2);\\n    const y4 = Math.pow(y, 4);\\n    const y6 = Math.pow(y, 6);\\n    const y8 = Math.pow(y, 8);\\n    const y10 = Math.pow(y, 10);\\n    const temp_p = 0.000658749161529837803157 + 0.0160837851487422766278 / y2\\n                 + 0.125781726111229246204 / y4 + 0.360344899949804439429 / y6\\n                 + 0.305326634961232344035 / y8 + 0.0163153871373020978498 / y10;\\n    const temp_q = -0.00233520497626869185443 - 0.0605183413124413191178 / y2\\n                   - 0.527905102951428412248 / y4 - 1.87295284992346047209 / y6\\n                   - 2.56852019228982242072 / y8 - 1.0 / y10;\\n    res = -0.6931471805599453 + Math.log(0.5641895835477563 + (temp_p / temp_q) / y2) - Math.log(-y) - y2;\\n  }\\n\\n  if (isNaN(res)) {\\n    return -Infinity;\\n  }\\n  else {\\n    return res;\\n  }\\n}\\n\\n\\nfunction findRootTrustRegion(\\n\\t\\tf, \\n\\t\\tx0, \\n\\t\\targs=[],\\n\\t\\tjac=jacCentralDiff,\\n\\t\\ttol=0.000000001, \\n\\t\\tmaxIters=10000, \\n\\t\\tdeltaBar=1000.0, \\n\\t\\teta=0.125, \\n\\t\\tminDelta=1e-12\\n  ) {\\n\\t\\n\\tlet x = deepCopy(x0);\\n\\n\\t\\n\\tlet delta = 0.99 * deltaBar;\\n\\n\\t\\n\\tlet r = f(x, ...args);\\n\\n\\t\\n\\tlet J = jac(f, x, args);\\n\\n\\t\\n\\tlet JTJ = mmMult(transpose(J), J);\\n\\n\\t\\n\\tlet JTr = mvMult(transpose(J), r);\\n\\n\\t\\n\\tlet normJTr = norm(JTr);\\n\\n\\tlet iters = 0;\\n\\twhile (iters &lt; maxIters &amp;&amp; checkTol(r, tol) &amp;&amp; delta &gt;= minDelta) {\\n\\t\\t\\n\\t\\tlet p = doglegStep(JTJ, JTr, normJTr, delta);\\n\\n\\t\\t\\n\\t\\tlet newr = f(vectorAdd(x, p), ...args);\\n\\t\\tlet rho = computeRho(r, newr, J, p);\\n\\n\\t\\t\\n\\t\\tif  (rho &lt; 0.25) {\\n\\t\\t\\tdelta = norm(p) / 4.0;\\n\\t\\t} else if (rho &gt; 0.75 &amp;&amp; Math.abs(norm(p) - delta) &lt; 1e-12) {\\n\\t\\t\\t\\tdelta = Math.min(2 * delta, deltaBar);\\n\\t\\t}\\n\\n\\t\\t\\n\\t\\tif (rho &gt; eta) {\\n\\t\\t\\tx = vectorAdd(x, p);\\n\\n\\t\\t\\tr = newr;\\n\\t\\t\\tJ = jac(f, x, args);\\n\\t\\t\\tJTJ = mmMult(transpose(J), J);\\n\\t\\t\\tJTr = mvMult(transpose(J), r);\\n\\t\\t\\tnormJTr = norm(JTr);\\n\\t\\t}\\n\\n\\t\\titers += 1;\\n\\t}\\n\\n\\tlet success = !checkTol(r, tol);\\n\\n\\treturn [x, success];\\n\\n}\\n\\n\\nfunction newtonSolve(x0, f, df, args=[], tol=1e-8, maxIter=200, epsilon=1e-14) {\\n\\tlet x = Infinity;\\n\\tlet solved = false;\\n\\n  for (let i = 0; i &lt; maxIter; i++) {\\n      let y = f(x0, ...args);\\n      let yprime = df(x0, ...args);\\n\\n      if (Math.abs(yprime) &lt; epsilon) {\\n      \\tbreak;\\n\\t\\t\\t}\\n\\n      x = x0 - y / yprime;\\n\\n      if (Math.abs(x - x0) &lt;= tol) {\\n      \\tsolved = true;\\n      \\tbreak;\\n      }\\n\\n      x0 = x;\\n  }\\n\\n  if (solved) return x;\\n  else return null;\\n}\\n\\n\\nfunction log1p(x) {\\n  \\n  \\n  if (x &lt;= -1.0) {\\n    throw new RangeError(&#x27;Argument must be greater than -1.0&#x27;);\\n  }\\n\\n  \\n  else if (Math.abs(x) &gt; 1e-4) {\\n    return Math.log(1.0 + x);\\n  }\\n\\n  else {\\n    return (-0.5*x + 1.0)*x;\\n  }\\n}\\n\\n\\nfunction erfc(x) {\\n  let y2 = Math.pow(x, 2);\\n  let y = x &lt; 0 ? -x : x;\\n  const term1 = 0.56418958354775629 / (y + 2.06955023132914151);\\n  \\n  const term2 = (y**2 + 2.71078540045147805 * y + 5.80755613130301624) / \\n                (y**2 + 3.47954057099518960 * y + 12.06166887286239555);\\n\\n  const term3 = (y**2 + 3.47469513777439592 * y + 12.07402036406381411) / \\n                (y**2 + 3.72068443960225092 * y + 8.44319781003968454);\\n\\n  const term4 = (y**2 + 4.00561509202259545 * y + 9.30596659485887898) / \\n                (y**2 + 3.90225704029924078 * y + 6.36161630953880464);\\n\\n  const term5 = (y**2 + 5.16722705817812584 * y + 9.12661617673673262) / \\n                (y**2 + 4.03296893109262491 * y + 5.13578530585681539);\\n\\n  const term6 = (y**2 + 5.95908795446633271 * y + 9.19435612886969243) / \\n                (y**2 + 4.11240942957450885 * y + 4.48640329523408675);\\n\\n  const expTerm = Math.exp(-Math.pow(x,2));\\n\\n  let res = term1 * term2 * term3 * term4 * term5 * term6 * expTerm;\\n\\n  return x &lt; 0 ? 2.0 - res : res;\\n}\\n\\n\\nfunction transpose(A) {\\n    return A[0].map((_, colIndex) =&gt; A.map(row =&gt; row[colIndex]));\\n}\\n\\n\\nfunction mvMult(A, v) {\\n  return A.map(Arow =&gt; dot(Arow, v));\\n}\\n\\n\\nfunction mmMult(A, B) {\\n  let mA = A.length;\\n  let nA = A[0].length;\\n  let mB = B.length;\\n  let nB = B[0].length;\\n\\n  if (nA !== mB) {\\n      throw new Error(&#x27;Matrix dimension mismatch.&#x27;);\\n  }\\n\\n  let result = zeros(mA, nB);\\n\\n  for (let i = 0; i &lt; mA; i++) {\\n    for (let j = 0; j &lt; nB; j++) {\\n      for (let k = 0; k &lt; nA; k++) {\\n        result[i][j] += A[i][k] * B[k][j];\\n      }\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction vectorAdd() {\\n  let m = arguments.length;\\n  let n = arguments[0].length;\\n \\n  let result = new Array(n).fill(0.0);\\n \\n  for (let i = 0; i &lt; n; i++) {\\n    for (let j = 0; j &lt; m; j++) {\\n        result[i] += arguments[j][i];\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction norm(v) {\\n  return Math.sqrt(dot(v, v));\\n}\\n\\n\\nfunction deepCopy(x) {\\n  return JSON.parse(JSON.stringify(x));\\n}\\n\\n\\nfunction computeRho(r, newr, J, p) {\\n\\tlet r2 = norm(r) ** 2;\\n\\tlet num = r2 - norm(newr)**2;\\n\\tlet denom = r2 - norm(vectorAdd(r, mvMult(J, p))) ** 2;\\n\\n\\treturn num / denom;\\n}\\n\\n\\nfunction checkTol(r, tol) {\\n\\t\\n\\tconst n = r.length;\\n\\tfor (let i = 0; i &lt; n; i++) {\\n\\t\\tif (tol &lt; Math.abs(r[i])) return true;\\n\\t}\\n\\n\\treturn false;\\n}\\n\\n\\nfunction doglegStep(JTJ, JTr, normJTr, delta) {\\n\\t\\n\\tlet [pJ, posDef] = solvePosDef(JTJ, JTr);\\n\\tpJ = svMult(-1.0, pJ);\\n\\n\\t\\n\\tif (posDef &amp;&amp; norm(pJ) &lt;= delta) {\\n\\t\\treturn pJ;\\n\\t}\\n\\n\\t\\n\\tlet tau = Math.min(1, normJTr**3 / delta / quadForm(JTJ, JTr));\\n\\tlet pC = svMult(-tau * delta / normJTr, JTr);\\n\\n\\tlet pCnorm = norm(pC);\\n\\tif (!posDef || Math.abs(pCnorm - delta) &lt;= 1e-12) {\\n\\t\\treturn pC;\\n\\t}\\n\\n\\t\\n\\tlet pJ2 = norm(pJ) ** 2;\\n\\tlet pC2 = pCnorm**2;\\n\\tlet pJpC = dot(pJ, pC);\\n\\tlet a = pJ2 + pC2 - 2.0 * pJpC;\\n\\tlet b = 2.0 * (pJpC - pC2);\\n\\tlet c = pC2 - delta**2;\\n\\tlet q = -0.5 * (b + Math.sign(b) * Math.sqrt(b**2 - 4.0 * a * c));\\n\\n\\t\\n\\tlet beta;\\n\\tif (Math.abs(b) &lt; 1e-12) beta = Math.sqrt(-c / a);\\n\\telse if (b &lt; 0.0) beta = q / a;\\n\\telse beta = c / q;\\n\\n\\t\\n\\tif (0.0 &lt;= beta &amp;&amp; beta &lt;= 1) {\\n\\t\\treturn vectorAdd(pC, svMult(beta, vectorAdd(pJ, svMult(-1.0, pC))));\\n\\t} else { \\n\\t\\treturn pC;\\n\\t}\\n\\n}\\n\\n\\nfunction jacCentralDiff(f, x, args=[], eps=4.7e-6) {\\n\\t\\n\\tlet xPlus = deepCopy(x);\\n\\tlet xMinus = deepCopy(x);\\n\\n\\t\\n\\tlet fOfx = f(x, ...args);\\n\\tlet m = fOfx.length;\\n\\n\\t\\n\\tlet n = x.length;\\n\\n\\t\\n\\tlet J = zeros(m, n);\\n\\n\\t\\n\\tlet fOfxPlus;\\n\\tlet fOfxMinus;\\n\\n\\tfor (let j = 0; j &lt; n; j++) {\\n\\t\\txPlus[j] += eps;\\n\\t\\txMinus[j] -= eps;\\n\\t\\tfOfxPlus = f(xPlus, ...args);\\n\\t\\tfOfxMinus = f(xMinus, ...args);\\n\\t\\txPlus[j] -= eps;\\n\\t\\txMinus[j] += eps;\\n\\n\\t\\tfor (let i = 0; i &lt; m; i++) {\\n\\t\\t\\tJ[i][j] = (fOfxPlus[i] - fOfxMinus[i]) / 2.0 / eps;\\n\\t\\t}\\n\\t}\\n\\n\\treturn J;\\n}\\n\\n\\nfunction dot(v1, v2) {\\n  const n = v1.length;\\n  let result = 0.0;\\n  for (let i = 0; i &lt; n; i++) result += v1[i] * v2[i];\\n\\n  return result;\\n}\\n\\n\\nfunction zeros(...dims) {\\n  let A = [];\\n\\n  \\n  for (let i = dims.length - 1; i &gt;= 0; i--) {\\n    let size = dims[i];\\n    if (i === dims.length - 1) {\\n      \\n      A = new Array(size).fill(0.0);\\n    } else {\\n      \\n      A = new Array(size).fill().map(() =&gt; deepCopy(A));\\n    }\\n  }\\n\\n  return A;\\n}\\n\\n\\nfunction svMult(a, v) {\\n  return v.map(x =&gt; a * x);\\n}\\n\\n\\nfunction quadForm(A, x) {\\n   return dot(x, mvMult(A, x)); \\n}\\n\\n\\nfunction solvePosDef(A, b) {\\n  let [L, p, success] = modifiedCholesky(A);\\n\\n  if (!success) {\\n    return [zeros(b.length), success];\\n  }\\n\\n  return [modifiedCholeskySolve(L, p, b), success];\\n}\\n\\n\\nfunction modifiedCholesky(A) {\\n    const floatEps = 1.0e-14;\\n    const n = A.length;\\n\\n    \\n    let L = deepCopy(A); \\n    let p = arange(0, n);\\n\\n    \\n    let success = true;\\n\\n    let xi = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        for (let j = 0; j &lt; i; j++) {\\n            let temp = Math.abs(L[i][j]);\\n            xi = Math.max(xi, temp);\\n        }\\n    }\\n\\n    let eta = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        let temp = Math.abs(L[i][i]);\\n        eta = Math.max(eta, temp);\\n    }\\n\\n    let beta;\\n    if (n &gt; 1) {\\n        beta = Math.sqrt(Math.max(eta, xi / Math.sqrt(n * n - 1)));\\n    } else {\\n        beta = Math.sqrt(eta);\\n    }\\n    beta = Math.max(beta, floatEps);\\n\\n    for (let k = 0; k &lt; n; k++) {\\n        \\n        let muVal = L[k][k];\\n        let mu = k;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            let temp = L[i][i];\\n            if (muVal &lt; temp) {\\n                mu = i;\\n                muVal = temp;\\n            }\\n        }\\n\\n        \\n        let iTemp = p[mu];\\n        p[mu] = p[k];\\n        p[k] = iTemp;\\n\\n        for (let i = 0; i &lt; k; i++) {\\n            let temp = L[k][i];\\n            L[k][i] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        let temp = L[k][k];\\n        L[k][k] = L[mu][mu];\\n        L[mu][mu] = temp;\\n        for (let i = k + 1; i &lt; mu; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        for (let i = mu + 1; i &lt; n; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[i][mu];\\n            L[i][mu] = temp;\\n        }\\n\\n        \\n        let cSum = 0;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            cSum = Math.max(cSum, Math.abs(L[i][k]));\\n        }\\n        cSum /= beta;\\n        cSum = cSum * cSum;\\n\\n        \\n        if (L[k][k] &lt; 0) {\\n            success = false;\\n        }\\n\\n        temp = Math.abs(L[k][k]);\\n        temp = Math.max(temp, floatEps * eta);\\n        temp = Math.max(temp, cSum);\\n        L[k][k] = Math.sqrt(temp);\\n\\n        \\n        for (let i = k + 1; i &lt; n; i++) {\\n            L[i][k] /= L[k][k];\\n        }\\n\\n        \\n        for (let j = k + 1; j &lt; n; j++) {\\n            for (let i = j; i &lt; n; i++) {\\n                L[i][j] -= L[i][k] * L[j][k];\\n            }\\n        }\\n\\n        \\n        for (let i = 0; i &lt; n - 1; i++) {\\n            for (let j = i + 1; j &lt; n; j++) {\\n                L[i][j] = 0.0;\\n            }\\n        }\\n    }\\n\\n    return [L, p, success];\\n}\\n\\n\\nfunction modifiedCholeskySolve(L, p, b) {\\n    const n = L.length;\\n\\n    let U = transpose(L);\\n    let xp = new Array(n).fill(0);\\n    for (let i = 0; i &lt; n; i++) {\\n        xp[i] = b[p[i]];\\n    }\\n\\n    \\n    let x = lowerTriSolve(L, xp);\\n\\n    \\n    xp = upperTriSolve(U, x);\\n\\n    for (let i = 0; i &lt; n; i++) {\\n        x[p[i]] = xp[i];\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction lowerTriSolve(L, b) {\\n    const floatEps = 1.0e-14;\\n    const n = L.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = 0; j &lt; n - 1; j++) {\\n        if (Math.abs(L[j][j]) &gt; floatEps) {\\n            x[j] /= L[j][j];\\n            for (let i = j + 1; i &lt; n; i++) {\\n                x[i] -= x[j] * L[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(L[n - 1][n - 1]) &gt; floatEps) {\\n            x[n - 1] /= L[n - 1][n - 1];\\n        } else {\\n            x[n - 1] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction upperTriSolve(U, b) {\\n    const floatEps = 1.0e-14;\\n    const n = U.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = n - 1; j &gt; 0; j--) {\\n        if (Math.abs(U[j][j]) &gt; floatEps) {\\n            x[j] /= U[j][j];\\n            for (let i = 0; i &lt; j; i++) {\\n                x[i] -= x[j] * U[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(U[0][0]) &gt; floatEps) {\\n            x[0] /= U[0][0];\\n        } else {\\n            x[0] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nclass InverseGaussianDistribution extends ContinuousUnivariateDistribution {\\n  \\n  \\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;InverseGaussian&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0.0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u00b5&#x27;, &#x27;\\u03bb&#x27;];\\n\\n    \\n    this.locationParam = undefined;\\n\\n    \\n    this.paramMin = [0.0, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds();\\n\\n    \\n    super.generateLocationParamIndex();\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    return 0.0;    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    if (x &lt; 0) return NaN;\\n    if (x === 0 || x === Infinity) return 0.0;  \\n\\n    let [mu, lambda] = params.slice(0, 2);\\n\\n    let lnProb;\\n    lnProb = -Math.log(2.0 * Math.PI) / 2.0 + (Math.log(lambda) - 3.0 * Math.log(x)) / 2.0\\n             - lambda * Math.pow(x - mu, 2) / (2.0 * Math.pow(mu, 2) * x);\\n\\n    return Math.exp(lnProb);\\n  }\\n\\n  cdfSingleValue(x, params, parametrization = this.parametrization) {\\n    if (x &lt;= 0) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let [mu, lambda] = params.slice(0, 2);\\n\\n    let term1 = lnStdNormCdf(Math.sqrt(lambda / x) * (x / mu - 1.0));\\n    let term2 = 2.0 * lambda / mu + lnStdNormCdf(-Math.sqrt(lambda / x) * (x / mu + 1.0));\\n\\n    return Math.exp(logSumExp(term1, term2));\\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n    if (p == 0) return 0.0;\\n    if (p == 1) return Infinity;\\n\\n    let [mu, lambda] = params.slice(0, 2);\\n\\n    \\n    let xMode = mu * (Math.sqrt(1.0 + 2.25 * Math.pow(mu, 2) / Math.pow(lambda, 2)) - 1.5 * mu / lambda);\\n\\n    \\n    let f;\\n    let df;\\n    if (p &lt; this.cdfSingleValue(xMode, params, parametrization)) {\\n      f = (x, params, p) =&gt; this.cdfSingleValue(x, params, parametrization) - p;\\n      df = (x, params, p) =&gt; this.pdfSingleValue(x, params, parametrization);\\n    }\\n    else {\\n      f = (x, params, p) =&gt; p - this.cdfSingleValue(x, params, parametrization);\\n      df = (x, params, p) =&gt; -this.pdfSingleValue(x, params, parametrization);\\n    }\\n\\n    return newtonSolve(xMode, f, df, [params, p]);\\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n    let [x1, x2] = this.ppf([0.01, 0.99], params);\\n\\n    \\n    if (x1 &lt; (x2 - x1) / 10.0) x1 = 0.0;\\n\\n    return [x1, x2];    \\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    \\n    let x1Rescaled = x1 / x2;\\n    let x2Rescaled = 1.0;\\n\\n    \\n    const quantileRootFun = (params, x1, p1, x2, p2) =&gt; {\\n      let mu = Math.exp(params[0]);\\n      let lambda = Math.exp(params[1]);\\n\\n      let r1 = this.cdfSingleValue(x1, [mu, lambda]) - p1;\\n      let r2 = this.cdfSingleValue(x2, [mu, lambda]) - p2;\\n\\n      return [r1, r2];\\n    };\\n\\n    let args = [x1Rescaled, p1, x2Rescaled, p2];\\n\\n    let guess = [2, 2];\\n\\n    let [logParams, optimSuccess] = findRootTrustRegion(quantileRootFun, guess, args=args);\\n\\n    \\n    let paramsOpt = [Math.exp(logParams[0]), Math.exp(logParams[1])];\\n\\n    \\n    return [[x2 * paramsOpt[0], x2 * paramsOpt[1]], optimSuccess];\\n  }\\n}\\n\\n\\n\\nvar dist = new InverseGaussianDistribution();\\n\\n\\nif (triggerCallbacks.active) {\\n  updateData(source_p, source_c, p_p, sliders, discrete);\\n}"}}]],["change:end",[{"id":"p2823"}]]]},"end":50}},"y_range":{"type":"object","name":"DataRange1d","id":"p2735","attributes":{"start":0.0}},"x_scale":{"type":"object","name":"LinearScale","id":"p2743"},"y_scale":{"type":"object","name":"LinearScale","id":"p2744"},"title":{"type":"object","name":"Title","id":"p2736","attributes":{"text":"Inverse Gaussian"}},"renderers":[{"type":"object","name":"GlyphRenderer","id":"p2804","attributes":{"level":"overlay","data_source":{"id":"p2783"},"view":{"type":"object","name":"CDSView","id":"p2805","attributes":{"filter":{"type":"object","name":"AllIndices","id":"p2806"}}},"glyph":{"type":"object","name":"Line","id":"p2801","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"line_color":"#1f77b4","line_width":2}},"nonselection_glyph":{"type":"object","name":"Line","id":"p2802","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"line_color":"#1f77b4","line_alpha":0.1,"line_width":2}},"muted_glyph":{"type":"object","name":"Line","id":"p2803","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"line_color":"#1f77b4","line_alpha":0.2,"line_width":2}}}}],"toolbar":{"type":"object","name":"Toolbar","id":"p2742","attributes":{"tools":[{"type":"object","name":"ResetTool","id":"p2755"},{"type":"object","name":"SaveTool","id":"p2756"}]}},"toolbar_location":null,"left":[{"type":"object","name":"LinearAxis","id":"p2750","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p2751","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p2752"},"axis_label":"PDF","axis_label_text_font_style":"normal","major_label_policy":{"type":"object","name":"AllLabels","id":"p2753"}}}],"below":[{"type":"object","name":"LinearAxis","id":"p2745","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p2746","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p2747"},"axis_label":"y","major_label_policy":{"type":"object","name":"AllLabels","id":"p2748"}}}],"center":[{"type":"object","name":"Grid","id":"p2749","attributes":{"axis":{"id":"p2745"}}},{"type":"object","name":"Grid","id":"p2754","attributes":{"dimension":1,"axis":{"id":"p2750"}}}],"frame_width":300,"frame_height":175,"background_fill_alpha":0,"border_fill_alpha":0}}],["p_c",{"id":"p2757"}],["source_p",{"id":"p2783"}],["source_c",{"id":"p2786"}],["discrete",false],["n",400],["sliders",[{"id":"p2808"},{"id":"p2810"}]],["xBoxes",[{"id":"p2815"},{"id":"p2816"}]],["pBoxes",[{"id":"p2817"},{"id":"p2818"}]],["quantileSetterSwitch",{"id":"p2820"}],["quantileSetterDiv",{"id":"p2819"}],["triggerCallbacks",{"id":"p2821"}],["startBoxes",[{"id":"p2811"},{"id":"p2812"}]],["endBoxes",[{"id":"p2813"},{"id":"p2814"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nfunction logSumExp(x1, x2) {\\n  if (x1 &gt; x2) {\\n    return x1 + log1p(Math.exp(x2 - x1));\\n  }\\n  else {\\n    return x2 + log1p(Math.exp(x1 - x2));\\n  }\\n}\\n\\n\\nfunction lnStdNormCdf(x) {\\n  \\n  let y = x / 1.4142135623730950488016887;\\n\\n  let res;\\n  \\n  if (y &gt; 0.0) {\\n    res = log1p(-0.5 * erfc(y));\\n  } \\n  else if (y &gt; -20.0) {\\n    \\n    res = Math.log(erfc(-y)) - 0.6931471805599453;\\n  }\\n  else {\\n    \\n    const y2 = Math.pow(y, 2);\\n    const y4 = Math.pow(y, 4);\\n    const y6 = Math.pow(y, 6);\\n    const y8 = Math.pow(y, 8);\\n    const y10 = Math.pow(y, 10);\\n    const temp_p = 0.000658749161529837803157 + 0.0160837851487422766278 / y2\\n                 + 0.125781726111229246204 / y4 + 0.360344899949804439429 / y6\\n                 + 0.305326634961232344035 / y8 + 0.0163153871373020978498 / y10;\\n    const temp_q = -0.00233520497626869185443 - 0.0605183413124413191178 / y2\\n                   - 0.527905102951428412248 / y4 - 1.87295284992346047209 / y6\\n                   - 2.56852019228982242072 / y8 - 1.0 / y10;\\n    res = -0.6931471805599453 + Math.log(0.5641895835477563 + (temp_p / temp_q) / y2) - Math.log(-y) - y2;\\n  }\\n\\n  if (isNaN(res)) {\\n    return -Infinity;\\n  }\\n  else {\\n    return res;\\n  }\\n}\\n\\n\\nfunction findRootTrustRegion(\\n\\t\\tf, \\n\\t\\tx0, \\n\\t\\targs=[],\\n\\t\\tjac=jacCentralDiff,\\n\\t\\ttol=0.000000001, \\n\\t\\tmaxIters=10000, \\n\\t\\tdeltaBar=1000.0, \\n\\t\\teta=0.125, \\n\\t\\tminDelta=1e-12\\n  ) {\\n\\t\\n\\tlet x = deepCopy(x0);\\n\\n\\t\\n\\tlet delta = 0.99 * deltaBar;\\n\\n\\t\\n\\tlet r = f(x, ...args);\\n\\n\\t\\n\\tlet J = jac(f, x, args);\\n\\n\\t\\n\\tlet JTJ = mmMult(transpose(J), J);\\n\\n\\t\\n\\tlet JTr = mvMult(transpose(J), r);\\n\\n\\t\\n\\tlet normJTr = norm(JTr);\\n\\n\\tlet iters = 0;\\n\\twhile (iters &lt; maxIters &amp;&amp; checkTol(r, tol) &amp;&amp; delta &gt;= minDelta) {\\n\\t\\t\\n\\t\\tlet p = doglegStep(JTJ, JTr, normJTr, delta);\\n\\n\\t\\t\\n\\t\\tlet newr = f(vectorAdd(x, p), ...args);\\n\\t\\tlet rho = computeRho(r, newr, J, p);\\n\\n\\t\\t\\n\\t\\tif  (rho &lt; 0.25) {\\n\\t\\t\\tdelta = norm(p) / 4.0;\\n\\t\\t} else if (rho &gt; 0.75 &amp;&amp; Math.abs(norm(p) - delta) &lt; 1e-12) {\\n\\t\\t\\t\\tdelta = Math.min(2 * delta, deltaBar);\\n\\t\\t}\\n\\n\\t\\t\\n\\t\\tif (rho &gt; eta) {\\n\\t\\t\\tx = vectorAdd(x, p);\\n\\n\\t\\t\\tr = newr;\\n\\t\\t\\tJ = jac(f, x, args);\\n\\t\\t\\tJTJ = mmMult(transpose(J), J);\\n\\t\\t\\tJTr = mvMult(transpose(J), r);\\n\\t\\t\\tnormJTr = norm(JTr);\\n\\t\\t}\\n\\n\\t\\titers += 1;\\n\\t}\\n\\n\\tlet success = !checkTol(r, tol);\\n\\n\\treturn [x, success];\\n\\n}\\n\\n\\nfunction newtonSolve(x0, f, df, args=[], tol=1e-8, maxIter=200, epsilon=1e-14) {\\n\\tlet x = Infinity;\\n\\tlet solved = false;\\n\\n  for (let i = 0; i &lt; maxIter; i++) {\\n      let y = f(x0, ...args);\\n      let yprime = df(x0, ...args);\\n\\n      if (Math.abs(yprime) &lt; epsilon) {\\n      \\tbreak;\\n\\t\\t\\t}\\n\\n      x = x0 - y / yprime;\\n\\n      if (Math.abs(x - x0) &lt;= tol) {\\n      \\tsolved = true;\\n      \\tbreak;\\n      }\\n\\n      x0 = x;\\n  }\\n\\n  if (solved) return x;\\n  else return null;\\n}\\n\\n\\nfunction log1p(x) {\\n  \\n  \\n  if (x &lt;= -1.0) {\\n    throw new RangeError(&#x27;Argument must be greater than -1.0&#x27;);\\n  }\\n\\n  \\n  else if (Math.abs(x) &gt; 1e-4) {\\n    return Math.log(1.0 + x);\\n  }\\n\\n  else {\\n    return (-0.5*x + 1.0)*x;\\n  }\\n}\\n\\n\\nfunction erfc(x) {\\n  let y2 = Math.pow(x, 2);\\n  let y = x &lt; 0 ? -x : x;\\n  const term1 = 0.56418958354775629 / (y + 2.06955023132914151);\\n  \\n  const term2 = (y**2 + 2.71078540045147805 * y + 5.80755613130301624) / \\n                (y**2 + 3.47954057099518960 * y + 12.06166887286239555);\\n\\n  const term3 = (y**2 + 3.47469513777439592 * y + 12.07402036406381411) / \\n                (y**2 + 3.72068443960225092 * y + 8.44319781003968454);\\n\\n  const term4 = (y**2 + 4.00561509202259545 * y + 9.30596659485887898) / \\n                (y**2 + 3.90225704029924078 * y + 6.36161630953880464);\\n\\n  const term5 = (y**2 + 5.16722705817812584 * y + 9.12661617673673262) / \\n                (y**2 + 4.03296893109262491 * y + 5.13578530585681539);\\n\\n  const term6 = (y**2 + 5.95908795446633271 * y + 9.19435612886969243) / \\n                (y**2 + 4.11240942957450885 * y + 4.48640329523408675);\\n\\n  const expTerm = Math.exp(-Math.pow(x,2));\\n\\n  let res = term1 * term2 * term3 * term4 * term5 * term6 * expTerm;\\n\\n  return x &lt; 0 ? 2.0 - res : res;\\n}\\n\\n\\nfunction transpose(A) {\\n    return A[0].map((_, colIndex) =&gt; A.map(row =&gt; row[colIndex]));\\n}\\n\\n\\nfunction mvMult(A, v) {\\n  return A.map(Arow =&gt; dot(Arow, v));\\n}\\n\\n\\nfunction mmMult(A, B) {\\n  let mA = A.length;\\n  let nA = A[0].length;\\n  let mB = B.length;\\n  let nB = B[0].length;\\n\\n  if (nA !== mB) {\\n      throw new Error(&#x27;Matrix dimension mismatch.&#x27;);\\n  }\\n\\n  let result = zeros(mA, nB);\\n\\n  for (let i = 0; i &lt; mA; i++) {\\n    for (let j = 0; j &lt; nB; j++) {\\n      for (let k = 0; k &lt; nA; k++) {\\n        result[i][j] += A[i][k] * B[k][j];\\n      }\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction vectorAdd() {\\n  let m = arguments.length;\\n  let n = arguments[0].length;\\n \\n  let result = new Array(n).fill(0.0);\\n \\n  for (let i = 0; i &lt; n; i++) {\\n    for (let j = 0; j &lt; m; j++) {\\n        result[i] += arguments[j][i];\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction norm(v) {\\n  return Math.sqrt(dot(v, v));\\n}\\n\\n\\nfunction deepCopy(x) {\\n  return JSON.parse(JSON.stringify(x));\\n}\\n\\n\\nfunction computeRho(r, newr, J, p) {\\n\\tlet r2 = norm(r) ** 2;\\n\\tlet num = r2 - norm(newr)**2;\\n\\tlet denom = r2 - norm(vectorAdd(r, mvMult(J, p))) ** 2;\\n\\n\\treturn num / denom;\\n}\\n\\n\\nfunction checkTol(r, tol) {\\n\\t\\n\\tconst n = r.length;\\n\\tfor (let i = 0; i &lt; n; i++) {\\n\\t\\tif (tol &lt; Math.abs(r[i])) return true;\\n\\t}\\n\\n\\treturn false;\\n}\\n\\n\\nfunction doglegStep(JTJ, JTr, normJTr, delta) {\\n\\t\\n\\tlet [pJ, posDef] = solvePosDef(JTJ, JTr);\\n\\tpJ = svMult(-1.0, pJ);\\n\\n\\t\\n\\tif (posDef &amp;&amp; norm(pJ) &lt;= delta) {\\n\\t\\treturn pJ;\\n\\t}\\n\\n\\t\\n\\tlet tau = Math.min(1, normJTr**3 / delta / quadForm(JTJ, JTr));\\n\\tlet pC = svMult(-tau * delta / normJTr, JTr);\\n\\n\\tlet pCnorm = norm(pC);\\n\\tif (!posDef || Math.abs(pCnorm - delta) &lt;= 1e-12) {\\n\\t\\treturn pC;\\n\\t}\\n\\n\\t\\n\\tlet pJ2 = norm(pJ) ** 2;\\n\\tlet pC2 = pCnorm**2;\\n\\tlet pJpC = dot(pJ, pC);\\n\\tlet a = pJ2 + pC2 - 2.0 * pJpC;\\n\\tlet b = 2.0 * (pJpC - pC2);\\n\\tlet c = pC2 - delta**2;\\n\\tlet q = -0.5 * (b + Math.sign(b) * Math.sqrt(b**2 - 4.0 * a * c));\\n\\n\\t\\n\\tlet beta;\\n\\tif (Math.abs(b) &lt; 1e-12) beta = Math.sqrt(-c / a);\\n\\telse if (b &lt; 0.0) beta = q / a;\\n\\telse beta = c / q;\\n\\n\\t\\n\\tif (0.0 &lt;= beta &amp;&amp; beta &lt;= 1) {\\n\\t\\treturn vectorAdd(pC, svMult(beta, vectorAdd(pJ, svMult(-1.0, pC))));\\n\\t} else { \\n\\t\\treturn pC;\\n\\t}\\n\\n}\\n\\n\\nfunction jacCentralDiff(f, x, args=[], eps=4.7e-6) {\\n\\t\\n\\tlet xPlus = deepCopy(x);\\n\\tlet xMinus = deepCopy(x);\\n\\n\\t\\n\\tlet fOfx = f(x, ...args);\\n\\tlet m = fOfx.length;\\n\\n\\t\\n\\tlet n = x.length;\\n\\n\\t\\n\\tlet J = zeros(m, n);\\n\\n\\t\\n\\tlet fOfxPlus;\\n\\tlet fOfxMinus;\\n\\n\\tfor (let j = 0; j &lt; n; j++) {\\n\\t\\txPlus[j] += eps;\\n\\t\\txMinus[j] -= eps;\\n\\t\\tfOfxPlus = f(xPlus, ...args);\\n\\t\\tfOfxMinus = f(xMinus, ...args);\\n\\t\\txPlus[j] -= eps;\\n\\t\\txMinus[j] += eps;\\n\\n\\t\\tfor (let i = 0; i &lt; m; i++) {\\n\\t\\t\\tJ[i][j] = (fOfxPlus[i] - fOfxMinus[i]) / 2.0 / eps;\\n\\t\\t}\\n\\t}\\n\\n\\treturn J;\\n}\\n\\n\\nfunction dot(v1, v2) {\\n  const n = v1.length;\\n  let result = 0.0;\\n  for (let i = 0; i &lt; n; i++) result += v1[i] * v2[i];\\n\\n  return result;\\n}\\n\\n\\nfunction zeros(...dims) {\\n  let A = [];\\n\\n  \\n  for (let i = dims.length - 1; i &gt;= 0; i--) {\\n    let size = dims[i];\\n    if (i === dims.length - 1) {\\n      \\n      A = new Array(size).fill(0.0);\\n    } else {\\n      \\n      A = new Array(size).fill().map(() =&gt; deepCopy(A));\\n    }\\n  }\\n\\n  return A;\\n}\\n\\n\\nfunction svMult(a, v) {\\n  return v.map(x =&gt; a * x);\\n}\\n\\n\\nfunction quadForm(A, x) {\\n   return dot(x, mvMult(A, x)); \\n}\\n\\n\\nfunction solvePosDef(A, b) {\\n  let [L, p, success] = modifiedCholesky(A);\\n\\n  if (!success) {\\n    return [zeros(b.length), success];\\n  }\\n\\n  return [modifiedCholeskySolve(L, p, b), success];\\n}\\n\\n\\nfunction modifiedCholesky(A) {\\n    const floatEps = 1.0e-14;\\n    const n = A.length;\\n\\n    \\n    let L = deepCopy(A); \\n    let p = arange(0, n);\\n\\n    \\n    let success = true;\\n\\n    let xi = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        for (let j = 0; j &lt; i; j++) {\\n            let temp = Math.abs(L[i][j]);\\n            xi = Math.max(xi, temp);\\n        }\\n    }\\n\\n    let eta = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        let temp = Math.abs(L[i][i]);\\n        eta = Math.max(eta, temp);\\n    }\\n\\n    let beta;\\n    if (n &gt; 1) {\\n        beta = Math.sqrt(Math.max(eta, xi / Math.sqrt(n * n - 1)));\\n    } else {\\n        beta = Math.sqrt(eta);\\n    }\\n    beta = Math.max(beta, floatEps);\\n\\n    for (let k = 0; k &lt; n; k++) {\\n        \\n        let muVal = L[k][k];\\n        let mu = k;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            let temp = L[i][i];\\n            if (muVal &lt; temp) {\\n                mu = i;\\n                muVal = temp;\\n            }\\n        }\\n\\n        \\n        let iTemp = p[mu];\\n        p[mu] = p[k];\\n        p[k] = iTemp;\\n\\n        for (let i = 0; i &lt; k; i++) {\\n            let temp = L[k][i];\\n            L[k][i] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        let temp = L[k][k];\\n        L[k][k] = L[mu][mu];\\n        L[mu][mu] = temp;\\n        for (let i = k + 1; i &lt; mu; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        for (let i = mu + 1; i &lt; n; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[i][mu];\\n            L[i][mu] = temp;\\n        }\\n\\n        \\n        let cSum = 0;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            cSum = Math.max(cSum, Math.abs(L[i][k]));\\n        }\\n        cSum /= beta;\\n        cSum = cSum * cSum;\\n\\n        \\n        if (L[k][k] &lt; 0) {\\n            success = false;\\n        }\\n\\n        temp = Math.abs(L[k][k]);\\n        temp = Math.max(temp, floatEps * eta);\\n        temp = Math.max(temp, cSum);\\n        L[k][k] = Math.sqrt(temp);\\n\\n        \\n        for (let i = k + 1; i &lt; n; i++) {\\n            L[i][k] /= L[k][k];\\n        }\\n\\n        \\n        for (let j = k + 1; j &lt; n; j++) {\\n            for (let i = j; i &lt; n; i++) {\\n                L[i][j] -= L[i][k] * L[j][k];\\n            }\\n        }\\n\\n        \\n        for (let i = 0; i &lt; n - 1; i++) {\\n            for (let j = i + 1; j &lt; n; j++) {\\n                L[i][j] = 0.0;\\n            }\\n        }\\n    }\\n\\n    return [L, p, success];\\n}\\n\\n\\nfunction modifiedCholeskySolve(L, p, b) {\\n    const n = L.length;\\n\\n    let U = transpose(L);\\n    let xp = new Array(n).fill(0);\\n    for (let i = 0; i &lt; n; i++) {\\n        xp[i] = b[p[i]];\\n    }\\n\\n    \\n    let x = lowerTriSolve(L, xp);\\n\\n    \\n    xp = upperTriSolve(U, x);\\n\\n    for (let i = 0; i &lt; n; i++) {\\n        x[p[i]] = xp[i];\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction lowerTriSolve(L, b) {\\n    const floatEps = 1.0e-14;\\n    const n = L.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = 0; j &lt; n - 1; j++) {\\n        if (Math.abs(L[j][j]) &gt; floatEps) {\\n            x[j] /= L[j][j];\\n            for (let i = j + 1; i &lt; n; i++) {\\n                x[i] -= x[j] * L[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(L[n - 1][n - 1]) &gt; floatEps) {\\n            x[n - 1] /= L[n - 1][n - 1];\\n        } else {\\n            x[n - 1] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction upperTriSolve(U, b) {\\n    const floatEps = 1.0e-14;\\n    const n = U.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = n - 1; j &gt; 0; j--) {\\n        if (Math.abs(U[j][j]) &gt; floatEps) {\\n            x[j] /= U[j][j];\\n            for (let i = 0; i &lt; j; i++) {\\n                x[i] -= x[j] * U[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(U[0][0]) &gt; floatEps) {\\n            x[0] /= U[0][0];\\n        } else {\\n            x[0] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nclass InverseGaussianDistribution extends ContinuousUnivariateDistribution {\\n  \\n  \\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;InverseGaussian&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0.0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u00b5&#x27;, &#x27;\\u03bb&#x27;];\\n\\n    \\n    this.locationParam = undefined;\\n\\n    \\n    this.paramMin = [0.0, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds();\\n\\n    \\n    super.generateLocationParamIndex();\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    return 0.0;    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    if (x &lt; 0) return NaN;\\n    if (x === 0 || x === Infinity) return 0.0;  \\n\\n    let [mu, lambda] = params.slice(0, 2);\\n\\n    let lnProb;\\n    lnProb = -Math.log(2.0 * Math.PI) / 2.0 + (Math.log(lambda) - 3.0 * Math.log(x)) / 2.0\\n             - lambda * Math.pow(x - mu, 2) / (2.0 * Math.pow(mu, 2) * x);\\n\\n    return Math.exp(lnProb);\\n  }\\n\\n  cdfSingleValue(x, params, parametrization = this.parametrization) {\\n    if (x &lt;= 0) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let [mu, lambda] = params.slice(0, 2);\\n\\n    let term1 = lnStdNormCdf(Math.sqrt(lambda / x) * (x / mu - 1.0));\\n    let term2 = 2.0 * lambda / mu + lnStdNormCdf(-Math.sqrt(lambda / x) * (x / mu + 1.0));\\n\\n    return Math.exp(logSumExp(term1, term2));\\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n    if (p == 0) return 0.0;\\n    if (p == 1) return Infinity;\\n\\n    let [mu, lambda] = params.slice(0, 2);\\n\\n    \\n    let xMode = mu * (Math.sqrt(1.0 + 2.25 * Math.pow(mu, 2) / Math.pow(lambda, 2)) - 1.5 * mu / lambda);\\n\\n    \\n    let f;\\n    let df;\\n    if (p &lt; this.cdfSingleValue(xMode, params, parametrization)) {\\n      f = (x, params, p) =&gt; this.cdfSingleValue(x, params, parametrization) - p;\\n      df = (x, params, p) =&gt; this.pdfSingleValue(x, params, parametrization);\\n    }\\n    else {\\n      f = (x, params, p) =&gt; p - this.cdfSingleValue(x, params, parametrization);\\n      df = (x, params, p) =&gt; -this.pdfSingleValue(x, params, parametrization);\\n    }\\n\\n    return newtonSolve(xMode, f, df, [params, p]);\\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n    let [x1, x2] = this.ppf([0.01, 0.99], params);\\n\\n    \\n    if (x1 &lt; (x2 - x1) / 10.0) x1 = 0.0;\\n\\n    return [x1, x2];    \\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    \\n    let x1Rescaled = x1 / x2;\\n    let x2Rescaled = 1.0;\\n\\n    \\n    const quantileRootFun = (params, x1, p1, x2, p2) =&gt; {\\n      let mu = Math.exp(params[0]);\\n      let lambda = Math.exp(params[1]);\\n\\n      let r1 = this.cdfSingleValue(x1, [mu, lambda]) - p1;\\n      let r2 = this.cdfSingleValue(x2, [mu, lambda]) - p2;\\n\\n      return [r1, r2];\\n    };\\n\\n    let args = [x1Rescaled, p1, x2Rescaled, p2];\\n\\n    let guess = [2, 2];\\n\\n    let [logParams, optimSuccess] = findRootTrustRegion(quantileRootFun, guess, args=args);\\n\\n    \\n    let paramsOpt = [Math.exp(logParams[0]), Math.exp(logParams[1])];\\n\\n    \\n    return [[x2 * paramsOpt[0], x2 * paramsOpt[1]], optimSuccess];\\n  }\\n}\\n\\n\\n\\nvar dist = new InverseGaussianDistribution();\\n\\n\\n\\nif (cb_obj.active) {\\n  for (let i = 0; i &lt; sliders.length; i++) {\\n    if (!dist.fixedParamsInds.includes(i)) {\\n      sliders[i].title = dist.paramNames[i] + &#x27; (computed)&#x27;;\\n      sliders[i].disabled = true;\\n    }\\n  }\\n  for (let xBox of xBoxes) {\\n    xBox.disabled = false;\\n  }\\n  for (let pBox of pBoxes) {\\n    pBox.disabled = false;\\n  }\\n} else {\\n  for (let i = 0; i &lt; sliders.length; i++) {\\n    if (!dist.fixedParamsInds.includes(i)) {\\n      sliders[i].title = dist.paramNames[i];\\n      sliders[i].disabled = false;\\n    }\\n  }\\n  for (let xBox of xBoxes) {\\n    xBox.disabled = true;\\n  }\\n  for (let pBox of pBoxes) {\\n    pBox.disabled = true;\\n  }\\n  quantileSetterDiv.text = &#x27;&#x27;;\\n}"}}]]]}}}]}},{"type":"object","name":"Spacer","id":"p2871","attributes":{"width":10}},{"id":"p2819"}]}},{"type":"object","name":"Spacer","id":"p2873","attributes":{"height":10}},{"type":"object","name":"Row","id":"p2875","attributes":{"children":[{"type":"object","name":"Column","id":"p2863","attributes":{"children":[{"type":"object","name":"Row","id":"p2861","attributes":{"children":[{"type":"object","name":"Column","id":"p2854","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2853","attributes":{"height":4}},{"id":"p2811"}]}},{"id":"p2808"},{"type":"object","name":"Column","id":"p2856","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2855","attributes":{"height":4}},{"id":"p2813"}]}}]}},{"type":"object","name":"Row","id":"p2862","attributes":{"children":[{"type":"object","name":"Column","id":"p2858","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2857","attributes":{"height":4}},{"id":"p2812"}]}},{"id":"p2810"},{"type":"object","name":"Column","id":"p2860","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2859","attributes":{"height":4}},{"id":"p2814"}]}}]}}]}},{"type":"object","name":"Spacer","id":"p2874","attributes":{"width":20}},{"type":"object","name":"Column","id":"p2852","attributes":{"children":[{"type":"object","name":"Row","id":"p2850","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2834","attributes":{"width":20}},{"type":"object","name":"Column","id":"p2837","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2835","attributes":{"height":7}},{"type":"object","name":"Div","id":"p2836","attributes":{"text":"&lt;p&gt;&lt;b&gt;lower y: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p2815"},{"type":"object","name":"Spacer","id":"p2838","attributes":{"width":34}},{"type":"object","name":"Column","id":"p2841","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2839","attributes":{"height":7}},{"type":"object","name":"Div","id":"p2840","attributes":{"text":"&lt;p&gt;&lt;b&gt;upper y: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p2816"}]}},{"type":"object","name":"Row","id":"p2851","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2842","attributes":{"width":16}},{"type":"object","name":"Column","id":"p2845","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2843","attributes":{"height":7}},{"type":"object","name":"Div","id":"p2844","attributes":{"text":"&lt;p&gt;&lt;b&gt;quantile: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p2817"},{"type":"object","name":"Spacer","id":"p2846","attributes":{"width":30}},{"type":"object","name":"Column","id":"p2849","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2847","attributes":{"height":7}},{"type":"object","name":"Div","id":"p2848","attributes":{"text":"&lt;p&gt;&lt;b&gt;quantile: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p2818"}]}}]}}]}},{"type":"object","name":"Spacer","id":"p2876","attributes":{"height":10}},{"type":"object","name":"GridPlot","id":"p2868","attributes":{"rows":null,"cols":null,"toolbar":{"type":"object","name":"Toolbar","id":"p2867","attributes":{"tools":[{"type":"object","name":"ToolProxy","id":"p2865","attributes":{"tools":[{"id":"p2755"},{"id":"p2779"},{"id":"p2755"},{"id":"p2779"}]}},{"type":"object","name":"SaveTool","id":"p2866"}]}},"toolbar_location":"right","children":[[{"id":"p2733"},0,0],[{"type":"object","name":"Spacer","id":"p2864","attributes":{"width":30}},0,1],[{"id":"p2757"},0,2]]}}]}}]}}';
                  const render_items = [{"docid":"e5cf8f90-7512-4519-b807-40da6ab2b7e8","roots":{"p2877":"dede0e30-7dda-4311-ab3d-0d128ee2a430"},"root_ids":["p2877"]}];
                  root.Bokeh.embed.embed_items(docs_json, render_items);
                  }
                  if (root.Bokeh !== undefined) {
                    embed_document(root);
                  } else {
                    let attempts = 0;
                    const timer = setInterval(function(root) {
                      if (root.Bokeh !== undefined) {
                        clearInterval(timer);
                        embed_document(root);
                      } else {
                        attempts++;
                        if (attempts > 100) {
                          clearInterval(timer);
                          console.log("Bokeh: ERROR: Unable to run BokehJS code because BokehJS library is missing");
                        }
                      }
                    }, 10, root)
                  }
                })(window);
              });
            };
            if (document.readyState != "loading") fn();
            else document.addEventListener("DOMContentLoaded", fn);
          })();
        },
    function(Bokeh) {
        }
      ];
    
      function run_inline_js() {
        for (let i = 0; i < inline_js.length; i++) {
          inline_js[i].call(root, root.Bokeh);
        }
      }
    
      if (root._bokeh_is_loading === 0) {
        console.debug("Bokeh: BokehJS loaded, going straight to plotting");
        run_inline_js();
      } else {
        load_libs(css_urls, js_urls, function() {
          console.debug("Bokeh: BokehJS plotting callback run at", now());
          run_inline_js();
        });
      }
    }(window));
  };
  if (document.readyState != "loading") fn();
  else document.addEventListener("DOMContentLoaded", fn);
})();