(function() {
  const fn = function() {
    (function(root) {
      function now() {
        return new Date();
      }
    
      const force = false;
    
      if (typeof root._bokeh_onload_callbacks === "undefined" || force === true) {
        root._bokeh_onload_callbacks = [];
        root._bokeh_is_loading = undefined;
      }
    
    
    const element = document.getElementById("afc67744-caa5-4742-a004-28d2a5d15082");
        if (element == null) {
          console.warn("Bokeh: autoload.js configured with elementid 'afc67744-caa5-4742-a004-28d2a5d15082' but no matching script tag was found.")
        }
      function run_callbacks() {
        try {
          root._bokeh_onload_callbacks.forEach(function(callback) {
            if (callback != null)
              callback();
          });
        } finally {
          delete root._bokeh_onload_callbacks
        }
        console.debug("Bokeh: all callbacks have finished");
      }
    
      function load_libs(css_urls, js_urls, callback) {
        if (css_urls == null) css_urls = [];
        if (js_urls == null) js_urls = [];
    
        root._bokeh_onload_callbacks.push(callback);
        if (root._bokeh_is_loading > 0) {
          console.debug("Bokeh: BokehJS is being loaded, scheduling callback at", now());
          return null;
        }
        if (js_urls == null || js_urls.length === 0) {
          run_callbacks();
          return null;
        }
        console.debug("Bokeh: BokehJS not loaded, scheduling load and callback at", now());
        root._bokeh_is_loading = css_urls.length + js_urls.length;
    
        function on_load() {
          root._bokeh_is_loading--;
          if (root._bokeh_is_loading === 0) {
            console.debug("Bokeh: all BokehJS libraries/stylesheets loaded");
            run_callbacks()
          }
        }
    
        function on_error(url) {
          console.error("failed to load " + url);
        }
    
        for (let i = 0; i < css_urls.length; i++) {
          const url = css_urls[i];
          const element = document.createElement("link");
          element.onload = on_load;
          element.onerror = on_error.bind(null, url);
          element.rel = "stylesheet";
          element.type = "text/css";
          element.href = url;
          console.debug("Bokeh: injecting link tag for BokehJS stylesheet: ", url);
          document.body.appendChild(element);
        }
    
        for (let i = 0; i < js_urls.length; i++) {
          const url = js_urls[i];
          const element = document.createElement('script');
          element.onload = on_load;
          element.onerror = on_error.bind(null, url);
          element.async = false;
          element.src = url;
          console.debug("Bokeh: injecting script tag for BokehJS library: ", url);
          document.head.appendChild(element);
        }
      };
    
      function inject_raw_css(css) {
        const element = document.createElement("style");
        element.appendChild(document.createTextNode(css));
        document.body.appendChild(element);
      }
    
      const js_urls = ["https://cdn.bokeh.org/bokeh/release/bokeh-3.3.0.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-gl-3.3.0.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-widgets-3.3.0.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-tables-3.3.0.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-mathjax-3.3.0.min.js"];
      const css_urls = [];
    
      const inline_js = [    function(Bokeh) {
          Bokeh.set_log_level("info");
        },
        function(Bokeh) {
          (function() {
            const fn = function() {
              Bokeh.safely(function() {
                (function(root) {
                  function embed_document(root) {
                  const docs_json = '{"618a4d8f-0ab1-4e07-a630-3e8003831f09":{"version":"3.3.0","title":"Bokeh Application","roots":[{"type":"object","name":"Column","id":"p3891","attributes":{"children":[{"type":"object","name":"Row","id":"p3886","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3884","attributes":{"width":409}},{"type":"object","name":"Row","id":"p3843","attributes":{"children":[{"type":"object","name":"Div","id":"p3841","attributes":{"text":"&lt;p&gt;&lt;b&gt;Quantile setter mode&lt;/b&gt;&lt;/p&gt;"}},{"type":"object","name":"Spacer","id":"p3842","attributes":{"width":2}},{"type":"object","name":"Switch","id":"p3830","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:active",[{"type":"object","name":"CustomJS","id":"p3834","attributes":{"args":{"type":"map","entries":[["p_p",{"type":"object","name":"Figure","id":"p3733","attributes":{"x_range":{"type":"object","name":"Range1d","id":"p3791","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:start",[{"type":"object","name":"CustomJS","id":"p3833","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p3733"}],["p_c",{"type":"object","name":"Figure","id":"p3762","attributes":{"js_event_callbacks":{"type":"map","entries":[["reset",[{"type":"object","name":"CustomJS","id":"p3836","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p3733"}],["p_c",{"id":"p3762"}],["source_p",{"type":"object","name":"ColumnDataSource","id":"p3793","attributes":{"selected":{"type":"object","name":"Selection","id":"p3794","attributes":{"indices":[],"line_indices":[]}},"selection_policy":{"type":"object","name":"UnionRenderers","id":"p3795"},"data":{"type":"map","entries":[["x",{"type":"ndarray","array":{"type":"bytes","data":"AAAAAAAAAACASAEiBYiUP4BIASIFiKQ/wOwBswfMrj+ASAEiBYi0P6CagWoGqrk/wOwBswfMvj9wH8F9BPfBP4BIASIFiMQ/kHFBxgUZxz+gmoFqBqrJP7DDwQ4HO8w/wOwBswfMzj/oCqErhK7QP3AfwX0E99E/+DPhz4Q/0z+ASAEiBYjUPwhdIXSF0NU/kHFBxgUZ1z8YhmEYhmHYP6CagWoGqtk/KK+hvIby2j+ww8EOBzvcPzjY4WCHg90/wOwBswfM3j+kAJECRArgP+gKoSuEruA/LBWxVMRS4T9wH8F9BPfhP7Qp0aZEm+I/+DPhz4Q/4z88PvH4xOPjP4BIASIFiOQ/xFIRS0Us5T8IXSF0hdDlP0xnMZ3FdOY/kHFBxgUZ5z/Ue1HvRb3nPxiGYRiGYeg/XJBxQcYF6T+gmoFqBqrpP+SkkZNGTuo/KK+hvIby6j9subHlxpbrP7DDwQ4HO+w/9M3RN0ff7D842OFgh4PtP3zi8YnHJ+4/wOwBswfM7j8E9xHcR3DvP6QAkQJECvA/xgUZF2Rc8D/oCqErhK7wPwoQKUCkAPE/LBWxVMRS8T9OGjlp5KTxP3AfwX0E9/E/kiRJkiRJ8j+0KdGmRJvyP9YuWbtk7fI/+DPhz4Q/8z8aOWnkpJHzPzw+8fjE4/M/XkN5DeU19D+ASAEiBYj0P6JNiTYl2vQ/xFIRS0Us9T/mV5lfZX71PwhdIXSF0PU/KmKpiKUi9j9MZzGdxXT2P25subHlxvY/kHFBxgUZ9z+ydsnaJWv3P9R7Ue9Fvfc/9oDZA2YP+D8YhmEYhmH4PzqL6Syms/g/XJBxQcYF+T9+lflV5lf5P6CagWoGqvk/wp8Jfyb8+T/kpJGTRk76PwaqGahmoPo/KK+hvIby+j9KtCnRpkT7P2y5seXGlvs/jr45+ubo+z+ww8EOBzv8P9LISSMnjfw/9M3RN0ff/D8W01lMZzH9PzjY4WCHg/0/Wt1pdafV/T984vGJxyf+P57neZ7nef4/wOwBswfM/j/i8YnHJx7/PwT3EdxHcP8/JvyZ8GfC/z+kAJECRAoAQDUD1QxUMwBAxgUZF2RcAEBXCF0hdIUAQOgKoSuErgBAeQ3lNZTXAEAKEClApAABQJsSbUq0KQFALBWxVMRSAUC9F/Ve1HsBQE4aOWnkpAFA3xx9c/TNAUBwH8F9BPcBQAEiBYgUIAJAkiRJkiRJAkAjJ42cNHICQLQp0aZEmwJARSwVsVTEAkDWLlm7ZO0CQGcxncV0FgNA+DPhz4Q/A0CJNiXalGgDQBo5aeSkkQNAqzut7rS6A0A8PvH4xOMDQM1ANQPVDARAXkN5DeU1BEDvRb0X9V4EQIBIASIFiARAEUtFLBWxBECiTYk2JdoEQDNQzUA1AwVAxFIRS0UsBUBVVVVVVVUFQOZXmV9lfgVAd1rdaXWnBUAIXSF0hdAFQJlfZX6V+QVAKmKpiKUiBkC7ZO2StUsGQExnMZ3FdAZA3Wl1p9WdBkBubLmx5cYGQP9u/bv17wZAkHFBxgUZB0AhdIXQFUIHQLJ2ydolawdAQ3kN5TWUB0DUe1HvRb0HQGV+lflV5gdA9oDZA2YPCECHgx0OdjgIQBiGYRiGYQhAqYilIpaKCEA6i+ksprMIQMuNLTe23AhAXJBxQcYFCUDtkrVL1i4JQH6V+VXmVwlAD5g9YPaACUCgmoFqBqoJQDGdxXQW0wlAwp8Jfyb8CUBTok2JNiUKQOSkkZNGTgpAdafVnVZ3CkAGqhmoZqAKQJesXbJ2yQpAKK+hvIbyCkC5seXGlhsLQEq0KdGmRAtA27Zt27ZtC0BsubHlxpYLQP279e/WvwtAjr45+uboC0AfwX0E9xEMQLDDwQ4HOwxAQcYFGRdkDEDSyEkjJ40MQGPLjS03tgxA9M3RN0ffDECF0BVCVwgNQBbTWUxnMQ1Ap9WdVndaDUA42OFgh4MNQMnaJWuXrA1AWt1pdafVDUDr361/t/4NQHzi8YnHJw5ADeU1lNdQDkCe53me53kOQC/qvaj3og5AwOwBswfMDkBR70W9F/UOQOLxiccnHg9Ac/TN0TdHD0AE9xHcR3APQJX5VeZXmQ9AJvyZ8GfCD0C3/t36d+sPQKQAkQJEChBA7AGzB8weEEA1A9UMVDMQQH4E9xHcRxBAxgUZF2RcEEAOBzsc7HAQQFcIXSF0hRBAoAl/JvyZEEDoCqErhK4QQDAMwzAMwxBAeQ3lNZTXEEDCDgc7HOwQQAoQKUCkABFAUhFLRSwVEUCbEm1KtCkRQOQTj088PhFALBWxVMRSEUB0FtNZTGcRQL0X9V7UexFABhkXZFyQEUBOGjlp5KQRQJYbW25suRFA3xx9c/TNEUAoHp94fOIRQHAfwX0E9xFAuCDjgowLEkABIgWIFCASQEojJ42cNBJAkiRJkiRJEkDaJWuXrF0SQCMnjZw0chJAbCivobyGEkC0KdGmRJsSQPwq86vMrxJARSwVsVTEEkCOLTe23NgSQNYuWbtk7RJAHjB7wOwBE0BnMZ3FdBYTQLAyv8r8KhNA+DPhz4Q/E0BANQPVDFQTQIk2JdqUaBNA0jdH3xx9E0AaOWnkpJETQGI6i+ksphNAqzut7rS6E0D0PM/zPM8TQDw+8fjE4xNAhD8T/kz4E0DNQDUD1QwUQBZCVwhdIRRAXkN5DeU1FECmRJsSbUoUQO9FvRf1XhRAOEffHH1zFECASAEiBYgUQMhJIyeNnBRAEUtFLBWxFEBaTGcxncUUQKJNiTYl2hRA6k6rO63uFEAzUM1ANQMVQHxR70W9FxVAxFIRS0UsFUAMVDNQzUAVQFVVVVVVVRVAnlZ3Wt1pFUDmV5lfZX4VQC5Zu2TtkhVAd1rdaXWnFUDAW/9u/bsVQAhdIXSF0BVAUF5DeQ3lFUCZX2V+lfkVQOJgh4MdDhZAKmKpiKUiFkByY8uNLTcWQLtk7ZK1SxZABGYPmD1gFkBMZzGdxXQWQJRoU6JNiRZA3Wl1p9WdFkAma5esXbIWQG5subHlxhZAtm3btm3bFkD/bv279e8WQEhwH8F9BBdAkHFBxgUZF0DYcmPLjS0XQCF0hdAVQhdAanWn1Z1WF0CydsnaJWsXQPp369+tfxdAQ3kN5TWUF0CMei/qvagXQNR7Ue9FvRdAHH1z9M3RF0BlfpX5VeYXQK5/t/7d+hdA9oDZA2YPGEA+gvsI7iMYQIeDHQ52OBhA0IQ/E/5MGEAYhmEYhmEYQGCHgx0OdhhAqYilIpaKGEDyiccnHp8YQDqL6SymsxhAgowLMi7IGEDLjS03ttwYQBSPTzw+8RhAXJBxQcYFGUCkkZNGThoZQO2StUvWLhlANpTXUF5DGUB+lflV5lcZQMaWG1tubBlAD5g9YPaAGUBYmV9lfpUZQKCagWoGqhlA6Jujb46+GUAxncV0FtMZQHqe53me5xlAwp8Jfyb8GUAKoSuErhAaQFOiTYk2JRpAnKNvjr45GkDkpJGTRk4aQCyms5jOYhpAdafVnVZ3GkC+qPei3osaQAaqGahmoBpATqs7re60GkCXrF2ydskaQOCtf7f+3RpAKK+hvIbyGkBwsMPBDgcbQLmx5caWGxtAArMHzB4wG0BKtCnRpkQbQJK1S9YuWRtA27Zt27ZtG0AkuI/gPoIbQGy5seXGlhtAtLrT6k6rG0D9u/Xv1r8bQEa9F/Ve1BtAjr45+uboG0DWv1v/bv0bQB/BfQT3ERxAaMKfCX8mHECww8EOBzscQPjE4xOPTxxAQcYFGRdkHECKxycen3gcQNLISSMnjRxAGsprKK+hHEBjy40tN7YcQKzMrzK/yhxA9M3RN0ffHEA8z/M8z/McQIXQFUJXCB1AztE3R98cHUAW01lMZzEdQF7Ue1HvRR1Ap9WdVndaHUDw1r9b/24dQDjY4WCHgx1AgNkDZg+YHUDJ2iVrl6wdQBLcR3AfwR1AWt1pdafVHUCi3ot6L+odQOvfrX+3/h1ANOHPhD8THkB84vGJxyceQMTjE49PPB5ADeU1lNdQHkBW5leZX2UeQJ7neZ7neR5A5uibo2+OHkAv6r2o96IeQHjr361/tx5AwOwBswfMHkAI7iO4j+AeQFHvRb0X9R5AmvBnwp8JH0Di8YnHJx4fQCrzq8yvMh9Ac/TN0TdHH0C89e/Wv1sfQAT3EdxHcB9ATPgz4c+EH0CV+VXmV5kfQN76d+vfrR9AJvyZ8GfCH0Bu/bv179YfQLf+3fp36x9AAAAAAAAAIEA="},"shape":[400],"dtype":"float64","order":"little"}],["y_p",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}]]}}}],["source_c",{"type":"object","name":"ColumnDataSource","id":"p3796","attributes":{"selected":{"type":"object","name":"Selection","id":"p3797","attributes":{"indices":[],"line_indices":[]}},"selection_policy":{"type":"object","name":"UnionRenderers","id":"p3798"},"data":{"type":"map","entries":[["x",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}],["y_c",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}]]}}}],["discrete",false],["n",400],["sliders",[{"type":"object","name":"Slider","id":"p3818","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p3832","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p3733"}],["p_c",{"id":"p3762"}],["source_p",{"id":"p3793"}],["source_c",{"id":"p3796"}],["discrete",false],["n",400],["sliders",[{"id":"p3818"},{"type":"object","name":"Slider","id":"p3820","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p3832"}]]]},"width":200,"title":"\\u03c3","format":{"type":"object","name":"CustomJSTickFormatter","id":"p3819","attributes":{"code":"return tick.toPrecision(4)"}},"start":0.1,"end":3,"value":1.5,"step":0.01}}]],["xBoxes",[{"type":"object","name":"TextInput","id":"p3825","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p3835","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p3733"}],["p_c",{"id":"p3762"}],["source_p",{"id":"p3793"}],["source_c",{"id":"p3796"}],["discrete",false],["n",400],["sliders",[{"id":"p3818"},{"id":"p3820"}]],["xBoxes",[{"id":"p3825"},{"type":"object","name":"TextInput","id":"p3826","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p3835"}]]]},"disabled":true,"width":80,"value":"5.5333"}}]],["pBoxes",[{"type":"object","name":"TextInput","id":"p3827","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p3835"}]]]},"disabled":true,"width":80,"value":"0.0250"}},{"type":"object","name":"TextInput","id":"p3828","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p3835"}]]]},"disabled":true,"width":80,"value":"0.9750"}}]],["quantileSetterSwitch",{"id":"p3830"}],["quantileSetterDiv",{"type":"object","name":"Div","id":"p3829"}],["triggerCallbacks",{"type":"object","name":"Switch","id":"p3831","attributes":{"active":true}}],["startBoxes",[{"type":"object","name":"TextInput","id":"p3821","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p3837","attributes":{"args":{"type":"map","entries":[["minValue","0"],["maxValue","Infinity"],["slider",{"id":"p3818"}]]},"code":"\\n\\nslider.start = Math.max(minValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"0.1"}},{"type":"object","name":"TextInput","id":"p3822","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p3839","attributes":{"args":{"type":"map","entries":[["minValue","0"],["maxValue","Infinity"],["slider",{"id":"p3820"}]]},"code":"\\n\\nslider.start = Math.max(minValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"0.1"}}]],["endBoxes",[{"type":"object","name":"TextInput","id":"p3823","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p3838","attributes":{"args":{"type":"map","entries":[["minValue","0"],["maxValue","Infinity"],["slider",{"id":"p3818"}]]},"code":"\\n\\nslider.end = Math.min(maxValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"5"}},{"type":"object","name":"TextInput","id":"p3824","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p3840","attributes":{"args":{"type":"map","entries":[["minValue","0"],["maxValue","Infinity"],["slider",{"id":"p3820"}]]},"code":"\\n\\nslider.end = Math.min(maxValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"3"}}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let x = paramsFromBoxes(xBoxes);\\n  let p = paramsFromBoxes(pBoxes);\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ){\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n          endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);        \\n        }\\n        sliders[dist.activeParamsInds[i]].value = optimParams[i];\\n      }\\n\\n      params = paramsFromSliders(sliders); \\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.floor(xRange.start);\\n  let xRangeMax = Math.ceil(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c = [xRangeMin - 1, ...x_p.flatMap(x =&gt; [x, x]), xRangeMax + 1];\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = -0.04;\\n    p_c.y_range.end = 1.04;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = -pdfMax * 0.04;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264&#x27; + xMax.toString() + &#x27;.&lt;/p\\\\&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nclass WeibullDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Weibull&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0.0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03b1&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0.0;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x &lt; 0) return NaN;\\n    if (x === 0) return 0.0;\\n    if (x === Infinity) return 0.0;\\n\\n    let [alpha, sigma] = params.slice(0, 2);\\n\\n    let logp = -Math.pow(x / sigma, alpha) + (alpha - 1) * Math.log(x) \\n                + Math.log(alpha) - alpha * Math.log(sigma);\\n\\n    return Math.exp(logp);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x &lt;= 0) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let [alpha, sigma] = params.slice(0, 2);\\n\\n    return 1 - Math.exp(-Math.pow(x / sigma, alpha));\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return 0.0;\\n    if (p === 1) return Infinity;\\n\\n    let [alpha, sigma] = params.slice(0, 2);\\n\\n    return sigma * Math.pow(-Math.log(1.0 - p), 1.0 / alpha);\\n  }\\n\\n  defaultXRange(params) {\\n    let [x1, x2] = this.ppf([0.001, 0.999], params);\\n\\n    \\n    if (x1 &lt; (x2 - x1) / 10.0) x1 = 0.0;\\n\\n    return [x1, x2];\\n  }\\n\\n  quantileSet(x, p, extraParams = []) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    let loglog1 = Math.log(-Math.log(1.0 - p1));\\n    let loglog2 = Math.log(-Math.log(1.0 - p2));\\n    let logx1 = Math.log(x1);\\n    let logx2 = Math.log(x2);\\n\\n    let alpha = (loglog2 - loglog1) / (logx2 - logx1);\\n    let sigma = Math.exp(logx2 - loglog2 / alpha);\\n\\n    return [[alpha, sigma], true];\\n  }\\n\\n  \\n}\\n\\n\\n\\nvar dist = new WeibullDistribution();\\n\\n\\n\\nif (quantileSetterSwitch.active) {\\n  quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p);\\n}"}}]]]},"disabled":true,"width":80,"value":"0.0380"}},{"id":"p3826"}]],["pBoxes",[{"id":"p3827"},{"id":"p3828"}]],["quantileSetterSwitch",{"id":"p3830"}],["quantileSetterDiv",{"id":"p3829"}],["triggerCallbacks",{"id":"p3831"}],["startBoxes",[{"id":"p3821"},{"id":"p3822"}]],["endBoxes",[{"id":"p3823"},{"id":"p3824"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let x = paramsFromBoxes(xBoxes);\\n  let p = paramsFromBoxes(pBoxes);\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ){\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n          endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);        \\n        }\\n        sliders[dist.activeParamsInds[i]].value = optimParams[i];\\n      }\\n\\n      params = paramsFromSliders(sliders); \\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.floor(xRange.start);\\n  let xRangeMax = Math.ceil(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c = [xRangeMin - 1, ...x_p.flatMap(x =&gt; [x, x]), xRangeMax + 1];\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = -0.04;\\n    p_c.y_range.end = 1.04;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = -pdfMax * 0.04;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264&#x27; + xMax.toString() + &#x27;.&lt;/p\\\\&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nclass WeibullDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Weibull&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0.0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03b1&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0.0;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x &lt; 0) return NaN;\\n    if (x === 0) return 0.0;\\n    if (x === Infinity) return 0.0;\\n\\n    let [alpha, sigma] = params.slice(0, 2);\\n\\n    let logp = -Math.pow(x / sigma, alpha) + (alpha - 1) * Math.log(x) \\n                + Math.log(alpha) - alpha * Math.log(sigma);\\n\\n    return Math.exp(logp);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x &lt;= 0) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let [alpha, sigma] = params.slice(0, 2);\\n\\n    return 1 - Math.exp(-Math.pow(x / sigma, alpha));\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return 0.0;\\n    if (p === 1) return Infinity;\\n\\n    let [alpha, sigma] = params.slice(0, 2);\\n\\n    return sigma * Math.pow(-Math.log(1.0 - p), 1.0 / alpha);\\n  }\\n\\n  defaultXRange(params) {\\n    let [x1, x2] = this.ppf([0.001, 0.999], params);\\n\\n    \\n    if (x1 &lt; (x2 - x1) / 10.0) x1 = 0.0;\\n\\n    return [x1, x2];\\n  }\\n\\n  quantileSet(x, p, extraParams = []) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    let loglog1 = Math.log(-Math.log(1.0 - p1));\\n    let loglog2 = Math.log(-Math.log(1.0 - p2));\\n    let logx1 = Math.log(x1);\\n    let logx2 = Math.log(x2);\\n\\n    let alpha = (loglog2 - loglog1) / (logx2 - logx1);\\n    let sigma = Math.exp(logx2 - loglog2 / alpha);\\n\\n    return [[alpha, sigma], true];\\n  }\\n\\n  \\n}\\n\\n\\n\\nvar dist = new WeibullDistribution();\\n\\n\\n\\nif (triggerCallbacks.active &amp;&amp; !cb_obj.disabled) {\\n\\tif (quantileSetterSwitch.active) {\\n\\t\\tquantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p);\\n\\t}\\n\\telse {\\n\\t\\tupdateData(source_p, source_c, p_p, sliders, discrete);\\n\\t\\tupdateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes);\\n\\t}\\n}"}}]]]},"width":200,"title":"\\u03b1","format":{"type":"object","name":"CustomJSTickFormatter","id":"p3817","attributes":{"code":"return tick.toPrecision(4)"}},"start":0.1,"end":5,"value":1,"step":0.01}},{"id":"p3820"}]],["xBoxes",[{"id":"p3825"},{"id":"p3826"}]],["pBoxes",[{"id":"p3827"},{"id":"p3828"}]],["quantileSetterSwitch",{"id":"p3830"}],["quantileSetterDiv",{"id":"p3829"}],["triggerCallbacks",{"id":"p3831"}],["startBoxes",[{"id":"p3821"},{"id":"p3822"}]],["endBoxes",[{"id":"p3823"},{"id":"p3824"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let x = paramsFromBoxes(xBoxes);\\n  let p = paramsFromBoxes(pBoxes);\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ){\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n          endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);        \\n        }\\n        sliders[dist.activeParamsInds[i]].value = optimParams[i];\\n      }\\n\\n      params = paramsFromSliders(sliders); \\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.floor(xRange.start);\\n  let xRangeMax = Math.ceil(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c = [xRangeMin - 1, ...x_p.flatMap(x =&gt; [x, x]), xRangeMax + 1];\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = -0.04;\\n    p_c.y_range.end = 1.04;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = -pdfMax * 0.04;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264&#x27; + xMax.toString() + &#x27;.&lt;/p\\\\&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nclass WeibullDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Weibull&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0.0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03b1&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0.0;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x &lt; 0) return NaN;\\n    if (x === 0) return 0.0;\\n    if (x === Infinity) return 0.0;\\n\\n    let [alpha, sigma] = params.slice(0, 2);\\n\\n    let logp = -Math.pow(x / sigma, alpha) + (alpha - 1) * Math.log(x) \\n                + Math.log(alpha) - alpha * Math.log(sigma);\\n\\n    return Math.exp(logp);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x &lt;= 0) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let [alpha, sigma] = params.slice(0, 2);\\n\\n    return 1 - Math.exp(-Math.pow(x / sigma, alpha));\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return 0.0;\\n    if (p === 1) return Infinity;\\n\\n    let [alpha, sigma] = params.slice(0, 2);\\n\\n    return sigma * Math.pow(-Math.log(1.0 - p), 1.0 / alpha);\\n  }\\n\\n  defaultXRange(params) {\\n    let [x1, x2] = this.ppf([0.001, 0.999], params);\\n\\n    \\n    if (x1 &lt; (x2 - x1) / 10.0) x1 = 0.0;\\n\\n    return [x1, x2];\\n  }\\n\\n  quantileSet(x, p, extraParams = []) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    let loglog1 = Math.log(-Math.log(1.0 - p1));\\n    let loglog2 = Math.log(-Math.log(1.0 - p2));\\n    let logx1 = Math.log(x1);\\n    let logx2 = Math.log(x2);\\n\\n    let alpha = (loglog2 - loglog1) / (logx2 - logx1);\\n    let sigma = Math.exp(logx2 - loglog2 / alpha);\\n\\n    return [[alpha, sigma], true];\\n  }\\n\\n  \\n}\\n\\n\\n\\nvar dist = new WeibullDistribution();\\n\\n\\n\\nlet params = paramsFromSliders(sliders); \\n\\n\\nlet [x1, x2] = dist.defaultXRange(params);\\n\\n\\ntriggerCallbacks.active = false;\\n\\n\\np_p.x_range.start = x1;\\np_p.x_range.end = x2;\\n\\nupdateData(source_p, source_c, p_p, sliders, discrete);\\n\\n\\nsetYRanges(p_p, p_c, source_p);  \\n\\ntriggerCallbacks.active = true;\\n"}}]]]},"x_range":{"id":"p3791"},"y_range":{"type":"object","name":"Range1d","id":"p3792","attributes":{"start":-0.04,"end":1.04}},"x_scale":{"type":"object","name":"LinearScale","id":"p3772"},"y_scale":{"type":"object","name":"LinearScale","id":"p3773"},"title":{"type":"object","name":"Title","id":"p3765","attributes":{"text":" "}},"renderers":[{"type":"object","name":"GlyphRenderer","id":"p3805","attributes":{"data_source":{"id":"p3796"},"view":{"type":"object","name":"CDSView","id":"p3806","attributes":{"filter":{"type":"object","name":"AllIndices","id":"p3807"}}},"glyph":{"type":"object","name":"Line","id":"p3802","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_width":2}},"nonselection_glyph":{"type":"object","name":"Line","id":"p3803","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_alpha":0.1,"line_width":2}},"muted_glyph":{"type":"object","name":"Line","id":"p3804","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_alpha":0.2,"line_width":2}}}}],"toolbar":{"type":"object","name":"Toolbar","id":"p3771","attributes":{"tools":[{"type":"object","name":"PanTool","id":"p3784"},{"type":"object","name":"WheelZoomTool","id":"p3785","attributes":{"renderers":"auto"}},{"type":"object","name":"BoxZoomTool","id":"p3786","attributes":{"overlay":{"type":"object","name":"BoxAnnotation","id":"p3787","attributes":{"syncable":false,"level":"overlay","visible":false,"left_units":"canvas","right_units":"canvas","top_units":"canvas","bottom_units":"canvas","line_color":"black","line_alpha":1.0,"line_width":2,"line_dash":[4,4],"fill_color":"lightgrey","fill_alpha":0.5}}}},{"type":"object","name":"SaveTool","id":"p3788"},{"type":"object","name":"ResetTool","id":"p3789"},{"type":"object","name":"HelpTool","id":"p3790"}]}},"toolbar_location":null,"left":[{"type":"object","name":"LinearAxis","id":"p3779","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p3780","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p3781"},"axis_label":"CDF","axis_label_text_font_style":"normal","major_label_policy":{"type":"object","name":"AllLabels","id":"p3782"}}}],"below":[{"type":"object","name":"LinearAxis","id":"p3774","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p3775","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p3776"},"axis_label":"y","major_label_policy":{"type":"object","name":"AllLabels","id":"p3777"}}}],"center":[{"type":"object","name":"Grid","id":"p3778","attributes":{"axis":{"id":"p3774"}}},{"type":"object","name":"Grid","id":"p3783","attributes":{"dimension":1,"axis":{"id":"p3779"}}}],"frame_width":300,"frame_height":175,"background_fill_alpha":0,"border_fill_alpha":0}}],["source_p",{"id":"p3793"}],["source_c",{"id":"p3796"}],["discrete",false],["n",400],["sliders",[{"id":"p3818"},{"id":"p3820"}]],["xBoxes",[{"id":"p3825"},{"id":"p3826"}]],["pBoxes",[{"id":"p3827"},{"id":"p3828"}]],["quantileSetterSwitch",{"id":"p3830"}],["quantileSetterDiv",{"id":"p3829"}],["triggerCallbacks",{"id":"p3831"}],["startBoxes",[{"id":"p3821"},{"id":"p3822"}]],["endBoxes",[{"id":"p3823"},{"id":"p3824"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let x = paramsFromBoxes(xBoxes);\\n  let p = paramsFromBoxes(pBoxes);\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ){\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n          endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);        \\n        }\\n        sliders[dist.activeParamsInds[i]].value = optimParams[i];\\n      }\\n\\n      params = paramsFromSliders(sliders); \\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.floor(xRange.start);\\n  let xRangeMax = Math.ceil(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c = [xRangeMin - 1, ...x_p.flatMap(x =&gt; [x, x]), xRangeMax + 1];\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = -0.04;\\n    p_c.y_range.end = 1.04;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = -pdfMax * 0.04;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264&#x27; + xMax.toString() + &#x27;.&lt;/p\\\\&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nclass WeibullDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Weibull&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0.0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03b1&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0.0;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x &lt; 0) return NaN;\\n    if (x === 0) return 0.0;\\n    if (x === Infinity) return 0.0;\\n\\n    let [alpha, sigma] = params.slice(0, 2);\\n\\n    let logp = -Math.pow(x / sigma, alpha) + (alpha - 1) * Math.log(x) \\n                + Math.log(alpha) - alpha * Math.log(sigma);\\n\\n    return Math.exp(logp);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x &lt;= 0) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let [alpha, sigma] = params.slice(0, 2);\\n\\n    return 1 - Math.exp(-Math.pow(x / sigma, alpha));\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return 0.0;\\n    if (p === 1) return Infinity;\\n\\n    let [alpha, sigma] = params.slice(0, 2);\\n\\n    return sigma * Math.pow(-Math.log(1.0 - p), 1.0 / alpha);\\n  }\\n\\n  defaultXRange(params) {\\n    let [x1, x2] = this.ppf([0.001, 0.999], params);\\n\\n    \\n    if (x1 &lt; (x2 - x1) / 10.0) x1 = 0.0;\\n\\n    return [x1, x2];\\n  }\\n\\n  quantileSet(x, p, extraParams = []) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    let loglog1 = Math.log(-Math.log(1.0 - p1));\\n    let loglog2 = Math.log(-Math.log(1.0 - p2));\\n    let logx1 = Math.log(x1);\\n    let logx2 = Math.log(x2);\\n\\n    let alpha = (loglog2 - loglog1) / (logx2 - logx1);\\n    let sigma = Math.exp(logx2 - loglog2 / alpha);\\n\\n    return [[alpha, sigma], true];\\n  }\\n\\n  \\n}\\n\\n\\n\\nvar dist = new WeibullDistribution();\\n\\n\\nif (triggerCallbacks.active) {\\n  updateData(source_p, source_c, p_p, sliders, discrete);\\n}"}}]],["change:end",[{"id":"p3833"}]]]},"end":8}},"y_range":{"type":"object","name":"DataRange1d","id":"p3735"},"x_scale":{"type":"object","name":"LinearScale","id":"p3743"},"y_scale":{"type":"object","name":"LinearScale","id":"p3744"},"title":{"type":"object","name":"Title","id":"p3736","attributes":{"text":"Weibull"}},"renderers":[{"type":"object","name":"GlyphRenderer","id":"p3814","attributes":{"data_source":{"id":"p3793"},"view":{"type":"object","name":"CDSView","id":"p3815","attributes":{"filter":{"type":"object","name":"AllIndices","id":"p3816"}}},"glyph":{"type":"object","name":"Line","id":"p3811","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"line_color":"#1f77b4","line_width":2}},"nonselection_glyph":{"type":"object","name":"Line","id":"p3812","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"line_color":"#1f77b4","line_alpha":0.1,"line_width":2}},"muted_glyph":{"type":"object","name":"Line","id":"p3813","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"line_color":"#1f77b4","line_alpha":0.2,"line_width":2}}}}],"toolbar":{"type":"object","name":"Toolbar","id":"p3742","attributes":{"tools":[{"type":"object","name":"PanTool","id":"p3755"},{"type":"object","name":"WheelZoomTool","id":"p3756","attributes":{"renderers":"auto"}},{"type":"object","name":"BoxZoomTool","id":"p3757","attributes":{"overlay":{"type":"object","name":"BoxAnnotation","id":"p3758","attributes":{"syncable":false,"level":"overlay","visible":false,"left_units":"canvas","right_units":"canvas","top_units":"canvas","bottom_units":"canvas","line_color":"black","line_alpha":1.0,"line_width":2,"line_dash":[4,4],"fill_color":"lightgrey","fill_alpha":0.5}}}},{"type":"object","name":"SaveTool","id":"p3759"},{"type":"object","name":"ResetTool","id":"p3760"},{"type":"object","name":"HelpTool","id":"p3761"}]}},"toolbar_location":null,"left":[{"type":"object","name":"LinearAxis","id":"p3750","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p3751","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p3752"},"axis_label":"PDF","axis_label_text_font_style":"normal","major_label_policy":{"type":"object","name":"AllLabels","id":"p3753"}}}],"below":[{"type":"object","name":"LinearAxis","id":"p3745","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p3746","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p3747"},"axis_label":"y","major_label_policy":{"type":"object","name":"AllLabels","id":"p3748"}}}],"center":[{"type":"object","name":"Grid","id":"p3749","attributes":{"axis":{"id":"p3745"}}},{"type":"object","name":"Grid","id":"p3754","attributes":{"dimension":1,"axis":{"id":"p3750"}}}],"frame_width":300,"frame_height":175,"background_fill_alpha":0,"border_fill_alpha":0}}],["p_c",{"id":"p3762"}],["source_p",{"id":"p3793"}],["source_c",{"id":"p3796"}],["discrete",false],["n",400],["sliders",[{"id":"p3818"},{"id":"p3820"}]],["xBoxes",[{"id":"p3825"},{"id":"p3826"}]],["pBoxes",[{"id":"p3827"},{"id":"p3828"}]],["quantileSetterSwitch",{"id":"p3830"}],["quantileSetterDiv",{"id":"p3829"}],["triggerCallbacks",{"id":"p3831"}],["startBoxes",[{"id":"p3821"},{"id":"p3822"}]],["endBoxes",[{"id":"p3823"},{"id":"p3824"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let x = paramsFromBoxes(xBoxes);\\n  let p = paramsFromBoxes(pBoxes);\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ){\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n          endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);        \\n        }\\n        sliders[dist.activeParamsInds[i]].value = optimParams[i];\\n      }\\n\\n      params = paramsFromSliders(sliders); \\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.floor(xRange.start);\\n  let xRangeMax = Math.ceil(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c = [xRangeMin - 1, ...x_p.flatMap(x =&gt; [x, x]), xRangeMax + 1];\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = -0.04;\\n    p_c.y_range.end = 1.04;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = -pdfMax * 0.04;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264&#x27; + xMax.toString() + &#x27;.&lt;/p\\\\&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nclass WeibullDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Weibull&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0.0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03b1&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0.0;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    if (x &lt; 0) return NaN;\\n    if (x === 0) return 0.0;\\n    if (x === Infinity) return 0.0;\\n\\n    let [alpha, sigma] = params.slice(0, 2);\\n\\n    let logp = -Math.pow(x / sigma, alpha) + (alpha - 1) * Math.log(x) \\n                + Math.log(alpha) - alpha * Math.log(sigma);\\n\\n    return Math.exp(logp);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x &lt;= 0) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let [alpha, sigma] = params.slice(0, 2);\\n\\n    return 1 - Math.exp(-Math.pow(x / sigma, alpha));\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    if (p === 0) return 0.0;\\n    if (p === 1) return Infinity;\\n\\n    let [alpha, sigma] = params.slice(0, 2);\\n\\n    return sigma * Math.pow(-Math.log(1.0 - p), 1.0 / alpha);\\n  }\\n\\n  defaultXRange(params) {\\n    let [x1, x2] = this.ppf([0.001, 0.999], params);\\n\\n    \\n    if (x1 &lt; (x2 - x1) / 10.0) x1 = 0.0;\\n\\n    return [x1, x2];\\n  }\\n\\n  quantileSet(x, p, extraParams = []) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    let loglog1 = Math.log(-Math.log(1.0 - p1));\\n    let loglog2 = Math.log(-Math.log(1.0 - p2));\\n    let logx1 = Math.log(x1);\\n    let logx2 = Math.log(x2);\\n\\n    let alpha = (loglog2 - loglog1) / (logx2 - logx1);\\n    let sigma = Math.exp(logx2 - loglog2 / alpha);\\n\\n    return [[alpha, sigma], true];\\n  }\\n\\n  \\n}\\n\\n\\n\\nvar dist = new WeibullDistribution();\\n\\n\\n\\nif (cb_obj.active) {\\n  for (let i = 0; i &lt; sliders.length; i++) {\\n    if (!dist.fixedParamsInds.includes(i)) {\\n      sliders[i].title = dist.paramNames[i] + &#x27; (computed)&#x27;;\\n      sliders[i].disabled = true;\\n    }\\n  }\\n  for (let xBox of xBoxes) {\\n    xBox.disabled = false;\\n  }\\n  for (let pBox of pBoxes) {\\n    pBox.disabled = false;\\n  }\\n} else {\\n  for (let i = 0; i &lt; sliders.length; i++) {\\n    if (!dist.fixedParamsInds.includes(i)) {\\n      sliders[i].title = dist.paramNames[i];\\n      sliders[i].disabled = false;\\n    }\\n  }\\n  for (let xBox of xBoxes) {\\n    xBox.disabled = true;\\n  }\\n  for (let pBox of pBoxes) {\\n    pBox.disabled = true;\\n  }\\n  quantileSetterDiv.text = &#x27;&#x27;;\\n}"}}]]]}}}]}},{"type":"object","name":"Spacer","id":"p3885","attributes":{"width":10}},{"id":"p3829"}]}},{"type":"object","name":"Spacer","id":"p3887","attributes":{"height":10}},{"type":"object","name":"Row","id":"p3889","attributes":{"children":[{"type":"object","name":"Column","id":"p3873","attributes":{"children":[{"type":"object","name":"Row","id":"p3871","attributes":{"children":[{"type":"object","name":"Column","id":"p3864","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3863","attributes":{"height":4}},{"id":"p3821"}]}},{"id":"p3818"},{"type":"object","name":"Column","id":"p3866","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3865","attributes":{"height":4}},{"id":"p3823"}]}}]}},{"type":"object","name":"Row","id":"p3872","attributes":{"children":[{"type":"object","name":"Column","id":"p3868","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3867","attributes":{"height":4}},{"id":"p3822"}]}},{"id":"p3820"},{"type":"object","name":"Column","id":"p3870","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3869","attributes":{"height":4}},{"id":"p3824"}]}}]}}]}},{"type":"object","name":"Spacer","id":"p3888","attributes":{"width":20}},{"type":"object","name":"Column","id":"p3862","attributes":{"children":[{"type":"object","name":"Row","id":"p3860","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3844","attributes":{"width":20}},{"type":"object","name":"Column","id":"p3847","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3845","attributes":{"height":7}},{"type":"object","name":"Div","id":"p3846","attributes":{"text":"&lt;p&gt;&lt;b&gt;lower y: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p3825"},{"type":"object","name":"Spacer","id":"p3848","attributes":{"width":34}},{"type":"object","name":"Column","id":"p3851","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3849","attributes":{"height":7}},{"type":"object","name":"Div","id":"p3850","attributes":{"text":"&lt;p&gt;&lt;b&gt;upper y: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p3826"}]}},{"type":"object","name":"Row","id":"p3861","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3852","attributes":{"width":16}},{"type":"object","name":"Column","id":"p3855","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3853","attributes":{"height":7}},{"type":"object","name":"Div","id":"p3854","attributes":{"text":"&lt;p&gt;&lt;b&gt;quantile: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p3827"},{"type":"object","name":"Spacer","id":"p3856","attributes":{"width":30}},{"type":"object","name":"Column","id":"p3859","attributes":{"children":[{"type":"object","name":"Spacer","id":"p3857","attributes":{"height":7}},{"type":"object","name":"Div","id":"p3858","attributes":{"text":"&lt;p&gt;&lt;b&gt;quantile: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p3828"}]}}]}}]}},{"type":"object","name":"Spacer","id":"p3890","attributes":{"height":10}},{"type":"object","name":"GridPlot","id":"p3882","attributes":{"rows":null,"cols":null,"toolbar":{"type":"object","name":"Toolbar","id":"p3881","attributes":{"tools":[{"type":"object","name":"ToolProxy","id":"p3875","attributes":{"tools":[{"id":"p3784"},{"id":"p3755"},{"id":"p3784"},{"id":"p3755"}]}},{"type":"object","name":"ToolProxy","id":"p3876","attributes":{"tools":[{"id":"p3785"},{"id":"p3756"},{"id":"p3785"},{"id":"p3756"}]}},{"type":"object","name":"ToolProxy","id":"p3877","attributes":{"tools":[{"id":"p3786"},{"id":"p3757"},{"id":"p3786"},{"id":"p3757"}]}},{"type":"object","name":"SaveTool","id":"p3878"},{"type":"object","name":"ToolProxy","id":"p3879","attributes":{"tools":[{"id":"p3789"},{"id":"p3760"},{"id":"p3789"},{"id":"p3760"}]}},{"type":"object","name":"ToolProxy","id":"p3880","attributes":{"tools":[{"id":"p3790"},{"id":"p3761"},{"id":"p3790"},{"id":"p3761"}]}}]}},"toolbar_location":"right","children":[[{"id":"p3733"},0,0],[{"type":"object","name":"Spacer","id":"p3874","attributes":{"width":30}},0,1],[{"id":"p3762"},0,2]]}}]}}]}}';
                  const render_items = [{"docid":"618a4d8f-0ab1-4e07-a630-3e8003831f09","roots":{"p3891":"afc67744-caa5-4742-a004-28d2a5d15082"},"root_ids":["p3891"]}];
                  root.Bokeh.embed.embed_items(docs_json, render_items);
                  }
                  if (root.Bokeh !== undefined) {
                    embed_document(root);
                  } else {
                    let attempts = 0;
                    const timer = setInterval(function(root) {
                      if (root.Bokeh !== undefined) {
                        clearInterval(timer);
                        embed_document(root);
                      } else {
                        attempts++;
                        if (attempts > 100) {
                          clearInterval(timer);
                          console.log("Bokeh: ERROR: Unable to run BokehJS code because BokehJS library is missing");
                        }
                      }
                    }, 10, root)
                  }
                })(window);
              });
            };
            if (document.readyState != "loading") fn();
            else document.addEventListener("DOMContentLoaded", fn);
          })();
        },
    function(Bokeh) {
        }
      ];
    
      function run_inline_js() {
        for (let i = 0; i < inline_js.length; i++) {
          inline_js[i].call(root, root.Bokeh);
        }
      }
    
      if (root._bokeh_is_loading === 0) {
        console.debug("Bokeh: BokehJS loaded, going straight to plotting");
        run_inline_js();
      } else {
        load_libs(css_urls, js_urls, function() {
          console.debug("Bokeh: BokehJS plotting callback run at", now());
          run_inline_js();
        });
      }
    }(window));
  };
  if (document.readyState != "loading") fn();
  else document.addEventListener("DOMContentLoaded", fn);
})();