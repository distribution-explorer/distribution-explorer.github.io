(function() {
  const fn = function() {
    (function(root) {
      function now() {
        return new Date();
      }
    
      const force = false;
    
      if (typeof root._bokeh_onload_callbacks === "undefined" || force === true) {
        root._bokeh_onload_callbacks = [];
        root._bokeh_is_loading = undefined;
      }
    
    
    const element = document.getElementById("e4db0293-6bdb-426b-909a-70833bea43a4");
        if (element == null) {
          console.warn("Bokeh: autoload.js configured with elementid 'e4db0293-6bdb-426b-909a-70833bea43a4' but no matching script tag was found.")
        }
      function run_callbacks() {
        try {
          root._bokeh_onload_callbacks.forEach(function(callback) {
            if (callback != null)
              callback();
          });
        } finally {
          delete root._bokeh_onload_callbacks
        }
        console.debug("Bokeh: all callbacks have finished");
      }
    
      function load_libs(css_urls, js_urls, callback) {
        if (css_urls == null) css_urls = [];
        if (js_urls == null) js_urls = [];
    
        root._bokeh_onload_callbacks.push(callback);
        if (root._bokeh_is_loading > 0) {
          console.debug("Bokeh: BokehJS is being loaded, scheduling callback at", now());
          return null;
        }
        if (js_urls == null || js_urls.length === 0) {
          run_callbacks();
          return null;
        }
        console.debug("Bokeh: BokehJS not loaded, scheduling load and callback at", now());
        root._bokeh_is_loading = css_urls.length + js_urls.length;
    
        function on_load() {
          root._bokeh_is_loading--;
          if (root._bokeh_is_loading === 0) {
            console.debug("Bokeh: all BokehJS libraries/stylesheets loaded");
            run_callbacks()
          }
        }
    
        function on_error(url) {
          console.error("failed to load " + url);
        }
    
        for (let i = 0; i < css_urls.length; i++) {
          const url = css_urls[i];
          const element = document.createElement("link");
          element.onload = on_load;
          element.onerror = on_error.bind(null, url);
          element.rel = "stylesheet";
          element.type = "text/css";
          element.href = url;
          console.debug("Bokeh: injecting link tag for BokehJS stylesheet: ", url);
          document.body.appendChild(element);
        }
    
        for (let i = 0; i < js_urls.length; i++) {
          const url = js_urls[i];
          const element = document.createElement('script');
          element.onload = on_load;
          element.onerror = on_error.bind(null, url);
          element.async = false;
          element.src = url;
          console.debug("Bokeh: injecting script tag for BokehJS library: ", url);
          document.head.appendChild(element);
        }
      };
    
      function inject_raw_css(css) {
        const element = document.createElement("style");
        element.appendChild(document.createTextNode(css));
        document.body.appendChild(element);
      }
    
      const js_urls = ["https://cdn.bokeh.org/bokeh/release/bokeh-3.3.0.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-gl-3.3.0.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-widgets-3.3.0.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-tables-3.3.0.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-mathjax-3.3.0.min.js"];
      const css_urls = [];
    
      const inline_js = [    function(Bokeh) {
          Bokeh.set_log_level("info");
        },
        function(Bokeh) {
          (function() {
            const fn = function() {
              Bokeh.safely(function() {
                (function(root) {
                  function embed_document(root) {
                  const docs_json = '{"4672ddda-b9b4-427a-8839-7c5b3b452fa5":{"version":"3.3.0","title":"Bokeh Application","roots":[{"type":"object","name":"Column","id":"p1912","attributes":{"children":[{"type":"object","name":"Row","id":"p1907","attributes":{"children":[{"type":"object","name":"Spacer","id":"p1905","attributes":{"width":409}},{"type":"object","name":"Row","id":"p1878","attributes":{"children":[{"type":"object","name":"Div","id":"p1876","attributes":{"text":"&lt;p&gt;&lt;b&gt;Quantile setter mode&lt;/b&gt;&lt;/p&gt;"}},{"type":"object","name":"Spacer","id":"p1877","attributes":{"width":2}},{"type":"object","name":"Switch","id":"p1867","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:active",[{"type":"object","name":"CustomJS","id":"p1871","attributes":{"args":{"type":"map","entries":[["p_p",{"type":"object","name":"Figure","id":"p1776","attributes":{"x_range":{"type":"object","name":"Range1d","id":"p1834","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:start",[{"type":"object","name":"CustomJS","id":"p1870","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p1776"}],["p_c",{"type":"object","name":"Figure","id":"p1805","attributes":{"js_event_callbacks":{"type":"map","entries":[["reset",[{"type":"object","name":"CustomJS","id":"p1873","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p1776"}],["p_c",{"id":"p1805"}],["source_p",{"type":"object","name":"ColumnDataSource","id":"p1836","attributes":{"selected":{"type":"object","name":"Selection","id":"p1837","attributes":{"indices":[],"line_indices":[]}},"selection_policy":{"type":"object","name":"UnionRenderers","id":"p1838"},"data":{"type":"map","entries":[["x",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}],["y_p",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}]]}}}],["source_c",{"type":"object","name":"ColumnDataSource","id":"p1839","attributes":{"selected":{"type":"object","name":"Selection","id":"p1840","attributes":{"indices":[],"line_indices":[]}},"selection_policy":{"type":"object","name":"UnionRenderers","id":"p1841"},"data":{"type":"map","entries":[["x",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}],["y_c",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}]]}}}],["discrete",false],["n",400],["sliders",[{"type":"object","name":"Slider","id":"p1861","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p1869","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p1776"}],["p_c",{"id":"p1805"}],["source_p",{"id":"p1836"}],["source_c",{"id":"p1839"}],["discrete",false],["n",400],["sliders",[{"id":"p1861"}]],["xBoxes",[{"type":"object","name":"TextInput","id":"p1864","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p1872","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p1776"}],["p_c",{"id":"p1805"}],["source_p",{"id":"p1836"}],["source_c",{"id":"p1839"}],["discrete",false],["n",400],["sliders",[{"id":"p1861"}]],["xBoxes",[{"id":"p1864"}]],["pBoxes",[{"type":"object","name":"TextInput","id":"p1865","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p1872"}]]]},"disabled":true,"width":80,"value":"0.9500"}}]],["quantileSetterSwitch",{"id":"p1867"}],["quantileSetterDiv",{"type":"object","name":"Div","id":"p1866"}],["triggerCallbacks",{"type":"object","name":"Switch","id":"p1868","attributes":{"active":true}}],["startBoxes",[{"type":"object","name":"TextInput","id":"p1862","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p1874","attributes":{"args":{"type":"map","entries":[["minValue","0"],["maxValue","Infinity"],["slider",{"id":"p1861"}]]},"code":"\\n\\nslider.start = Math.max(minValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"0.1"}}]],["endBoxes",[{"type":"object","name":"TextInput","id":"p1863","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p1875","attributes":{"args":{"type":"map","entries":[["minValue","0"],["maxValue","Infinity"],["slider",{"id":"p1861"}]]},"code":"\\n\\nslider.end = Math.min(maxValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"1"}}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let x = paramsFromBoxes(xBoxes);\\n  let p = paramsFromBoxes(pBoxes);\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ){\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n          endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);        \\n        }\\n        sliders[dist.activeParamsInds[i]].value = optimParams[i];\\n      }\\n\\n      params = paramsFromSliders(sliders); \\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.floor(xRange.start);\\n  let xRangeMax = Math.ceil(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c = [xRangeMin - 1, ...x_p.flatMap(x =&gt; [x, x]), xRangeMax + 1];\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = -0.04;\\n    p_c.y_range.end = 1.04;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = -pdfMax * 0.04;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264&#x27; + xMax.toString() + &#x27;.&lt;/p\\\\&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nclass ExponentialDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Exponential&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03b2&#x27;];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0.0;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let beta = params[0];\\n\\n    if (x &lt; 0) return NaN;\\n    if (x == Infinity) return 0.0;\\n\\n    return beta * Math.exp(-beta * x);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let beta = params[0];\\n\\n    if (x &lt; 0) return 0.0;\\n    if (x == Infinity) return 0.0;\\n\\n    return 1 - Math.exp(-beta * x);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let beta = params[0];\\n\\n    if (p == 0) return 0.0;\\n    if (p == 1) return Infinity;\\n\\n    return -Math.log(1.0 - p) / beta;\\n  }\\n\\n  quantileSet(x, p) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n\\n    let betaOptim;\\n    if (x1 == 0 || p1 == 1) {\\n      betaOptim = Infinity;\\n    }\\n    else {\\n      betaOptim = -Math.log(1.0 - p1) / x1\\n    }\\n\\n    return [[betaOptim], true];\\n  }\\n\\n  defaultXRange(params) {\\n    return [0.0, this.ppfSingleValue(0.999, params)];\\n  }\\n\\n}\\n\\n\\n\\nvar dist = new ExponentialDistribution();\\n\\n\\n\\nif (quantileSetterSwitch.active) {\\n  quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p);\\n}"}}]]]},"disabled":true,"width":80,"value":"11.9829"}}]],["pBoxes",[{"id":"p1865"}]],["quantileSetterSwitch",{"id":"p1867"}],["quantileSetterDiv",{"id":"p1866"}],["triggerCallbacks",{"id":"p1868"}],["startBoxes",[{"id":"p1862"}]],["endBoxes",[{"id":"p1863"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let x = paramsFromBoxes(xBoxes);\\n  let p = paramsFromBoxes(pBoxes);\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ){\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n          endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);        \\n        }\\n        sliders[dist.activeParamsInds[i]].value = optimParams[i];\\n      }\\n\\n      params = paramsFromSliders(sliders); \\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.floor(xRange.start);\\n  let xRangeMax = Math.ceil(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c = [xRangeMin - 1, ...x_p.flatMap(x =&gt; [x, x]), xRangeMax + 1];\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = -0.04;\\n    p_c.y_range.end = 1.04;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = -pdfMax * 0.04;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264&#x27; + xMax.toString() + &#x27;.&lt;/p\\\\&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nclass ExponentialDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Exponential&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03b2&#x27;];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0.0;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let beta = params[0];\\n\\n    if (x &lt; 0) return NaN;\\n    if (x == Infinity) return 0.0;\\n\\n    return beta * Math.exp(-beta * x);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let beta = params[0];\\n\\n    if (x &lt; 0) return 0.0;\\n    if (x == Infinity) return 0.0;\\n\\n    return 1 - Math.exp(-beta * x);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let beta = params[0];\\n\\n    if (p == 0) return 0.0;\\n    if (p == 1) return Infinity;\\n\\n    return -Math.log(1.0 - p) / beta;\\n  }\\n\\n  quantileSet(x, p) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n\\n    let betaOptim;\\n    if (x1 == 0 || p1 == 1) {\\n      betaOptim = Infinity;\\n    }\\n    else {\\n      betaOptim = -Math.log(1.0 - p1) / x1\\n    }\\n\\n    return [[betaOptim], true];\\n  }\\n\\n  defaultXRange(params) {\\n    return [0.0, this.ppfSingleValue(0.999, params)];\\n  }\\n\\n}\\n\\n\\n\\nvar dist = new ExponentialDistribution();\\n\\n\\n\\nif (triggerCallbacks.active &amp;&amp; !cb_obj.disabled) {\\n\\tif (quantileSetterSwitch.active) {\\n\\t\\tquantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p);\\n\\t}\\n\\telse {\\n\\t\\tupdateData(source_p, source_c, p_p, sliders, discrete);\\n\\t\\tupdateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes);\\n\\t}\\n}"}}]]]},"width":200,"title":"\\u03b2","format":{"type":"object","name":"CustomJSTickFormatter","id":"p1860","attributes":{"code":"return tick.toPrecision(4)"}},"start":0.1,"end":1,"value":0.25,"step":0.01}}]],["xBoxes",[{"id":"p1864"}]],["pBoxes",[{"id":"p1865"}]],["quantileSetterSwitch",{"id":"p1867"}],["quantileSetterDiv",{"id":"p1866"}],["triggerCallbacks",{"id":"p1868"}],["startBoxes",[{"id":"p1862"}]],["endBoxes",[{"id":"p1863"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let x = paramsFromBoxes(xBoxes);\\n  let p = paramsFromBoxes(pBoxes);\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ){\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n          endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);        \\n        }\\n        sliders[dist.activeParamsInds[i]].value = optimParams[i];\\n      }\\n\\n      params = paramsFromSliders(sliders); \\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.floor(xRange.start);\\n  let xRangeMax = Math.ceil(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c = [xRangeMin - 1, ...x_p.flatMap(x =&gt; [x, x]), xRangeMax + 1];\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = -0.04;\\n    p_c.y_range.end = 1.04;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = -pdfMax * 0.04;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264&#x27; + xMax.toString() + &#x27;.&lt;/p\\\\&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nclass ExponentialDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Exponential&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03b2&#x27;];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0.0;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let beta = params[0];\\n\\n    if (x &lt; 0) return NaN;\\n    if (x == Infinity) return 0.0;\\n\\n    return beta * Math.exp(-beta * x);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let beta = params[0];\\n\\n    if (x &lt; 0) return 0.0;\\n    if (x == Infinity) return 0.0;\\n\\n    return 1 - Math.exp(-beta * x);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let beta = params[0];\\n\\n    if (p == 0) return 0.0;\\n    if (p == 1) return Infinity;\\n\\n    return -Math.log(1.0 - p) / beta;\\n  }\\n\\n  quantileSet(x, p) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n\\n    let betaOptim;\\n    if (x1 == 0 || p1 == 1) {\\n      betaOptim = Infinity;\\n    }\\n    else {\\n      betaOptim = -Math.log(1.0 - p1) / x1\\n    }\\n\\n    return [[betaOptim], true];\\n  }\\n\\n  defaultXRange(params) {\\n    return [0.0, this.ppfSingleValue(0.999, params)];\\n  }\\n\\n}\\n\\n\\n\\nvar dist = new ExponentialDistribution();\\n\\n\\n\\nlet params = paramsFromSliders(sliders); \\n\\n\\nlet [x1, x2] = dist.defaultXRange(params);\\n\\n\\ntriggerCallbacks.active = false;\\n\\n\\np_p.x_range.start = x1;\\np_p.x_range.end = x2;\\n\\nupdateData(source_p, source_c, p_p, sliders, discrete);\\n\\n\\nsetYRanges(p_p, p_c, source_p);  \\n\\ntriggerCallbacks.active = true;\\n"}}]]]},"x_range":{"id":"p1834"},"y_range":{"type":"object","name":"Range1d","id":"p1835","attributes":{"start":-0.04,"end":1.04}},"x_scale":{"type":"object","name":"LinearScale","id":"p1815"},"y_scale":{"type":"object","name":"LinearScale","id":"p1816"},"title":{"type":"object","name":"Title","id":"p1808","attributes":{"text":" "}},"renderers":[{"type":"object","name":"GlyphRenderer","id":"p1848","attributes":{"data_source":{"id":"p1839"},"view":{"type":"object","name":"CDSView","id":"p1849","attributes":{"filter":{"type":"object","name":"AllIndices","id":"p1850"}}},"glyph":{"type":"object","name":"Line","id":"p1845","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_width":2}},"nonselection_glyph":{"type":"object","name":"Line","id":"p1846","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_alpha":0.1,"line_width":2}},"muted_glyph":{"type":"object","name":"Line","id":"p1847","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_alpha":0.2,"line_width":2}}}}],"toolbar":{"type":"object","name":"Toolbar","id":"p1814","attributes":{"tools":[{"type":"object","name":"PanTool","id":"p1827"},{"type":"object","name":"WheelZoomTool","id":"p1828","attributes":{"renderers":"auto"}},{"type":"object","name":"BoxZoomTool","id":"p1829","attributes":{"overlay":{"type":"object","name":"BoxAnnotation","id":"p1830","attributes":{"syncable":false,"level":"overlay","visible":false,"left_units":"canvas","right_units":"canvas","top_units":"canvas","bottom_units":"canvas","line_color":"black","line_alpha":1.0,"line_width":2,"line_dash":[4,4],"fill_color":"lightgrey","fill_alpha":0.5}}}},{"type":"object","name":"SaveTool","id":"p1831"},{"type":"object","name":"ResetTool","id":"p1832"},{"type":"object","name":"HelpTool","id":"p1833"}]}},"toolbar_location":null,"left":[{"type":"object","name":"LinearAxis","id":"p1822","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p1823","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p1824"},"axis_label":"CDF","axis_label_text_font_style":"normal","major_label_policy":{"type":"object","name":"AllLabels","id":"p1825"}}}],"below":[{"type":"object","name":"LinearAxis","id":"p1817","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p1818","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p1819"},"axis_label":"y","major_label_policy":{"type":"object","name":"AllLabels","id":"p1820"}}}],"center":[{"type":"object","name":"Grid","id":"p1821","attributes":{"axis":{"id":"p1817"}}},{"type":"object","name":"Grid","id":"p1826","attributes":{"dimension":1,"axis":{"id":"p1822"}}}],"frame_width":300,"frame_height":175,"background_fill_alpha":0,"border_fill_alpha":0}}],["source_p",{"id":"p1836"}],["source_c",{"id":"p1839"}],["discrete",false],["n",400],["sliders",[{"id":"p1861"}]],["xBoxes",[{"id":"p1864"}]],["pBoxes",[{"id":"p1865"}]],["quantileSetterSwitch",{"id":"p1867"}],["quantileSetterDiv",{"id":"p1866"}],["triggerCallbacks",{"id":"p1868"}],["startBoxes",[{"id":"p1862"}]],["endBoxes",[{"id":"p1863"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let x = paramsFromBoxes(xBoxes);\\n  let p = paramsFromBoxes(pBoxes);\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ){\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n          endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);        \\n        }\\n        sliders[dist.activeParamsInds[i]].value = optimParams[i];\\n      }\\n\\n      params = paramsFromSliders(sliders); \\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.floor(xRange.start);\\n  let xRangeMax = Math.ceil(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c = [xRangeMin - 1, ...x_p.flatMap(x =&gt; [x, x]), xRangeMax + 1];\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = -0.04;\\n    p_c.y_range.end = 1.04;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = -pdfMax * 0.04;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264&#x27; + xMax.toString() + &#x27;.&lt;/p\\\\&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nclass ExponentialDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Exponential&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03b2&#x27;];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0.0;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let beta = params[0];\\n\\n    if (x &lt; 0) return NaN;\\n    if (x == Infinity) return 0.0;\\n\\n    return beta * Math.exp(-beta * x);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let beta = params[0];\\n\\n    if (x &lt; 0) return 0.0;\\n    if (x == Infinity) return 0.0;\\n\\n    return 1 - Math.exp(-beta * x);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let beta = params[0];\\n\\n    if (p == 0) return 0.0;\\n    if (p == 1) return Infinity;\\n\\n    return -Math.log(1.0 - p) / beta;\\n  }\\n\\n  quantileSet(x, p) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n\\n    let betaOptim;\\n    if (x1 == 0 || p1 == 1) {\\n      betaOptim = Infinity;\\n    }\\n    else {\\n      betaOptim = -Math.log(1.0 - p1) / x1\\n    }\\n\\n    return [[betaOptim], true];\\n  }\\n\\n  defaultXRange(params) {\\n    return [0.0, this.ppfSingleValue(0.999, params)];\\n  }\\n\\n}\\n\\n\\n\\nvar dist = new ExponentialDistribution();\\n\\n\\nif (triggerCallbacks.active) {\\n  updateData(source_p, source_c, p_p, sliders, discrete);\\n}"}}]],["change:end",[{"id":"p1870"}]]]},"end":30}},"y_range":{"type":"object","name":"DataRange1d","id":"p1778"},"x_scale":{"type":"object","name":"LinearScale","id":"p1786"},"y_scale":{"type":"object","name":"LinearScale","id":"p1787"},"title":{"type":"object","name":"Title","id":"p1779","attributes":{"text":"Exponential"}},"renderers":[{"type":"object","name":"GlyphRenderer","id":"p1857","attributes":{"data_source":{"id":"p1836"},"view":{"type":"object","name":"CDSView","id":"p1858","attributes":{"filter":{"type":"object","name":"AllIndices","id":"p1859"}}},"glyph":{"type":"object","name":"Line","id":"p1854","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"line_color":"#1f77b4","line_width":2}},"nonselection_glyph":{"type":"object","name":"Line","id":"p1855","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"line_color":"#1f77b4","line_alpha":0.1,"line_width":2}},"muted_glyph":{"type":"object","name":"Line","id":"p1856","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"line_color":"#1f77b4","line_alpha":0.2,"line_width":2}}}}],"toolbar":{"type":"object","name":"Toolbar","id":"p1785","attributes":{"tools":[{"type":"object","name":"PanTool","id":"p1798"},{"type":"object","name":"WheelZoomTool","id":"p1799","attributes":{"renderers":"auto"}},{"type":"object","name":"BoxZoomTool","id":"p1800","attributes":{"overlay":{"type":"object","name":"BoxAnnotation","id":"p1801","attributes":{"syncable":false,"level":"overlay","visible":false,"left_units":"canvas","right_units":"canvas","top_units":"canvas","bottom_units":"canvas","line_color":"black","line_alpha":1.0,"line_width":2,"line_dash":[4,4],"fill_color":"lightgrey","fill_alpha":0.5}}}},{"type":"object","name":"SaveTool","id":"p1802"},{"type":"object","name":"ResetTool","id":"p1803"},{"type":"object","name":"HelpTool","id":"p1804"}]}},"toolbar_location":null,"left":[{"type":"object","name":"LinearAxis","id":"p1793","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p1794","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p1795"},"axis_label":"PDF","axis_label_text_font_style":"normal","major_label_policy":{"type":"object","name":"AllLabels","id":"p1796"}}}],"below":[{"type":"object","name":"LinearAxis","id":"p1788","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p1789","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p1790"},"axis_label":"y","major_label_policy":{"type":"object","name":"AllLabels","id":"p1791"}}}],"center":[{"type":"object","name":"Grid","id":"p1792","attributes":{"axis":{"id":"p1788"}}},{"type":"object","name":"Grid","id":"p1797","attributes":{"dimension":1,"axis":{"id":"p1793"}}}],"frame_width":300,"frame_height":175,"background_fill_alpha":0,"border_fill_alpha":0}}],["p_c",{"id":"p1805"}],["source_p",{"id":"p1836"}],["source_c",{"id":"p1839"}],["discrete",false],["n",400],["sliders",[{"id":"p1861"}]],["xBoxes",[{"id":"p1864"}]],["pBoxes",[{"id":"p1865"}]],["quantileSetterSwitch",{"id":"p1867"}],["quantileSetterDiv",{"id":"p1866"}],["triggerCallbacks",{"id":"p1868"}],["startBoxes",[{"id":"p1862"}]],["endBoxes",[{"id":"p1863"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let x = paramsFromBoxes(xBoxes);\\n  let p = paramsFromBoxes(pBoxes);\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ){\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n          endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);        \\n        }\\n        sliders[dist.activeParamsInds[i]].value = optimParams[i];\\n      }\\n\\n      params = paramsFromSliders(sliders); \\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.floor(xRange.start);\\n  let xRangeMax = Math.ceil(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c = [xRangeMin - 1, ...x_p.flatMap(x =&gt; [x, x]), xRangeMax + 1];\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = -0.04;\\n    p_c.y_range.end = 1.04;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = -pdfMax * 0.04;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264&#x27; + xMax.toString() + &#x27;.&lt;/p\\\\&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nclass ExponentialDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Exponential&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03b2&#x27;];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0.0;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let beta = params[0];\\n\\n    if (x &lt; 0) return NaN;\\n    if (x == Infinity) return 0.0;\\n\\n    return beta * Math.exp(-beta * x);\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let beta = params[0];\\n\\n    if (x &lt; 0) return 0.0;\\n    if (x == Infinity) return 0.0;\\n\\n    return 1 - Math.exp(-beta * x);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let beta = params[0];\\n\\n    if (p == 0) return 0.0;\\n    if (p == 1) return Infinity;\\n\\n    return -Math.log(1.0 - p) / beta;\\n  }\\n\\n  quantileSet(x, p) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n\\n    let betaOptim;\\n    if (x1 == 0 || p1 == 1) {\\n      betaOptim = Infinity;\\n    }\\n    else {\\n      betaOptim = -Math.log(1.0 - p1) / x1\\n    }\\n\\n    return [[betaOptim], true];\\n  }\\n\\n  defaultXRange(params) {\\n    return [0.0, this.ppfSingleValue(0.999, params)];\\n  }\\n\\n}\\n\\n\\n\\nvar dist = new ExponentialDistribution();\\n\\n\\n\\nif (cb_obj.active) {\\n  for (let i = 0; i &lt; sliders.length; i++) {\\n    if (!dist.fixedParamsInds.includes(i)) {\\n      sliders[i].title = dist.paramNames[i] + &#x27; (computed)&#x27;;\\n      sliders[i].disabled = true;\\n    }\\n  }\\n  for (let xBox of xBoxes) {\\n    xBox.disabled = false;\\n  }\\n  for (let pBox of pBoxes) {\\n    pBox.disabled = false;\\n  }\\n} else {\\n  for (let i = 0; i &lt; sliders.length; i++) {\\n    if (!dist.fixedParamsInds.includes(i)) {\\n      sliders[i].title = dist.paramNames[i];\\n      sliders[i].disabled = false;\\n    }\\n  }\\n  for (let xBox of xBoxes) {\\n    xBox.disabled = true;\\n  }\\n  for (let pBox of pBoxes) {\\n    pBox.disabled = true;\\n  }\\n  quantileSetterDiv.text = &#x27;&#x27;;\\n}"}}]]]}}}]}},{"type":"object","name":"Spacer","id":"p1906","attributes":{"width":10}},{"id":"p1866"}]}},{"type":"object","name":"Spacer","id":"p1908","attributes":{"height":10}},{"type":"object","name":"Row","id":"p1910","attributes":{"children":[{"type":"object","name":"Column","id":"p1894","attributes":{"children":[{"type":"object","name":"Row","id":"p1893","attributes":{"children":[{"type":"object","name":"Column","id":"p1890","attributes":{"children":[{"type":"object","name":"Spacer","id":"p1889","attributes":{"height":4}},{"id":"p1862"}]}},{"id":"p1861"},{"type":"object","name":"Column","id":"p1892","attributes":{"children":[{"type":"object","name":"Spacer","id":"p1891","attributes":{"height":4}},{"id":"p1863"}]}}]}}]}},{"type":"object","name":"Spacer","id":"p1909","attributes":{"width":20}},{"type":"object","name":"Column","id":"p1888","attributes":{"children":[{"type":"object","name":"Row","id":"p1887","attributes":{"children":[{"type":"object","name":"Spacer","id":"p1879","attributes":{"width":20}},{"type":"object","name":"Column","id":"p1882","attributes":{"children":[{"type":"object","name":"Spacer","id":"p1880","attributes":{"height":7}},{"type":"object","name":"Div","id":"p1881","attributes":{"text":"&lt;p&gt;&lt;b&gt;y: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p1864"},{"type":"object","name":"Spacer","id":"p1883","attributes":{"width":16}},{"type":"object","name":"Column","id":"p1886","attributes":{"children":[{"type":"object","name":"Spacer","id":"p1884","attributes":{"height":7}},{"type":"object","name":"Div","id":"p1885","attributes":{"text":"&lt;p&gt;&lt;b&gt;quantile: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p1865"}]}}]}}]}},{"type":"object","name":"Spacer","id":"p1911","attributes":{"height":10}},{"type":"object","name":"GridPlot","id":"p1903","attributes":{"rows":null,"cols":null,"toolbar":{"type":"object","name":"Toolbar","id":"p1902","attributes":{"tools":[{"type":"object","name":"ToolProxy","id":"p1896","attributes":{"tools":[{"id":"p1798"},{"id":"p1827"},{"id":"p1798"},{"id":"p1827"}]}},{"type":"object","name":"ToolProxy","id":"p1897","attributes":{"tools":[{"id":"p1799"},{"id":"p1828"},{"id":"p1799"},{"id":"p1828"}]}},{"type":"object","name":"ToolProxy","id":"p1898","attributes":{"tools":[{"id":"p1800"},{"id":"p1829"},{"id":"p1800"},{"id":"p1829"}]}},{"type":"object","name":"SaveTool","id":"p1899"},{"type":"object","name":"ToolProxy","id":"p1900","attributes":{"tools":[{"id":"p1803"},{"id":"p1832"},{"id":"p1803"},{"id":"p1832"}]}},{"type":"object","name":"ToolProxy","id":"p1901","attributes":{"tools":[{"id":"p1804"},{"id":"p1833"},{"id":"p1804"},{"id":"p1833"}]}}]}},"toolbar_location":"right","children":[[{"id":"p1776"},0,0],[{"type":"object","name":"Spacer","id":"p1895","attributes":{"width":30}},0,1],[{"id":"p1805"},0,2]]}}]}}]}}';
                  const render_items = [{"docid":"4672ddda-b9b4-427a-8839-7c5b3b452fa5","roots":{"p1912":"e4db0293-6bdb-426b-909a-70833bea43a4"},"root_ids":["p1912"]}];
                  root.Bokeh.embed.embed_items(docs_json, render_items);
                  }
                  if (root.Bokeh !== undefined) {
                    embed_document(root);
                  } else {
                    let attempts = 0;
                    const timer = setInterval(function(root) {
                      if (root.Bokeh !== undefined) {
                        clearInterval(timer);
                        embed_document(root);
                      } else {
                        attempts++;
                        if (attempts > 100) {
                          clearInterval(timer);
                          console.log("Bokeh: ERROR: Unable to run BokehJS code because BokehJS library is missing");
                        }
                      }
                    }, 10, root)
                  }
                })(window);
              });
            };
            if (document.readyState != "loading") fn();
            else document.addEventListener("DOMContentLoaded", fn);
          })();
        },
    function(Bokeh) {
        }
      ];
    
      function run_inline_js() {
        for (let i = 0; i < inline_js.length; i++) {
          inline_js[i].call(root, root.Bokeh);
        }
      }
    
      if (root._bokeh_is_loading === 0) {
        console.debug("Bokeh: BokehJS loaded, going straight to plotting");
        run_inline_js();
      } else {
        load_libs(css_urls, js_urls, function() {
          console.debug("Bokeh: BokehJS plotting callback run at", now());
          run_inline_js();
        });
      }
    }(window));
  };
  if (document.readyState != "loading") fn();
  else document.addEventListener("DOMContentLoaded", fn);
})();