(function() {
  const fn = function() {
    'use strict';
    (function(root) {
      function now() {
        return new Date();
      }
    
      const force = false;
    
      if (typeof root._bokeh_onload_callbacks === "undefined" || force === true) {
        root._bokeh_onload_callbacks = [];
        root._bokeh_is_loading = undefined;
      }
    
    
    const element = document.getElementById("de17555b-2dc2-4312-beab-b36360a5cd9d");
        if (element == null) {
          console.warn("Bokeh: autoload.js configured with elementid 'de17555b-2dc2-4312-beab-b36360a5cd9d' but no matching script tag was found.")
        }
      function run_callbacks() {
        try {
          root._bokeh_onload_callbacks.forEach(function(callback) {
            if (callback != null)
              callback();
          });
        } finally {
          delete root._bokeh_onload_callbacks
        }
        console.debug("Bokeh: all callbacks have finished");
      }
    
      function load_libs(css_urls, js_urls, callback) {
        if (css_urls == null) css_urls = [];
        if (js_urls == null) js_urls = [];
    
        root._bokeh_onload_callbacks.push(callback);
        if (root._bokeh_is_loading > 0) {
          console.debug("Bokeh: BokehJS is being loaded, scheduling callback at", now());
          return null;
        }
        if (js_urls == null || js_urls.length === 0) {
          run_callbacks();
          return null;
        }
        console.debug("Bokeh: BokehJS not loaded, scheduling load and callback at", now());
        root._bokeh_is_loading = css_urls.length + js_urls.length;
    
        function on_load() {
          root._bokeh_is_loading--;
          if (root._bokeh_is_loading === 0) {
            console.debug("Bokeh: all BokehJS libraries/stylesheets loaded");
            run_callbacks()
          }
        }
    
        function on_error(url) {
          console.error("failed to load " + url);
        }
    
        for (let i = 0; i < css_urls.length; i++) {
          const url = css_urls[i];
          const element = document.createElement("link");
          element.onload = on_load;
          element.onerror = on_error.bind(null, url);
          element.rel = "stylesheet";
          element.type = "text/css";
          element.href = url;
          console.debug("Bokeh: injecting link tag for BokehJS stylesheet: ", url);
          document.body.appendChild(element);
        }
    
        for (let i = 0; i < js_urls.length; i++) {
          const url = js_urls[i];
          const element = document.createElement('script');
          element.onload = on_load;
          element.onerror = on_error.bind(null, url);
          element.async = false;
          element.src = url;
          console.debug("Bokeh: injecting script tag for BokehJS library: ", url);
          document.head.appendChild(element);
        }
      };
    
      function inject_raw_css(css) {
        const element = document.createElement("style");
        element.appendChild(document.createTextNode(css));
        document.body.appendChild(element);
      }
    
      const js_urls = ["https://cdn.bokeh.org/bokeh/release/bokeh-3.4.1.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-gl-3.4.1.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-widgets-3.4.1.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-tables-3.4.1.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-mathjax-3.4.1.min.js"];
      const css_urls = [];
    
      const inline_js = [    function(Bokeh) {
          Bokeh.set_log_level("info");
        },
        function(Bokeh) {
          (function() {
            const fn = function() {
              Bokeh.safely(function() {
                (function(root) {
                  function embed_document(root) {
                  const docs_json = '{"b3c66964-bbfb-4986-b42a-98a6c5781aec":{"version":"3.4.1","title":"Bokeh Application","roots":[{"type":"object","name":"Column","id":"p2122","attributes":{"children":[{"type":"object","name":"Row","id":"p2117","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2115","attributes":{"width":409}},{"type":"object","name":"Row","id":"p2075","attributes":{"children":[{"type":"object","name":"Div","id":"p2073","attributes":{"text":"&lt;p&gt;&lt;b&gt;Quantile setter mode&lt;/b&gt;&lt;/p&gt;"}},{"type":"object","name":"Spacer","id":"p2074","attributes":{"width":2}},{"type":"object","name":"Switch","id":"p2062","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:active",[{"type":"object","name":"CustomJS","id":"p2066","attributes":{"args":{"type":"map","entries":[["p_p",{"type":"object","name":"Figure","id":"p1959","attributes":{"x_range":{"type":"object","name":"Range1d","id":"p2023","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:start",[{"type":"object","name":"CustomJS","id":"p2065","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p1959"}],["p_c",{"type":"object","name":"Figure","id":"p1991","attributes":{"js_event_callbacks":{"type":"map","entries":[["reset",[{"type":"object","name":"CustomJS","id":"p2068","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p1959"}],["p_c",{"id":"p1991"}],["source_p",{"type":"object","name":"ColumnDataSource","id":"p2025","attributes":{"selected":{"type":"object","name":"Selection","id":"p2026","attributes":{"indices":[],"line_indices":[]}},"selection_policy":{"type":"object","name":"UnionRenderers","id":"p2027"},"data":{"type":"map","entries":[["x",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}],["y_p",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}]]}}}],["source_c",{"type":"object","name":"ColumnDataSource","id":"p2028","attributes":{"selected":{"type":"object","name":"Selection","id":"p2029","attributes":{"indices":[],"line_indices":[]}},"selection_policy":{"type":"object","name":"UnionRenderers","id":"p2030"},"data":{"type":"map","entries":[["x",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}],["y_c",{"type":"ndarray","array":{"type":"bytes","data":"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"},"shape":[400],"dtype":"float64","order":"little"}]]}}}],["discrete",false],["n",400],["sliders",[{"type":"object","name":"Slider","id":"p2050","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p2064","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p1959"}],["p_c",{"id":"p1991"}],["source_p",{"id":"p2025"}],["source_c",{"id":"p2028"}],["discrete",false],["n",400],["sliders",[{"id":"p2050"},{"type":"object","name":"Slider","id":"p2052","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p2064"}]]]},"width":200,"title":"\\u03c3","format":{"type":"object","name":"CustomJSTickFormatter","id":"p2051","attributes":{"code":"return tick.toPrecision(4)"}},"start":0,"end":1,"value":0.2,"step":0.01}}]],["xBoxes",[{"type":"object","name":"TextInput","id":"p2057","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p2067","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p1959"}],["p_c",{"id":"p1991"}],["source_p",{"id":"p2025"}],["source_c",{"id":"p2028"}],["discrete",false],["n",400],["sliders",[{"id":"p2050"},{"id":"p2052"}]],["xBoxes",[{"id":"p2057"},{"type":"object","name":"TextInput","id":"p2058","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p2067"}]]]},"disabled":true,"width":80,"value":"0.5991"}}]],["pBoxes",[{"type":"object","name":"TextInput","id":"p2059","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p2067"}]]]},"disabled":true,"width":80,"value":"0.0250"}},{"type":"object","name":"TextInput","id":"p2060","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p2067"}]]]},"disabled":true,"width":80,"value":"0.9750"}}]],["quantileSetterSwitch",{"id":"p2062"}],["quantileSetterDiv",{"type":"object","name":"Div","id":"p2061"}],["triggerCallbacks",{"type":"object","name":"Switch","id":"p2063","attributes":{"active":true}}],["startBoxes",[{"type":"object","name":"TextInput","id":"p2053","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p2069","attributes":{"args":{"type":"map","entries":[["minValue","-Infinity"],["maxValue","Infinity"],["slider",{"id":"p2050"}]]},"code":"\\n\\nslider.start = Math.max(minValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"-0.5"}},{"type":"object","name":"TextInput","id":"p2054","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p2071","attributes":{"args":{"type":"map","entries":[["minValue","0"],["maxValue","Infinity"],["slider",{"id":"p2052"}]]},"code":"\\n\\nslider.start = Math.max(minValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"0"}}]],["endBoxes",[{"type":"object","name":"TextInput","id":"p2055","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p2070","attributes":{"args":{"type":"map","entries":[["minValue","-Infinity"],["maxValue","Infinity"],["slider",{"id":"p2050"}]]},"code":"\\n\\nslider.end = Math.min(maxValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"0.5"}},{"type":"object","name":"TextInput","id":"p2056","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p2072","attributes":{"args":{"type":"map","entries":[["minValue","0"],["maxValue","Infinity"],["slider",{"id":"p2052"}]]},"code":"\\n\\nslider.end = Math.min(maxValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"1"}}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nclass DoubleExponentialDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Double exponential (Laplace)&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u00b5&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.paramMin = [-Infinity, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return -Infinity;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let result;\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x == Infinity | x == -Infinity) result = 0.0;\\n    else if (sigma == 0) result = x == mu ? Infinity : 0.0;\\n    else result = Math.exp(-Math.abs(x - mu) / sigma) / 2.0 / sigma;\\n\\n    return result;\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let result;\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x == -Infinity) result = 0.0;\\n    else if (x == Infinity) result = 1.0;\\n    else if (sigma == 0.0) result = x &lt; mu ? 0.0 : 1.0;\\n    else if (x &lt;= mu) result = Math.exp((x - mu) / sigma) / 2.0;\\n    else result = 1.0 - Math.exp(-(x - mu) / sigma) / 2.0;\\n\\n    return result;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let result;\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (p == 0) result = -Infinity;\\n    else if (p == 1) result = Infinity;\\n    else if (p &lt;= 0.5) result = mu + sigma * Math.log(2 * p);\\n    else result = mu - sigma * Math.log(2 - 2 * p);\\n\\n    return result;\\n  }\\n\\n  defaultXRange(params) {\\n    return this.ppf([0.001, 0.999], params);\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    let p1log = Math.log(1.0 - 2 * Math.abs(p1 - 0.5))\\n    let p2log = Math.log(1.0 - 2 * Math.abs(p2 - 0.5));\\n    let p1sgn = Math.sign(p1 - 0.5);\\n    let p2sgn = Math.sign(p2 - 0.5);\\n\\n    let sigma = (x2 - x1) / (p1sgn * p1log - p2sgn * p2log);\\n    let mu = x1 + sigma * p1sgn * p1log;\\n\\n    return [[mu, sigma], true];\\n  }\\n}\\n\\n\\n\\nvar dist = new DoubleExponentialDistribution();\\n\\n\\n\\nif (quantileSetterSwitch.active) {\\n  quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p);\\n}"}}]]]},"disabled":true,"width":80,"value":"-0.5991"}},{"id":"p2058"}]],["pBoxes",[{"id":"p2059"},{"id":"p2060"}]],["quantileSetterSwitch",{"id":"p2062"}],["quantileSetterDiv",{"id":"p2061"}],["triggerCallbacks",{"id":"p2063"}],["startBoxes",[{"id":"p2053"},{"id":"p2054"}]],["endBoxes",[{"id":"p2055"},{"id":"p2056"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nclass DoubleExponentialDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Double exponential (Laplace)&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u00b5&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.paramMin = [-Infinity, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return -Infinity;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let result;\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x == Infinity | x == -Infinity) result = 0.0;\\n    else if (sigma == 0) result = x == mu ? Infinity : 0.0;\\n    else result = Math.exp(-Math.abs(x - mu) / sigma) / 2.0 / sigma;\\n\\n    return result;\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let result;\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x == -Infinity) result = 0.0;\\n    else if (x == Infinity) result = 1.0;\\n    else if (sigma == 0.0) result = x &lt; mu ? 0.0 : 1.0;\\n    else if (x &lt;= mu) result = Math.exp((x - mu) / sigma) / 2.0;\\n    else result = 1.0 - Math.exp(-(x - mu) / sigma) / 2.0;\\n\\n    return result;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let result;\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (p == 0) result = -Infinity;\\n    else if (p == 1) result = Infinity;\\n    else if (p &lt;= 0.5) result = mu + sigma * Math.log(2 * p);\\n    else result = mu - sigma * Math.log(2 - 2 * p);\\n\\n    return result;\\n  }\\n\\n  defaultXRange(params) {\\n    return this.ppf([0.001, 0.999], params);\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    let p1log = Math.log(1.0 - 2 * Math.abs(p1 - 0.5))\\n    let p2log = Math.log(1.0 - 2 * Math.abs(p2 - 0.5));\\n    let p1sgn = Math.sign(p1 - 0.5);\\n    let p2sgn = Math.sign(p2 - 0.5);\\n\\n    let sigma = (x2 - x1) / (p1sgn * p1log - p2sgn * p2log);\\n    let mu = x1 + sigma * p1sgn * p1log;\\n\\n    return [[mu, sigma], true];\\n  }\\n}\\n\\n\\n\\nvar dist = new DoubleExponentialDistribution();\\n\\n\\n\\nif (triggerCallbacks.active &amp;&amp; !cb_obj.disabled) {\\n\\tif (quantileSetterSwitch.active) {\\n\\t\\tquantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p);\\n\\t}\\n\\telse {\\n\\t\\tupdateData(source_p, source_c, p_p, sliders, discrete);\\n\\t\\tupdateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes);\\n\\t}\\n}"}}]]]},"width":200,"title":"\\u00b5","format":{"type":"object","name":"CustomJSTickFormatter","id":"p2049","attributes":{"code":"return tick.toPrecision(4)"}},"start":-0.5,"end":0.5,"value":0,"step":0.01}},{"id":"p2052"}]],["xBoxes",[{"id":"p2057"},{"id":"p2058"}]],["pBoxes",[{"id":"p2059"},{"id":"p2060"}]],["quantileSetterSwitch",{"id":"p2062"}],["quantileSetterDiv",{"id":"p2061"}],["triggerCallbacks",{"id":"p2063"}],["startBoxes",[{"id":"p2053"},{"id":"p2054"}]],["endBoxes",[{"id":"p2055"},{"id":"p2056"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nclass DoubleExponentialDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Double exponential (Laplace)&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u00b5&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.paramMin = [-Infinity, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return -Infinity;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let result;\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x == Infinity | x == -Infinity) result = 0.0;\\n    else if (sigma == 0) result = x == mu ? Infinity : 0.0;\\n    else result = Math.exp(-Math.abs(x - mu) / sigma) / 2.0 / sigma;\\n\\n    return result;\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let result;\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x == -Infinity) result = 0.0;\\n    else if (x == Infinity) result = 1.0;\\n    else if (sigma == 0.0) result = x &lt; mu ? 0.0 : 1.0;\\n    else if (x &lt;= mu) result = Math.exp((x - mu) / sigma) / 2.0;\\n    else result = 1.0 - Math.exp(-(x - mu) / sigma) / 2.0;\\n\\n    return result;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let result;\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (p == 0) result = -Infinity;\\n    else if (p == 1) result = Infinity;\\n    else if (p &lt;= 0.5) result = mu + sigma * Math.log(2 * p);\\n    else result = mu - sigma * Math.log(2 - 2 * p);\\n\\n    return result;\\n  }\\n\\n  defaultXRange(params) {\\n    return this.ppf([0.001, 0.999], params);\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    let p1log = Math.log(1.0 - 2 * Math.abs(p1 - 0.5))\\n    let p2log = Math.log(1.0 - 2 * Math.abs(p2 - 0.5));\\n    let p1sgn = Math.sign(p1 - 0.5);\\n    let p2sgn = Math.sign(p2 - 0.5);\\n\\n    let sigma = (x2 - x1) / (p1sgn * p1log - p2sgn * p2log);\\n    let mu = x1 + sigma * p1sgn * p1log;\\n\\n    return [[mu, sigma], true];\\n  }\\n}\\n\\n\\n\\nvar dist = new DoubleExponentialDistribution();\\n\\n\\n\\nlet params = paramsFromSliders(sliders); \\n\\n\\nlet [x1, x2] = dist.defaultXRange(params);\\n\\n\\ntriggerCallbacks.active = false;\\n\\n\\np_p.x_range.start = x1;\\np_p.x_range.end = x2;\\n\\nupdateData(source_p, source_c, p_p, sliders, discrete);\\n\\n\\nsetYRanges(p_p, p_c, source_p);  \\n\\ntriggerCallbacks.active = true;\\n"}}]]]},"x_range":{"id":"p2023"},"y_range":{"type":"object","name":"Range1d","id":"p2024"},"x_scale":{"type":"object","name":"LinearScale","id":"p2001"},"y_scale":{"type":"object","name":"LinearScale","id":"p2002"},"title":{"type":"object","name":"Title","id":"p1994","attributes":{"text":" "}},"renderers":[{"type":"object","name":"GlyphRenderer","id":"p2037","attributes":{"data_source":{"id":"p2028"},"view":{"type":"object","name":"CDSView","id":"p2038","attributes":{"filter":{"type":"object","name":"AllIndices","id":"p2039"}}},"glyph":{"type":"object","name":"Line","id":"p2034","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_width":2}},"nonselection_glyph":{"type":"object","name":"Line","id":"p2035","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_alpha":0.1,"line_width":2}},"muted_glyph":{"type":"object","name":"Line","id":"p2036","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_alpha":0.2,"line_width":2}}}}],"toolbar":{"type":"object","name":"Toolbar","id":"p2000","attributes":{"tools":[{"type":"object","name":"PanTool","id":"p2013"},{"type":"object","name":"BoxZoomTool","id":"p2014","attributes":{"overlay":{"type":"object","name":"BoxAnnotation","id":"p2015","attributes":{"syncable":false,"level":"overlay","visible":false,"left":{"type":"number","value":"nan"},"right":{"type":"number","value":"nan"},"top":{"type":"number","value":"nan"},"bottom":{"type":"number","value":"nan"},"left_units":"canvas","right_units":"canvas","top_units":"canvas","bottom_units":"canvas","line_color":"black","line_alpha":1.0,"line_width":2,"line_dash":[4,4],"fill_color":"lightgrey","fill_alpha":0.5}}}},{"type":"object","name":"WheelZoomTool","id":"p2020","attributes":{"renderers":"auto"}},{"type":"object","name":"SaveTool","id":"p2021"},{"type":"object","name":"ResetTool","id":"p2022"}]}},"toolbar_location":null,"left":[{"type":"object","name":"LinearAxis","id":"p2008","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p2009","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p2010"},"axis_label":"CDF","axis_label_text_font_style":"normal","major_label_policy":{"type":"object","name":"AllLabels","id":"p2011"}}}],"below":[{"type":"object","name":"LinearAxis","id":"p2003","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p2004","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p2005"},"axis_label":"y","major_label_policy":{"type":"object","name":"AllLabels","id":"p2006"}}}],"center":[{"type":"object","name":"Grid","id":"p2007","attributes":{"axis":{"id":"p2003"}}},{"type":"object","name":"Grid","id":"p2012","attributes":{"dimension":1,"axis":{"id":"p2008"}}}],"frame_width":300,"frame_height":175,"background_fill_alpha":0,"border_fill_alpha":0}}],["source_p",{"id":"p2025"}],["source_c",{"id":"p2028"}],["discrete",false],["n",400],["sliders",[{"id":"p2050"},{"id":"p2052"}]],["xBoxes",[{"id":"p2057"},{"id":"p2058"}]],["pBoxes",[{"id":"p2059"},{"id":"p2060"}]],["quantileSetterSwitch",{"id":"p2062"}],["quantileSetterDiv",{"id":"p2061"}],["triggerCallbacks",{"id":"p2063"}],["startBoxes",[{"id":"p2053"},{"id":"p2054"}]],["endBoxes",[{"id":"p2055"},{"id":"p2056"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nclass DoubleExponentialDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Double exponential (Laplace)&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u00b5&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.paramMin = [-Infinity, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return -Infinity;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let result;\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x == Infinity | x == -Infinity) result = 0.0;\\n    else if (sigma == 0) result = x == mu ? Infinity : 0.0;\\n    else result = Math.exp(-Math.abs(x - mu) / sigma) / 2.0 / sigma;\\n\\n    return result;\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let result;\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x == -Infinity) result = 0.0;\\n    else if (x == Infinity) result = 1.0;\\n    else if (sigma == 0.0) result = x &lt; mu ? 0.0 : 1.0;\\n    else if (x &lt;= mu) result = Math.exp((x - mu) / sigma) / 2.0;\\n    else result = 1.0 - Math.exp(-(x - mu) / sigma) / 2.0;\\n\\n    return result;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let result;\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (p == 0) result = -Infinity;\\n    else if (p == 1) result = Infinity;\\n    else if (p &lt;= 0.5) result = mu + sigma * Math.log(2 * p);\\n    else result = mu - sigma * Math.log(2 - 2 * p);\\n\\n    return result;\\n  }\\n\\n  defaultXRange(params) {\\n    return this.ppf([0.001, 0.999], params);\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    let p1log = Math.log(1.0 - 2 * Math.abs(p1 - 0.5))\\n    let p2log = Math.log(1.0 - 2 * Math.abs(p2 - 0.5));\\n    let p1sgn = Math.sign(p1 - 0.5);\\n    let p2sgn = Math.sign(p2 - 0.5);\\n\\n    let sigma = (x2 - x1) / (p1sgn * p1log - p2sgn * p2log);\\n    let mu = x1 + sigma * p1sgn * p1log;\\n\\n    return [[mu, sigma], true];\\n  }\\n}\\n\\n\\n\\nvar dist = new DoubleExponentialDistribution();\\n\\n\\nif (triggerCallbacks.active) {\\n  updateData(source_p, source_c, p_p, sliders, discrete);\\n}"}}]],["change:end",[{"id":"p2065"}]]]},"start":-2.5,"end":2.5}},"y_range":{"type":"object","name":"DataRange1d","id":"p1961","attributes":{"start":0.0}},"x_scale":{"type":"object","name":"LinearScale","id":"p1969"},"y_scale":{"type":"object","name":"LinearScale","id":"p1970"},"title":{"type":"object","name":"Title","id":"p1962","attributes":{"text":"Double Exponential (Laplace)"}},"renderers":[{"type":"object","name":"GlyphRenderer","id":"p2046","attributes":{"data_source":{"id":"p2025"},"view":{"type":"object","name":"CDSView","id":"p2047","attributes":{"filter":{"type":"object","name":"AllIndices","id":"p2048"}}},"glyph":{"type":"object","name":"Line","id":"p2043","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"line_color":"#1f77b4","line_width":2}},"nonselection_glyph":{"type":"object","name":"Line","id":"p2044","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"line_color":"#1f77b4","line_alpha":0.1,"line_width":2}},"muted_glyph":{"type":"object","name":"Line","id":"p2045","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"line_color":"#1f77b4","line_alpha":0.2,"line_width":2}}}}],"toolbar":{"type":"object","name":"Toolbar","id":"p1968","attributes":{"tools":[{"type":"object","name":"PanTool","id":"p1981"},{"type":"object","name":"BoxZoomTool","id":"p1982","attributes":{"overlay":{"type":"object","name":"BoxAnnotation","id":"p1983","attributes":{"syncable":false,"level":"overlay","visible":false,"left":{"type":"number","value":"nan"},"right":{"type":"number","value":"nan"},"top":{"type":"number","value":"nan"},"bottom":{"type":"number","value":"nan"},"left_units":"canvas","right_units":"canvas","top_units":"canvas","bottom_units":"canvas","line_color":"black","line_alpha":1.0,"line_width":2,"line_dash":[4,4],"fill_color":"lightgrey","fill_alpha":0.5}}}},{"type":"object","name":"WheelZoomTool","id":"p1988","attributes":{"renderers":"auto"}},{"type":"object","name":"SaveTool","id":"p1989"},{"type":"object","name":"ResetTool","id":"p1990"}]}},"toolbar_location":null,"left":[{"type":"object","name":"LinearAxis","id":"p1976","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p1977","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p1978"},"axis_label":"PDF","axis_label_text_font_style":"normal","major_label_policy":{"type":"object","name":"AllLabels","id":"p1979"}}}],"below":[{"type":"object","name":"LinearAxis","id":"p1971","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p1972","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p1973"},"axis_label":"y","major_label_policy":{"type":"object","name":"AllLabels","id":"p1974"}}}],"center":[{"type":"object","name":"Grid","id":"p1975","attributes":{"axis":{"id":"p1971"}}},{"type":"object","name":"Grid","id":"p1980","attributes":{"dimension":1,"axis":{"id":"p1976"}}}],"frame_width":300,"frame_height":175,"background_fill_alpha":0,"border_fill_alpha":0}}],["p_c",{"id":"p1991"}],["source_p",{"id":"p2025"}],["source_c",{"id":"p2028"}],["discrete",false],["n",400],["sliders",[{"id":"p2050"},{"id":"p2052"}]],["xBoxes",[{"id":"p2057"},{"id":"p2058"}]],["pBoxes",[{"id":"p2059"},{"id":"p2060"}]],["quantileSetterSwitch",{"id":"p2062"}],["quantileSetterDiv",{"id":"p2061"}],["triggerCallbacks",{"id":"p2063"}],["startBoxes",[{"id":"p2053"},{"id":"p2054"}]],["endBoxes",[{"id":"p2055"},{"id":"p2056"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass ContinuousUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pdfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n}\\n\\nclass DoubleExponentialDistribution extends ContinuousUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Double exponential (Laplace)&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = -Infinity;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u00b5&#x27;, &#x27;\\u03c3&#x27;];\\n\\n    \\n    this.paramMin = [-Infinity, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return -Infinity;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pdfSingleValue(x, params) {\\n    let result;\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x == Infinity | x == -Infinity) result = 0.0;\\n    else if (sigma == 0) result = x == mu ? Infinity : 0.0;\\n    else result = Math.exp(-Math.abs(x - mu) / sigma) / 2.0 / sigma;\\n\\n    return result;\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    let result;\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (x == -Infinity) result = 0.0;\\n    else if (x == Infinity) result = 1.0;\\n    else if (sigma == 0.0) result = x &lt; mu ? 0.0 : 1.0;\\n    else if (x &lt;= mu) result = Math.exp((x - mu) / sigma) / 2.0;\\n    else result = 1.0 - Math.exp(-(x - mu) / sigma) / 2.0;\\n\\n    return result;\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let result;\\n    let [mu, sigma] = params.slice(0, 2);\\n\\n    if (p == 0) result = -Infinity;\\n    else if (p == 1) result = Infinity;\\n    else if (p &lt;= 0.5) result = mu + sigma * Math.log(2 * p);\\n    else result = mu - sigma * Math.log(2 - 2 * p);\\n\\n    return result;\\n  }\\n\\n  defaultXRange(params) {\\n    return this.ppf([0.001, 0.999], params);\\n  }\\n\\n  quantileSet(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    let p1log = Math.log(1.0 - 2 * Math.abs(p1 - 0.5))\\n    let p2log = Math.log(1.0 - 2 * Math.abs(p2 - 0.5));\\n    let p1sgn = Math.sign(p1 - 0.5);\\n    let p2sgn = Math.sign(p2 - 0.5);\\n\\n    let sigma = (x2 - x1) / (p1sgn * p1log - p2sgn * p2log);\\n    let mu = x1 + sigma * p1sgn * p1log;\\n\\n    return [[mu, sigma], true];\\n  }\\n}\\n\\n\\n\\nvar dist = new DoubleExponentialDistribution();\\n\\n\\n\\nif (cb_obj.active) {\\n  for (let i = 0; i &lt; sliders.length; i++) {\\n    if (!dist.fixedParamsInds.includes(i)) {\\n      sliders[i].title = dist.paramNames[i] + &#x27; (computed)&#x27;;\\n      sliders[i].disabled = true;\\n    }\\n  }\\n  for (let xBox of xBoxes) {\\n    xBox.disabled = false;\\n  }\\n  for (let pBox of pBoxes) {\\n    pBox.disabled = false;\\n  }\\n} else {\\n  for (let i = 0; i &lt; sliders.length; i++) {\\n    if (!dist.fixedParamsInds.includes(i)) {\\n      sliders[i].title = dist.paramNames[i];\\n      sliders[i].disabled = false;\\n    }\\n  }\\n  for (let xBox of xBoxes) {\\n    xBox.disabled = true;\\n  }\\n  for (let pBox of pBoxes) {\\n    pBox.disabled = true;\\n  }\\n  quantileSetterDiv.text = &#x27;&#x27;;\\n}"}}]]]}}}]}},{"type":"object","name":"Spacer","id":"p2116","attributes":{"width":10}},{"id":"p2061"}]}},{"type":"object","name":"Spacer","id":"p2118","attributes":{"height":10}},{"type":"object","name":"Row","id":"p2120","attributes":{"children":[{"type":"object","name":"Column","id":"p2105","attributes":{"children":[{"type":"object","name":"Row","id":"p2103","attributes":{"children":[{"type":"object","name":"Column","id":"p2096","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2095","attributes":{"height":4}},{"id":"p2053"}]}},{"id":"p2050"},{"type":"object","name":"Column","id":"p2098","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2097","attributes":{"height":4}},{"id":"p2055"}]}}]}},{"type":"object","name":"Row","id":"p2104","attributes":{"children":[{"type":"object","name":"Column","id":"p2100","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2099","attributes":{"height":4}},{"id":"p2054"}]}},{"id":"p2052"},{"type":"object","name":"Column","id":"p2102","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2101","attributes":{"height":4}},{"id":"p2056"}]}}]}}]}},{"type":"object","name":"Spacer","id":"p2119","attributes":{"width":20}},{"type":"object","name":"Column","id":"p2094","attributes":{"children":[{"type":"object","name":"Row","id":"p2092","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2076","attributes":{"width":20}},{"type":"object","name":"Column","id":"p2079","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2077","attributes":{"height":7}},{"type":"object","name":"Div","id":"p2078","attributes":{"text":"&lt;p&gt;&lt;b&gt;lower y: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p2057"},{"type":"object","name":"Spacer","id":"p2080","attributes":{"width":34}},{"type":"object","name":"Column","id":"p2083","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2081","attributes":{"height":7}},{"type":"object","name":"Div","id":"p2082","attributes":{"text":"&lt;p&gt;&lt;b&gt;upper y: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p2058"}]}},{"type":"object","name":"Row","id":"p2093","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2084","attributes":{"width":16}},{"type":"object","name":"Column","id":"p2087","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2085","attributes":{"height":7}},{"type":"object","name":"Div","id":"p2086","attributes":{"text":"&lt;p&gt;&lt;b&gt;quantile: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p2059"},{"type":"object","name":"Spacer","id":"p2088","attributes":{"width":30}},{"type":"object","name":"Column","id":"p2091","attributes":{"children":[{"type":"object","name":"Spacer","id":"p2089","attributes":{"height":7}},{"type":"object","name":"Div","id":"p2090","attributes":{"text":"&lt;p&gt;&lt;b&gt;quantile: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p2060"}]}}]}}]}},{"type":"object","name":"Spacer","id":"p2121","attributes":{"height":10}},{"type":"object","name":"GridPlot","id":"p2113","attributes":{"rows":null,"cols":null,"toolbar":{"type":"object","name":"Toolbar","id":"p2112","attributes":{"tools":[{"type":"object","name":"ToolProxy","id":"p2107","attributes":{"tools":[{"id":"p1981"},{"id":"p2013"},{"id":"p1981"},{"id":"p2013"}]}},{"type":"object","name":"ToolProxy","id":"p2108","attributes":{"tools":[{"id":"p1982"},{"id":"p2014"},{"id":"p1982"},{"id":"p2014"}]}},{"type":"object","name":"ToolProxy","id":"p2109","attributes":{"tools":[{"id":"p1988"},{"id":"p2020"},{"id":"p1988"},{"id":"p2020"}]}},{"type":"object","name":"SaveTool","id":"p2110"},{"type":"object","name":"ToolProxy","id":"p2111","attributes":{"tools":[{"id":"p1990"},{"id":"p2022"},{"id":"p1990"},{"id":"p2022"}]}}]}},"toolbar_location":"right","children":[[{"id":"p1959"},0,0],[{"type":"object","name":"Spacer","id":"p2106","attributes":{"width":30}},0,1],[{"id":"p1991"},0,2]]}}]}}]}}';
                  const render_items = [{"docid":"b3c66964-bbfb-4986-b42a-98a6c5781aec","roots":{"p2122":"de17555b-2dc2-4312-beab-b36360a5cd9d"},"root_ids":["p2122"]}];
                  root.Bokeh.embed.embed_items(docs_json, render_items);
                  }
                  if (root.Bokeh !== undefined) {
                    embed_document(root);
                  } else {
                    let attempts = 0;
                    const timer = setInterval(function(root) {
                      if (root.Bokeh !== undefined) {
                        clearInterval(timer);
                        embed_document(root);
                      } else {
                        attempts++;
                        if (attempts > 100) {
                          clearInterval(timer);
                          console.log("Bokeh: ERROR: Unable to run BokehJS code because BokehJS library is missing");
                        }
                      }
                    }, 10, root)
                  }
                })(window);
              });
            };
            if (document.readyState != "loading") fn();
            else document.addEventListener("DOMContentLoaded", fn);
          })();
        },
    function(Bokeh) {
        }
      ];
    
      function run_inline_js() {
        for (let i = 0; i < inline_js.length; i++) {
          inline_js[i].call(root, root.Bokeh);
        }
      }
    
      if (root._bokeh_is_loading === 0) {
        console.debug("Bokeh: BokehJS loaded, going straight to plotting");
        run_inline_js();
      } else {
        load_libs(css_urls, js_urls, function() {
          console.debug("Bokeh: BokehJS plotting callback run at", now());
          run_inline_js();
        });
      }
    }(window));
  };
  if (document.readyState != "loading") fn();
  else document.addEventListener("DOMContentLoaded", fn);
})();