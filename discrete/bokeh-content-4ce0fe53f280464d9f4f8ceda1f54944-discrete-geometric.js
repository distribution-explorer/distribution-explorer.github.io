(function() {
  const fn = function() {
    (function(root) {
      function now() {
        return new Date();
      }
    
      const force = false;
    
      if (typeof root._bokeh_onload_callbacks === "undefined" || force === true) {
        root._bokeh_onload_callbacks = [];
        root._bokeh_is_loading = undefined;
      }
    
    
    const element = document.getElementById("c612f538-ee86-4d85-bd13-bb1780105b53");
        if (element == null) {
          console.warn("Bokeh: autoload.js configured with elementid 'c612f538-ee86-4d85-bd13-bb1780105b53' but no matching script tag was found.")
        }
      function run_callbacks() {
        try {
          root._bokeh_onload_callbacks.forEach(function(callback) {
            if (callback != null)
              callback();
          });
        } finally {
          delete root._bokeh_onload_callbacks
        }
        console.debug("Bokeh: all callbacks have finished");
      }
    
      function load_libs(css_urls, js_urls, callback) {
        if (css_urls == null) css_urls = [];
        if (js_urls == null) js_urls = [];
    
        root._bokeh_onload_callbacks.push(callback);
        if (root._bokeh_is_loading > 0) {
          console.debug("Bokeh: BokehJS is being loaded, scheduling callback at", now());
          return null;
        }
        if (js_urls == null || js_urls.length === 0) {
          run_callbacks();
          return null;
        }
        console.debug("Bokeh: BokehJS not loaded, scheduling load and callback at", now());
        root._bokeh_is_loading = css_urls.length + js_urls.length;
    
        function on_load() {
          root._bokeh_is_loading--;
          if (root._bokeh_is_loading === 0) {
            console.debug("Bokeh: all BokehJS libraries/stylesheets loaded");
            run_callbacks()
          }
        }
    
        function on_error(url) {
          console.error("failed to load " + url);
        }
    
        for (let i = 0; i < css_urls.length; i++) {
          const url = css_urls[i];
          const element = document.createElement("link");
          element.onload = on_load;
          element.onerror = on_error.bind(null, url);
          element.rel = "stylesheet";
          element.type = "text/css";
          element.href = url;
          console.debug("Bokeh: injecting link tag for BokehJS stylesheet: ", url);
          document.body.appendChild(element);
        }
    
        for (let i = 0; i < js_urls.length; i++) {
          const url = js_urls[i];
          const element = document.createElement('script');
          element.onload = on_load;
          element.onerror = on_error.bind(null, url);
          element.async = false;
          element.src = url;
          console.debug("Bokeh: injecting script tag for BokehJS library: ", url);
          document.head.appendChild(element);
        }
      };
    
      function inject_raw_css(css) {
        const element = document.createElement("style");
        element.appendChild(document.createTextNode(css));
        document.body.appendChild(element);
      }
    
      const js_urls = ["https://cdn.bokeh.org/bokeh/release/bokeh-3.3.0.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-gl-3.3.0.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-widgets-3.3.0.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-tables-3.3.0.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-mathjax-3.3.0.min.js"];
      const css_urls = [];
    
      const inline_js = [    function(Bokeh) {
          Bokeh.set_log_level("info");
        },
        function(Bokeh) {
          (function() {
            const fn = function() {
              Bokeh.safely(function() {
                (function(root) {
                  function embed_document(root) {
                  const docs_json = '{"e5143045-8cd3-4a34-bad0-ea3fb2a3cc3b":{"version":"3.3.0","title":"Bokeh Application","roots":[{"type":"object","name":"Column","id":"p4606","attributes":{"children":[{"type":"object","name":"Row","id":"p4601","attributes":{"children":[{"type":"object","name":"Spacer","id":"p4599","attributes":{"width":409}},{"type":"object","name":"Row","id":"p4572","attributes":{"children":[{"type":"object","name":"Div","id":"p4570","attributes":{"text":"&lt;p&gt;&lt;b&gt;Quantile setter mode&lt;/b&gt;&lt;/p&gt;"}},{"type":"object","name":"Spacer","id":"p4571","attributes":{"width":2}},{"type":"object","name":"Switch","id":"p4561","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:active",[{"type":"object","name":"CustomJS","id":"p4565","attributes":{"args":{"type":"map","entries":[["p_p",{"type":"object","name":"Figure","id":"p4461","attributes":{"x_range":{"type":"object","name":"Range1d","id":"p4519","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:start",[{"type":"object","name":"CustomJS","id":"p4564","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p4461"}],["p_c",{"type":"object","name":"Figure","id":"p4490","attributes":{"js_event_callbacks":{"type":"map","entries":[["reset",[{"type":"object","name":"CustomJS","id":"p4567","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p4461"}],["p_c",{"id":"p4490"}],["source_p",{"type":"object","name":"ColumnDataSource","id":"p4521","attributes":{"selected":{"type":"object","name":"Selection","id":"p4522","attributes":{"indices":[],"line_indices":[]}},"selection_policy":{"type":"object","name":"UnionRenderers","id":"p4523"},"data":{"type":"map","entries":[["x",{"type":"ndarray","array":{"type":"bytes","data":"/////wAAAAABAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAAA=="},"shape":[22],"dtype":"int32","order":"little"}],["y_p",{"type":"ndarray","array":{"type":"bytes","data":"AAAAAAAAAAAAAAAAAADgPwAAAAAAANA/AAAAAAAAwD8AAAAAAACwPwAAAAAAAKA/AAAAAAAAkD8AAAAAAACAPwAAAAAAAHA/AAAAAAAAYD8AAAAAAABQPwAAAAAAAEA/AAAAAAAAMD8AAAAAAAAgPwAAAAAAABA/AAAAAAAAAD8AAAAAAADwPgAAAAAAAOA+AAAAAAAA0D4AAAAAAADAPgAAAAAAALA+AAAAAAAAoD4="},"shape":[22],"dtype":"float64","order":"little"}]]}}}],["source_c",{"type":"object","name":"ColumnDataSource","id":"p4524","attributes":{"selected":{"type":"object","name":"Selection","id":"p4525","attributes":{"indices":[],"line_indices":[]}},"selection_policy":{"type":"object","name":"UnionRenderers","id":"p4526"},"data":{"type":"map","entries":[["x",{"type":"ndarray","array":{"type":"bytes","data":"MzMzMzMz/78AAAAAAADwvwAAAAAAAPC/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAPA/AAAAAAAA8D8AAAAAAAAAQAAAAAAAAABAAAAAAAAACEAAAAAAAAAIQAAAAAAAABBAAAAAAAAAEEAAAAAAAAAUQAAAAAAAABRAAAAAAAAAGEAAAAAAAAAYQAAAAAAAABxAAAAAAAAAHEAAAAAAAAAgQAAAAAAAACBAAAAAAAAAIkAAAAAAAAAiQAAAAAAAACRAAAAAAAAAJEAAAAAAAAAmQAAAAAAAACZAAAAAAAAAKEAAAAAAAAAoQAAAAAAAACpAAAAAAAAAKkAAAAAAAAAsQAAAAAAAACxAAAAAAAAALkAAAAAAAAAuQAAAAAAAADBAAAAAAAAAMEAAAAAAAAAxQAAAAAAAADFAAAAAAAAAMkAAAAAAAAAyQAAAAAAAADNAAAAAAAAAM0AAAAAAAAA0QAAAAAAAADRAMzMzMzPzNEA="},"shape":[46],"dtype":"float64","order":"little"}],["y_c",{"type":"ndarray","array":{"type":"bytes","data":"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgPwAAAAAAAOA/AAAAAAAA6D8AAAAAAADoPwAAAAAAAOw/AAAAAAAA7D8AAAAAAADuPwAAAAAAAO4/AAAAAAAA7z8AAAAAAADvPwAAAAAAgO8/AAAAAACA7z8AAAAAAMDvPwAAAAAAwO8/AAAAAADg7z8AAAAAAODvPwAAAAAA8O8/AAAAAADw7z8AAAAAAPjvPwAAAAAA+O8/AAAAAAD87z8AAAAAAPzvPwAAAAAA/u8/AAAAAAD+7z8AAAAAAP/vPwAAAAAA/+8/AAAAAID/7z8AAAAAgP/vPwAAAADA/+8/AAAAAMD/7z8AAAAA4P/vPwAAAADg/+8/AAAAAPD/7z8AAAAA8P/vPwAAAAD4/+8/AAAAAPj/7z8AAAAA/P/vPwAAAAD8/+8/AAAAAP7/7z8AAAAA/v/vPwAAAAD//+8/AAAAAP//7z8="},"shape":[46],"dtype":"float64","order":"little"}]]}}}],["discrete",true],["n",400],["sliders",[{"type":"object","name":"Slider","id":"p4555","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p4563","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p4461"}],["p_c",{"id":"p4490"}],["source_p",{"id":"p4521"}],["source_c",{"id":"p4524"}],["discrete",true],["n",400],["sliders",[{"id":"p4555"}]],["xBoxes",[{"type":"object","name":"TextInput","id":"p4558","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p4566","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p4461"}],["p_c",{"id":"p4490"}],["source_p",{"id":"p4521"}],["source_c",{"id":"p4524"}],["discrete",true],["n",400],["sliders",[{"id":"p4555"}]],["xBoxes",[{"id":"p4558"}]],["pBoxes",[{"type":"object","name":"TextInput","id":"p4559","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p4566"}]]]},"disabled":true,"width":80,"value":"0.5000"}}]],["quantileSetterSwitch",{"id":"p4561"}],["quantileSetterDiv",{"type":"object","name":"Div","id":"p4560"}],["triggerCallbacks",{"type":"object","name":"Switch","id":"p4562","attributes":{"active":true}}],["startBoxes",[{"type":"object","name":"TextInput","id":"p4556","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p4568","attributes":{"args":{"type":"map","entries":[["minValue",0],["maxValue",1],["slider",{"id":"p4555"}]]},"code":"\\n\\nslider.start = Math.max(minValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"0"}}]],["endBoxes",[{"type":"object","name":"TextInput","id":"p4557","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p4569","attributes":{"args":{"type":"map","entries":[["minValue",0],["maxValue",1],["slider",{"id":"p4555"}]]},"code":"\\n\\nslider.end = Math.min(maxValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"1"}}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let x = paramsFromBoxes(xBoxes);\\n  let p = paramsFromBoxes(pBoxes);\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ){\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n          endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);        \\n        }\\n        sliders[dist.activeParamsInds[i]].value = optimParams[i];\\n      }\\n\\n      params = paramsFromSliders(sliders); \\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.floor(xRange.start);\\n  let xRangeMax = Math.ceil(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c = [xRangeMin - 1, ...x_p.flatMap(x =&gt; [x, x]), xRangeMax + 1];\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = -0.04;\\n    p_c.y_range.end = 1.04;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = -pdfMax * 0.04;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264&#x27; + xMax.toString() + &#x27;.&lt;/p\\\\&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass DiscreteUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pmfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pmf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pmfSingleValue(x, params, parametrization),\\n      x,\\n      params);\\n  }\\n\\n  cdfSingleValue(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    \\n    let cumsum = 0.0;\\n    let summand = 0.0;\\n    for (let n = this.xMin(params, parametrization); n &lt;= x; n++) {\\n        summand = this.pmfSingleValue(n, params, parametrization);\\n        if (!isNaN(summand)) cumsum += summand;\\n    }\\n\\n    return cumsum;\\n  }\\n\\n  cdfForPlotting(xStart, xEnd, params, parametrization = this.parametrization) {\\n\\n    params = this.scalarToArrayParams(params);\\n\\n    \\n    let cumsum = 0.0;\\n    let prob;\\n    for (let x = this.xMin(params, parametrization); x &lt; xStart; x++) {\\n      prob = this.pmfSingleValue(x, params, parametrization);\\n      if (!isNaN(prob)) cumsum += prob;\\n    }\\n\\n    \\n    let yCDF = [];\\n    for (let x = xStart; x &lt; xEnd; x++) {\\n      prob = this.pmfSingleValue(x, params, parametrization);\\n      if (!isNaN(prob)) cumsum += prob;\\n      yCDF.push(cumsum, cumsum);\\n    }\\n\\n    return yCDF;\\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) throw new Error(&#x27;p must be between 0 and 1.&#x27;)\\n\\n    \\n    if (p == 0) return xMin(params, parametrization);\\n\\n    \\n    if (p == 1) return xMax(params, parametrization);\\n\\n    params = this.scalarToArrayParams(params);\\n\\n    \\n    let n = this.xMin(params, parametrization);\\n    let cumsum = this.pmfSingleValue(n, params, parametrization);\\n\\n    let iters = 0;\\n    let summand = 0.0;\\n    let xMaxForTheseParams = this.xMax(params, parametrization);\\n    while (cumsum &lt; p &amp;&amp; !isclose(cumsum, p) &amp;&amp; !isNaN(summand) &amp;&amp; n &lt; xMaxForTheseParams) {\\n      n += 1;\\n      summand = this.pmfSingleValue(n, params, parametrization);\\n\\n      if (!isNaN(summand)) cumsum += summand;\\n\\n      iters += 1;\\n    }\\n\\n    return n;\\n  }\\n\\n}\\n\\nfunction isclose(x, y, rtol = 1.0e-7, atol = 1.0e-8) {\\n  return Math.abs(x - y) &lt;= (atol + rtol * Math.abs(y));\\n}\\n\\n\\nclass GeometricDistribution extends DiscreteUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Geometric&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03b8&#x27;];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pmfSingleValue(x, params) {\\n    let theta = params[0];\\n\\n    if (theta == 1) {\\n      if (x == 0) return 1.0;\\n      return 0.0;\\n    }\\n\\n    if (theta == 0) return 0.0;\\n\\n    if (x &lt; 0) return NaN;\\n\\n    return Math.exp(x * Math.log(1.0 - theta) + Math.log(theta));\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x &lt; 0) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let theta = params[0];\\n\\n    return 1.0 - Math.pow(1.0 - theta, x + 1.0);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let theta = params[0];\\n\\n    if (p === 0) return 0;\\n    if (p === 1) return Infinity;\\n    if (theta === 1) return 0;\\n\\n    let res = Math.ceil(Math.log(1 - p) / Math.log(1 - theta) - 1);\\n\\n    if (res === -0) return 0;\\n    return res;\\n  }\\n\\n  defaultXRange(params) {\\n    let theta = params[0];\\n\\n    return [-1, this.ppfSingleValue(0.999, params)];\\n  }\\n\\n  quantileSet(x, p) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n\\n    if (!Number.isInteger(x1)) {\\n      throw new Error(this.varName + &#x27; must be integer.&#x27;)\\n    }\\n    if (x1 &lt; 0) {\\n      throw new Error(&#x27;Must have &#x27; + this.varName + &#x27; &gt; 0.&#x27;)\\n    }\\n\\n    return [[1.0 - Math.pow(1.0 - p1, 1.0 / (x1 + 1.0))], true];\\n  }\\n\\n}\\n\\n\\n\\nvar dist = new GeometricDistribution();\\n\\n\\n\\nif (quantileSetterSwitch.active) {\\n  quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p);\\n}"}}]]]},"disabled":true,"width":80,"value":"0.0000"}}]],["pBoxes",[{"id":"p4559"}]],["quantileSetterSwitch",{"id":"p4561"}],["quantileSetterDiv",{"id":"p4560"}],["triggerCallbacks",{"id":"p4562"}],["startBoxes",[{"id":"p4556"}]],["endBoxes",[{"id":"p4557"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let x = paramsFromBoxes(xBoxes);\\n  let p = paramsFromBoxes(pBoxes);\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ){\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n          endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);        \\n        }\\n        sliders[dist.activeParamsInds[i]].value = optimParams[i];\\n      }\\n\\n      params = paramsFromSliders(sliders); \\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.floor(xRange.start);\\n  let xRangeMax = Math.ceil(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c = [xRangeMin - 1, ...x_p.flatMap(x =&gt; [x, x]), xRangeMax + 1];\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = -0.04;\\n    p_c.y_range.end = 1.04;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = -pdfMax * 0.04;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264&#x27; + xMax.toString() + &#x27;.&lt;/p\\\\&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass DiscreteUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pmfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pmf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pmfSingleValue(x, params, parametrization),\\n      x,\\n      params);\\n  }\\n\\n  cdfSingleValue(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    \\n    let cumsum = 0.0;\\n    let summand = 0.0;\\n    for (let n = this.xMin(params, parametrization); n &lt;= x; n++) {\\n        summand = this.pmfSingleValue(n, params, parametrization);\\n        if (!isNaN(summand)) cumsum += summand;\\n    }\\n\\n    return cumsum;\\n  }\\n\\n  cdfForPlotting(xStart, xEnd, params, parametrization = this.parametrization) {\\n\\n    params = this.scalarToArrayParams(params);\\n\\n    \\n    let cumsum = 0.0;\\n    let prob;\\n    for (let x = this.xMin(params, parametrization); x &lt; xStart; x++) {\\n      prob = this.pmfSingleValue(x, params, parametrization);\\n      if (!isNaN(prob)) cumsum += prob;\\n    }\\n\\n    \\n    let yCDF = [];\\n    for (let x = xStart; x &lt; xEnd; x++) {\\n      prob = this.pmfSingleValue(x, params, parametrization);\\n      if (!isNaN(prob)) cumsum += prob;\\n      yCDF.push(cumsum, cumsum);\\n    }\\n\\n    return yCDF;\\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) throw new Error(&#x27;p must be between 0 and 1.&#x27;)\\n\\n    \\n    if (p == 0) return xMin(params, parametrization);\\n\\n    \\n    if (p == 1) return xMax(params, parametrization);\\n\\n    params = this.scalarToArrayParams(params);\\n\\n    \\n    let n = this.xMin(params, parametrization);\\n    let cumsum = this.pmfSingleValue(n, params, parametrization);\\n\\n    let iters = 0;\\n    let summand = 0.0;\\n    let xMaxForTheseParams = this.xMax(params, parametrization);\\n    while (cumsum &lt; p &amp;&amp; !isclose(cumsum, p) &amp;&amp; !isNaN(summand) &amp;&amp; n &lt; xMaxForTheseParams) {\\n      n += 1;\\n      summand = this.pmfSingleValue(n, params, parametrization);\\n\\n      if (!isNaN(summand)) cumsum += summand;\\n\\n      iters += 1;\\n    }\\n\\n    return n;\\n  }\\n\\n}\\n\\nfunction isclose(x, y, rtol = 1.0e-7, atol = 1.0e-8) {\\n  return Math.abs(x - y) &lt;= (atol + rtol * Math.abs(y));\\n}\\n\\n\\nclass GeometricDistribution extends DiscreteUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Geometric&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03b8&#x27;];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pmfSingleValue(x, params) {\\n    let theta = params[0];\\n\\n    if (theta == 1) {\\n      if (x == 0) return 1.0;\\n      return 0.0;\\n    }\\n\\n    if (theta == 0) return 0.0;\\n\\n    if (x &lt; 0) return NaN;\\n\\n    return Math.exp(x * Math.log(1.0 - theta) + Math.log(theta));\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x &lt; 0) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let theta = params[0];\\n\\n    return 1.0 - Math.pow(1.0 - theta, x + 1.0);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let theta = params[0];\\n\\n    if (p === 0) return 0;\\n    if (p === 1) return Infinity;\\n    if (theta === 1) return 0;\\n\\n    let res = Math.ceil(Math.log(1 - p) / Math.log(1 - theta) - 1);\\n\\n    if (res === -0) return 0;\\n    return res;\\n  }\\n\\n  defaultXRange(params) {\\n    let theta = params[0];\\n\\n    return [-1, this.ppfSingleValue(0.999, params)];\\n  }\\n\\n  quantileSet(x, p) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n\\n    if (!Number.isInteger(x1)) {\\n      throw new Error(this.varName + &#x27; must be integer.&#x27;)\\n    }\\n    if (x1 &lt; 0) {\\n      throw new Error(&#x27;Must have &#x27; + this.varName + &#x27; &gt; 0.&#x27;)\\n    }\\n\\n    return [[1.0 - Math.pow(1.0 - p1, 1.0 / (x1 + 1.0))], true];\\n  }\\n\\n}\\n\\n\\n\\nvar dist = new GeometricDistribution();\\n\\n\\n\\nif (triggerCallbacks.active &amp;&amp; !cb_obj.disabled) {\\n\\tif (quantileSetterSwitch.active) {\\n\\t\\tquantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p);\\n\\t}\\n\\telse {\\n\\t\\tupdateData(source_p, source_c, p_p, sliders, discrete);\\n\\t\\tupdateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes);\\n\\t}\\n}"}}]]]},"width":200,"title":"\\u03b8","format":{"type":"object","name":"CustomJSTickFormatter","id":"p4554","attributes":{"code":"return tick.toPrecision(4)"}},"start":0,"end":1,"value":0.5,"step":0.01}}]],["xBoxes",[{"id":"p4558"}]],["pBoxes",[{"id":"p4559"}]],["quantileSetterSwitch",{"id":"p4561"}],["quantileSetterDiv",{"id":"p4560"}],["triggerCallbacks",{"id":"p4562"}],["startBoxes",[{"id":"p4556"}]],["endBoxes",[{"id":"p4557"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let x = paramsFromBoxes(xBoxes);\\n  let p = paramsFromBoxes(pBoxes);\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ){\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n          endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);        \\n        }\\n        sliders[dist.activeParamsInds[i]].value = optimParams[i];\\n      }\\n\\n      params = paramsFromSliders(sliders); \\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.floor(xRange.start);\\n  let xRangeMax = Math.ceil(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c = [xRangeMin - 1, ...x_p.flatMap(x =&gt; [x, x]), xRangeMax + 1];\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = -0.04;\\n    p_c.y_range.end = 1.04;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = -pdfMax * 0.04;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264&#x27; + xMax.toString() + &#x27;.&lt;/p\\\\&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass DiscreteUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pmfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pmf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pmfSingleValue(x, params, parametrization),\\n      x,\\n      params);\\n  }\\n\\n  cdfSingleValue(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    \\n    let cumsum = 0.0;\\n    let summand = 0.0;\\n    for (let n = this.xMin(params, parametrization); n &lt;= x; n++) {\\n        summand = this.pmfSingleValue(n, params, parametrization);\\n        if (!isNaN(summand)) cumsum += summand;\\n    }\\n\\n    return cumsum;\\n  }\\n\\n  cdfForPlotting(xStart, xEnd, params, parametrization = this.parametrization) {\\n\\n    params = this.scalarToArrayParams(params);\\n\\n    \\n    let cumsum = 0.0;\\n    let prob;\\n    for (let x = this.xMin(params, parametrization); x &lt; xStart; x++) {\\n      prob = this.pmfSingleValue(x, params, parametrization);\\n      if (!isNaN(prob)) cumsum += prob;\\n    }\\n\\n    \\n    let yCDF = [];\\n    for (let x = xStart; x &lt; xEnd; x++) {\\n      prob = this.pmfSingleValue(x, params, parametrization);\\n      if (!isNaN(prob)) cumsum += prob;\\n      yCDF.push(cumsum, cumsum);\\n    }\\n\\n    return yCDF;\\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) throw new Error(&#x27;p must be between 0 and 1.&#x27;)\\n\\n    \\n    if (p == 0) return xMin(params, parametrization);\\n\\n    \\n    if (p == 1) return xMax(params, parametrization);\\n\\n    params = this.scalarToArrayParams(params);\\n\\n    \\n    let n = this.xMin(params, parametrization);\\n    let cumsum = this.pmfSingleValue(n, params, parametrization);\\n\\n    let iters = 0;\\n    let summand = 0.0;\\n    let xMaxForTheseParams = this.xMax(params, parametrization);\\n    while (cumsum &lt; p &amp;&amp; !isclose(cumsum, p) &amp;&amp; !isNaN(summand) &amp;&amp; n &lt; xMaxForTheseParams) {\\n      n += 1;\\n      summand = this.pmfSingleValue(n, params, parametrization);\\n\\n      if (!isNaN(summand)) cumsum += summand;\\n\\n      iters += 1;\\n    }\\n\\n    return n;\\n  }\\n\\n}\\n\\nfunction isclose(x, y, rtol = 1.0e-7, atol = 1.0e-8) {\\n  return Math.abs(x - y) &lt;= (atol + rtol * Math.abs(y));\\n}\\n\\n\\nclass GeometricDistribution extends DiscreteUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Geometric&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03b8&#x27;];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pmfSingleValue(x, params) {\\n    let theta = params[0];\\n\\n    if (theta == 1) {\\n      if (x == 0) return 1.0;\\n      return 0.0;\\n    }\\n\\n    if (theta == 0) return 0.0;\\n\\n    if (x &lt; 0) return NaN;\\n\\n    return Math.exp(x * Math.log(1.0 - theta) + Math.log(theta));\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x &lt; 0) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let theta = params[0];\\n\\n    return 1.0 - Math.pow(1.0 - theta, x + 1.0);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let theta = params[0];\\n\\n    if (p === 0) return 0;\\n    if (p === 1) return Infinity;\\n    if (theta === 1) return 0;\\n\\n    let res = Math.ceil(Math.log(1 - p) / Math.log(1 - theta) - 1);\\n\\n    if (res === -0) return 0;\\n    return res;\\n  }\\n\\n  defaultXRange(params) {\\n    let theta = params[0];\\n\\n    return [-1, this.ppfSingleValue(0.999, params)];\\n  }\\n\\n  quantileSet(x, p) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n\\n    if (!Number.isInteger(x1)) {\\n      throw new Error(this.varName + &#x27; must be integer.&#x27;)\\n    }\\n    if (x1 &lt; 0) {\\n      throw new Error(&#x27;Must have &#x27; + this.varName + &#x27; &gt; 0.&#x27;)\\n    }\\n\\n    return [[1.0 - Math.pow(1.0 - p1, 1.0 / (x1 + 1.0))], true];\\n  }\\n\\n}\\n\\n\\n\\nvar dist = new GeometricDistribution();\\n\\n\\n\\nlet params = paramsFromSliders(sliders); \\n\\n\\nlet [x1, x2] = dist.defaultXRange(params);\\n\\n\\ntriggerCallbacks.active = false;\\n\\n\\np_p.x_range.start = x1;\\np_p.x_range.end = x2;\\n\\nupdateData(source_p, source_c, p_p, sliders, discrete);\\n\\n\\nsetYRanges(p_p, p_c, source_p);  \\n\\ntriggerCallbacks.active = true;\\n"}}]]]},"x_range":{"id":"p4519"},"y_range":{"type":"object","name":"Range1d","id":"p4520","attributes":{"start":-0.04,"end":1.04}},"x_scale":{"type":"object","name":"LinearScale","id":"p4500"},"y_scale":{"type":"object","name":"LinearScale","id":"p4501"},"title":{"type":"object","name":"Title","id":"p4493","attributes":{"text":" "}},"renderers":[{"type":"object","name":"GlyphRenderer","id":"p4533","attributes":{"data_source":{"id":"p4524"},"view":{"type":"object","name":"CDSView","id":"p4534","attributes":{"filter":{"type":"object","name":"AllIndices","id":"p4535"}}},"glyph":{"type":"object","name":"Line","id":"p4530","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_width":2}},"nonselection_glyph":{"type":"object","name":"Line","id":"p4531","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_alpha":0.1,"line_width":2}},"muted_glyph":{"type":"object","name":"Line","id":"p4532","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_alpha":0.2,"line_width":2}}}}],"toolbar":{"type":"object","name":"Toolbar","id":"p4499","attributes":{"tools":[{"type":"object","name":"PanTool","id":"p4512"},{"type":"object","name":"WheelZoomTool","id":"p4513","attributes":{"renderers":"auto"}},{"type":"object","name":"BoxZoomTool","id":"p4514","attributes":{"overlay":{"type":"object","name":"BoxAnnotation","id":"p4515","attributes":{"syncable":false,"level":"overlay","visible":false,"left_units":"canvas","right_units":"canvas","top_units":"canvas","bottom_units":"canvas","line_color":"black","line_alpha":1.0,"line_width":2,"line_dash":[4,4],"fill_color":"lightgrey","fill_alpha":0.5}}}},{"type":"object","name":"SaveTool","id":"p4516"},{"type":"object","name":"ResetTool","id":"p4517"},{"type":"object","name":"HelpTool","id":"p4518"}]}},"toolbar_location":null,"left":[{"type":"object","name":"LinearAxis","id":"p4507","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p4508","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p4509"},"axis_label":"CDF","axis_label_text_font_style":"normal","major_label_policy":{"type":"object","name":"AllLabels","id":"p4510"}}}],"below":[{"type":"object","name":"LinearAxis","id":"p4502","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p4503","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p4504"},"axis_label":"y","major_label_policy":{"type":"object","name":"AllLabels","id":"p4505"}}}],"center":[{"type":"object","name":"Grid","id":"p4506","attributes":{"axis":{"id":"p4502"}}},{"type":"object","name":"Grid","id":"p4511","attributes":{"dimension":1,"axis":{"id":"p4507"}}}],"frame_width":300,"frame_height":175,"background_fill_alpha":0,"border_fill_alpha":0}}],["source_p",{"id":"p4521"}],["source_c",{"id":"p4524"}],["discrete",true],["n",400],["sliders",[{"id":"p4555"}]],["xBoxes",[{"id":"p4558"}]],["pBoxes",[{"id":"p4559"}]],["quantileSetterSwitch",{"id":"p4561"}],["quantileSetterDiv",{"id":"p4560"}],["triggerCallbacks",{"id":"p4562"}],["startBoxes",[{"id":"p4556"}]],["endBoxes",[{"id":"p4557"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let x = paramsFromBoxes(xBoxes);\\n  let p = paramsFromBoxes(pBoxes);\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ){\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n          endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);        \\n        }\\n        sliders[dist.activeParamsInds[i]].value = optimParams[i];\\n      }\\n\\n      params = paramsFromSliders(sliders); \\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.floor(xRange.start);\\n  let xRangeMax = Math.ceil(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c = [xRangeMin - 1, ...x_p.flatMap(x =&gt; [x, x]), xRangeMax + 1];\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = -0.04;\\n    p_c.y_range.end = 1.04;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = -pdfMax * 0.04;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264&#x27; + xMax.toString() + &#x27;.&lt;/p\\\\&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass DiscreteUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pmfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pmf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pmfSingleValue(x, params, parametrization),\\n      x,\\n      params);\\n  }\\n\\n  cdfSingleValue(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    \\n    let cumsum = 0.0;\\n    let summand = 0.0;\\n    for (let n = this.xMin(params, parametrization); n &lt;= x; n++) {\\n        summand = this.pmfSingleValue(n, params, parametrization);\\n        if (!isNaN(summand)) cumsum += summand;\\n    }\\n\\n    return cumsum;\\n  }\\n\\n  cdfForPlotting(xStart, xEnd, params, parametrization = this.parametrization) {\\n\\n    params = this.scalarToArrayParams(params);\\n\\n    \\n    let cumsum = 0.0;\\n    let prob;\\n    for (let x = this.xMin(params, parametrization); x &lt; xStart; x++) {\\n      prob = this.pmfSingleValue(x, params, parametrization);\\n      if (!isNaN(prob)) cumsum += prob;\\n    }\\n\\n    \\n    let yCDF = [];\\n    for (let x = xStart; x &lt; xEnd; x++) {\\n      prob = this.pmfSingleValue(x, params, parametrization);\\n      if (!isNaN(prob)) cumsum += prob;\\n      yCDF.push(cumsum, cumsum);\\n    }\\n\\n    return yCDF;\\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) throw new Error(&#x27;p must be between 0 and 1.&#x27;)\\n\\n    \\n    if (p == 0) return xMin(params, parametrization);\\n\\n    \\n    if (p == 1) return xMax(params, parametrization);\\n\\n    params = this.scalarToArrayParams(params);\\n\\n    \\n    let n = this.xMin(params, parametrization);\\n    let cumsum = this.pmfSingleValue(n, params, parametrization);\\n\\n    let iters = 0;\\n    let summand = 0.0;\\n    let xMaxForTheseParams = this.xMax(params, parametrization);\\n    while (cumsum &lt; p &amp;&amp; !isclose(cumsum, p) &amp;&amp; !isNaN(summand) &amp;&amp; n &lt; xMaxForTheseParams) {\\n      n += 1;\\n      summand = this.pmfSingleValue(n, params, parametrization);\\n\\n      if (!isNaN(summand)) cumsum += summand;\\n\\n      iters += 1;\\n    }\\n\\n    return n;\\n  }\\n\\n}\\n\\nfunction isclose(x, y, rtol = 1.0e-7, atol = 1.0e-8) {\\n  return Math.abs(x - y) &lt;= (atol + rtol * Math.abs(y));\\n}\\n\\n\\nclass GeometricDistribution extends DiscreteUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Geometric&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03b8&#x27;];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pmfSingleValue(x, params) {\\n    let theta = params[0];\\n\\n    if (theta == 1) {\\n      if (x == 0) return 1.0;\\n      return 0.0;\\n    }\\n\\n    if (theta == 0) return 0.0;\\n\\n    if (x &lt; 0) return NaN;\\n\\n    return Math.exp(x * Math.log(1.0 - theta) + Math.log(theta));\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x &lt; 0) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let theta = params[0];\\n\\n    return 1.0 - Math.pow(1.0 - theta, x + 1.0);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let theta = params[0];\\n\\n    if (p === 0) return 0;\\n    if (p === 1) return Infinity;\\n    if (theta === 1) return 0;\\n\\n    let res = Math.ceil(Math.log(1 - p) / Math.log(1 - theta) - 1);\\n\\n    if (res === -0) return 0;\\n    return res;\\n  }\\n\\n  defaultXRange(params) {\\n    let theta = params[0];\\n\\n    return [-1, this.ppfSingleValue(0.999, params)];\\n  }\\n\\n  quantileSet(x, p) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n\\n    if (!Number.isInteger(x1)) {\\n      throw new Error(this.varName + &#x27; must be integer.&#x27;)\\n    }\\n    if (x1 &lt; 0) {\\n      throw new Error(&#x27;Must have &#x27; + this.varName + &#x27; &gt; 0.&#x27;)\\n    }\\n\\n    return [[1.0 - Math.pow(1.0 - p1, 1.0 / (x1 + 1.0))], true];\\n  }\\n\\n}\\n\\n\\n\\nvar dist = new GeometricDistribution();\\n\\n\\nif (triggerCallbacks.active) {\\n  updateData(source_p, source_c, p_p, sliders, discrete);\\n}"}}]],["change:end",[{"id":"p4564"}]]]},"start":-0.5,"end":20}},"y_range":{"type":"object","name":"DataRange1d","id":"p4463"},"x_scale":{"type":"object","name":"LinearScale","id":"p4471"},"y_scale":{"type":"object","name":"LinearScale","id":"p4472"},"title":{"type":"object","name":"Title","id":"p4464","attributes":{"text":"Geometric"}},"renderers":[{"type":"object","name":"GlyphRenderer","id":"p4542","attributes":{"data_source":{"id":"p4521"},"view":{"type":"object","name":"CDSView","id":"p4543","attributes":{"filter":{"type":"object","name":"AllIndices","id":"p4544"}}},"glyph":{"type":"object","name":"Circle","id":"p4539","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"size":{"type":"value","value":5},"line_color":{"type":"value","value":"#1f77b4"},"fill_color":{"type":"value","value":"#1f77b4"}}},"nonselection_glyph":{"type":"object","name":"Circle","id":"p4540","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"size":{"type":"value","value":5},"line_color":{"type":"value","value":"#1f77b4"},"line_alpha":{"type":"value","value":0.1},"fill_color":{"type":"value","value":"#1f77b4"},"fill_alpha":{"type":"value","value":0.1},"hatch_alpha":{"type":"value","value":0.1}}},"muted_glyph":{"type":"object","name":"Circle","id":"p4541","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"size":{"type":"value","value":5},"line_color":{"type":"value","value":"#1f77b4"},"line_alpha":{"type":"value","value":0.2},"fill_color":{"type":"value","value":"#1f77b4"},"fill_alpha":{"type":"value","value":0.2},"hatch_alpha":{"type":"value","value":0.2}}}}},{"type":"object","name":"GlyphRenderer","id":"p4551","attributes":{"data_source":{"id":"p4521"},"view":{"type":"object","name":"CDSView","id":"p4552","attributes":{"filter":{"type":"object","name":"AllIndices","id":"p4553"}}},"glyph":{"type":"object","name":"Segment","id":"p4548","attributes":{"x0":{"type":"field","field":"x"},"y0":{"type":"value","value":0},"x1":{"type":"field","field":"x"},"y1":{"type":"field","field":"y_p"},"line_color":{"type":"value","value":"#1f77b4"},"line_width":{"type":"value","value":2}}},"nonselection_glyph":{"type":"object","name":"Segment","id":"p4549","attributes":{"x0":{"type":"field","field":"x"},"y0":{"type":"value","value":0},"x1":{"type":"field","field":"x"},"y1":{"type":"field","field":"y_p"},"line_color":{"type":"value","value":"#1f77b4"},"line_alpha":{"type":"value","value":0.1},"line_width":{"type":"value","value":2}}},"muted_glyph":{"type":"object","name":"Segment","id":"p4550","attributes":{"x0":{"type":"field","field":"x"},"y0":{"type":"value","value":0},"x1":{"type":"field","field":"x"},"y1":{"type":"field","field":"y_p"},"line_color":{"type":"value","value":"#1f77b4"},"line_alpha":{"type":"value","value":0.2},"line_width":{"type":"value","value":2}}}}}],"toolbar":{"type":"object","name":"Toolbar","id":"p4470","attributes":{"tools":[{"type":"object","name":"PanTool","id":"p4483"},{"type":"object","name":"WheelZoomTool","id":"p4484","attributes":{"renderers":"auto"}},{"type":"object","name":"BoxZoomTool","id":"p4485","attributes":{"overlay":{"type":"object","name":"BoxAnnotation","id":"p4486","attributes":{"syncable":false,"level":"overlay","visible":false,"left_units":"canvas","right_units":"canvas","top_units":"canvas","bottom_units":"canvas","line_color":"black","line_alpha":1.0,"line_width":2,"line_dash":[4,4],"fill_color":"lightgrey","fill_alpha":0.5}}}},{"type":"object","name":"SaveTool","id":"p4487"},{"type":"object","name":"ResetTool","id":"p4488"},{"type":"object","name":"HelpTool","id":"p4489"}]}},"toolbar_location":null,"left":[{"type":"object","name":"LinearAxis","id":"p4478","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p4479","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p4480"},"axis_label":"PMF","axis_label_text_font_style":"normal","major_label_policy":{"type":"object","name":"AllLabels","id":"p4481"}}}],"below":[{"type":"object","name":"LinearAxis","id":"p4473","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p4474","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p4475"},"axis_label":"y","major_label_policy":{"type":"object","name":"AllLabels","id":"p4476"}}}],"center":[{"type":"object","name":"Grid","id":"p4477","attributes":{"axis":{"id":"p4473"}}},{"type":"object","name":"Grid","id":"p4482","attributes":{"dimension":1,"axis":{"id":"p4478"}}}],"frame_width":300,"frame_height":175,"background_fill_alpha":0,"border_fill_alpha":0}}],["p_c",{"id":"p4490"}],["source_p",{"id":"p4521"}],["source_c",{"id":"p4524"}],["discrete",true],["n",400],["sliders",[{"id":"p4555"}]],["xBoxes",[{"id":"p4558"}]],["pBoxes",[{"id":"p4559"}]],["quantileSetterSwitch",{"id":"p4561"}],["quantileSetterDiv",{"id":"p4560"}],["triggerCallbacks",{"id":"p4562"}],["startBoxes",[{"id":"p4556"}]],["endBoxes",[{"id":"p4557"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let x = paramsFromBoxes(xBoxes);\\n  let p = paramsFromBoxes(pBoxes);\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ){\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n          endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);        \\n        }\\n        sliders[dist.activeParamsInds[i]].value = optimParams[i];\\n      }\\n\\n      params = paramsFromSliders(sliders); \\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.floor(xRange.start);\\n  let xRangeMax = Math.ceil(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c = [xRangeMin - 1, ...x_p.flatMap(x =&gt; [x, x]), xRangeMax + 1];\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = -0.04;\\n    p_c.y_range.end = 1.04;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = -pdfMax * 0.04;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264&#x27; + xMax.toString() + &#x27;.&lt;/p\\\\&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass DiscreteUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pmfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pmf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pmfSingleValue(x, params, parametrization),\\n      x,\\n      params);\\n  }\\n\\n  cdfSingleValue(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    \\n    let cumsum = 0.0;\\n    let summand = 0.0;\\n    for (let n = this.xMin(params, parametrization); n &lt;= x; n++) {\\n        summand = this.pmfSingleValue(n, params, parametrization);\\n        if (!isNaN(summand)) cumsum += summand;\\n    }\\n\\n    return cumsum;\\n  }\\n\\n  cdfForPlotting(xStart, xEnd, params, parametrization = this.parametrization) {\\n\\n    params = this.scalarToArrayParams(params);\\n\\n    \\n    let cumsum = 0.0;\\n    let prob;\\n    for (let x = this.xMin(params, parametrization); x &lt; xStart; x++) {\\n      prob = this.pmfSingleValue(x, params, parametrization);\\n      if (!isNaN(prob)) cumsum += prob;\\n    }\\n\\n    \\n    let yCDF = [];\\n    for (let x = xStart; x &lt; xEnd; x++) {\\n      prob = this.pmfSingleValue(x, params, parametrization);\\n      if (!isNaN(prob)) cumsum += prob;\\n      yCDF.push(cumsum, cumsum);\\n    }\\n\\n    return yCDF;\\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) throw new Error(&#x27;p must be between 0 and 1.&#x27;)\\n\\n    \\n    if (p == 0) return xMin(params, parametrization);\\n\\n    \\n    if (p == 1) return xMax(params, parametrization);\\n\\n    params = this.scalarToArrayParams(params);\\n\\n    \\n    let n = this.xMin(params, parametrization);\\n    let cumsum = this.pmfSingleValue(n, params, parametrization);\\n\\n    let iters = 0;\\n    let summand = 0.0;\\n    let xMaxForTheseParams = this.xMax(params, parametrization);\\n    while (cumsum &lt; p &amp;&amp; !isclose(cumsum, p) &amp;&amp; !isNaN(summand) &amp;&amp; n &lt; xMaxForTheseParams) {\\n      n += 1;\\n      summand = this.pmfSingleValue(n, params, parametrization);\\n\\n      if (!isNaN(summand)) cumsum += summand;\\n\\n      iters += 1;\\n    }\\n\\n    return n;\\n  }\\n\\n}\\n\\nfunction isclose(x, y, rtol = 1.0e-7, atol = 1.0e-8) {\\n  return Math.abs(x - y) &lt;= (atol + rtol * Math.abs(y));\\n}\\n\\n\\nclass GeometricDistribution extends DiscreteUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Geometric&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03b8&#x27;];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pmfSingleValue(x, params) {\\n    let theta = params[0];\\n\\n    if (theta == 1) {\\n      if (x == 0) return 1.0;\\n      return 0.0;\\n    }\\n\\n    if (theta == 0) return 0.0;\\n\\n    if (x &lt; 0) return NaN;\\n\\n    return Math.exp(x * Math.log(1.0 - theta) + Math.log(theta));\\n  }\\n\\n  cdfSingleValue(x, params) {\\n    if (x &lt; 0) return 0.0;\\n    if (x === Infinity) return 1.0;\\n\\n    let theta = params[0];\\n\\n    return 1.0 - Math.pow(1.0 - theta, x + 1.0);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let theta = params[0];\\n\\n    if (p === 0) return 0;\\n    if (p === 1) return Infinity;\\n    if (theta === 1) return 0;\\n\\n    let res = Math.ceil(Math.log(1 - p) / Math.log(1 - theta) - 1);\\n\\n    if (res === -0) return 0;\\n    return res;\\n  }\\n\\n  defaultXRange(params) {\\n    let theta = params[0];\\n\\n    return [-1, this.ppfSingleValue(0.999, params)];\\n  }\\n\\n  quantileSet(x, p) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n\\n    if (!Number.isInteger(x1)) {\\n      throw new Error(this.varName + &#x27; must be integer.&#x27;)\\n    }\\n    if (x1 &lt; 0) {\\n      throw new Error(&#x27;Must have &#x27; + this.varName + &#x27; &gt; 0.&#x27;)\\n    }\\n\\n    return [[1.0 - Math.pow(1.0 - p1, 1.0 / (x1 + 1.0))], true];\\n  }\\n\\n}\\n\\n\\n\\nvar dist = new GeometricDistribution();\\n\\n\\n\\nif (cb_obj.active) {\\n  for (let i = 0; i &lt; sliders.length; i++) {\\n    if (!dist.fixedParamsInds.includes(i)) {\\n      sliders[i].title = dist.paramNames[i] + &#x27; (computed)&#x27;;\\n      sliders[i].disabled = true;\\n    }\\n  }\\n  for (let xBox of xBoxes) {\\n    xBox.disabled = false;\\n  }\\n  for (let pBox of pBoxes) {\\n    pBox.disabled = false;\\n  }\\n} else {\\n  for (let i = 0; i &lt; sliders.length; i++) {\\n    if (!dist.fixedParamsInds.includes(i)) {\\n      sliders[i].title = dist.paramNames[i];\\n      sliders[i].disabled = false;\\n    }\\n  }\\n  for (let xBox of xBoxes) {\\n    xBox.disabled = true;\\n  }\\n  for (let pBox of pBoxes) {\\n    pBox.disabled = true;\\n  }\\n  quantileSetterDiv.text = &#x27;&#x27;;\\n}"}}]]]}}}]}},{"type":"object","name":"Spacer","id":"p4600","attributes":{"width":10}},{"id":"p4560"}]}},{"type":"object","name":"Spacer","id":"p4602","attributes":{"height":10}},{"type":"object","name":"Row","id":"p4604","attributes":{"children":[{"type":"object","name":"Column","id":"p4588","attributes":{"children":[{"type":"object","name":"Row","id":"p4587","attributes":{"children":[{"type":"object","name":"Column","id":"p4584","attributes":{"children":[{"type":"object","name":"Spacer","id":"p4583","attributes":{"height":4}},{"id":"p4556"}]}},{"id":"p4555"},{"type":"object","name":"Column","id":"p4586","attributes":{"children":[{"type":"object","name":"Spacer","id":"p4585","attributes":{"height":4}},{"id":"p4557"}]}}]}}]}},{"type":"object","name":"Spacer","id":"p4603","attributes":{"width":20}},{"type":"object","name":"Column","id":"p4582","attributes":{"children":[{"type":"object","name":"Row","id":"p4581","attributes":{"children":[{"type":"object","name":"Spacer","id":"p4573","attributes":{"width":20}},{"type":"object","name":"Column","id":"p4576","attributes":{"children":[{"type":"object","name":"Spacer","id":"p4574","attributes":{"height":7}},{"type":"object","name":"Div","id":"p4575","attributes":{"text":"&lt;p&gt;&lt;b&gt;y: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p4558"},{"type":"object","name":"Spacer","id":"p4577","attributes":{"width":16}},{"type":"object","name":"Column","id":"p4580","attributes":{"children":[{"type":"object","name":"Spacer","id":"p4578","attributes":{"height":7}},{"type":"object","name":"Div","id":"p4579","attributes":{"text":"&lt;p&gt;&lt;b&gt;quantile: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p4559"}]}}]}}]}},{"type":"object","name":"Spacer","id":"p4605","attributes":{"height":10}},{"type":"object","name":"GridPlot","id":"p4597","attributes":{"rows":null,"cols":null,"toolbar":{"type":"object","name":"Toolbar","id":"p4596","attributes":{"tools":[{"type":"object","name":"ToolProxy","id":"p4590","attributes":{"tools":[{"id":"p4512"},{"id":"p4483"},{"id":"p4512"},{"id":"p4483"}]}},{"type":"object","name":"ToolProxy","id":"p4591","attributes":{"tools":[{"id":"p4513"},{"id":"p4484"},{"id":"p4513"},{"id":"p4484"}]}},{"type":"object","name":"ToolProxy","id":"p4592","attributes":{"tools":[{"id":"p4514"},{"id":"p4485"},{"id":"p4514"},{"id":"p4485"}]}},{"type":"object","name":"SaveTool","id":"p4593"},{"type":"object","name":"ToolProxy","id":"p4594","attributes":{"tools":[{"id":"p4517"},{"id":"p4488"},{"id":"p4517"},{"id":"p4488"}]}},{"type":"object","name":"ToolProxy","id":"p4595","attributes":{"tools":[{"id":"p4518"},{"id":"p4489"},{"id":"p4518"},{"id":"p4489"}]}}]}},"toolbar_location":"right","children":[[{"id":"p4461"},0,0],[{"type":"object","name":"Spacer","id":"p4589","attributes":{"width":30}},0,1],[{"id":"p4490"},0,2]]}}]}}]}}';
                  const render_items = [{"docid":"e5143045-8cd3-4a34-bad0-ea3fb2a3cc3b","roots":{"p4606":"c612f538-ee86-4d85-bd13-bb1780105b53"},"root_ids":["p4606"]}];
                  root.Bokeh.embed.embed_items(docs_json, render_items);
                  }
                  if (root.Bokeh !== undefined) {
                    embed_document(root);
                  } else {
                    let attempts = 0;
                    const timer = setInterval(function(root) {
                      if (root.Bokeh !== undefined) {
                        clearInterval(timer);
                        embed_document(root);
                      } else {
                        attempts++;
                        if (attempts > 100) {
                          clearInterval(timer);
                          console.log("Bokeh: ERROR: Unable to run BokehJS code because BokehJS library is missing");
                        }
                      }
                    }, 10, root)
                  }
                })(window);
              });
            };
            if (document.readyState != "loading") fn();
            else document.addEventListener("DOMContentLoaded", fn);
          })();
        },
    function(Bokeh) {
        }
      ];
    
      function run_inline_js() {
        for (let i = 0; i < inline_js.length; i++) {
          inline_js[i].call(root, root.Bokeh);
        }
      }
    
      if (root._bokeh_is_loading === 0) {
        console.debug("Bokeh: BokehJS loaded, going straight to plotting");
        run_inline_js();
      } else {
        load_libs(css_urls, js_urls, function() {
          console.debug("Bokeh: BokehJS plotting callback run at", now());
          run_inline_js();
        });
      }
    }(window));
  };
  if (document.readyState != "loading") fn();
  else document.addEventListener("DOMContentLoaded", fn);
})();