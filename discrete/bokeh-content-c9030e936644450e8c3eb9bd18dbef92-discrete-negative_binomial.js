(function() {
  const fn = function() {
    'use strict';
    (function(root) {
      function now() {
        return new Date();
      }
    
      const force = false;
    
      if (typeof root._bokeh_onload_callbacks === "undefined" || force === true) {
        root._bokeh_onload_callbacks = [];
        root._bokeh_is_loading = undefined;
      }
    
    
    const element = document.getElementById("dae8ba92-eeab-44bb-b44d-4d5feef7e632");
        if (element == null) {
          console.warn("Bokeh: autoload.js configured with elementid 'dae8ba92-eeab-44bb-b44d-4d5feef7e632' but no matching script tag was found.")
        }
      function run_callbacks() {
        try {
          root._bokeh_onload_callbacks.forEach(function(callback) {
            if (callback != null)
              callback();
          });
        } finally {
          delete root._bokeh_onload_callbacks
        }
        console.debug("Bokeh: all callbacks have finished");
      }
    
      function load_libs(css_urls, js_urls, callback) {
        if (css_urls == null) css_urls = [];
        if (js_urls == null) js_urls = [];
    
        root._bokeh_onload_callbacks.push(callback);
        if (root._bokeh_is_loading > 0) {
          console.debug("Bokeh: BokehJS is being loaded, scheduling callback at", now());
          return null;
        }
        if (js_urls == null || js_urls.length === 0) {
          run_callbacks();
          return null;
        }
        console.debug("Bokeh: BokehJS not loaded, scheduling load and callback at", now());
        root._bokeh_is_loading = css_urls.length + js_urls.length;
    
        function on_load() {
          root._bokeh_is_loading--;
          if (root._bokeh_is_loading === 0) {
            console.debug("Bokeh: all BokehJS libraries/stylesheets loaded");
            run_callbacks()
          }
        }
    
        function on_error(url) {
          console.error("failed to load " + url);
        }
    
        for (let i = 0; i < css_urls.length; i++) {
          const url = css_urls[i];
          const element = document.createElement("link");
          element.onload = on_load;
          element.onerror = on_error.bind(null, url);
          element.rel = "stylesheet";
          element.type = "text/css";
          element.href = url;
          console.debug("Bokeh: injecting link tag for BokehJS stylesheet: ", url);
          document.body.appendChild(element);
        }
    
        for (let i = 0; i < js_urls.length; i++) {
          const url = js_urls[i];
          const element = document.createElement('script');
          element.onload = on_load;
          element.onerror = on_error.bind(null, url);
          element.async = false;
          element.src = url;
          console.debug("Bokeh: injecting script tag for BokehJS library: ", url);
          document.head.appendChild(element);
        }
      };
    
      function inject_raw_css(css) {
        const element = document.createElement("style");
        element.appendChild(document.createTextNode(css));
        document.body.appendChild(element);
      }
    
      const js_urls = ["https://cdn.bokeh.org/bokeh/release/bokeh-3.4.0.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-gl-3.4.0.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-widgets-3.4.0.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-tables-3.4.0.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-mathjax-3.4.0.min.js"];
      const css_urls = [];
    
      const inline_js = [    function(Bokeh) {
          Bokeh.set_log_level("info");
        },
        function(Bokeh) {
          (function() {
            const fn = function() {
              Bokeh.safely(function() {
                (function(root) {
                  function embed_document(root) {
                  const docs_json = '{"a03891bc-f212-4e55-bbc7-ea844acaeb52":{"version":"3.4.0","title":"Bokeh Application","roots":[{"type":"object","name":"Column","id":"p4775","attributes":{"children":[{"type":"object","name":"Row","id":"p4770","attributes":{"children":[{"type":"object","name":"Spacer","id":"p4768","attributes":{"width":409}},{"type":"object","name":"Row","id":"p4740","attributes":{"children":[{"type":"object","name":"Div","id":"p4738","attributes":{"text":"&lt;p&gt;&lt;b&gt;Quantile setter mode&lt;/b&gt;&lt;/p&gt;"}},{"type":"object","name":"Spacer","id":"p4739","attributes":{"width":2}},{"type":"object","name":"Switch","id":"p4727","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:active",[{"type":"object","name":"CustomJS","id":"p4731","attributes":{"args":{"type":"map","entries":[["p_p",{"type":"object","name":"Figure","id":"p4633","attributes":{"x_range":{"type":"object","name":"Range1d","id":"p4681","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:start",[{"type":"object","name":"CustomJS","id":"p4730","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p4633"}],["p_c",{"type":"object","name":"Figure","id":"p4657","attributes":{"js_event_callbacks":{"type":"map","entries":[["reset",[{"type":"object","name":"CustomJS","id":"p4733","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p4633"}],["p_c",{"id":"p4657"}],["source_p",{"type":"object","name":"ColumnDataSource","id":"p4683","attributes":{"selected":{"type":"object","name":"Selection","id":"p4684","attributes":{"indices":[],"line_indices":[]}},"selection_policy":{"type":"object","name":"UnionRenderers","id":"p4685"},"data":{"type":"map","entries":[["x",{"type":"ndarray","array":{"type":"bytes","data":"AAAAAAEAAAACAAAAAwAAAAQAAAAFAAAABgAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAAAARAAAAEgAAABMAAAAUAAAAFQAAABYAAAAXAAAAGAAAABkAAAAaAAAAGwAAABwAAAAdAAAAHgAAAB8AAAAgAAAAIQAAACIAAAAjAAAAJAAAACUAAAAmAAAAJwAAACgAAAApAAAAKgAAACsAAAAsAAAALQAAAC4AAAAvAAAAMAAAADEAAAAyAAAA"},"shape":[51],"dtype":"int32","order":"little"}],["y_p",{"type":"ndarray","array":{"type":"bytes","data":"FZ8ztVy42T85r1Xs927VPzivVez3bsU/Soh7YqSrsD9hYE+DMDqWP0ENLDc6rHo/Jyu/WeuiXT+MgpeCMww/P4WCl4IzDB8/PWGbydLl/T7Ua/eIkefbPghisjYnXrk+bqxlopSMlj40ICSUgahzPtytjKOT2VA+0f1T2yZ1LD42/sW29bYHPgGGGy2dh+M9oFU24YTTvz0kGK7ZMK+ZPZFGixQnjHQ9oN7DbblOUD0c8mp+WrIpPZ9vPdJGHAQ9xHSYKm5I3zy6fw+mLzG4PAJ2qUT9m5I8YO2qTAV9bDyOX8tSlrRFPOsBQo5XdyA8nnTEo9nh+DuET1fIgrrSO2n3gizEF6w7vuRh6Kn/hDvaQPH/ykpfO38hVPHfPjc7Om4FLg44ETstgG10zXDpOgxs1zrovsI67/FWvc2OmzoroB3PhTV0OtTw00ECk0068vxpxgmYJTrfVCugXXj/Obfgk9Es49Y5wN8qvFOdsDkl4Cf+PRSIOcnory89a2E5EjTFfR8pOTkHFHSLniQSObCX5HZAIOo4"},"shape":[51],"dtype":"float64","order":"little"}]]}}}],["source_c",{"type":"object","name":"ColumnDataSource","id":"p4686","attributes":{"selected":{"type":"object","name":"Selection","id":"p4687","attributes":{"indices":[],"line_indices":[]}},"selection_policy":{"type":"object","name":"UnionRenderers","id":"p4688"},"data":{"type":"map","entries":[["x",{"type":"ndarray","array":{"type":"bytes","data":"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8D8AAAAAAADwPwAAAAAAAABAAAAAAAAAAEAAAAAAAAAIQAAAAAAAAAhAAAAAAAAAEEAAAAAAAAAQQAAAAAAAABRAAAAAAAAAFEAAAAAAAAAYQAAAAAAAABhAAAAAAAAAHEAAAAAAAAAcQAAAAAAAACBAAAAAAAAAIEAAAAAAAAAiQAAAAAAAACJAAAAAAAAAJEAAAAAAAAAkQAAAAAAAACZAAAAAAAAAJkAAAAAAAAAoQAAAAAAAAChAAAAAAAAAKkAAAAAAAAAqQAAAAAAAACxAAAAAAAAALEAAAAAAAAAuQAAAAAAAAC5AAAAAAAAAMEAAAAAAAAAwQAAAAAAAADFAAAAAAAAAMUAAAAAAAAAyQAAAAAAAADJAAAAAAAAAM0AAAAAAAAAzQAAAAAAAADRAAAAAAAAANEAAAAAAAAA1QAAAAAAAADVAAAAAAAAANkAAAAAAAAA2QAAAAAAAADdAAAAAAAAAN0AAAAAAAAA4QAAAAAAAADhAAAAAAAAAOUAAAAAAAAA5QAAAAAAAADpAAAAAAAAAOkAAAAAAAAA7QAAAAAAAADtAAAAAAAAAPEAAAAAAAAA8QAAAAAAAAD1AAAAAAAAAPUAAAAAAAAA+QAAAAAAAAD5AAAAAAAAAP0AAAAAAAAA/QAAAAAAAAEBAAAAAAAAAQEAAAAAAAIBAQAAAAAAAgEBAAAAAAAAAQUAAAAAAAABBQAAAAAAAgEFAAAAAAACAQUAAAAAAAABCQAAAAAAAAEJAAAAAAACAQkAAAAAAAIBCQAAAAAAAAENAAAAAAAAAQ0AAAAAAAIBDQAAAAAAAgENAAAAAAAAAREAAAAAAAABEQAAAAAAAgERAAAAAAACAREAAAAAAAABFQAAAAAAAAEVAAAAAAACARUAAAAAAAIBFQAAAAAAAAEZAAAAAAAAARkAAAAAAAIBGQAAAAAAAgEZAAAAAAAAAR0AAAAAAAABHQAAAAAAAgEdAAAAAAACAR0AAAAAAAABIQAAAAAAAAEhAAAAAAACASEAAAAAAAIBIQAAAAAAAAElAAAAAAAAASUAAAAAAAABJQA=="},"shape":[104],"dtype":"float64","order":"little"}],["y_c",{"type":"ndarray","array":{"type":"bytes","data":"Fp8ztVy42T8WnzO1XLjZPxafM7VcuNk/Fp8ztVy42T8op8RQqpPnPyinxFCqk+c/9xLaS2jv7D/3EtpLaO/sPwCEKdjcBO8/AIQp2NwE7z8D/0NcrrbvPwP/Q1yutu8/Hley0Abs7z8eV7LQBuzvP7M2X0bY+u8/szZfRtj67z+jic/Muf7vP6OJz8y5/u8/X55rLrL/7z9fnmsusv/vP5YxEfrt/+8/ljER+u3/7z8S9tnt+//vPxL22e37/+8/6NyeGf//7z/o3J4Z///vP/uBA87//+8/+4EDzv//7z8khVT1///vPySFVPX//+8/9U7B/f//7z/1TsH9///vP2OhiP///+8/Y6GI////7z86fef////vPzp95////+8/1wT7////7z/XBPv////vP0j//v///+8/SP/+////7z/BzP/////vP8HM/////+8/2vX/////7z/a9f/////vPwH+/////+8/Af7/////7z+c///////vP5z//////+8/7f//////7z/t///////vP/z//////+8//P//////7z/////////vP////////+8/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPwAAAAAAAPA/AAAAAAAA8D8AAAAAAADwPw=="},"shape":[104],"dtype":"float64","order":"little"}]]}}}],["discrete",true],["n",400],["sliders",[{"type":"object","name":"Slider","id":"p4717","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p4729","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p4633"}],["p_c",{"id":"p4657"}],["source_p",{"id":"p4683"}],["source_c",{"id":"p4686"}],["discrete",true],["n",400],["sliders",[{"id":"p4717"},{"type":"object","name":"Slider","id":"p4719","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p4729"}]]]},"width":200,"title":"\\u03b2","format":{"type":"object","name":"CustomJSTickFormatter","id":"p4718","attributes":{"code":"return tick.toPrecision(4)"}},"start":0.01,"end":20,"value":5,"step":0.01}}]],["xBoxes",[{"type":"object","name":"TextInput","id":"p4724","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p4732","attributes":{"args":{"type":"map","entries":[["p_p",{"id":"p4633"}],["p_c",{"id":"p4657"}],["source_p",{"id":"p4683"}],["source_c",{"id":"p4686"}],["discrete",true],["n",400],["sliders",[{"id":"p4717"},{"id":"p4719"}]],["xBoxes",[{"id":"p4724"}]],["pBoxes",[{"type":"object","name":"TextInput","id":"p4725","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"id":"p4732"}]]]},"disabled":true,"width":80,"value":"0.5000"}}]],["quantileSetterSwitch",{"id":"p4727"}],["quantileSetterDiv",{"type":"object","name":"Div","id":"p4726"}],["triggerCallbacks",{"type":"object","name":"Switch","id":"p4728","attributes":{"active":true}}],["startBoxes",[{"type":"object","name":"TextInput","id":"p4720","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p4734","attributes":{"args":{"type":"map","entries":[["minValue",0],["maxValue","Infinity"],["slider",{"id":"p4717"}]]},"code":"\\n\\nslider.start = Math.max(minValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"0.01"}},{"type":"object","name":"TextInput","id":"p4721","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p4736","attributes":{"args":{"type":"map","entries":[["minValue",0],["maxValue","Infinity"],["slider",{"id":"p4719"}]]},"code":"\\n\\nslider.start = Math.max(minValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"0.01"}}]],["endBoxes",[{"type":"object","name":"TextInput","id":"p4722","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p4735","attributes":{"args":{"type":"map","entries":[["minValue",0],["maxValue","Infinity"],["slider",{"id":"p4717"}]]},"code":"\\n\\nslider.end = Math.min(maxValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"20"}},{"type":"object","name":"TextInput","id":"p4723","attributes":{"js_property_callbacks":{"type":"map","entries":[["change:value",[{"type":"object","name":"CustomJS","id":"p4737","attributes":{"args":{"type":"map","entries":[["minValue",0],["maxValue","Infinity"],["slider",{"id":"p4719"}]]},"code":"\\n\\nslider.end = Math.min(maxValue, Number(cb_obj.value));\\nslider.step = (slider.end - slider.start) / 1000;"}}]]]},"width":70,"value":"20"}}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p\\\\&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass DiscreteUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pmfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pmf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pmfSingleValue(x, params, parametrization),\\n      x,\\n      params);\\n  }\\n\\n  cdfSingleValue(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    \\n    let cumsum = 0.0;\\n    let summand = 0.0;\\n    for (let n = this.xMin(params, parametrization); n &lt;= x; n++) {\\n        summand = this.pmfSingleValue(n, params, parametrization);\\n        if (!isNaN(summand)) cumsum += summand;\\n    }\\n\\n    return cumsum;\\n  }\\n\\n  cdfForPlotting(xStart, xEnd, params, parametrization = this.parametrization) {\\n\\n    params = this.scalarToArrayParams(params);\\n\\n    \\n    let cumsum;\\n    let y_c;\\n    let prob;\\n    if (Number.isInteger(xStart)) {\\n      \\n      cumsum = this.cdfSingleValue(Math.floor(xStart) - 1, params, parametrization);\\n\\n      if (Number.isInteger(xEnd)) {\\n        y_c = [cumsum];\\n        for (let x = xStart; x &lt; xEnd; x++) {\\n          prob = this.pmfSingleValue(x, params, parametrization);\\n          if (!isNaN(prob)) cumsum += prob;\\n          y_c.push(cumsum, cumsum);\\n        }\\n        prob = this.pmfSingleValue(xEnd, params, parametrization);\\n        if (!isNaN(prob)) cumsum += prob;\\n        y_c.push(cumsum);\\n      }\\n      else {\\n        y_c = [cumsum];\\n        for (let x = xStart; x &lt;= Math.floor(xEnd); x++) {\\n          prob = this.pmfSingleValue(x, params, parametrization);\\n          if (!isNaN(prob)) cumsum += prob;\\n          y_c.push(cumsum, cumsum);\\n        }\\n      }\\n    }\\n    else {\\n      \\n      cumsum = this.cdfSingleValue(Math.floor(xStart), params, parametrization);\\n\\n      if (Number.isInteger(xEnd)) {\\n        y_c = [cumsum, cumsum];\\n        for (let x = Math.ceil(xStart); x &lt; xEnd; x++) {\\n          prob = this.pmfSingleValue(x, params, parametrization);\\n          if (!isNaN(prob)) cumsum += prob;\\n          y_c.push(cumsum, cumsum);\\n        }\\n        prob = this.pmfSingleValue(xEnd, params, parametrization);\\n        if (!isNaN(prob)) cumsum += prob;\\n        y_c.push(cumsum);        \\n      }\\n      else {\\n        y_c = [cumsum, cumsum];\\n        for (let x = Math.ceil(xStart); x &lt;= xEnd; x++) {\\n          prob = this.pmfSingleValue(x, params, parametrization);\\n          if (!isNaN(prob)) cumsum += prob;\\n          y_c.push(cumsum, cumsum);\\n        }\\n      }    \\n    }\\n\\n    return y_c;\\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) throw new Error(&#x27;p must be between 0 and 1.&#x27;)\\n\\n    \\n    if (p == 0) return xMin(params, parametrization);\\n\\n    \\n    if (p == 1) return xMax(params, parametrization);\\n\\n    params = this.scalarToArrayParams(params);\\n\\n    \\n    let n = this.xMin(params, parametrization);\\n    let cumsum = this.pmfSingleValue(n, params, parametrization);\\n\\n    let iters = 0;\\n    let summand = 0.0;\\n    let xMaxForTheseParams = this.xMax(params, parametrization);\\n    while (cumsum &lt; p &amp;&amp; !isclose(cumsum, p) &amp;&amp; !isNaN(summand) &amp;&amp; n &lt; xMaxForTheseParams) {\\n      n += 1;\\n      summand = this.pmfSingleValue(n, params, parametrization);\\n\\n      if (!isNaN(summand)) cumsum += summand;\\n\\n      iters += 1;\\n    }\\n\\n    return n;\\n  }\\n\\n}\\n\\nclass BinomialDistribution extends DiscreteUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Binomial&#x27;;\\n\\n    \\n    this.varName = &#x27;n&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;N&#x27;, &#x27;\\u03b8&#x27;];\\n\\n    \\n    this.paramMin = [0, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, 1.0];\\n\\n    \\n    this.fixedParams = [&#x27;N&#x27;];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0;\\n  }\\n\\n  xMax(params) {\\n    return params[0];\\n  }\\n\\n  pmfSingleValue(n, params) {\\n    let [N, theta] = params.slice(0, 2);\\n\\n    if (n &gt; N || n &lt; 0) return NaN;\\n\\n    if (theta == 0) {\\n      if (n == 0) return 1.0;\\n      return 0.0;\\n    }\\n\\n    if (theta == 1) {\\n      if (n == N) return 1.0;\\n      return 0.0;\\n    }\\n\\n    return Math.exp(lnchoice(N, n) +\\n      n * Math.log(theta) +\\n      (N - n) * Math.log(1 - theta));\\n  }\\n\\n  cdfSingleValue(n, params) {\\n    let [N, theta] = params.slice(0, 2);\\n\\n    if (n &lt; 0) return 0.0;\\n    if (n &gt;= N) return 1.0;\\n    return regularizedIncompleteBeta(1.0 - theta, N - n, n + 1);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let [N, theta] = params.slice(0, 2);\\n    \\n    return super.ppfSingleValue(p, params, 0, N, N);\\n  }\\n\\n  defaultXRange(params) {\\n    let [N, theta] = params.slice(0, 2);\\n\\n    if (N &lt; 50) {\\n      return [-1, N + 1];\\n    } else {\\n      return this.ppf([0.001, 0.999], params);\\n    }\\n  }\\n\\n  quantileSet(x, p, extraParams) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n    let N = extraParams[0];\\n\\n    if (!Number.isInteger(x1)) {\\n      throw new Error(this.varName + &#x27; must be integer.&#x27;)\\n    }\\n    if (x1 &lt; 0) {\\n      throw new Error(&#x27;Must have &#x27; + this.varName + &#x27; &gt; 0.&#x27;)\\n    }\\n    if (x1 &gt;= N) {\\n      throw new Error(&#x27;Must have &#x27; + this.varName + &#x27; &lt; N.&#x27;)\\n    }\\n\\n    \\n    let rootFun = (theta, N) =&gt; p1 - this.cdfSingleValue(x1, [N, theta]);\\n\\n    let thetaOpt = brentSolve(rootFun, 0.0, 1.0, [N]);\\n    let optimSuccess = thetaOpt != null;\\n    \\n    return [[thetaOpt], optimSuccess];\\n  }\\n}\\n\\nclass PoissonDistribution extends DiscreteUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Poisson&#x27;;\\n\\n    \\n    this.varName = &#x27;n&#x27;;  \\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bb&#x27;];\\n\\n    \\n    this.paramMin = [0.0];\\n\\n    \\n    this.paramMax = [Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pmfSingleValue(n, params) {\\n    let lam = params[0];\\n\\n    if (lam &lt; 0) {\\n      return NaN;\\n    } else if (lam == 0) {\\n      if (n == 0) return 1.0;\\n      return 0.0;\\n    }\\n\\n    return Math.exp(n * Math.log(lam) - lnfactorial(n) - lam);\\n  }\\n\\n  cdfSingleValue(n, params) {\\n    if (n &lt; 0) return 0.0;\\n    if (n === Infinity) return 1.0;\\n\\n    let lam = params[0];\\n\\n    if (lam === 0) return 1.0;\\n\\n    return gammaincU(lam, n + 1, true);\\n  }\\n\\n  defaultXRange(params) {\\n    return super.ppf([0.001, 0.999], params)\\n  }\\n\\n  quantileSet(x, p) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n\\n    if (!Number.isInteger(x1)) {\\n      throw new Error(this.varName + &#x27; must be integer.&#x27;)\\n    }\\n    if (x1 &lt; 0) {\\n      throw new Error(&#x27;Must have &#x27; + this.varName + &#x27; \\u2265 0.&#x27;)\\n    }\\n\\n    \\n    if (x1 === 0 &amp;&amp; p1 === 1) return [[0.0], true];\\n\\n    \\n    const rootFun = (xi) =&gt; {\\n      if (xi === 1) return p1;\\n      return p1 - this.cdfSingleValue(x1, [xi / (1 - xi)]);\\n    }\\n\\n    let xiOpt = brentSolve(rootFun, 0.0, 1.0);\\n    let optimSuccess = xiOpt != null;\\n    \\n    return [[xiOpt / (1 - xiOpt)], optimSuccess];\\n  }\\n\\n}\\n\\nfunction regularizedIncompleteBeta(x, a, b) {\\n    \\n    \\n    if (x &lt; 0 || x &gt; 1) {\\n        throw new RangeError(&#x27;First argument must be between 0 and 1.&#x27;);\\n    }\\n\\n    \\n    else if (a === 1 &amp;&amp; b === 1) return x;\\n    else if (x === 0) return 0;\\n    else if (x === 1) return 1;\\n    else if (a === 0) return 1;\\n    else if (b === 0) return 0;\\n\\n    else {\\n        var bt = Math.exp(lngamma(a + b) - lngamma(a) - lngamma(b) + a * Math.log(x) + b * log1p(-x));\\n\\n        \\n        if (x &lt; (a + 1) / (a + b + 2)) return bt * betacf(x, a, b) / a;\\n\\n        \\n        else return 1 - bt * betacf(1 - x, b, a) / b;\\n    }\\n}\\n\\n\\nfunction lngamma(z) {\\n\\n    if(z &lt; 0) return Number(&#x27;0/0&#x27;);\\n\\n    if (z &lt; 0.5) return Math.log(Math.PI) - Math.log(Math.sin(Math.PI * z)) - lngamma(1-z);\\n\\n    var p = [676.5203681218851,\\n             -1259.1392167224028,\\n             771.32342877765313,\\n             -176.61502916214059,\\n             12.507343278686905,\\n             -0.13857109526572012,\\n             9.9843695780195716e-6,\\n             1.5056327351493116e-7];\\n\\n    z -= 1.0;\\n    var Ag = 0.99999999999980993;\\n    for (var i = 0; i &lt; p.length; i++) {\\n        Ag += p[i] / (z + i + 1);\\n    }\\n    var t = z + p.length - 0.5;\\n\\n    return 0.5 * Math.log(2*Math.PI) + (z + 0.5)*Math.log(t) - t + Math.log(Ag);\\n}\\n\\n\\nfunction lnfactorial(n) {\\n  if (n &gt; 254) { \\n    let x = n + 1;\\n    return (x - 0.5) * Math.log(x) - x + 0.5 * Math.log(2 * Math.PI) + 1.0 / (12.0 * x);\\n  }\\n  else { \\n    const lnfact = [0.000000000000000,\\n                    0.000000000000000,\\n                    0.693147180559945,\\n                    1.791759469228055,\\n                    3.178053830347946,\\n                    4.787491742782046,\\n                    6.579251212010101,\\n                    8.525161361065415,\\n                    10.604602902745251,\\n                    12.801827480081469,\\n                    15.104412573075516,\\n                    17.502307845873887,\\n                    19.987214495661885,\\n                    22.552163853123421,\\n                    25.191221182738683,\\n                    27.899271383840894,\\n                    30.671860106080675,\\n                    33.505073450136891,\\n                    36.395445208033053,\\n                    39.339884187199495,\\n                    42.335616460753485,\\n                    45.380138898476908,\\n                    48.471181351835227,\\n                    51.606675567764377,\\n                    54.784729398112319,\\n                    58.003605222980518,\\n                    61.261701761002001,\\n                    64.557538627006323,\\n                    67.889743137181526,\\n                    71.257038967168000,\\n                    74.658236348830158,\\n                    78.092223553315307,\\n                    81.557959456115029,\\n                    85.054467017581516,\\n                    88.580827542197682,\\n                    92.136175603687079,\\n                    95.719694542143202,\\n                    99.330612454787428,\\n                    102.968198614513810,\\n                    106.631760260643450,\\n                    110.320639714757390,\\n                    114.034211781461690,\\n                    117.771881399745060,\\n                    121.533081515438640,\\n                    125.317271149356880,\\n                    129.123933639127240,\\n                    132.952575035616290,\\n                    136.802722637326350,\\n                    140.673923648234250,\\n                    144.565743946344900,\\n                    148.477766951773020,\\n                    152.409592584497350,\\n                    156.360836303078800,\\n                    160.331128216630930,\\n                    164.320112263195170,\\n                    168.327445448427650,\\n                    172.352797139162820,\\n                    176.395848406997370,\\n                    180.456291417543780,\\n                    184.533828861449510,\\n                    188.628173423671600,\\n                    192.739047287844900,\\n                    196.866181672889980,\\n                    201.009316399281570,\\n                    205.168199482641200,\\n                    209.342586752536820,\\n                    213.532241494563270,\\n                    217.736934113954250,\\n                    221.956441819130360,\\n                    226.190548323727570,\\n                    230.439043565776930,\\n                    234.701723442818260,\\n                    238.978389561834350,\\n                    243.268849002982730,\\n                    247.572914096186910,\\n                    251.890402209723190,\\n                    256.221135550009480,\\n                    260.564940971863220,\\n                    264.921649798552780,\\n                    269.291097651019810,\\n                    273.673124285693690,\\n                    278.067573440366120,\\n                    282.474292687630400,\\n                    286.893133295426990,\\n                    291.323950094270290,\\n                    295.766601350760600,\\n                    300.220948647014100,\\n                    304.686856765668720,\\n                    309.164193580146900,\\n                    313.652829949878990,\\n                    318.152639620209300,\\n                    322.663499126726210,\\n                    327.185287703775200,\\n                    331.717887196928470,\\n                    336.261181979198450,\\n                    340.815058870798960,\\n                    345.379407062266860,\\n                    349.954118040770250,\\n                    354.539085519440790,\\n                    359.134205369575340,\\n                    363.739375555563470,\\n                    368.354496072404690,\\n                    372.979468885689020,\\n                    377.614197873918670,\\n                    382.258588773060010,\\n                    386.912549123217560,\\n                    391.575988217329610,\\n                    396.248817051791490,\\n                    400.930948278915760,\\n                    405.622296161144900,\\n                    410.322776526937280,\\n                    415.032306728249580,\\n                    419.750805599544780,\\n                    424.478193418257090,\\n                    429.214391866651570,\\n                    433.959323995014870,\\n                    438.712914186121170,\\n                    443.475088120918940,\\n                    448.245772745384610,\\n                    453.024896238496130,\\n                    457.812387981278110,\\n                    462.608178526874890,\\n                    467.412199571608080,\\n                    472.224383926980520,\\n                    477.044665492585580,\\n                    481.872979229887900,\\n                    486.709261136839360,\\n                    491.553448223298010,\\n                    496.405478487217580,\\n                    501.265290891579240,\\n                    506.132825342034830,\\n                    511.008022665236070,\\n                    515.890824587822520,\\n                    520.781173716044240,\\n                    525.679013515995050,\\n                    530.584288294433580,\\n                    535.496943180169520,\\n                    540.416924105997740,\\n                    545.344177791154950,\\n                    550.278651724285620,\\n                    555.220294146894960,\\n                    560.169054037273100,\\n                    565.124881094874350,\\n                    570.087725725134190,\\n                    575.057539024710200,\\n                    580.034272767130800,\\n                    585.017879388839220,\\n                    590.008311975617860,\\n                    595.005524249382010,\\n                    600.009470555327430,\\n                    605.020105849423770,\\n                    610.037385686238740,\\n                    615.061266207084940,\\n                    620.091704128477430,\\n                    625.128656730891070,\\n                    630.172081847810200,\\n                    635.221937855059760,\\n                    640.278183660408100,\\n                    645.340778693435030,\\n                    650.409682895655240,\\n                    655.484856710889060,\\n                    660.566261075873510,\\n                    665.653857411105950,\\n                    670.747607611912710,\\n                    675.847474039736880,\\n                    680.953419513637530,\\n                    686.065407301994010,\\n                    691.183401114410800,\\n                    696.307365093814040,\\n                    701.437263808737160,\\n                    706.573062245787470,\\n                    711.714725802289990,\\n                    716.862220279103440,\\n                    722.015511873601330,\\n                    727.174567172815840,\\n                    732.339353146739310,\\n                    737.509837141777440,\\n                    742.685986874351220,\\n                    747.867770424643370,\\n                    753.055156230484160,\\n                    758.248113081374300,\\n                    763.446610112640200,\\n                    768.650616799717000,\\n                    773.860102952558460,\\n                    779.075038710167410,\\n                    784.295394535245690,\\n                    789.521141208958970,\\n                    794.752249825813460,\\n                    799.988691788643450,\\n                    805.230438803703120,\\n                    810.477462875863580,\\n                    815.729736303910160,\\n                    820.987231675937890,\\n                    826.249921864842800,\\n                    831.517780023906310,\\n                    836.790779582469900,\\n                    842.068894241700490,\\n                    847.352097970438420,\\n                    852.640365001133090,\\n                    857.933669825857460,\\n                    863.231987192405430,\\n                    868.535292100464630,\\n                    873.843559797865740,\\n                    879.156765776907600,\\n                    884.474885770751830,\\n                    889.797895749890240,\\n                    895.125771918679900,\\n                    900.458490711945270,\\n                    905.796028791646340,\\n                    911.138363043611210,\\n                    916.485470574328820,\\n                    921.837328707804890,\\n                    927.193914982476710,\\n                    932.555207148186240,\\n                    937.921183163208070,\\n                    943.291821191335660,\\n                    948.667099599019820,\\n                    954.046996952560450,\\n                    959.431492015349480,\\n                    964.820563745165940,\\n                    970.214191291518320,\\n                    975.612353993036210,\\n                    981.015031374908400,\\n                    986.422203146368590,\\n                    991.833849198223450,\\n                    997.249949600427840,\\n                    1002.670484599700300,\\n                    1008.095434617181700,\\n                    1013.524780246136200,\\n                    1018.958502249690200,\\n                    1024.396581558613400,\\n                    1029.838999269135500,\\n                    1035.285736640801600,\\n                    1040.736775094367400,\\n                    1046.192096209724900,\\n                    1051.651681723869200,\\n                    1057.115513528895000,\\n                    1062.583573670030100,\\n                    1068.055844343701400,\\n                    1073.532307895632800,\\n                    1079.012946818975000,\\n                    1084.497743752465600,\\n                    1089.986681478622400,\\n                    1095.479742921962700,\\n                    1100.976911147256000,\\n                    1106.478169357800900,\\n                    1111.983500893733000,\\n                    1117.492889230361000,\\n                    1123.006317976526100,\\n                    1128.523770872990800,\\n                    1134.045231790853000,\\n                    1139.570684729984800,\\n                    1145.100113817496100,\\n                    1150.633503306223700,\\n                    1156.170837573242400];\\n    return lnfact[n];\\n  }\\n}\\n\\n\\nfunction findRootTrustRegion(\\n\\t\\tf, \\n\\t\\tx0, \\n\\t\\targs=[],\\n\\t\\tjac=jacCentralDiff,\\n\\t\\ttol=0.000000001, \\n\\t\\tmaxIters=10000, \\n\\t\\tdeltaBar=1000.0, \\n\\t\\teta=0.125, \\n\\t\\tminDelta=1e-12\\n  ) {\\n\\t\\n\\tlet x = deepCopy(x0);\\n\\n\\t\\n\\tlet delta = 0.99 * deltaBar;\\n\\n\\t\\n\\tlet r = f(x, ...args);\\n\\n\\t\\n\\tlet J = jac(f, x, args);\\n\\n\\t\\n\\tlet JTJ = mmMult(transpose(J), J);\\n\\n\\t\\n\\tlet JTr = mvMult(transpose(J), r);\\n\\n\\t\\n\\tlet normJTr = norm(JTr);\\n\\n\\tlet iters = 0;\\n\\twhile (iters &lt; maxIters &amp;&amp; checkTol(r, tol) &amp;&amp; delta &gt;= minDelta) {\\n\\t\\t\\n\\t\\tlet p = doglegStep(JTJ, JTr, normJTr, delta);\\n\\n\\t\\t\\n\\t\\tlet newr = f(vectorAdd(x, p), ...args);\\n\\t\\tlet rho = computeRho(r, newr, J, p);\\n\\n\\t\\t\\n\\t\\tif  (rho &lt; 0.25) {\\n\\t\\t\\tdelta = norm(p) / 4.0;\\n\\t\\t} else if (rho &gt; 0.75 &amp;&amp; Math.abs(norm(p) - delta) &lt; 1e-12) {\\n\\t\\t\\t\\tdelta = Math.min(2 * delta, deltaBar);\\n\\t\\t}\\n\\n\\t\\t\\n\\t\\tif (rho &gt; eta) {\\n\\t\\t\\tx = vectorAdd(x, p);\\n\\n\\t\\t\\tr = newr;\\n\\t\\t\\tJ = jac(f, x, args);\\n\\t\\t\\tJTJ = mmMult(transpose(J), J);\\n\\t\\t\\tJTr = mvMult(transpose(J), r);\\n\\t\\t\\tnormJTr = norm(JTr);\\n\\t\\t}\\n\\n\\t\\titers += 1;\\n\\t}\\n\\n\\tlet success = !checkTol(r, tol);\\n\\n\\treturn [x, success];\\n\\n}\\n\\n\\nfunction bisectionSolve(f, lower, upper, args=[], tol=1e-8, maxIter=1000) {\\n\\t\\n  if (f(lower, ...args) * f(upper, ...args) &gt;= 0) return null;\\n\\n  let mid = lower;\\n  for (let i = 0; i &lt; maxIter; i++) {\\n    mid = (lower + upper) / 2;\\n    let fMid = f(mid, ...args);\\n\\n    if (fMid === 0 || (upper - lower) / 2 &lt; tol) return mid;\\n\\n    if (fMid * f(lower, ...args) &gt; 0) lower = mid;\\n    else upper = mid;\\n  }\\n\\n  return mid;\\n}\\n\\n\\nfunction brentSolve(f, lower, upper, args=[], tol=1e-8, maxIter=1000) {\\n\\tlet a = lower;\\n\\tlet b = upper;\\n  let fa = f(a, ...args);\\n  let fb = f(b, ...args);\\n\\n  \\n  if (Math.abs(fa) &lt; tol) return a;\\n  if (Math.abs(fb) &lt; tol) return b;\\n\\n  \\n  if (fa * fb &gt;= 0) {\\n  \\treturn null;\\n\\t}\\n\\n  \\n  let c = a;\\n  let fc = fa;\\n\\n\\tlet iter = 0;\\n  while (iter++ &lt; maxIter) {\\n  \\tlet prevStep = b - a;\\n\\n    \\n    if (Math.abs(fc) &lt; Math.abs(fb)) {      \\n    \\t[a, b, c] = [b, c, b];\\n    \\t[fa, fb, fc] = [fb, fc, fb];\\n    }\\n\\n    \\n    let newStep = (c - b) / 2.0;\\n\\n    \\n    let tolAdj = 1e-15 * Math.abs(b) + tol / 2;\\n\\n    \\n  \\tif (Math.abs(newStep) &lt;= tolAdj || fb === 0 ) {\\n    \\t\\treturn b;\\n  \\t}\\n\\n    \\n    if (Math.abs(prevStep) &gt; tolAdj &amp;&amp; Math.abs(fa) &gt; Math.abs(fb)) {\\n    \\tlet p;\\n    \\tlet q;\\n    \\tlet t1;\\n    \\tlet t2;\\n    \\tlet cb = c - b;\\n    \\tif (a === c) { \\n    \\t\\tt1 = fb / fa;\\n    \\t\\tp = cb * t1;\\n    \\t\\tq = 1.0 - t1;\\n    \\t}\\n    \\telse { \\n    \\t\\tq = fa / fc;\\n    \\t\\tt1 = fb / fc;\\n    \\t\\tt2 = fb / fa;\\n    \\t\\tp = t2 * (cb * q * (q - t1) - (b - a) * (t1 - 1.0));\\n    \\t\\tq = (q - 1.0) * (t1 - 1.0) * (t2 - 1.0);\\n    \\t}\\n\\n    \\t\\n    \\tif (p &gt; 0) q = -q;\\n    \\telse p = -p;\\n\\n    \\t\\n    \\tif (p &lt; (0.75 * cb * q - Math.abs(tolAdj * q) / 2.0) \\n    \\t\\t&amp;&amp; p &lt; Math.abs(prevStep * q / 2.0)) { \\n\\t        newStep = p / q;\\n      \\t}\\n    }\\n\\n    if (Math.abs(newStep) &lt; tolAdj) {\\n      newStep = (newStep &gt; 0) ? tolAdj : -tolAdj;\\n    }\\n\\n    \\n    a = b;\\n    fa = fb;\\n\\n    \\n    b += newStep;\\n    fb = f(b, ...args);\\n\\n\\t\\n    if ((fb &gt; 0 &amp;&amp; fc &gt; 0) || (fb &lt; 0 &amp;&amp; fc &lt; 0)) {\\n      c = a; \\n      fc = fa;\\n    }\\n  }\\n\\n  \\n  return null;\\n}\\n\\n\\nfunction lnchoice(n, k) {\\n    return lnfactorial(n) - lnfactorial(n-k) - lnfactorial(k);\\n}\\n\\n\\nfunction log1p(x) {\\n  \\n  \\n  if (x &lt;= -1.0) {\\n    throw new RangeError(&#x27;Argument must be greater than -1.0&#x27;);\\n  }\\n\\n  \\n  else if (Math.abs(x) &gt; 1e-4) {\\n    return Math.log(1.0 + x);\\n  }\\n\\n  else {\\n    return (-0.5*x + 1.0)*x;\\n  }\\n}\\n\\n\\nfunction betacf(x, a, b) {\\n    \\n    \\n    var fpmin = 1e-30,\\n        m = 1,\\n        m2, aa, c, d, del, h, qab, qam, qap;\\n    \\n    qab = a + b;\\n    qap = a + 1;\\n    qam = a - 1;\\n    c = 1;\\n    d = 1 - qab * x / qap;\\n    if (Math.abs(d) &lt; fpmin) d = fpmin;\\n    d = 1 / d;\\n    h = d;\\n    for (; m &lt;= 100; m++) {\\n        m2 = 2 * m;\\n        aa = m * (b - m) * x / ((qam + m2) * (a + m2));\\n        \\n        d = 1 + aa * d;\\n        if (Math.abs(d) &lt; fpmin) d = fpmin;\\n        c = 1 + aa / c;\\n        if (Math.abs(c) &lt; fpmin) c = fpmin;\\n        d = 1 / d;\\n        h *= d * c;\\n        aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));\\n        \\n        d = 1 + aa * d;\\n        if (Math.abs(d) &lt; fpmin) d = fpmin;\\n        c = 1 + aa / c;\\n        if (Math.abs(c) &lt; fpmin) c = fpmin;\\n        d = 1 / d;\\n        del = d * c;\\n        h *= del;\\n        if (Math.abs(del - 1.0) &lt; 3e-7) break;\\n    }\\n    return h;\\n}\\n\\n\\nfunction isclose(x, y, rtol = 1.0e-7, atol = 1.0e-8) {\\n  return Math.abs(x - y) &lt;= (atol + rtol * Math.abs(y));\\n}\\n\\n\\nfunction gammaincU(x, s, regularized) {\\n\\n  var EPSILON = 1e-12;\\n\\n  if (x &lt;= 1.1 || x &lt;= s) {\\n    if (regularized !== false) {\\n      return 1 - gammaincL(x, s, regularized);\\n    } else {\\n      return Math.exp(lngamma(s)) - gammaincL(x, s, regularized);\\n    }\\n  }\\n\\n  var f = 1 + x - s,\\n    C = f,\\n    D = 0,\\n    i = 1,\\n    a, b, chg;\\n  for (i = 1; i &lt; 10000; i++) {\\n    a = i * (s - i);\\n    b = (i&lt;&lt;1) + 1 + x - s;\\n    D = b + a * D;\\n    C = b + a / C;\\n    D = 1 / D;\\n    chg = C * D;\\n    f *= chg;\\n    if (Math.abs(chg - 1) &lt; EPSILON) {\\n      break;\\n    }\\n  }\\n  if (regularized !== false) {\\n    return Math.exp(s * Math.log(x) - x - lngamma(s) - Math.log(f));\\n  } else {\\n    return Math.exp(s * Math.log(x) - x - Math.log(f));\\n  }\\n}\\n\\n\\nfunction transpose(A) {\\n    return A[0].map((_, colIndex) =&gt; A.map(row =&gt; row[colIndex]));\\n}\\n\\n\\nfunction mvMult(A, v) {\\n  return A.map(Arow =&gt; dot(Arow, v));\\n}\\n\\n\\nfunction mmMult(A, B) {\\n  let mA = A.length;\\n  let nA = A[0].length;\\n  let mB = B.length;\\n  let nB = B[0].length;\\n\\n  if (nA !== mB) {\\n      throw new Error(&#x27;Matrix dimension mismatch.&#x27;);\\n  }\\n\\n  let result = zeros(mA, nB);\\n\\n  for (let i = 0; i &lt; mA; i++) {\\n    for (let j = 0; j &lt; nB; j++) {\\n      for (let k = 0; k &lt; nA; k++) {\\n        result[i][j] += A[i][k] * B[k][j];\\n      }\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction vectorAdd() {\\n  let m = arguments.length;\\n  let n = arguments[0].length;\\n \\n  let result = new Array(n).fill(0.0);\\n \\n  for (let i = 0; i &lt; n; i++) {\\n    for (let j = 0; j &lt; m; j++) {\\n        result[i] += arguments[j][i];\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction norm(v) {\\n  return Math.sqrt(dot(v, v));\\n}\\n\\n\\nfunction deepCopy(x) {\\n  return JSON.parse(JSON.stringify(x));\\n}\\n\\n\\nfunction computeRho(r, newr, J, p) {\\n\\tlet r2 = norm(r) ** 2;\\n\\tlet num = r2 - norm(newr)**2;\\n\\tlet denom = r2 - norm(vectorAdd(r, mvMult(J, p))) ** 2;\\n\\n\\treturn num / denom;\\n}\\n\\n\\nfunction checkTol(r, tol) {\\n\\t\\n\\tconst n = r.length;\\n\\tfor (let i = 0; i &lt; n; i++) {\\n\\t\\tif (tol &lt; Math.abs(r[i])) return true;\\n\\t}\\n\\n\\treturn false;\\n}\\n\\n\\nfunction doglegStep(JTJ, JTr, normJTr, delta) {\\n\\t\\n\\tlet [pJ, posDef] = solvePosDef(JTJ, JTr);\\n\\tpJ = svMult(-1.0, pJ);\\n\\n\\t\\n\\tif (posDef &amp;&amp; norm(pJ) &lt;= delta) {\\n\\t\\treturn pJ;\\n\\t}\\n\\n\\t\\n\\tlet tau = Math.min(1, normJTr**3 / delta / quadForm(JTJ, JTr));\\n\\tlet pC = svMult(-tau * delta / normJTr, JTr);\\n\\n\\tlet pCnorm = norm(pC);\\n\\tif (!posDef || Math.abs(pCnorm - delta) &lt;= 1e-12) {\\n\\t\\treturn pC;\\n\\t}\\n\\n\\t\\n\\tlet pJ2 = norm(pJ) ** 2;\\n\\tlet pC2 = pCnorm**2;\\n\\tlet pJpC = dot(pJ, pC);\\n\\tlet a = pJ2 + pC2 - 2.0 * pJpC;\\n\\tlet b = 2.0 * (pJpC - pC2);\\n\\tlet c = pC2 - delta**2;\\n\\tlet q = -0.5 * (b + Math.sign(b) * Math.sqrt(b**2 - 4.0 * a * c));\\n\\n\\t\\n\\tlet beta;\\n\\tif (Math.abs(b) &lt; 1e-12) beta = Math.sqrt(-c / a);\\n\\telse if (b &lt; 0.0) beta = q / a;\\n\\telse beta = c / q;\\n\\n\\t\\n\\tif (0.0 &lt;= beta &amp;&amp; beta &lt;= 1) {\\n\\t\\treturn vectorAdd(pC, svMult(beta, vectorAdd(pJ, svMult(-1.0, pC))));\\n\\t} else { \\n\\t\\treturn pC;\\n\\t}\\n\\n}\\n\\n\\nfunction jacCentralDiff(f, x, args=[], eps=4.7e-6) {\\n\\t\\n\\tlet xPlus = deepCopy(x);\\n\\tlet xMinus = deepCopy(x);\\n\\n\\t\\n\\tlet fOfx = f(x, ...args);\\n\\tlet m = fOfx.length;\\n\\n\\t\\n\\tlet n = x.length;\\n\\n\\t\\n\\tlet J = zeros(m, n);\\n\\n\\t\\n\\tlet fOfxPlus;\\n\\tlet fOfxMinus;\\n\\n\\tfor (let j = 0; j &lt; n; j++) {\\n\\t\\txPlus[j] += eps;\\n\\t\\txMinus[j] -= eps;\\n\\t\\tfOfxPlus = f(xPlus, ...args);\\n\\t\\tfOfxMinus = f(xMinus, ...args);\\n\\t\\txPlus[j] -= eps;\\n\\t\\txMinus[j] += eps;\\n\\n\\t\\tfor (let i = 0; i &lt; m; i++) {\\n\\t\\t\\tJ[i][j] = (fOfxPlus[i] - fOfxMinus[i]) / 2.0 / eps;\\n\\t\\t}\\n\\t}\\n\\n\\treturn J;\\n}\\n\\n\\nfunction gammaincL(x, s, regularized) {\\n\\n  var EPSILON = 1e-12;\\n\\n  if (x === 0) {\\n    return 0;\\n  }\\n  if (x &lt; 0 || s &lt;= 0) {\\n    return NaN;\\n  }\\n\\n  if (x &gt; 1.1 &amp;&amp; x &gt; s) {\\n    if (regularized !== false) {\\n      return 1 - gammaincU(x, s, regularized);\\n    } else {\\n      return Math.exp(lngamma(s)) - gammaincU(x, s, regularized);\\n    }\\n  }\\n\\n  var ft,\\n    r = s,\\n    c = 1,\\n    pws = 1;\\n\\n  if (regularized !== false) {\\n    ft = s * Math.log(x) - x - lngamma(s);\\n  } else {\\n    ft = s * Math.log(x) - x;\\n  }\\n  ft = Math.exp(ft);\\n  do {\\n    r += 1;\\n    c *= x/r;\\n    pws += c;\\n  } while (c / pws &gt; EPSILON);\\n\\n  return pws * ft / s;\\n}\\n\\n\\nfunction dot(v1, v2) {\\n  const n = v1.length;\\n  let result = 0.0;\\n  for (let i = 0; i &lt; n; i++) result += v1[i] * v2[i];\\n\\n  return result;\\n}\\n\\n\\nfunction zeros(...dims) {\\n  let A = [];\\n\\n  \\n  for (let i = dims.length - 1; i &gt;= 0; i--) {\\n    let size = dims[i];\\n    if (i === dims.length - 1) {\\n      \\n      A = new Array(size).fill(0.0);\\n    } else {\\n      \\n      A = new Array(size).fill().map(() =&gt; deepCopy(A));\\n    }\\n  }\\n\\n  return A;\\n}\\n\\n\\nfunction svMult(a, v) {\\n  return v.map(x =&gt; a * x);\\n}\\n\\n\\nfunction quadForm(A, x) {\\n   return dot(x, mvMult(A, x)); \\n}\\n\\n\\nfunction solvePosDef(A, b) {\\n  let [L, p, success] = modifiedCholesky(A);\\n\\n  if (!success) {\\n    return [zeros(b.length), success];\\n  }\\n\\n  return [modifiedCholeskySolve(L, p, b), success];\\n}\\n\\n\\nfunction modifiedCholesky(A) {\\n    const floatEps = 1.0e-14;\\n    const n = A.length;\\n\\n    \\n    let L = deepCopy(A); \\n    let p = arange(0, n);\\n\\n    \\n    let success = true;\\n\\n    let xi = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        for (let j = 0; j &lt; i; j++) {\\n            let temp = Math.abs(L[i][j]);\\n            xi = Math.max(xi, temp);\\n        }\\n    }\\n\\n    let eta = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        let temp = Math.abs(L[i][i]);\\n        eta = Math.max(eta, temp);\\n    }\\n\\n    let beta;\\n    if (n &gt; 1) {\\n        beta = Math.sqrt(Math.max(eta, xi / Math.sqrt(n * n - 1)));\\n    } else {\\n        beta = Math.sqrt(eta);\\n    }\\n    beta = Math.max(beta, floatEps);\\n\\n    for (let k = 0; k &lt; n; k++) {\\n        \\n        let muVal = L[k][k];\\n        let mu = k;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            let temp = L[i][i];\\n            if (muVal &lt; temp) {\\n                mu = i;\\n                muVal = temp;\\n            }\\n        }\\n\\n        \\n        let iTemp = p[mu];\\n        p[mu] = p[k];\\n        p[k] = iTemp;\\n\\n        for (let i = 0; i &lt; k; i++) {\\n            let temp = L[k][i];\\n            L[k][i] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        let temp = L[k][k];\\n        L[k][k] = L[mu][mu];\\n        L[mu][mu] = temp;\\n        for (let i = k + 1; i &lt; mu; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        for (let i = mu + 1; i &lt; n; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[i][mu];\\n            L[i][mu] = temp;\\n        }\\n\\n        \\n        let cSum = 0;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            cSum = Math.max(cSum, Math.abs(L[i][k]));\\n        }\\n        cSum /= beta;\\n        cSum = cSum * cSum;\\n\\n        \\n        if (L[k][k] &lt; 0) {\\n            success = false;\\n        }\\n\\n        temp = Math.abs(L[k][k]);\\n        temp = Math.max(temp, floatEps * eta);\\n        temp = Math.max(temp, cSum);\\n        L[k][k] = Math.sqrt(temp);\\n\\n        \\n        for (let i = k + 1; i &lt; n; i++) {\\n            L[i][k] /= L[k][k];\\n        }\\n\\n        \\n        for (let j = k + 1; j &lt; n; j++) {\\n            for (let i = j; i &lt; n; i++) {\\n                L[i][j] -= L[i][k] * L[j][k];\\n            }\\n        }\\n\\n        \\n        for (let i = 0; i &lt; n - 1; i++) {\\n            for (let j = i + 1; j &lt; n; j++) {\\n                L[i][j] = 0.0;\\n            }\\n        }\\n    }\\n\\n    return [L, p, success];\\n}\\n\\n\\nfunction modifiedCholeskySolve(L, p, b) {\\n    const n = L.length;\\n\\n    let U = transpose(L);\\n    let xp = new Array(n).fill(0);\\n    for (let i = 0; i &lt; n; i++) {\\n        xp[i] = b[p[i]];\\n    }\\n\\n    \\n    let x = lowerTriSolve(L, xp);\\n\\n    \\n    xp = upperTriSolve(U, x);\\n\\n    for (let i = 0; i &lt; n; i++) {\\n        x[p[i]] = xp[i];\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction lowerTriSolve(L, b) {\\n    const floatEps = 1.0e-14;\\n    const n = L.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = 0; j &lt; n - 1; j++) {\\n        if (Math.abs(L[j][j]) &gt; floatEps) {\\n            x[j] /= L[j][j];\\n            for (let i = j + 1; i &lt; n; i++) {\\n                x[i] -= x[j] * L[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(L[n - 1][n - 1]) &gt; floatEps) {\\n            x[n - 1] /= L[n - 1][n - 1];\\n        } else {\\n            x[n - 1] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction upperTriSolve(U, b) {\\n    const floatEps = 1.0e-14;\\n    const n = U.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = n - 1; j &gt; 0; j--) {\\n        if (Math.abs(U[j][j]) &gt; floatEps) {\\n            x[j] /= U[j][j];\\n            for (let i = 0; i &lt; j; i++) {\\n                x[i] -= x[j] * U[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(U[0][0]) &gt; floatEps) {\\n            x[0] /= U[0][0];\\n        } else {\\n            x[0] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nclass NegativeBinomialDistribution extends DiscreteUnivariateDistribution {\\n  constructor(parametrization = &#x27;alpha-beta&#x27;, fixedParam = undefined) {\\n    super(parametrization);\\n\\n    \\n    this.name = &#x27;NegativeBinomial&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    if (this.parametrization === &#x27;alpha-beta&#x27;) {\\n      this.paramNames = [&#x27;\\u03b1&#x27;, &#x27;\\u03b2&#x27;];\\n      this.paramMin = [0.0, 0.0];\\n      this.paramMax = [Infinity, Infinity];\\n      if (fixedParam === undefined) this.fixedParams = [&#x27;\\u03b1&#x27;];\\n      else this.fixedParams = [fixedParam];\\n    } else if (this.parametrization === &#x27;mu-phi&#x27;) {\\n      this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03c6&#x27;];\\n      this.paramMin = [0.0, 0.0];\\n      this.paramMax = [Infinity, Infinity];\\n      if (fixedParam === undefined) this.fixedParams = [&#x27;\\u03c6&#x27;];\\n      else this.fixedParams = [fixedParam];\\n    } else if (this.parametrization === &#x27;alpha-p&#x27;) {\\n      this.paramNames = [&#x27;\\u03b1&#x27;, &#x27;p&#x27;];\\n      this.paramMin = [0.0, 0.0];\\n      this.paramMax = [Infinity, 1.0];\\n      if (fixedParam === undefined) this.fixedParams = [&#x27;\\u03b1&#x27;];\\n      else this.fixedParams = [fixedParam];\\n    } else if (this.parametrization === &#x27;r-b&#x27;) {\\n      this.paramNames = [&#x27;r&#x27;, &#x27;b&#x27;];\\n      this.paramMin = [0.0, 0.0];\\n      this.paramMax = [Infinity, Infinity];\\n      if (fixedParam === undefined) this.fixedParams = [&#x27;r&#x27;];\\n      else this.fixedParams = [fixedParam];\\n    } else { \\n      this.paramNames = [&#x27;unnamedParam1&#x27;, &#x27;unnamedParam2&#x27;];\\n      this.paramMin = [0.0, 0.0];\\n      this.paramMax = [Infinity, Infinity];\\n      if (fixedParam === undefined) this.fixedParams = [&#x27;unnamedParam1&#x27;];\\n      else this.fixedParams = [fixedParam];\\n    }\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  convertParams(params, from = this.parametrization, to = &#x27;alpha-beta&#x27;) {\\n    if (from === to) return params;\\n    else if (to === &#x27;alpha-beta&#x27;) return this.convertParamsToAlphaBeta(params, from);\\n    else if (from === &#x27;alpha-beta&#x27;) return this.convertParamsFromAlphaBeta(params, to);\\n    else return this.convertParamsFromAlphaBeta(this.convertParamsToAlphaBeta(params, from), to);\\n  }\\n\\n  convertParamsToAlphaBeta(params, from = this.parametrization) {\\n    \\n    let alpha, beta;\\n\\n    if (from === &#x27;mu-phi&#x27;) {\\n      let [mu, phi] = params.slice(0, 2);\\n      alpha = phi;\\n      beta = alpha / mu;\\n    } else if (from === &#x27;alpha-p&#x27;) {\\n      let [a, p] = params.slice(0, 2);\\n      alpha = a;\\n      beta = p / (1 - p);\\n    } else if (from === &#x27;r-b&#x27;) {\\n      let [r, b] = params.slice(0, 2);\\n      alpha = r;\\n      beta = 1 / b;\\n    } else if (from === &#x27;alpha-beta&#x27;) {\\n      [alpha, beta] = params.slice(0, 2);\\n    } else {\\n      throw new Error(&#x27;Invalid parametrization for converting. Allowed values are alpha-beta, mu-phi, alpha-p, and r-b.&#x27;);\\n    }\\n\\n    return [alpha, beta];\\n  }\\n\\n  convertParamsFromAlphaBeta(params, to = this.parametrization) {\\n    \\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    let output;\\n    if (to === &#x27;mu-phi&#x27;) {\\n      let mu = alpha / beta;\\n      let phi = alpha;\\n      output = [mu, phi];\\n    } else if (to === &#x27;alpha-p&#x27;) {\\n      let a = alpha;\\n      let p = beta / (1 + beta);\\n      output = [a, p];\\n    } else if (to === &#x27;r-b&#x27;) {\\n      let r = alpha;\\n      let b = 1 / beta;\\n      output = [r, b];\\n    } else if (to === &#x27;alpha-beta&#x27;) {\\n      output = [alpha, beta];\\n    } else {\\n      throw new Error(&#x27;Invalid parametrization for converting. Allowed values are alpha-beta, mu-phi, alpha-p, and r-b.&#x27;);\\n    }\\n\\n    return output;\\n  }\\n\\n  pmfSingleValue(y, params, parametrization = this.parametrization) {\\n    if (y &lt; 0) return NaN;\\n\\n    \\n    let [alpha, beta] = this.convertParamsToAlphaBeta(params, parametrization);\\n\\n    if (alpha &lt;= 0 || beta &lt;= 0) return NaN;\\n\\n    return Math.exp(lngamma(y + alpha)\\n                    - lngamma(alpha)\\n                    - lnfactorial(y)\\n                    + alpha * Math.log(beta / (1 + beta))\\n                    - y * Math.log(1 + beta));\\n  }\\n\\n  cdfSingleValue(y, params, parametrization = this.parametrization) {\\n    let [alpha, beta] = this.convertParamsToAlphaBeta(params, parametrization);\\n\\n    if (alpha === 0 || beta === Infinity) return 1.0;\\n    if (alpha === Infinity) return y === Infinity ? 1.0 : 0.0; \\n\\n    if (y &lt;= 0) return 0.0;\\n    if (y === Infinity) return 1.0;\\n\\n    return regularizedIncompleteBeta(beta / (1 + beta), alpha, y + 1);\\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    let [x1, x2] = super.ppf([0.001, 0.999], this.convertParamsToAlphaBeta(params, parametrization));\\n\\n    \\n    if (x1 &lt; (x2 - x1) / 10.0) x1 = -1.0;\\n\\n    return [x1, x2];\\n  }\\n\\n  \\n  quantileSet(x, p, extraParams) {\\n    if (this.fixedParams.length != 1) {\\n      throw new Error(&#x27;Must have exactly one fixed parameter.&#x27;)\\n    }\\n\\n    let x1 = x[0];\\n    let p1 = p[0];\\n    let otherParam = extraParams[0];\\n\\n    if (!Number.isInteger(x1)) {\\n      throw new Error(this.varName + &#x27; must be integer.&#x27;)\\n    }\\n    if (x1 &lt; 0 ) {\\n      throw new Error(&#x27;Must have &#x27; + this.varName + &#x27; &gt; 0.&#x27;)\\n    }\\n\\n    const rootFun = (xi, x1, p1) =&gt; {\\n      if (this.fixedParamsInds[0] === 0) {\\n        return p1 - this.cdfSingleValue(x1, [otherParam, xi / (1 - xi)], this.parametrization);\\n      } else {\\n        return p1 - this.cdfSingleValue(x1, [xi / (1 - xi), otherParam], this.parametrization);        \\n      }\\n    }\\n\\n    let xiOpt = brentSolve(rootFun, 0.0, 1.0, [x1, p1]);\\n    let optimSuccess = xiOpt != null;\\n    \\n    return [[xiOpt / (1 - xiOpt)], optimSuccess];\\n  }\\n\\n  quantileSetBoth(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    if (!Number.isInteger(x1) || !Number.isInteger(x2)) {\\n      throw new Error(this.varName + &#x27; must be integer.&#x27;)\\n    }\\n    if (x1 &lt; 0 || x2 &lt; 0) {\\n      throw new Error(&#x27;Must have &#x27; + this.varName + &#x27; &gt; 0.&#x27;)\\n    }\\n\\n    const quantileRootFun = (params, x1, p1, x2, p2) =&gt; {\\n      let mu = Math.exp(params[0]);\\n      let phi = Math.exp(params[1]);\\n\\n      let r1 = this.cdfSingleValue(x1, [mu, phi], &#x27;mu-phi&#x27;) - p1;\\n      let r2 = this.cdfSingleValue(x2, [mu, phi], &#x27;mu-phi&#x27;) - p2;\\n\\n      return [r1, r2];\\n    };\\n\\n    \\n    let meanp = (p1 + p2) / 2;\\n    let muGuess;\\n    if (Math.abs(meanp - 0.5) &lt; 0.2) {\\n      let meanx = (x1 + x2) / 2;\\n      muGuess = meanx;\\n    }\\n    else {\\n      muGuess = 1.0;\\n    }\\n\\n    let args = [x1, p1, x2, p2];\\n    let guess = [Math.log(muGuess), 1.0];\\n    let [logParams, optimSuccess] = findRootTrustRegion(quantileRootFun, guess, args=args);\\n\\n    let paramsOpt;\\n    if (optimSuccess) {\\n      let muOpt = Math.exp(logParams[0]);\\n      let phiOpt = Math.exp(logParams[1]);\\n\\n      \\n      if (phiOpt &gt; 1) {\\n\\n        \\n        const muGivenPhi = (phi, x, p) =&gt; {\\n          dist = new NegativeBinomialDistribution(&#x27;mu-phi&#x27;);\\n\\n          \\n          const rootFun = (xi, phi, x, p) =&gt; { \\n            if (xi === 1) return p;\\n            if (xi === 0) return p - 1;\\n            return p - this.cdfSingleValue(x, [xi / (1 - xi), phi], &#x27;mu-phi&#x27;);\\n          }\\n\\n          let xiOpt = brentSolve(rootFun, 0.0, 1.0, [phi, x, p]);\\n          let optimSuccess = xiOpt != null;\\n          \\n          return [xiOpt / (1 - xiOpt), optimSuccess];\\n        }\\n\\n        const hitQuantiles = (phi, x1, p1, x2, p2) =&gt; {\\n          let [muAdj, rootFindSuccess] = muGivenPhi(phi, x2, p2);\\n\\n          if (rootFindSuccess) {\\n            let [q1, q2] = this.ppf([p1, p2], [muAdj, phi], &#x27;mu-phi&#x27;);\\n\\n            if (q1 === x1 &amp;&amp; q2 === x2) return 1;\\n            else return -1;\\n          } else {\\n            return -1;\\n          }\\n        } \\n\\n        if (hitQuantiles(1.0) === 1) {\\n          phiOpt = 1.0;\\n          let [muAdj, rootFindSuccess] = muGivenPhi(phiOpt, x2, p2);\\n          muOpt = muAdj;\\n        }\\n        else {\\n          let phiAdj = bisectionSolve(hitQuantiles, 1.0, phiOpt, [x1, p1, x2, p2]);\\n          if (phiAdj != null) {\\n            phiOpt = phiAdj;\\n            let [muAdj, rootFindSuccess] = muGivenPhi(phiOpt, x2, p2);\\n            muOpt = muAdj;\\n          }\\n        }\\n      }\\n\\n      paramsOpt = this.convertParams([muOpt, phiOpt], &#x27;mu-phi&#x27;, this.parametrization);\\n    } else { \\n      let pois = new PoissonDistribution();\\n      let [paramsPois, optimSuccessPois] = pois.quantileSet([x2], [p2]);\\n\\n      if (optimSuccessPois) {\\n        let poisQuants = pois.ppf([p1, p2], paramsPois);\\n        if (poisQuants[0] === x1 &amp;&amp; poisQuants[1] === x2) {\\n          let errText;\\n          if (this.parametrization == &#x27;alpha-beta&#x27;|| this.parametrization == &#x27;alpha-p&#x27;) {\\n            errText = &#x27;Use Poisson (\\u03b1 \\u2192 \\u221e limit) with \\u03bb = &#x27; + paramsPois[0].toPrecision(4);\\n          }\\n          else if (this.parametrization == &#x27;mu-phi&#x27;) {\\n            errText = &#x27;Use Poisson (\\u03c6 \\u2192 \\u221e limit) with \\u03bb = &#x27; + paramsPois[0].toPrecision(4);\\n          }\\n          else if (this.parametrization == &#x27;r-b&#x27;) {\\n            errText = &#x27;Use Poisson (r \\u2192 \\u221e limit) with \\u03bb = &#x27; + paramsPois[0].toPrecision(4);\\n          }\\n          throw new Error(errText);\\n        }\\n        \\n      }\\n      paramsOpt = [];\\n    }\\n\\n    return [paramsOpt, optimSuccess];\\n  }\\n}\\n\\n\\n\\nvar dist = new NegativeBinomialDistribution();\\n\\n\\n\\nif (quantileSetterSwitch.active) {\\n  quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p);\\n}"}}]]]},"disabled":true,"width":80,"value":"1.0000"}}]],["pBoxes",[{"id":"p4725"}]],["quantileSetterSwitch",{"id":"p4727"}],["quantileSetterDiv",{"id":"p4726"}],["triggerCallbacks",{"id":"p4728"}],["startBoxes",[{"id":"p4720"},{"id":"p4721"}]],["endBoxes",[{"id":"p4722"},{"id":"p4723"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p\\\\&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass DiscreteUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pmfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pmf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pmfSingleValue(x, params, parametrization),\\n      x,\\n      params);\\n  }\\n\\n  cdfSingleValue(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    \\n    let cumsum = 0.0;\\n    let summand = 0.0;\\n    for (let n = this.xMin(params, parametrization); n &lt;= x; n++) {\\n        summand = this.pmfSingleValue(n, params, parametrization);\\n        if (!isNaN(summand)) cumsum += summand;\\n    }\\n\\n    return cumsum;\\n  }\\n\\n  cdfForPlotting(xStart, xEnd, params, parametrization = this.parametrization) {\\n\\n    params = this.scalarToArrayParams(params);\\n\\n    \\n    let cumsum;\\n    let y_c;\\n    let prob;\\n    if (Number.isInteger(xStart)) {\\n      \\n      cumsum = this.cdfSingleValue(Math.floor(xStart) - 1, params, parametrization);\\n\\n      if (Number.isInteger(xEnd)) {\\n        y_c = [cumsum];\\n        for (let x = xStart; x &lt; xEnd; x++) {\\n          prob = this.pmfSingleValue(x, params, parametrization);\\n          if (!isNaN(prob)) cumsum += prob;\\n          y_c.push(cumsum, cumsum);\\n        }\\n        prob = this.pmfSingleValue(xEnd, params, parametrization);\\n        if (!isNaN(prob)) cumsum += prob;\\n        y_c.push(cumsum);\\n      }\\n      else {\\n        y_c = [cumsum];\\n        for (let x = xStart; x &lt;= Math.floor(xEnd); x++) {\\n          prob = this.pmfSingleValue(x, params, parametrization);\\n          if (!isNaN(prob)) cumsum += prob;\\n          y_c.push(cumsum, cumsum);\\n        }\\n      }\\n    }\\n    else {\\n      \\n      cumsum = this.cdfSingleValue(Math.floor(xStart), params, parametrization);\\n\\n      if (Number.isInteger(xEnd)) {\\n        y_c = [cumsum, cumsum];\\n        for (let x = Math.ceil(xStart); x &lt; xEnd; x++) {\\n          prob = this.pmfSingleValue(x, params, parametrization);\\n          if (!isNaN(prob)) cumsum += prob;\\n          y_c.push(cumsum, cumsum);\\n        }\\n        prob = this.pmfSingleValue(xEnd, params, parametrization);\\n        if (!isNaN(prob)) cumsum += prob;\\n        y_c.push(cumsum);        \\n      }\\n      else {\\n        y_c = [cumsum, cumsum];\\n        for (let x = Math.ceil(xStart); x &lt;= xEnd; x++) {\\n          prob = this.pmfSingleValue(x, params, parametrization);\\n          if (!isNaN(prob)) cumsum += prob;\\n          y_c.push(cumsum, cumsum);\\n        }\\n      }    \\n    }\\n\\n    return y_c;\\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) throw new Error(&#x27;p must be between 0 and 1.&#x27;)\\n\\n    \\n    if (p == 0) return xMin(params, parametrization);\\n\\n    \\n    if (p == 1) return xMax(params, parametrization);\\n\\n    params = this.scalarToArrayParams(params);\\n\\n    \\n    let n = this.xMin(params, parametrization);\\n    let cumsum = this.pmfSingleValue(n, params, parametrization);\\n\\n    let iters = 0;\\n    let summand = 0.0;\\n    let xMaxForTheseParams = this.xMax(params, parametrization);\\n    while (cumsum &lt; p &amp;&amp; !isclose(cumsum, p) &amp;&amp; !isNaN(summand) &amp;&amp; n &lt; xMaxForTheseParams) {\\n      n += 1;\\n      summand = this.pmfSingleValue(n, params, parametrization);\\n\\n      if (!isNaN(summand)) cumsum += summand;\\n\\n      iters += 1;\\n    }\\n\\n    return n;\\n  }\\n\\n}\\n\\nclass BinomialDistribution extends DiscreteUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Binomial&#x27;;\\n\\n    \\n    this.varName = &#x27;n&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;N&#x27;, &#x27;\\u03b8&#x27;];\\n\\n    \\n    this.paramMin = [0, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, 1.0];\\n\\n    \\n    this.fixedParams = [&#x27;N&#x27;];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0;\\n  }\\n\\n  xMax(params) {\\n    return params[0];\\n  }\\n\\n  pmfSingleValue(n, params) {\\n    let [N, theta] = params.slice(0, 2);\\n\\n    if (n &gt; N || n &lt; 0) return NaN;\\n\\n    if (theta == 0) {\\n      if (n == 0) return 1.0;\\n      return 0.0;\\n    }\\n\\n    if (theta == 1) {\\n      if (n == N) return 1.0;\\n      return 0.0;\\n    }\\n\\n    return Math.exp(lnchoice(N, n) +\\n      n * Math.log(theta) +\\n      (N - n) * Math.log(1 - theta));\\n  }\\n\\n  cdfSingleValue(n, params) {\\n    let [N, theta] = params.slice(0, 2);\\n\\n    if (n &lt; 0) return 0.0;\\n    if (n &gt;= N) return 1.0;\\n    return regularizedIncompleteBeta(1.0 - theta, N - n, n + 1);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let [N, theta] = params.slice(0, 2);\\n    \\n    return super.ppfSingleValue(p, params, 0, N, N);\\n  }\\n\\n  defaultXRange(params) {\\n    let [N, theta] = params.slice(0, 2);\\n\\n    if (N &lt; 50) {\\n      return [-1, N + 1];\\n    } else {\\n      return this.ppf([0.001, 0.999], params);\\n    }\\n  }\\n\\n  quantileSet(x, p, extraParams) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n    let N = extraParams[0];\\n\\n    if (!Number.isInteger(x1)) {\\n      throw new Error(this.varName + &#x27; must be integer.&#x27;)\\n    }\\n    if (x1 &lt; 0) {\\n      throw new Error(&#x27;Must have &#x27; + this.varName + &#x27; &gt; 0.&#x27;)\\n    }\\n    if (x1 &gt;= N) {\\n      throw new Error(&#x27;Must have &#x27; + this.varName + &#x27; &lt; N.&#x27;)\\n    }\\n\\n    \\n    let rootFun = (theta, N) =&gt; p1 - this.cdfSingleValue(x1, [N, theta]);\\n\\n    let thetaOpt = brentSolve(rootFun, 0.0, 1.0, [N]);\\n    let optimSuccess = thetaOpt != null;\\n    \\n    return [[thetaOpt], optimSuccess];\\n  }\\n}\\n\\nclass PoissonDistribution extends DiscreteUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Poisson&#x27;;\\n\\n    \\n    this.varName = &#x27;n&#x27;;  \\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bb&#x27;];\\n\\n    \\n    this.paramMin = [0.0];\\n\\n    \\n    this.paramMax = [Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pmfSingleValue(n, params) {\\n    let lam = params[0];\\n\\n    if (lam &lt; 0) {\\n      return NaN;\\n    } else if (lam == 0) {\\n      if (n == 0) return 1.0;\\n      return 0.0;\\n    }\\n\\n    return Math.exp(n * Math.log(lam) - lnfactorial(n) - lam);\\n  }\\n\\n  cdfSingleValue(n, params) {\\n    if (n &lt; 0) return 0.0;\\n    if (n === Infinity) return 1.0;\\n\\n    let lam = params[0];\\n\\n    if (lam === 0) return 1.0;\\n\\n    return gammaincU(lam, n + 1, true);\\n  }\\n\\n  defaultXRange(params) {\\n    return super.ppf([0.001, 0.999], params)\\n  }\\n\\n  quantileSet(x, p) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n\\n    if (!Number.isInteger(x1)) {\\n      throw new Error(this.varName + &#x27; must be integer.&#x27;)\\n    }\\n    if (x1 &lt; 0) {\\n      throw new Error(&#x27;Must have &#x27; + this.varName + &#x27; \\u2265 0.&#x27;)\\n    }\\n\\n    \\n    if (x1 === 0 &amp;&amp; p1 === 1) return [[0.0], true];\\n\\n    \\n    const rootFun = (xi) =&gt; {\\n      if (xi === 1) return p1;\\n      return p1 - this.cdfSingleValue(x1, [xi / (1 - xi)]);\\n    }\\n\\n    let xiOpt = brentSolve(rootFun, 0.0, 1.0);\\n    let optimSuccess = xiOpt != null;\\n    \\n    return [[xiOpt / (1 - xiOpt)], optimSuccess];\\n  }\\n\\n}\\n\\nfunction regularizedIncompleteBeta(x, a, b) {\\n    \\n    \\n    if (x &lt; 0 || x &gt; 1) {\\n        throw new RangeError(&#x27;First argument must be between 0 and 1.&#x27;);\\n    }\\n\\n    \\n    else if (a === 1 &amp;&amp; b === 1) return x;\\n    else if (x === 0) return 0;\\n    else if (x === 1) return 1;\\n    else if (a === 0) return 1;\\n    else if (b === 0) return 0;\\n\\n    else {\\n        var bt = Math.exp(lngamma(a + b) - lngamma(a) - lngamma(b) + a * Math.log(x) + b * log1p(-x));\\n\\n        \\n        if (x &lt; (a + 1) / (a + b + 2)) return bt * betacf(x, a, b) / a;\\n\\n        \\n        else return 1 - bt * betacf(1 - x, b, a) / b;\\n    }\\n}\\n\\n\\nfunction lngamma(z) {\\n\\n    if(z &lt; 0) return Number(&#x27;0/0&#x27;);\\n\\n    if (z &lt; 0.5) return Math.log(Math.PI) - Math.log(Math.sin(Math.PI * z)) - lngamma(1-z);\\n\\n    var p = [676.5203681218851,\\n             -1259.1392167224028,\\n             771.32342877765313,\\n             -176.61502916214059,\\n             12.507343278686905,\\n             -0.13857109526572012,\\n             9.9843695780195716e-6,\\n             1.5056327351493116e-7];\\n\\n    z -= 1.0;\\n    var Ag = 0.99999999999980993;\\n    for (var i = 0; i &lt; p.length; i++) {\\n        Ag += p[i] / (z + i + 1);\\n    }\\n    var t = z + p.length - 0.5;\\n\\n    return 0.5 * Math.log(2*Math.PI) + (z + 0.5)*Math.log(t) - t + Math.log(Ag);\\n}\\n\\n\\nfunction lnfactorial(n) {\\n  if (n &gt; 254) { \\n    let x = n + 1;\\n    return (x - 0.5) * Math.log(x) - x + 0.5 * Math.log(2 * Math.PI) + 1.0 / (12.0 * x);\\n  }\\n  else { \\n    const lnfact = [0.000000000000000,\\n                    0.000000000000000,\\n                    0.693147180559945,\\n                    1.791759469228055,\\n                    3.178053830347946,\\n                    4.787491742782046,\\n                    6.579251212010101,\\n                    8.525161361065415,\\n                    10.604602902745251,\\n                    12.801827480081469,\\n                    15.104412573075516,\\n                    17.502307845873887,\\n                    19.987214495661885,\\n                    22.552163853123421,\\n                    25.191221182738683,\\n                    27.899271383840894,\\n                    30.671860106080675,\\n                    33.505073450136891,\\n                    36.395445208033053,\\n                    39.339884187199495,\\n                    42.335616460753485,\\n                    45.380138898476908,\\n                    48.471181351835227,\\n                    51.606675567764377,\\n                    54.784729398112319,\\n                    58.003605222980518,\\n                    61.261701761002001,\\n                    64.557538627006323,\\n                    67.889743137181526,\\n                    71.257038967168000,\\n                    74.658236348830158,\\n                    78.092223553315307,\\n                    81.557959456115029,\\n                    85.054467017581516,\\n                    88.580827542197682,\\n                    92.136175603687079,\\n                    95.719694542143202,\\n                    99.330612454787428,\\n                    102.968198614513810,\\n                    106.631760260643450,\\n                    110.320639714757390,\\n                    114.034211781461690,\\n                    117.771881399745060,\\n                    121.533081515438640,\\n                    125.317271149356880,\\n                    129.123933639127240,\\n                    132.952575035616290,\\n                    136.802722637326350,\\n                    140.673923648234250,\\n                    144.565743946344900,\\n                    148.477766951773020,\\n                    152.409592584497350,\\n                    156.360836303078800,\\n                    160.331128216630930,\\n                    164.320112263195170,\\n                    168.327445448427650,\\n                    172.352797139162820,\\n                    176.395848406997370,\\n                    180.456291417543780,\\n                    184.533828861449510,\\n                    188.628173423671600,\\n                    192.739047287844900,\\n                    196.866181672889980,\\n                    201.009316399281570,\\n                    205.168199482641200,\\n                    209.342586752536820,\\n                    213.532241494563270,\\n                    217.736934113954250,\\n                    221.956441819130360,\\n                    226.190548323727570,\\n                    230.439043565776930,\\n                    234.701723442818260,\\n                    238.978389561834350,\\n                    243.268849002982730,\\n                    247.572914096186910,\\n                    251.890402209723190,\\n                    256.221135550009480,\\n                    260.564940971863220,\\n                    264.921649798552780,\\n                    269.291097651019810,\\n                    273.673124285693690,\\n                    278.067573440366120,\\n                    282.474292687630400,\\n                    286.893133295426990,\\n                    291.323950094270290,\\n                    295.766601350760600,\\n                    300.220948647014100,\\n                    304.686856765668720,\\n                    309.164193580146900,\\n                    313.652829949878990,\\n                    318.152639620209300,\\n                    322.663499126726210,\\n                    327.185287703775200,\\n                    331.717887196928470,\\n                    336.261181979198450,\\n                    340.815058870798960,\\n                    345.379407062266860,\\n                    349.954118040770250,\\n                    354.539085519440790,\\n                    359.134205369575340,\\n                    363.739375555563470,\\n                    368.354496072404690,\\n                    372.979468885689020,\\n                    377.614197873918670,\\n                    382.258588773060010,\\n                    386.912549123217560,\\n                    391.575988217329610,\\n                    396.248817051791490,\\n                    400.930948278915760,\\n                    405.622296161144900,\\n                    410.322776526937280,\\n                    415.032306728249580,\\n                    419.750805599544780,\\n                    424.478193418257090,\\n                    429.214391866651570,\\n                    433.959323995014870,\\n                    438.712914186121170,\\n                    443.475088120918940,\\n                    448.245772745384610,\\n                    453.024896238496130,\\n                    457.812387981278110,\\n                    462.608178526874890,\\n                    467.412199571608080,\\n                    472.224383926980520,\\n                    477.044665492585580,\\n                    481.872979229887900,\\n                    486.709261136839360,\\n                    491.553448223298010,\\n                    496.405478487217580,\\n                    501.265290891579240,\\n                    506.132825342034830,\\n                    511.008022665236070,\\n                    515.890824587822520,\\n                    520.781173716044240,\\n                    525.679013515995050,\\n                    530.584288294433580,\\n                    535.496943180169520,\\n                    540.416924105997740,\\n                    545.344177791154950,\\n                    550.278651724285620,\\n                    555.220294146894960,\\n                    560.169054037273100,\\n                    565.124881094874350,\\n                    570.087725725134190,\\n                    575.057539024710200,\\n                    580.034272767130800,\\n                    585.017879388839220,\\n                    590.008311975617860,\\n                    595.005524249382010,\\n                    600.009470555327430,\\n                    605.020105849423770,\\n                    610.037385686238740,\\n                    615.061266207084940,\\n                    620.091704128477430,\\n                    625.128656730891070,\\n                    630.172081847810200,\\n                    635.221937855059760,\\n                    640.278183660408100,\\n                    645.340778693435030,\\n                    650.409682895655240,\\n                    655.484856710889060,\\n                    660.566261075873510,\\n                    665.653857411105950,\\n                    670.747607611912710,\\n                    675.847474039736880,\\n                    680.953419513637530,\\n                    686.065407301994010,\\n                    691.183401114410800,\\n                    696.307365093814040,\\n                    701.437263808737160,\\n                    706.573062245787470,\\n                    711.714725802289990,\\n                    716.862220279103440,\\n                    722.015511873601330,\\n                    727.174567172815840,\\n                    732.339353146739310,\\n                    737.509837141777440,\\n                    742.685986874351220,\\n                    747.867770424643370,\\n                    753.055156230484160,\\n                    758.248113081374300,\\n                    763.446610112640200,\\n                    768.650616799717000,\\n                    773.860102952558460,\\n                    779.075038710167410,\\n                    784.295394535245690,\\n                    789.521141208958970,\\n                    794.752249825813460,\\n                    799.988691788643450,\\n                    805.230438803703120,\\n                    810.477462875863580,\\n                    815.729736303910160,\\n                    820.987231675937890,\\n                    826.249921864842800,\\n                    831.517780023906310,\\n                    836.790779582469900,\\n                    842.068894241700490,\\n                    847.352097970438420,\\n                    852.640365001133090,\\n                    857.933669825857460,\\n                    863.231987192405430,\\n                    868.535292100464630,\\n                    873.843559797865740,\\n                    879.156765776907600,\\n                    884.474885770751830,\\n                    889.797895749890240,\\n                    895.125771918679900,\\n                    900.458490711945270,\\n                    905.796028791646340,\\n                    911.138363043611210,\\n                    916.485470574328820,\\n                    921.837328707804890,\\n                    927.193914982476710,\\n                    932.555207148186240,\\n                    937.921183163208070,\\n                    943.291821191335660,\\n                    948.667099599019820,\\n                    954.046996952560450,\\n                    959.431492015349480,\\n                    964.820563745165940,\\n                    970.214191291518320,\\n                    975.612353993036210,\\n                    981.015031374908400,\\n                    986.422203146368590,\\n                    991.833849198223450,\\n                    997.249949600427840,\\n                    1002.670484599700300,\\n                    1008.095434617181700,\\n                    1013.524780246136200,\\n                    1018.958502249690200,\\n                    1024.396581558613400,\\n                    1029.838999269135500,\\n                    1035.285736640801600,\\n                    1040.736775094367400,\\n                    1046.192096209724900,\\n                    1051.651681723869200,\\n                    1057.115513528895000,\\n                    1062.583573670030100,\\n                    1068.055844343701400,\\n                    1073.532307895632800,\\n                    1079.012946818975000,\\n                    1084.497743752465600,\\n                    1089.986681478622400,\\n                    1095.479742921962700,\\n                    1100.976911147256000,\\n                    1106.478169357800900,\\n                    1111.983500893733000,\\n                    1117.492889230361000,\\n                    1123.006317976526100,\\n                    1128.523770872990800,\\n                    1134.045231790853000,\\n                    1139.570684729984800,\\n                    1145.100113817496100,\\n                    1150.633503306223700,\\n                    1156.170837573242400];\\n    return lnfact[n];\\n  }\\n}\\n\\n\\nfunction findRootTrustRegion(\\n\\t\\tf, \\n\\t\\tx0, \\n\\t\\targs=[],\\n\\t\\tjac=jacCentralDiff,\\n\\t\\ttol=0.000000001, \\n\\t\\tmaxIters=10000, \\n\\t\\tdeltaBar=1000.0, \\n\\t\\teta=0.125, \\n\\t\\tminDelta=1e-12\\n  ) {\\n\\t\\n\\tlet x = deepCopy(x0);\\n\\n\\t\\n\\tlet delta = 0.99 * deltaBar;\\n\\n\\t\\n\\tlet r = f(x, ...args);\\n\\n\\t\\n\\tlet J = jac(f, x, args);\\n\\n\\t\\n\\tlet JTJ = mmMult(transpose(J), J);\\n\\n\\t\\n\\tlet JTr = mvMult(transpose(J), r);\\n\\n\\t\\n\\tlet normJTr = norm(JTr);\\n\\n\\tlet iters = 0;\\n\\twhile (iters &lt; maxIters &amp;&amp; checkTol(r, tol) &amp;&amp; delta &gt;= minDelta) {\\n\\t\\t\\n\\t\\tlet p = doglegStep(JTJ, JTr, normJTr, delta);\\n\\n\\t\\t\\n\\t\\tlet newr = f(vectorAdd(x, p), ...args);\\n\\t\\tlet rho = computeRho(r, newr, J, p);\\n\\n\\t\\t\\n\\t\\tif  (rho &lt; 0.25) {\\n\\t\\t\\tdelta = norm(p) / 4.0;\\n\\t\\t} else if (rho &gt; 0.75 &amp;&amp; Math.abs(norm(p) - delta) &lt; 1e-12) {\\n\\t\\t\\t\\tdelta = Math.min(2 * delta, deltaBar);\\n\\t\\t}\\n\\n\\t\\t\\n\\t\\tif (rho &gt; eta) {\\n\\t\\t\\tx = vectorAdd(x, p);\\n\\n\\t\\t\\tr = newr;\\n\\t\\t\\tJ = jac(f, x, args);\\n\\t\\t\\tJTJ = mmMult(transpose(J), J);\\n\\t\\t\\tJTr = mvMult(transpose(J), r);\\n\\t\\t\\tnormJTr = norm(JTr);\\n\\t\\t}\\n\\n\\t\\titers += 1;\\n\\t}\\n\\n\\tlet success = !checkTol(r, tol);\\n\\n\\treturn [x, success];\\n\\n}\\n\\n\\nfunction bisectionSolve(f, lower, upper, args=[], tol=1e-8, maxIter=1000) {\\n\\t\\n  if (f(lower, ...args) * f(upper, ...args) &gt;= 0) return null;\\n\\n  let mid = lower;\\n  for (let i = 0; i &lt; maxIter; i++) {\\n    mid = (lower + upper) / 2;\\n    let fMid = f(mid, ...args);\\n\\n    if (fMid === 0 || (upper - lower) / 2 &lt; tol) return mid;\\n\\n    if (fMid * f(lower, ...args) &gt; 0) lower = mid;\\n    else upper = mid;\\n  }\\n\\n  return mid;\\n}\\n\\n\\nfunction brentSolve(f, lower, upper, args=[], tol=1e-8, maxIter=1000) {\\n\\tlet a = lower;\\n\\tlet b = upper;\\n  let fa = f(a, ...args);\\n  let fb = f(b, ...args);\\n\\n  \\n  if (Math.abs(fa) &lt; tol) return a;\\n  if (Math.abs(fb) &lt; tol) return b;\\n\\n  \\n  if (fa * fb &gt;= 0) {\\n  \\treturn null;\\n\\t}\\n\\n  \\n  let c = a;\\n  let fc = fa;\\n\\n\\tlet iter = 0;\\n  while (iter++ &lt; maxIter) {\\n  \\tlet prevStep = b - a;\\n\\n    \\n    if (Math.abs(fc) &lt; Math.abs(fb)) {      \\n    \\t[a, b, c] = [b, c, b];\\n    \\t[fa, fb, fc] = [fb, fc, fb];\\n    }\\n\\n    \\n    let newStep = (c - b) / 2.0;\\n\\n    \\n    let tolAdj = 1e-15 * Math.abs(b) + tol / 2;\\n\\n    \\n  \\tif (Math.abs(newStep) &lt;= tolAdj || fb === 0 ) {\\n    \\t\\treturn b;\\n  \\t}\\n\\n    \\n    if (Math.abs(prevStep) &gt; tolAdj &amp;&amp; Math.abs(fa) &gt; Math.abs(fb)) {\\n    \\tlet p;\\n    \\tlet q;\\n    \\tlet t1;\\n    \\tlet t2;\\n    \\tlet cb = c - b;\\n    \\tif (a === c) { \\n    \\t\\tt1 = fb / fa;\\n    \\t\\tp = cb * t1;\\n    \\t\\tq = 1.0 - t1;\\n    \\t}\\n    \\telse { \\n    \\t\\tq = fa / fc;\\n    \\t\\tt1 = fb / fc;\\n    \\t\\tt2 = fb / fa;\\n    \\t\\tp = t2 * (cb * q * (q - t1) - (b - a) * (t1 - 1.0));\\n    \\t\\tq = (q - 1.0) * (t1 - 1.0) * (t2 - 1.0);\\n    \\t}\\n\\n    \\t\\n    \\tif (p &gt; 0) q = -q;\\n    \\telse p = -p;\\n\\n    \\t\\n    \\tif (p &lt; (0.75 * cb * q - Math.abs(tolAdj * q) / 2.0) \\n    \\t\\t&amp;&amp; p &lt; Math.abs(prevStep * q / 2.0)) { \\n\\t        newStep = p / q;\\n      \\t}\\n    }\\n\\n    if (Math.abs(newStep) &lt; tolAdj) {\\n      newStep = (newStep &gt; 0) ? tolAdj : -tolAdj;\\n    }\\n\\n    \\n    a = b;\\n    fa = fb;\\n\\n    \\n    b += newStep;\\n    fb = f(b, ...args);\\n\\n\\t\\n    if ((fb &gt; 0 &amp;&amp; fc &gt; 0) || (fb &lt; 0 &amp;&amp; fc &lt; 0)) {\\n      c = a; \\n      fc = fa;\\n    }\\n  }\\n\\n  \\n  return null;\\n}\\n\\n\\nfunction lnchoice(n, k) {\\n    return lnfactorial(n) - lnfactorial(n-k) - lnfactorial(k);\\n}\\n\\n\\nfunction log1p(x) {\\n  \\n  \\n  if (x &lt;= -1.0) {\\n    throw new RangeError(&#x27;Argument must be greater than -1.0&#x27;);\\n  }\\n\\n  \\n  else if (Math.abs(x) &gt; 1e-4) {\\n    return Math.log(1.0 + x);\\n  }\\n\\n  else {\\n    return (-0.5*x + 1.0)*x;\\n  }\\n}\\n\\n\\nfunction betacf(x, a, b) {\\n    \\n    \\n    var fpmin = 1e-30,\\n        m = 1,\\n        m2, aa, c, d, del, h, qab, qam, qap;\\n    \\n    qab = a + b;\\n    qap = a + 1;\\n    qam = a - 1;\\n    c = 1;\\n    d = 1 - qab * x / qap;\\n    if (Math.abs(d) &lt; fpmin) d = fpmin;\\n    d = 1 / d;\\n    h = d;\\n    for (; m &lt;= 100; m++) {\\n        m2 = 2 * m;\\n        aa = m * (b - m) * x / ((qam + m2) * (a + m2));\\n        \\n        d = 1 + aa * d;\\n        if (Math.abs(d) &lt; fpmin) d = fpmin;\\n        c = 1 + aa / c;\\n        if (Math.abs(c) &lt; fpmin) c = fpmin;\\n        d = 1 / d;\\n        h *= d * c;\\n        aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));\\n        \\n        d = 1 + aa * d;\\n        if (Math.abs(d) &lt; fpmin) d = fpmin;\\n        c = 1 + aa / c;\\n        if (Math.abs(c) &lt; fpmin) c = fpmin;\\n        d = 1 / d;\\n        del = d * c;\\n        h *= del;\\n        if (Math.abs(del - 1.0) &lt; 3e-7) break;\\n    }\\n    return h;\\n}\\n\\n\\nfunction isclose(x, y, rtol = 1.0e-7, atol = 1.0e-8) {\\n  return Math.abs(x - y) &lt;= (atol + rtol * Math.abs(y));\\n}\\n\\n\\nfunction gammaincU(x, s, regularized) {\\n\\n  var EPSILON = 1e-12;\\n\\n  if (x &lt;= 1.1 || x &lt;= s) {\\n    if (regularized !== false) {\\n      return 1 - gammaincL(x, s, regularized);\\n    } else {\\n      return Math.exp(lngamma(s)) - gammaincL(x, s, regularized);\\n    }\\n  }\\n\\n  var f = 1 + x - s,\\n    C = f,\\n    D = 0,\\n    i = 1,\\n    a, b, chg;\\n  for (i = 1; i &lt; 10000; i++) {\\n    a = i * (s - i);\\n    b = (i&lt;&lt;1) + 1 + x - s;\\n    D = b + a * D;\\n    C = b + a / C;\\n    D = 1 / D;\\n    chg = C * D;\\n    f *= chg;\\n    if (Math.abs(chg - 1) &lt; EPSILON) {\\n      break;\\n    }\\n  }\\n  if (regularized !== false) {\\n    return Math.exp(s * Math.log(x) - x - lngamma(s) - Math.log(f));\\n  } else {\\n    return Math.exp(s * Math.log(x) - x - Math.log(f));\\n  }\\n}\\n\\n\\nfunction transpose(A) {\\n    return A[0].map((_, colIndex) =&gt; A.map(row =&gt; row[colIndex]));\\n}\\n\\n\\nfunction mvMult(A, v) {\\n  return A.map(Arow =&gt; dot(Arow, v));\\n}\\n\\n\\nfunction mmMult(A, B) {\\n  let mA = A.length;\\n  let nA = A[0].length;\\n  let mB = B.length;\\n  let nB = B[0].length;\\n\\n  if (nA !== mB) {\\n      throw new Error(&#x27;Matrix dimension mismatch.&#x27;);\\n  }\\n\\n  let result = zeros(mA, nB);\\n\\n  for (let i = 0; i &lt; mA; i++) {\\n    for (let j = 0; j &lt; nB; j++) {\\n      for (let k = 0; k &lt; nA; k++) {\\n        result[i][j] += A[i][k] * B[k][j];\\n      }\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction vectorAdd() {\\n  let m = arguments.length;\\n  let n = arguments[0].length;\\n \\n  let result = new Array(n).fill(0.0);\\n \\n  for (let i = 0; i &lt; n; i++) {\\n    for (let j = 0; j &lt; m; j++) {\\n        result[i] += arguments[j][i];\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction norm(v) {\\n  return Math.sqrt(dot(v, v));\\n}\\n\\n\\nfunction deepCopy(x) {\\n  return JSON.parse(JSON.stringify(x));\\n}\\n\\n\\nfunction computeRho(r, newr, J, p) {\\n\\tlet r2 = norm(r) ** 2;\\n\\tlet num = r2 - norm(newr)**2;\\n\\tlet denom = r2 - norm(vectorAdd(r, mvMult(J, p))) ** 2;\\n\\n\\treturn num / denom;\\n}\\n\\n\\nfunction checkTol(r, tol) {\\n\\t\\n\\tconst n = r.length;\\n\\tfor (let i = 0; i &lt; n; i++) {\\n\\t\\tif (tol &lt; Math.abs(r[i])) return true;\\n\\t}\\n\\n\\treturn false;\\n}\\n\\n\\nfunction doglegStep(JTJ, JTr, normJTr, delta) {\\n\\t\\n\\tlet [pJ, posDef] = solvePosDef(JTJ, JTr);\\n\\tpJ = svMult(-1.0, pJ);\\n\\n\\t\\n\\tif (posDef &amp;&amp; norm(pJ) &lt;= delta) {\\n\\t\\treturn pJ;\\n\\t}\\n\\n\\t\\n\\tlet tau = Math.min(1, normJTr**3 / delta / quadForm(JTJ, JTr));\\n\\tlet pC = svMult(-tau * delta / normJTr, JTr);\\n\\n\\tlet pCnorm = norm(pC);\\n\\tif (!posDef || Math.abs(pCnorm - delta) &lt;= 1e-12) {\\n\\t\\treturn pC;\\n\\t}\\n\\n\\t\\n\\tlet pJ2 = norm(pJ) ** 2;\\n\\tlet pC2 = pCnorm**2;\\n\\tlet pJpC = dot(pJ, pC);\\n\\tlet a = pJ2 + pC2 - 2.0 * pJpC;\\n\\tlet b = 2.0 * (pJpC - pC2);\\n\\tlet c = pC2 - delta**2;\\n\\tlet q = -0.5 * (b + Math.sign(b) * Math.sqrt(b**2 - 4.0 * a * c));\\n\\n\\t\\n\\tlet beta;\\n\\tif (Math.abs(b) &lt; 1e-12) beta = Math.sqrt(-c / a);\\n\\telse if (b &lt; 0.0) beta = q / a;\\n\\telse beta = c / q;\\n\\n\\t\\n\\tif (0.0 &lt;= beta &amp;&amp; beta &lt;= 1) {\\n\\t\\treturn vectorAdd(pC, svMult(beta, vectorAdd(pJ, svMult(-1.0, pC))));\\n\\t} else { \\n\\t\\treturn pC;\\n\\t}\\n\\n}\\n\\n\\nfunction jacCentralDiff(f, x, args=[], eps=4.7e-6) {\\n\\t\\n\\tlet xPlus = deepCopy(x);\\n\\tlet xMinus = deepCopy(x);\\n\\n\\t\\n\\tlet fOfx = f(x, ...args);\\n\\tlet m = fOfx.length;\\n\\n\\t\\n\\tlet n = x.length;\\n\\n\\t\\n\\tlet J = zeros(m, n);\\n\\n\\t\\n\\tlet fOfxPlus;\\n\\tlet fOfxMinus;\\n\\n\\tfor (let j = 0; j &lt; n; j++) {\\n\\t\\txPlus[j] += eps;\\n\\t\\txMinus[j] -= eps;\\n\\t\\tfOfxPlus = f(xPlus, ...args);\\n\\t\\tfOfxMinus = f(xMinus, ...args);\\n\\t\\txPlus[j] -= eps;\\n\\t\\txMinus[j] += eps;\\n\\n\\t\\tfor (let i = 0; i &lt; m; i++) {\\n\\t\\t\\tJ[i][j] = (fOfxPlus[i] - fOfxMinus[i]) / 2.0 / eps;\\n\\t\\t}\\n\\t}\\n\\n\\treturn J;\\n}\\n\\n\\nfunction gammaincL(x, s, regularized) {\\n\\n  var EPSILON = 1e-12;\\n\\n  if (x === 0) {\\n    return 0;\\n  }\\n  if (x &lt; 0 || s &lt;= 0) {\\n    return NaN;\\n  }\\n\\n  if (x &gt; 1.1 &amp;&amp; x &gt; s) {\\n    if (regularized !== false) {\\n      return 1 - gammaincU(x, s, regularized);\\n    } else {\\n      return Math.exp(lngamma(s)) - gammaincU(x, s, regularized);\\n    }\\n  }\\n\\n  var ft,\\n    r = s,\\n    c = 1,\\n    pws = 1;\\n\\n  if (regularized !== false) {\\n    ft = s * Math.log(x) - x - lngamma(s);\\n  } else {\\n    ft = s * Math.log(x) - x;\\n  }\\n  ft = Math.exp(ft);\\n  do {\\n    r += 1;\\n    c *= x/r;\\n    pws += c;\\n  } while (c / pws &gt; EPSILON);\\n\\n  return pws * ft / s;\\n}\\n\\n\\nfunction dot(v1, v2) {\\n  const n = v1.length;\\n  let result = 0.0;\\n  for (let i = 0; i &lt; n; i++) result += v1[i] * v2[i];\\n\\n  return result;\\n}\\n\\n\\nfunction zeros(...dims) {\\n  let A = [];\\n\\n  \\n  for (let i = dims.length - 1; i &gt;= 0; i--) {\\n    let size = dims[i];\\n    if (i === dims.length - 1) {\\n      \\n      A = new Array(size).fill(0.0);\\n    } else {\\n      \\n      A = new Array(size).fill().map(() =&gt; deepCopy(A));\\n    }\\n  }\\n\\n  return A;\\n}\\n\\n\\nfunction svMult(a, v) {\\n  return v.map(x =&gt; a * x);\\n}\\n\\n\\nfunction quadForm(A, x) {\\n   return dot(x, mvMult(A, x)); \\n}\\n\\n\\nfunction solvePosDef(A, b) {\\n  let [L, p, success] = modifiedCholesky(A);\\n\\n  if (!success) {\\n    return [zeros(b.length), success];\\n  }\\n\\n  return [modifiedCholeskySolve(L, p, b), success];\\n}\\n\\n\\nfunction modifiedCholesky(A) {\\n    const floatEps = 1.0e-14;\\n    const n = A.length;\\n\\n    \\n    let L = deepCopy(A); \\n    let p = arange(0, n);\\n\\n    \\n    let success = true;\\n\\n    let xi = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        for (let j = 0; j &lt; i; j++) {\\n            let temp = Math.abs(L[i][j]);\\n            xi = Math.max(xi, temp);\\n        }\\n    }\\n\\n    let eta = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        let temp = Math.abs(L[i][i]);\\n        eta = Math.max(eta, temp);\\n    }\\n\\n    let beta;\\n    if (n &gt; 1) {\\n        beta = Math.sqrt(Math.max(eta, xi / Math.sqrt(n * n - 1)));\\n    } else {\\n        beta = Math.sqrt(eta);\\n    }\\n    beta = Math.max(beta, floatEps);\\n\\n    for (let k = 0; k &lt; n; k++) {\\n        \\n        let muVal = L[k][k];\\n        let mu = k;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            let temp = L[i][i];\\n            if (muVal &lt; temp) {\\n                mu = i;\\n                muVal = temp;\\n            }\\n        }\\n\\n        \\n        let iTemp = p[mu];\\n        p[mu] = p[k];\\n        p[k] = iTemp;\\n\\n        for (let i = 0; i &lt; k; i++) {\\n            let temp = L[k][i];\\n            L[k][i] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        let temp = L[k][k];\\n        L[k][k] = L[mu][mu];\\n        L[mu][mu] = temp;\\n        for (let i = k + 1; i &lt; mu; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        for (let i = mu + 1; i &lt; n; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[i][mu];\\n            L[i][mu] = temp;\\n        }\\n\\n        \\n        let cSum = 0;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            cSum = Math.max(cSum, Math.abs(L[i][k]));\\n        }\\n        cSum /= beta;\\n        cSum = cSum * cSum;\\n\\n        \\n        if (L[k][k] &lt; 0) {\\n            success = false;\\n        }\\n\\n        temp = Math.abs(L[k][k]);\\n        temp = Math.max(temp, floatEps * eta);\\n        temp = Math.max(temp, cSum);\\n        L[k][k] = Math.sqrt(temp);\\n\\n        \\n        for (let i = k + 1; i &lt; n; i++) {\\n            L[i][k] /= L[k][k];\\n        }\\n\\n        \\n        for (let j = k + 1; j &lt; n; j++) {\\n            for (let i = j; i &lt; n; i++) {\\n                L[i][j] -= L[i][k] * L[j][k];\\n            }\\n        }\\n\\n        \\n        for (let i = 0; i &lt; n - 1; i++) {\\n            for (let j = i + 1; j &lt; n; j++) {\\n                L[i][j] = 0.0;\\n            }\\n        }\\n    }\\n\\n    return [L, p, success];\\n}\\n\\n\\nfunction modifiedCholeskySolve(L, p, b) {\\n    const n = L.length;\\n\\n    let U = transpose(L);\\n    let xp = new Array(n).fill(0);\\n    for (let i = 0; i &lt; n; i++) {\\n        xp[i] = b[p[i]];\\n    }\\n\\n    \\n    let x = lowerTriSolve(L, xp);\\n\\n    \\n    xp = upperTriSolve(U, x);\\n\\n    for (let i = 0; i &lt; n; i++) {\\n        x[p[i]] = xp[i];\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction lowerTriSolve(L, b) {\\n    const floatEps = 1.0e-14;\\n    const n = L.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = 0; j &lt; n - 1; j++) {\\n        if (Math.abs(L[j][j]) &gt; floatEps) {\\n            x[j] /= L[j][j];\\n            for (let i = j + 1; i &lt; n; i++) {\\n                x[i] -= x[j] * L[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(L[n - 1][n - 1]) &gt; floatEps) {\\n            x[n - 1] /= L[n - 1][n - 1];\\n        } else {\\n            x[n - 1] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction upperTriSolve(U, b) {\\n    const floatEps = 1.0e-14;\\n    const n = U.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = n - 1; j &gt; 0; j--) {\\n        if (Math.abs(U[j][j]) &gt; floatEps) {\\n            x[j] /= U[j][j];\\n            for (let i = 0; i &lt; j; i++) {\\n                x[i] -= x[j] * U[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(U[0][0]) &gt; floatEps) {\\n            x[0] /= U[0][0];\\n        } else {\\n            x[0] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nclass NegativeBinomialDistribution extends DiscreteUnivariateDistribution {\\n  constructor(parametrization = &#x27;alpha-beta&#x27;, fixedParam = undefined) {\\n    super(parametrization);\\n\\n    \\n    this.name = &#x27;NegativeBinomial&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    if (this.parametrization === &#x27;alpha-beta&#x27;) {\\n      this.paramNames = [&#x27;\\u03b1&#x27;, &#x27;\\u03b2&#x27;];\\n      this.paramMin = [0.0, 0.0];\\n      this.paramMax = [Infinity, Infinity];\\n      if (fixedParam === undefined) this.fixedParams = [&#x27;\\u03b1&#x27;];\\n      else this.fixedParams = [fixedParam];\\n    } else if (this.parametrization === &#x27;mu-phi&#x27;) {\\n      this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03c6&#x27;];\\n      this.paramMin = [0.0, 0.0];\\n      this.paramMax = [Infinity, Infinity];\\n      if (fixedParam === undefined) this.fixedParams = [&#x27;\\u03c6&#x27;];\\n      else this.fixedParams = [fixedParam];\\n    } else if (this.parametrization === &#x27;alpha-p&#x27;) {\\n      this.paramNames = [&#x27;\\u03b1&#x27;, &#x27;p&#x27;];\\n      this.paramMin = [0.0, 0.0];\\n      this.paramMax = [Infinity, 1.0];\\n      if (fixedParam === undefined) this.fixedParams = [&#x27;\\u03b1&#x27;];\\n      else this.fixedParams = [fixedParam];\\n    } else if (this.parametrization === &#x27;r-b&#x27;) {\\n      this.paramNames = [&#x27;r&#x27;, &#x27;b&#x27;];\\n      this.paramMin = [0.0, 0.0];\\n      this.paramMax = [Infinity, Infinity];\\n      if (fixedParam === undefined) this.fixedParams = [&#x27;r&#x27;];\\n      else this.fixedParams = [fixedParam];\\n    } else { \\n      this.paramNames = [&#x27;unnamedParam1&#x27;, &#x27;unnamedParam2&#x27;];\\n      this.paramMin = [0.0, 0.0];\\n      this.paramMax = [Infinity, Infinity];\\n      if (fixedParam === undefined) this.fixedParams = [&#x27;unnamedParam1&#x27;];\\n      else this.fixedParams = [fixedParam];\\n    }\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  convertParams(params, from = this.parametrization, to = &#x27;alpha-beta&#x27;) {\\n    if (from === to) return params;\\n    else if (to === &#x27;alpha-beta&#x27;) return this.convertParamsToAlphaBeta(params, from);\\n    else if (from === &#x27;alpha-beta&#x27;) return this.convertParamsFromAlphaBeta(params, to);\\n    else return this.convertParamsFromAlphaBeta(this.convertParamsToAlphaBeta(params, from), to);\\n  }\\n\\n  convertParamsToAlphaBeta(params, from = this.parametrization) {\\n    \\n    let alpha, beta;\\n\\n    if (from === &#x27;mu-phi&#x27;) {\\n      let [mu, phi] = params.slice(0, 2);\\n      alpha = phi;\\n      beta = alpha / mu;\\n    } else if (from === &#x27;alpha-p&#x27;) {\\n      let [a, p] = params.slice(0, 2);\\n      alpha = a;\\n      beta = p / (1 - p);\\n    } else if (from === &#x27;r-b&#x27;) {\\n      let [r, b] = params.slice(0, 2);\\n      alpha = r;\\n      beta = 1 / b;\\n    } else if (from === &#x27;alpha-beta&#x27;) {\\n      [alpha, beta] = params.slice(0, 2);\\n    } else {\\n      throw new Error(&#x27;Invalid parametrization for converting. Allowed values are alpha-beta, mu-phi, alpha-p, and r-b.&#x27;);\\n    }\\n\\n    return [alpha, beta];\\n  }\\n\\n  convertParamsFromAlphaBeta(params, to = this.parametrization) {\\n    \\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    let output;\\n    if (to === &#x27;mu-phi&#x27;) {\\n      let mu = alpha / beta;\\n      let phi = alpha;\\n      output = [mu, phi];\\n    } else if (to === &#x27;alpha-p&#x27;) {\\n      let a = alpha;\\n      let p = beta / (1 + beta);\\n      output = [a, p];\\n    } else if (to === &#x27;r-b&#x27;) {\\n      let r = alpha;\\n      let b = 1 / beta;\\n      output = [r, b];\\n    } else if (to === &#x27;alpha-beta&#x27;) {\\n      output = [alpha, beta];\\n    } else {\\n      throw new Error(&#x27;Invalid parametrization for converting. Allowed values are alpha-beta, mu-phi, alpha-p, and r-b.&#x27;);\\n    }\\n\\n    return output;\\n  }\\n\\n  pmfSingleValue(y, params, parametrization = this.parametrization) {\\n    if (y &lt; 0) return NaN;\\n\\n    \\n    let [alpha, beta] = this.convertParamsToAlphaBeta(params, parametrization);\\n\\n    if (alpha &lt;= 0 || beta &lt;= 0) return NaN;\\n\\n    return Math.exp(lngamma(y + alpha)\\n                    - lngamma(alpha)\\n                    - lnfactorial(y)\\n                    + alpha * Math.log(beta / (1 + beta))\\n                    - y * Math.log(1 + beta));\\n  }\\n\\n  cdfSingleValue(y, params, parametrization = this.parametrization) {\\n    let [alpha, beta] = this.convertParamsToAlphaBeta(params, parametrization);\\n\\n    if (alpha === 0 || beta === Infinity) return 1.0;\\n    if (alpha === Infinity) return y === Infinity ? 1.0 : 0.0; \\n\\n    if (y &lt;= 0) return 0.0;\\n    if (y === Infinity) return 1.0;\\n\\n    return regularizedIncompleteBeta(beta / (1 + beta), alpha, y + 1);\\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    let [x1, x2] = super.ppf([0.001, 0.999], this.convertParamsToAlphaBeta(params, parametrization));\\n\\n    \\n    if (x1 &lt; (x2 - x1) / 10.0) x1 = -1.0;\\n\\n    return [x1, x2];\\n  }\\n\\n  \\n  quantileSet(x, p, extraParams) {\\n    if (this.fixedParams.length != 1) {\\n      throw new Error(&#x27;Must have exactly one fixed parameter.&#x27;)\\n    }\\n\\n    let x1 = x[0];\\n    let p1 = p[0];\\n    let otherParam = extraParams[0];\\n\\n    if (!Number.isInteger(x1)) {\\n      throw new Error(this.varName + &#x27; must be integer.&#x27;)\\n    }\\n    if (x1 &lt; 0 ) {\\n      throw new Error(&#x27;Must have &#x27; + this.varName + &#x27; &gt; 0.&#x27;)\\n    }\\n\\n    const rootFun = (xi, x1, p1) =&gt; {\\n      if (this.fixedParamsInds[0] === 0) {\\n        return p1 - this.cdfSingleValue(x1, [otherParam, xi / (1 - xi)], this.parametrization);\\n      } else {\\n        return p1 - this.cdfSingleValue(x1, [xi / (1 - xi), otherParam], this.parametrization);        \\n      }\\n    }\\n\\n    let xiOpt = brentSolve(rootFun, 0.0, 1.0, [x1, p1]);\\n    let optimSuccess = xiOpt != null;\\n    \\n    return [[xiOpt / (1 - xiOpt)], optimSuccess];\\n  }\\n\\n  quantileSetBoth(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    if (!Number.isInteger(x1) || !Number.isInteger(x2)) {\\n      throw new Error(this.varName + &#x27; must be integer.&#x27;)\\n    }\\n    if (x1 &lt; 0 || x2 &lt; 0) {\\n      throw new Error(&#x27;Must have &#x27; + this.varName + &#x27; &gt; 0.&#x27;)\\n    }\\n\\n    const quantileRootFun = (params, x1, p1, x2, p2) =&gt; {\\n      let mu = Math.exp(params[0]);\\n      let phi = Math.exp(params[1]);\\n\\n      let r1 = this.cdfSingleValue(x1, [mu, phi], &#x27;mu-phi&#x27;) - p1;\\n      let r2 = this.cdfSingleValue(x2, [mu, phi], &#x27;mu-phi&#x27;) - p2;\\n\\n      return [r1, r2];\\n    };\\n\\n    \\n    let meanp = (p1 + p2) / 2;\\n    let muGuess;\\n    if (Math.abs(meanp - 0.5) &lt; 0.2) {\\n      let meanx = (x1 + x2) / 2;\\n      muGuess = meanx;\\n    }\\n    else {\\n      muGuess = 1.0;\\n    }\\n\\n    let args = [x1, p1, x2, p2];\\n    let guess = [Math.log(muGuess), 1.0];\\n    let [logParams, optimSuccess] = findRootTrustRegion(quantileRootFun, guess, args=args);\\n\\n    let paramsOpt;\\n    if (optimSuccess) {\\n      let muOpt = Math.exp(logParams[0]);\\n      let phiOpt = Math.exp(logParams[1]);\\n\\n      \\n      if (phiOpt &gt; 1) {\\n\\n        \\n        const muGivenPhi = (phi, x, p) =&gt; {\\n          dist = new NegativeBinomialDistribution(&#x27;mu-phi&#x27;);\\n\\n          \\n          const rootFun = (xi, phi, x, p) =&gt; { \\n            if (xi === 1) return p;\\n            if (xi === 0) return p - 1;\\n            return p - this.cdfSingleValue(x, [xi / (1 - xi), phi], &#x27;mu-phi&#x27;);\\n          }\\n\\n          let xiOpt = brentSolve(rootFun, 0.0, 1.0, [phi, x, p]);\\n          let optimSuccess = xiOpt != null;\\n          \\n          return [xiOpt / (1 - xiOpt), optimSuccess];\\n        }\\n\\n        const hitQuantiles = (phi, x1, p1, x2, p2) =&gt; {\\n          let [muAdj, rootFindSuccess] = muGivenPhi(phi, x2, p2);\\n\\n          if (rootFindSuccess) {\\n            let [q1, q2] = this.ppf([p1, p2], [muAdj, phi], &#x27;mu-phi&#x27;);\\n\\n            if (q1 === x1 &amp;&amp; q2 === x2) return 1;\\n            else return -1;\\n          } else {\\n            return -1;\\n          }\\n        } \\n\\n        if (hitQuantiles(1.0) === 1) {\\n          phiOpt = 1.0;\\n          let [muAdj, rootFindSuccess] = muGivenPhi(phiOpt, x2, p2);\\n          muOpt = muAdj;\\n        }\\n        else {\\n          let phiAdj = bisectionSolve(hitQuantiles, 1.0, phiOpt, [x1, p1, x2, p2]);\\n          if (phiAdj != null) {\\n            phiOpt = phiAdj;\\n            let [muAdj, rootFindSuccess] = muGivenPhi(phiOpt, x2, p2);\\n            muOpt = muAdj;\\n          }\\n        }\\n      }\\n\\n      paramsOpt = this.convertParams([muOpt, phiOpt], &#x27;mu-phi&#x27;, this.parametrization);\\n    } else { \\n      let pois = new PoissonDistribution();\\n      let [paramsPois, optimSuccessPois] = pois.quantileSet([x2], [p2]);\\n\\n      if (optimSuccessPois) {\\n        let poisQuants = pois.ppf([p1, p2], paramsPois);\\n        if (poisQuants[0] === x1 &amp;&amp; poisQuants[1] === x2) {\\n          let errText;\\n          if (this.parametrization == &#x27;alpha-beta&#x27;|| this.parametrization == &#x27;alpha-p&#x27;) {\\n            errText = &#x27;Use Poisson (\\u03b1 \\u2192 \\u221e limit) with \\u03bb = &#x27; + paramsPois[0].toPrecision(4);\\n          }\\n          else if (this.parametrization == &#x27;mu-phi&#x27;) {\\n            errText = &#x27;Use Poisson (\\u03c6 \\u2192 \\u221e limit) with \\u03bb = &#x27; + paramsPois[0].toPrecision(4);\\n          }\\n          else if (this.parametrization == &#x27;r-b&#x27;) {\\n            errText = &#x27;Use Poisson (r \\u2192 \\u221e limit) with \\u03bb = &#x27; + paramsPois[0].toPrecision(4);\\n          }\\n          throw new Error(errText);\\n        }\\n        \\n      }\\n      paramsOpt = [];\\n    }\\n\\n    return [paramsOpt, optimSuccess];\\n  }\\n}\\n\\n\\n\\nvar dist = new NegativeBinomialDistribution();\\n\\n\\n\\nif (triggerCallbacks.active &amp;&amp; !cb_obj.disabled) {\\n\\tif (quantileSetterSwitch.active) {\\n\\t\\tquantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p);\\n\\t}\\n\\telse {\\n\\t\\tupdateData(source_p, source_c, p_p, sliders, discrete);\\n\\t\\tupdateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes);\\n\\t}\\n}"}}]]]},"width":200,"title":"\\u03b1","format":{"type":"object","name":"CustomJSTickFormatter","id":"p4716","attributes":{"code":"return tick.toPrecision(4)"}},"start":0.01,"end":20,"value":5,"step":0.01}},{"id":"p4719"}]],["xBoxes",[{"id":"p4724"}]],["pBoxes",[{"id":"p4725"}]],["quantileSetterSwitch",{"id":"p4727"}],["quantileSetterDiv",{"id":"p4726"}],["triggerCallbacks",{"id":"p4728"}],["startBoxes",[{"id":"p4720"},{"id":"p4721"}]],["endBoxes",[{"id":"p4722"},{"id":"p4723"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p\\\\&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass DiscreteUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pmfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pmf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pmfSingleValue(x, params, parametrization),\\n      x,\\n      params);\\n  }\\n\\n  cdfSingleValue(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    \\n    let cumsum = 0.0;\\n    let summand = 0.0;\\n    for (let n = this.xMin(params, parametrization); n &lt;= x; n++) {\\n        summand = this.pmfSingleValue(n, params, parametrization);\\n        if (!isNaN(summand)) cumsum += summand;\\n    }\\n\\n    return cumsum;\\n  }\\n\\n  cdfForPlotting(xStart, xEnd, params, parametrization = this.parametrization) {\\n\\n    params = this.scalarToArrayParams(params);\\n\\n    \\n    let cumsum;\\n    let y_c;\\n    let prob;\\n    if (Number.isInteger(xStart)) {\\n      \\n      cumsum = this.cdfSingleValue(Math.floor(xStart) - 1, params, parametrization);\\n\\n      if (Number.isInteger(xEnd)) {\\n        y_c = [cumsum];\\n        for (let x = xStart; x &lt; xEnd; x++) {\\n          prob = this.pmfSingleValue(x, params, parametrization);\\n          if (!isNaN(prob)) cumsum += prob;\\n          y_c.push(cumsum, cumsum);\\n        }\\n        prob = this.pmfSingleValue(xEnd, params, parametrization);\\n        if (!isNaN(prob)) cumsum += prob;\\n        y_c.push(cumsum);\\n      }\\n      else {\\n        y_c = [cumsum];\\n        for (let x = xStart; x &lt;= Math.floor(xEnd); x++) {\\n          prob = this.pmfSingleValue(x, params, parametrization);\\n          if (!isNaN(prob)) cumsum += prob;\\n          y_c.push(cumsum, cumsum);\\n        }\\n      }\\n    }\\n    else {\\n      \\n      cumsum = this.cdfSingleValue(Math.floor(xStart), params, parametrization);\\n\\n      if (Number.isInteger(xEnd)) {\\n        y_c = [cumsum, cumsum];\\n        for (let x = Math.ceil(xStart); x &lt; xEnd; x++) {\\n          prob = this.pmfSingleValue(x, params, parametrization);\\n          if (!isNaN(prob)) cumsum += prob;\\n          y_c.push(cumsum, cumsum);\\n        }\\n        prob = this.pmfSingleValue(xEnd, params, parametrization);\\n        if (!isNaN(prob)) cumsum += prob;\\n        y_c.push(cumsum);        \\n      }\\n      else {\\n        y_c = [cumsum, cumsum];\\n        for (let x = Math.ceil(xStart); x &lt;= xEnd; x++) {\\n          prob = this.pmfSingleValue(x, params, parametrization);\\n          if (!isNaN(prob)) cumsum += prob;\\n          y_c.push(cumsum, cumsum);\\n        }\\n      }    \\n    }\\n\\n    return y_c;\\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) throw new Error(&#x27;p must be between 0 and 1.&#x27;)\\n\\n    \\n    if (p == 0) return xMin(params, parametrization);\\n\\n    \\n    if (p == 1) return xMax(params, parametrization);\\n\\n    params = this.scalarToArrayParams(params);\\n\\n    \\n    let n = this.xMin(params, parametrization);\\n    let cumsum = this.pmfSingleValue(n, params, parametrization);\\n\\n    let iters = 0;\\n    let summand = 0.0;\\n    let xMaxForTheseParams = this.xMax(params, parametrization);\\n    while (cumsum &lt; p &amp;&amp; !isclose(cumsum, p) &amp;&amp; !isNaN(summand) &amp;&amp; n &lt; xMaxForTheseParams) {\\n      n += 1;\\n      summand = this.pmfSingleValue(n, params, parametrization);\\n\\n      if (!isNaN(summand)) cumsum += summand;\\n\\n      iters += 1;\\n    }\\n\\n    return n;\\n  }\\n\\n}\\n\\nclass BinomialDistribution extends DiscreteUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Binomial&#x27;;\\n\\n    \\n    this.varName = &#x27;n&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;N&#x27;, &#x27;\\u03b8&#x27;];\\n\\n    \\n    this.paramMin = [0, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, 1.0];\\n\\n    \\n    this.fixedParams = [&#x27;N&#x27;];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0;\\n  }\\n\\n  xMax(params) {\\n    return params[0];\\n  }\\n\\n  pmfSingleValue(n, params) {\\n    let [N, theta] = params.slice(0, 2);\\n\\n    if (n &gt; N || n &lt; 0) return NaN;\\n\\n    if (theta == 0) {\\n      if (n == 0) return 1.0;\\n      return 0.0;\\n    }\\n\\n    if (theta == 1) {\\n      if (n == N) return 1.0;\\n      return 0.0;\\n    }\\n\\n    return Math.exp(lnchoice(N, n) +\\n      n * Math.log(theta) +\\n      (N - n) * Math.log(1 - theta));\\n  }\\n\\n  cdfSingleValue(n, params) {\\n    let [N, theta] = params.slice(0, 2);\\n\\n    if (n &lt; 0) return 0.0;\\n    if (n &gt;= N) return 1.0;\\n    return regularizedIncompleteBeta(1.0 - theta, N - n, n + 1);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let [N, theta] = params.slice(0, 2);\\n    \\n    return super.ppfSingleValue(p, params, 0, N, N);\\n  }\\n\\n  defaultXRange(params) {\\n    let [N, theta] = params.slice(0, 2);\\n\\n    if (N &lt; 50) {\\n      return [-1, N + 1];\\n    } else {\\n      return this.ppf([0.001, 0.999], params);\\n    }\\n  }\\n\\n  quantileSet(x, p, extraParams) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n    let N = extraParams[0];\\n\\n    if (!Number.isInteger(x1)) {\\n      throw new Error(this.varName + &#x27; must be integer.&#x27;)\\n    }\\n    if (x1 &lt; 0) {\\n      throw new Error(&#x27;Must have &#x27; + this.varName + &#x27; &gt; 0.&#x27;)\\n    }\\n    if (x1 &gt;= N) {\\n      throw new Error(&#x27;Must have &#x27; + this.varName + &#x27; &lt; N.&#x27;)\\n    }\\n\\n    \\n    let rootFun = (theta, N) =&gt; p1 - this.cdfSingleValue(x1, [N, theta]);\\n\\n    let thetaOpt = brentSolve(rootFun, 0.0, 1.0, [N]);\\n    let optimSuccess = thetaOpt != null;\\n    \\n    return [[thetaOpt], optimSuccess];\\n  }\\n}\\n\\nclass PoissonDistribution extends DiscreteUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Poisson&#x27;;\\n\\n    \\n    this.varName = &#x27;n&#x27;;  \\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bb&#x27;];\\n\\n    \\n    this.paramMin = [0.0];\\n\\n    \\n    this.paramMax = [Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pmfSingleValue(n, params) {\\n    let lam = params[0];\\n\\n    if (lam &lt; 0) {\\n      return NaN;\\n    } else if (lam == 0) {\\n      if (n == 0) return 1.0;\\n      return 0.0;\\n    }\\n\\n    return Math.exp(n * Math.log(lam) - lnfactorial(n) - lam);\\n  }\\n\\n  cdfSingleValue(n, params) {\\n    if (n &lt; 0) return 0.0;\\n    if (n === Infinity) return 1.0;\\n\\n    let lam = params[0];\\n\\n    if (lam === 0) return 1.0;\\n\\n    return gammaincU(lam, n + 1, true);\\n  }\\n\\n  defaultXRange(params) {\\n    return super.ppf([0.001, 0.999], params)\\n  }\\n\\n  quantileSet(x, p) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n\\n    if (!Number.isInteger(x1)) {\\n      throw new Error(this.varName + &#x27; must be integer.&#x27;)\\n    }\\n    if (x1 &lt; 0) {\\n      throw new Error(&#x27;Must have &#x27; + this.varName + &#x27; \\u2265 0.&#x27;)\\n    }\\n\\n    \\n    if (x1 === 0 &amp;&amp; p1 === 1) return [[0.0], true];\\n\\n    \\n    const rootFun = (xi) =&gt; {\\n      if (xi === 1) return p1;\\n      return p1 - this.cdfSingleValue(x1, [xi / (1 - xi)]);\\n    }\\n\\n    let xiOpt = brentSolve(rootFun, 0.0, 1.0);\\n    let optimSuccess = xiOpt != null;\\n    \\n    return [[xiOpt / (1 - xiOpt)], optimSuccess];\\n  }\\n\\n}\\n\\nfunction regularizedIncompleteBeta(x, a, b) {\\n    \\n    \\n    if (x &lt; 0 || x &gt; 1) {\\n        throw new RangeError(&#x27;First argument must be between 0 and 1.&#x27;);\\n    }\\n\\n    \\n    else if (a === 1 &amp;&amp; b === 1) return x;\\n    else if (x === 0) return 0;\\n    else if (x === 1) return 1;\\n    else if (a === 0) return 1;\\n    else if (b === 0) return 0;\\n\\n    else {\\n        var bt = Math.exp(lngamma(a + b) - lngamma(a) - lngamma(b) + a * Math.log(x) + b * log1p(-x));\\n\\n        \\n        if (x &lt; (a + 1) / (a + b + 2)) return bt * betacf(x, a, b) / a;\\n\\n        \\n        else return 1 - bt * betacf(1 - x, b, a) / b;\\n    }\\n}\\n\\n\\nfunction lngamma(z) {\\n\\n    if(z &lt; 0) return Number(&#x27;0/0&#x27;);\\n\\n    if (z &lt; 0.5) return Math.log(Math.PI) - Math.log(Math.sin(Math.PI * z)) - lngamma(1-z);\\n\\n    var p = [676.5203681218851,\\n             -1259.1392167224028,\\n             771.32342877765313,\\n             -176.61502916214059,\\n             12.507343278686905,\\n             -0.13857109526572012,\\n             9.9843695780195716e-6,\\n             1.5056327351493116e-7];\\n\\n    z -= 1.0;\\n    var Ag = 0.99999999999980993;\\n    for (var i = 0; i &lt; p.length; i++) {\\n        Ag += p[i] / (z + i + 1);\\n    }\\n    var t = z + p.length - 0.5;\\n\\n    return 0.5 * Math.log(2*Math.PI) + (z + 0.5)*Math.log(t) - t + Math.log(Ag);\\n}\\n\\n\\nfunction lnfactorial(n) {\\n  if (n &gt; 254) { \\n    let x = n + 1;\\n    return (x - 0.5) * Math.log(x) - x + 0.5 * Math.log(2 * Math.PI) + 1.0 / (12.0 * x);\\n  }\\n  else { \\n    const lnfact = [0.000000000000000,\\n                    0.000000000000000,\\n                    0.693147180559945,\\n                    1.791759469228055,\\n                    3.178053830347946,\\n                    4.787491742782046,\\n                    6.579251212010101,\\n                    8.525161361065415,\\n                    10.604602902745251,\\n                    12.801827480081469,\\n                    15.104412573075516,\\n                    17.502307845873887,\\n                    19.987214495661885,\\n                    22.552163853123421,\\n                    25.191221182738683,\\n                    27.899271383840894,\\n                    30.671860106080675,\\n                    33.505073450136891,\\n                    36.395445208033053,\\n                    39.339884187199495,\\n                    42.335616460753485,\\n                    45.380138898476908,\\n                    48.471181351835227,\\n                    51.606675567764377,\\n                    54.784729398112319,\\n                    58.003605222980518,\\n                    61.261701761002001,\\n                    64.557538627006323,\\n                    67.889743137181526,\\n                    71.257038967168000,\\n                    74.658236348830158,\\n                    78.092223553315307,\\n                    81.557959456115029,\\n                    85.054467017581516,\\n                    88.580827542197682,\\n                    92.136175603687079,\\n                    95.719694542143202,\\n                    99.330612454787428,\\n                    102.968198614513810,\\n                    106.631760260643450,\\n                    110.320639714757390,\\n                    114.034211781461690,\\n                    117.771881399745060,\\n                    121.533081515438640,\\n                    125.317271149356880,\\n                    129.123933639127240,\\n                    132.952575035616290,\\n                    136.802722637326350,\\n                    140.673923648234250,\\n                    144.565743946344900,\\n                    148.477766951773020,\\n                    152.409592584497350,\\n                    156.360836303078800,\\n                    160.331128216630930,\\n                    164.320112263195170,\\n                    168.327445448427650,\\n                    172.352797139162820,\\n                    176.395848406997370,\\n                    180.456291417543780,\\n                    184.533828861449510,\\n                    188.628173423671600,\\n                    192.739047287844900,\\n                    196.866181672889980,\\n                    201.009316399281570,\\n                    205.168199482641200,\\n                    209.342586752536820,\\n                    213.532241494563270,\\n                    217.736934113954250,\\n                    221.956441819130360,\\n                    226.190548323727570,\\n                    230.439043565776930,\\n                    234.701723442818260,\\n                    238.978389561834350,\\n                    243.268849002982730,\\n                    247.572914096186910,\\n                    251.890402209723190,\\n                    256.221135550009480,\\n                    260.564940971863220,\\n                    264.921649798552780,\\n                    269.291097651019810,\\n                    273.673124285693690,\\n                    278.067573440366120,\\n                    282.474292687630400,\\n                    286.893133295426990,\\n                    291.323950094270290,\\n                    295.766601350760600,\\n                    300.220948647014100,\\n                    304.686856765668720,\\n                    309.164193580146900,\\n                    313.652829949878990,\\n                    318.152639620209300,\\n                    322.663499126726210,\\n                    327.185287703775200,\\n                    331.717887196928470,\\n                    336.261181979198450,\\n                    340.815058870798960,\\n                    345.379407062266860,\\n                    349.954118040770250,\\n                    354.539085519440790,\\n                    359.134205369575340,\\n                    363.739375555563470,\\n                    368.354496072404690,\\n                    372.979468885689020,\\n                    377.614197873918670,\\n                    382.258588773060010,\\n                    386.912549123217560,\\n                    391.575988217329610,\\n                    396.248817051791490,\\n                    400.930948278915760,\\n                    405.622296161144900,\\n                    410.322776526937280,\\n                    415.032306728249580,\\n                    419.750805599544780,\\n                    424.478193418257090,\\n                    429.214391866651570,\\n                    433.959323995014870,\\n                    438.712914186121170,\\n                    443.475088120918940,\\n                    448.245772745384610,\\n                    453.024896238496130,\\n                    457.812387981278110,\\n                    462.608178526874890,\\n                    467.412199571608080,\\n                    472.224383926980520,\\n                    477.044665492585580,\\n                    481.872979229887900,\\n                    486.709261136839360,\\n                    491.553448223298010,\\n                    496.405478487217580,\\n                    501.265290891579240,\\n                    506.132825342034830,\\n                    511.008022665236070,\\n                    515.890824587822520,\\n                    520.781173716044240,\\n                    525.679013515995050,\\n                    530.584288294433580,\\n                    535.496943180169520,\\n                    540.416924105997740,\\n                    545.344177791154950,\\n                    550.278651724285620,\\n                    555.220294146894960,\\n                    560.169054037273100,\\n                    565.124881094874350,\\n                    570.087725725134190,\\n                    575.057539024710200,\\n                    580.034272767130800,\\n                    585.017879388839220,\\n                    590.008311975617860,\\n                    595.005524249382010,\\n                    600.009470555327430,\\n                    605.020105849423770,\\n                    610.037385686238740,\\n                    615.061266207084940,\\n                    620.091704128477430,\\n                    625.128656730891070,\\n                    630.172081847810200,\\n                    635.221937855059760,\\n                    640.278183660408100,\\n                    645.340778693435030,\\n                    650.409682895655240,\\n                    655.484856710889060,\\n                    660.566261075873510,\\n                    665.653857411105950,\\n                    670.747607611912710,\\n                    675.847474039736880,\\n                    680.953419513637530,\\n                    686.065407301994010,\\n                    691.183401114410800,\\n                    696.307365093814040,\\n                    701.437263808737160,\\n                    706.573062245787470,\\n                    711.714725802289990,\\n                    716.862220279103440,\\n                    722.015511873601330,\\n                    727.174567172815840,\\n                    732.339353146739310,\\n                    737.509837141777440,\\n                    742.685986874351220,\\n                    747.867770424643370,\\n                    753.055156230484160,\\n                    758.248113081374300,\\n                    763.446610112640200,\\n                    768.650616799717000,\\n                    773.860102952558460,\\n                    779.075038710167410,\\n                    784.295394535245690,\\n                    789.521141208958970,\\n                    794.752249825813460,\\n                    799.988691788643450,\\n                    805.230438803703120,\\n                    810.477462875863580,\\n                    815.729736303910160,\\n                    820.987231675937890,\\n                    826.249921864842800,\\n                    831.517780023906310,\\n                    836.790779582469900,\\n                    842.068894241700490,\\n                    847.352097970438420,\\n                    852.640365001133090,\\n                    857.933669825857460,\\n                    863.231987192405430,\\n                    868.535292100464630,\\n                    873.843559797865740,\\n                    879.156765776907600,\\n                    884.474885770751830,\\n                    889.797895749890240,\\n                    895.125771918679900,\\n                    900.458490711945270,\\n                    905.796028791646340,\\n                    911.138363043611210,\\n                    916.485470574328820,\\n                    921.837328707804890,\\n                    927.193914982476710,\\n                    932.555207148186240,\\n                    937.921183163208070,\\n                    943.291821191335660,\\n                    948.667099599019820,\\n                    954.046996952560450,\\n                    959.431492015349480,\\n                    964.820563745165940,\\n                    970.214191291518320,\\n                    975.612353993036210,\\n                    981.015031374908400,\\n                    986.422203146368590,\\n                    991.833849198223450,\\n                    997.249949600427840,\\n                    1002.670484599700300,\\n                    1008.095434617181700,\\n                    1013.524780246136200,\\n                    1018.958502249690200,\\n                    1024.396581558613400,\\n                    1029.838999269135500,\\n                    1035.285736640801600,\\n                    1040.736775094367400,\\n                    1046.192096209724900,\\n                    1051.651681723869200,\\n                    1057.115513528895000,\\n                    1062.583573670030100,\\n                    1068.055844343701400,\\n                    1073.532307895632800,\\n                    1079.012946818975000,\\n                    1084.497743752465600,\\n                    1089.986681478622400,\\n                    1095.479742921962700,\\n                    1100.976911147256000,\\n                    1106.478169357800900,\\n                    1111.983500893733000,\\n                    1117.492889230361000,\\n                    1123.006317976526100,\\n                    1128.523770872990800,\\n                    1134.045231790853000,\\n                    1139.570684729984800,\\n                    1145.100113817496100,\\n                    1150.633503306223700,\\n                    1156.170837573242400];\\n    return lnfact[n];\\n  }\\n}\\n\\n\\nfunction findRootTrustRegion(\\n\\t\\tf, \\n\\t\\tx0, \\n\\t\\targs=[],\\n\\t\\tjac=jacCentralDiff,\\n\\t\\ttol=0.000000001, \\n\\t\\tmaxIters=10000, \\n\\t\\tdeltaBar=1000.0, \\n\\t\\teta=0.125, \\n\\t\\tminDelta=1e-12\\n  ) {\\n\\t\\n\\tlet x = deepCopy(x0);\\n\\n\\t\\n\\tlet delta = 0.99 * deltaBar;\\n\\n\\t\\n\\tlet r = f(x, ...args);\\n\\n\\t\\n\\tlet J = jac(f, x, args);\\n\\n\\t\\n\\tlet JTJ = mmMult(transpose(J), J);\\n\\n\\t\\n\\tlet JTr = mvMult(transpose(J), r);\\n\\n\\t\\n\\tlet normJTr = norm(JTr);\\n\\n\\tlet iters = 0;\\n\\twhile (iters &lt; maxIters &amp;&amp; checkTol(r, tol) &amp;&amp; delta &gt;= minDelta) {\\n\\t\\t\\n\\t\\tlet p = doglegStep(JTJ, JTr, normJTr, delta);\\n\\n\\t\\t\\n\\t\\tlet newr = f(vectorAdd(x, p), ...args);\\n\\t\\tlet rho = computeRho(r, newr, J, p);\\n\\n\\t\\t\\n\\t\\tif  (rho &lt; 0.25) {\\n\\t\\t\\tdelta = norm(p) / 4.0;\\n\\t\\t} else if (rho &gt; 0.75 &amp;&amp; Math.abs(norm(p) - delta) &lt; 1e-12) {\\n\\t\\t\\t\\tdelta = Math.min(2 * delta, deltaBar);\\n\\t\\t}\\n\\n\\t\\t\\n\\t\\tif (rho &gt; eta) {\\n\\t\\t\\tx = vectorAdd(x, p);\\n\\n\\t\\t\\tr = newr;\\n\\t\\t\\tJ = jac(f, x, args);\\n\\t\\t\\tJTJ = mmMult(transpose(J), J);\\n\\t\\t\\tJTr = mvMult(transpose(J), r);\\n\\t\\t\\tnormJTr = norm(JTr);\\n\\t\\t}\\n\\n\\t\\titers += 1;\\n\\t}\\n\\n\\tlet success = !checkTol(r, tol);\\n\\n\\treturn [x, success];\\n\\n}\\n\\n\\nfunction bisectionSolve(f, lower, upper, args=[], tol=1e-8, maxIter=1000) {\\n\\t\\n  if (f(lower, ...args) * f(upper, ...args) &gt;= 0) return null;\\n\\n  let mid = lower;\\n  for (let i = 0; i &lt; maxIter; i++) {\\n    mid = (lower + upper) / 2;\\n    let fMid = f(mid, ...args);\\n\\n    if (fMid === 0 || (upper - lower) / 2 &lt; tol) return mid;\\n\\n    if (fMid * f(lower, ...args) &gt; 0) lower = mid;\\n    else upper = mid;\\n  }\\n\\n  return mid;\\n}\\n\\n\\nfunction brentSolve(f, lower, upper, args=[], tol=1e-8, maxIter=1000) {\\n\\tlet a = lower;\\n\\tlet b = upper;\\n  let fa = f(a, ...args);\\n  let fb = f(b, ...args);\\n\\n  \\n  if (Math.abs(fa) &lt; tol) return a;\\n  if (Math.abs(fb) &lt; tol) return b;\\n\\n  \\n  if (fa * fb &gt;= 0) {\\n  \\treturn null;\\n\\t}\\n\\n  \\n  let c = a;\\n  let fc = fa;\\n\\n\\tlet iter = 0;\\n  while (iter++ &lt; maxIter) {\\n  \\tlet prevStep = b - a;\\n\\n    \\n    if (Math.abs(fc) &lt; Math.abs(fb)) {      \\n    \\t[a, b, c] = [b, c, b];\\n    \\t[fa, fb, fc] = [fb, fc, fb];\\n    }\\n\\n    \\n    let newStep = (c - b) / 2.0;\\n\\n    \\n    let tolAdj = 1e-15 * Math.abs(b) + tol / 2;\\n\\n    \\n  \\tif (Math.abs(newStep) &lt;= tolAdj || fb === 0 ) {\\n    \\t\\treturn b;\\n  \\t}\\n\\n    \\n    if (Math.abs(prevStep) &gt; tolAdj &amp;&amp; Math.abs(fa) &gt; Math.abs(fb)) {\\n    \\tlet p;\\n    \\tlet q;\\n    \\tlet t1;\\n    \\tlet t2;\\n    \\tlet cb = c - b;\\n    \\tif (a === c) { \\n    \\t\\tt1 = fb / fa;\\n    \\t\\tp = cb * t1;\\n    \\t\\tq = 1.0 - t1;\\n    \\t}\\n    \\telse { \\n    \\t\\tq = fa / fc;\\n    \\t\\tt1 = fb / fc;\\n    \\t\\tt2 = fb / fa;\\n    \\t\\tp = t2 * (cb * q * (q - t1) - (b - a) * (t1 - 1.0));\\n    \\t\\tq = (q - 1.0) * (t1 - 1.0) * (t2 - 1.0);\\n    \\t}\\n\\n    \\t\\n    \\tif (p &gt; 0) q = -q;\\n    \\telse p = -p;\\n\\n    \\t\\n    \\tif (p &lt; (0.75 * cb * q - Math.abs(tolAdj * q) / 2.0) \\n    \\t\\t&amp;&amp; p &lt; Math.abs(prevStep * q / 2.0)) { \\n\\t        newStep = p / q;\\n      \\t}\\n    }\\n\\n    if (Math.abs(newStep) &lt; tolAdj) {\\n      newStep = (newStep &gt; 0) ? tolAdj : -tolAdj;\\n    }\\n\\n    \\n    a = b;\\n    fa = fb;\\n\\n    \\n    b += newStep;\\n    fb = f(b, ...args);\\n\\n\\t\\n    if ((fb &gt; 0 &amp;&amp; fc &gt; 0) || (fb &lt; 0 &amp;&amp; fc &lt; 0)) {\\n      c = a; \\n      fc = fa;\\n    }\\n  }\\n\\n  \\n  return null;\\n}\\n\\n\\nfunction lnchoice(n, k) {\\n    return lnfactorial(n) - lnfactorial(n-k) - lnfactorial(k);\\n}\\n\\n\\nfunction log1p(x) {\\n  \\n  \\n  if (x &lt;= -1.0) {\\n    throw new RangeError(&#x27;Argument must be greater than -1.0&#x27;);\\n  }\\n\\n  \\n  else if (Math.abs(x) &gt; 1e-4) {\\n    return Math.log(1.0 + x);\\n  }\\n\\n  else {\\n    return (-0.5*x + 1.0)*x;\\n  }\\n}\\n\\n\\nfunction betacf(x, a, b) {\\n    \\n    \\n    var fpmin = 1e-30,\\n        m = 1,\\n        m2, aa, c, d, del, h, qab, qam, qap;\\n    \\n    qab = a + b;\\n    qap = a + 1;\\n    qam = a - 1;\\n    c = 1;\\n    d = 1 - qab * x / qap;\\n    if (Math.abs(d) &lt; fpmin) d = fpmin;\\n    d = 1 / d;\\n    h = d;\\n    for (; m &lt;= 100; m++) {\\n        m2 = 2 * m;\\n        aa = m * (b - m) * x / ((qam + m2) * (a + m2));\\n        \\n        d = 1 + aa * d;\\n        if (Math.abs(d) &lt; fpmin) d = fpmin;\\n        c = 1 + aa / c;\\n        if (Math.abs(c) &lt; fpmin) c = fpmin;\\n        d = 1 / d;\\n        h *= d * c;\\n        aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));\\n        \\n        d = 1 + aa * d;\\n        if (Math.abs(d) &lt; fpmin) d = fpmin;\\n        c = 1 + aa / c;\\n        if (Math.abs(c) &lt; fpmin) c = fpmin;\\n        d = 1 / d;\\n        del = d * c;\\n        h *= del;\\n        if (Math.abs(del - 1.0) &lt; 3e-7) break;\\n    }\\n    return h;\\n}\\n\\n\\nfunction isclose(x, y, rtol = 1.0e-7, atol = 1.0e-8) {\\n  return Math.abs(x - y) &lt;= (atol + rtol * Math.abs(y));\\n}\\n\\n\\nfunction gammaincU(x, s, regularized) {\\n\\n  var EPSILON = 1e-12;\\n\\n  if (x &lt;= 1.1 || x &lt;= s) {\\n    if (regularized !== false) {\\n      return 1 - gammaincL(x, s, regularized);\\n    } else {\\n      return Math.exp(lngamma(s)) - gammaincL(x, s, regularized);\\n    }\\n  }\\n\\n  var f = 1 + x - s,\\n    C = f,\\n    D = 0,\\n    i = 1,\\n    a, b, chg;\\n  for (i = 1; i &lt; 10000; i++) {\\n    a = i * (s - i);\\n    b = (i&lt;&lt;1) + 1 + x - s;\\n    D = b + a * D;\\n    C = b + a / C;\\n    D = 1 / D;\\n    chg = C * D;\\n    f *= chg;\\n    if (Math.abs(chg - 1) &lt; EPSILON) {\\n      break;\\n    }\\n  }\\n  if (regularized !== false) {\\n    return Math.exp(s * Math.log(x) - x - lngamma(s) - Math.log(f));\\n  } else {\\n    return Math.exp(s * Math.log(x) - x - Math.log(f));\\n  }\\n}\\n\\n\\nfunction transpose(A) {\\n    return A[0].map((_, colIndex) =&gt; A.map(row =&gt; row[colIndex]));\\n}\\n\\n\\nfunction mvMult(A, v) {\\n  return A.map(Arow =&gt; dot(Arow, v));\\n}\\n\\n\\nfunction mmMult(A, B) {\\n  let mA = A.length;\\n  let nA = A[0].length;\\n  let mB = B.length;\\n  let nB = B[0].length;\\n\\n  if (nA !== mB) {\\n      throw new Error(&#x27;Matrix dimension mismatch.&#x27;);\\n  }\\n\\n  let result = zeros(mA, nB);\\n\\n  for (let i = 0; i &lt; mA; i++) {\\n    for (let j = 0; j &lt; nB; j++) {\\n      for (let k = 0; k &lt; nA; k++) {\\n        result[i][j] += A[i][k] * B[k][j];\\n      }\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction vectorAdd() {\\n  let m = arguments.length;\\n  let n = arguments[0].length;\\n \\n  let result = new Array(n).fill(0.0);\\n \\n  for (let i = 0; i &lt; n; i++) {\\n    for (let j = 0; j &lt; m; j++) {\\n        result[i] += arguments[j][i];\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction norm(v) {\\n  return Math.sqrt(dot(v, v));\\n}\\n\\n\\nfunction deepCopy(x) {\\n  return JSON.parse(JSON.stringify(x));\\n}\\n\\n\\nfunction computeRho(r, newr, J, p) {\\n\\tlet r2 = norm(r) ** 2;\\n\\tlet num = r2 - norm(newr)**2;\\n\\tlet denom = r2 - norm(vectorAdd(r, mvMult(J, p))) ** 2;\\n\\n\\treturn num / denom;\\n}\\n\\n\\nfunction checkTol(r, tol) {\\n\\t\\n\\tconst n = r.length;\\n\\tfor (let i = 0; i &lt; n; i++) {\\n\\t\\tif (tol &lt; Math.abs(r[i])) return true;\\n\\t}\\n\\n\\treturn false;\\n}\\n\\n\\nfunction doglegStep(JTJ, JTr, normJTr, delta) {\\n\\t\\n\\tlet [pJ, posDef] = solvePosDef(JTJ, JTr);\\n\\tpJ = svMult(-1.0, pJ);\\n\\n\\t\\n\\tif (posDef &amp;&amp; norm(pJ) &lt;= delta) {\\n\\t\\treturn pJ;\\n\\t}\\n\\n\\t\\n\\tlet tau = Math.min(1, normJTr**3 / delta / quadForm(JTJ, JTr));\\n\\tlet pC = svMult(-tau * delta / normJTr, JTr);\\n\\n\\tlet pCnorm = norm(pC);\\n\\tif (!posDef || Math.abs(pCnorm - delta) &lt;= 1e-12) {\\n\\t\\treturn pC;\\n\\t}\\n\\n\\t\\n\\tlet pJ2 = norm(pJ) ** 2;\\n\\tlet pC2 = pCnorm**2;\\n\\tlet pJpC = dot(pJ, pC);\\n\\tlet a = pJ2 + pC2 - 2.0 * pJpC;\\n\\tlet b = 2.0 * (pJpC - pC2);\\n\\tlet c = pC2 - delta**2;\\n\\tlet q = -0.5 * (b + Math.sign(b) * Math.sqrt(b**2 - 4.0 * a * c));\\n\\n\\t\\n\\tlet beta;\\n\\tif (Math.abs(b) &lt; 1e-12) beta = Math.sqrt(-c / a);\\n\\telse if (b &lt; 0.0) beta = q / a;\\n\\telse beta = c / q;\\n\\n\\t\\n\\tif (0.0 &lt;= beta &amp;&amp; beta &lt;= 1) {\\n\\t\\treturn vectorAdd(pC, svMult(beta, vectorAdd(pJ, svMult(-1.0, pC))));\\n\\t} else { \\n\\t\\treturn pC;\\n\\t}\\n\\n}\\n\\n\\nfunction jacCentralDiff(f, x, args=[], eps=4.7e-6) {\\n\\t\\n\\tlet xPlus = deepCopy(x);\\n\\tlet xMinus = deepCopy(x);\\n\\n\\t\\n\\tlet fOfx = f(x, ...args);\\n\\tlet m = fOfx.length;\\n\\n\\t\\n\\tlet n = x.length;\\n\\n\\t\\n\\tlet J = zeros(m, n);\\n\\n\\t\\n\\tlet fOfxPlus;\\n\\tlet fOfxMinus;\\n\\n\\tfor (let j = 0; j &lt; n; j++) {\\n\\t\\txPlus[j] += eps;\\n\\t\\txMinus[j] -= eps;\\n\\t\\tfOfxPlus = f(xPlus, ...args);\\n\\t\\tfOfxMinus = f(xMinus, ...args);\\n\\t\\txPlus[j] -= eps;\\n\\t\\txMinus[j] += eps;\\n\\n\\t\\tfor (let i = 0; i &lt; m; i++) {\\n\\t\\t\\tJ[i][j] = (fOfxPlus[i] - fOfxMinus[i]) / 2.0 / eps;\\n\\t\\t}\\n\\t}\\n\\n\\treturn J;\\n}\\n\\n\\nfunction gammaincL(x, s, regularized) {\\n\\n  var EPSILON = 1e-12;\\n\\n  if (x === 0) {\\n    return 0;\\n  }\\n  if (x &lt; 0 || s &lt;= 0) {\\n    return NaN;\\n  }\\n\\n  if (x &gt; 1.1 &amp;&amp; x &gt; s) {\\n    if (regularized !== false) {\\n      return 1 - gammaincU(x, s, regularized);\\n    } else {\\n      return Math.exp(lngamma(s)) - gammaincU(x, s, regularized);\\n    }\\n  }\\n\\n  var ft,\\n    r = s,\\n    c = 1,\\n    pws = 1;\\n\\n  if (regularized !== false) {\\n    ft = s * Math.log(x) - x - lngamma(s);\\n  } else {\\n    ft = s * Math.log(x) - x;\\n  }\\n  ft = Math.exp(ft);\\n  do {\\n    r += 1;\\n    c *= x/r;\\n    pws += c;\\n  } while (c / pws &gt; EPSILON);\\n\\n  return pws * ft / s;\\n}\\n\\n\\nfunction dot(v1, v2) {\\n  const n = v1.length;\\n  let result = 0.0;\\n  for (let i = 0; i &lt; n; i++) result += v1[i] * v2[i];\\n\\n  return result;\\n}\\n\\n\\nfunction zeros(...dims) {\\n  let A = [];\\n\\n  \\n  for (let i = dims.length - 1; i &gt;= 0; i--) {\\n    let size = dims[i];\\n    if (i === dims.length - 1) {\\n      \\n      A = new Array(size).fill(0.0);\\n    } else {\\n      \\n      A = new Array(size).fill().map(() =&gt; deepCopy(A));\\n    }\\n  }\\n\\n  return A;\\n}\\n\\n\\nfunction svMult(a, v) {\\n  return v.map(x =&gt; a * x);\\n}\\n\\n\\nfunction quadForm(A, x) {\\n   return dot(x, mvMult(A, x)); \\n}\\n\\n\\nfunction solvePosDef(A, b) {\\n  let [L, p, success] = modifiedCholesky(A);\\n\\n  if (!success) {\\n    return [zeros(b.length), success];\\n  }\\n\\n  return [modifiedCholeskySolve(L, p, b), success];\\n}\\n\\n\\nfunction modifiedCholesky(A) {\\n    const floatEps = 1.0e-14;\\n    const n = A.length;\\n\\n    \\n    let L = deepCopy(A); \\n    let p = arange(0, n);\\n\\n    \\n    let success = true;\\n\\n    let xi = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        for (let j = 0; j &lt; i; j++) {\\n            let temp = Math.abs(L[i][j]);\\n            xi = Math.max(xi, temp);\\n        }\\n    }\\n\\n    let eta = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        let temp = Math.abs(L[i][i]);\\n        eta = Math.max(eta, temp);\\n    }\\n\\n    let beta;\\n    if (n &gt; 1) {\\n        beta = Math.sqrt(Math.max(eta, xi / Math.sqrt(n * n - 1)));\\n    } else {\\n        beta = Math.sqrt(eta);\\n    }\\n    beta = Math.max(beta, floatEps);\\n\\n    for (let k = 0; k &lt; n; k++) {\\n        \\n        let muVal = L[k][k];\\n        let mu = k;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            let temp = L[i][i];\\n            if (muVal &lt; temp) {\\n                mu = i;\\n                muVal = temp;\\n            }\\n        }\\n\\n        \\n        let iTemp = p[mu];\\n        p[mu] = p[k];\\n        p[k] = iTemp;\\n\\n        for (let i = 0; i &lt; k; i++) {\\n            let temp = L[k][i];\\n            L[k][i] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        let temp = L[k][k];\\n        L[k][k] = L[mu][mu];\\n        L[mu][mu] = temp;\\n        for (let i = k + 1; i &lt; mu; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        for (let i = mu + 1; i &lt; n; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[i][mu];\\n            L[i][mu] = temp;\\n        }\\n\\n        \\n        let cSum = 0;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            cSum = Math.max(cSum, Math.abs(L[i][k]));\\n        }\\n        cSum /= beta;\\n        cSum = cSum * cSum;\\n\\n        \\n        if (L[k][k] &lt; 0) {\\n            success = false;\\n        }\\n\\n        temp = Math.abs(L[k][k]);\\n        temp = Math.max(temp, floatEps * eta);\\n        temp = Math.max(temp, cSum);\\n        L[k][k] = Math.sqrt(temp);\\n\\n        \\n        for (let i = k + 1; i &lt; n; i++) {\\n            L[i][k] /= L[k][k];\\n        }\\n\\n        \\n        for (let j = k + 1; j &lt; n; j++) {\\n            for (let i = j; i &lt; n; i++) {\\n                L[i][j] -= L[i][k] * L[j][k];\\n            }\\n        }\\n\\n        \\n        for (let i = 0; i &lt; n - 1; i++) {\\n            for (let j = i + 1; j &lt; n; j++) {\\n                L[i][j] = 0.0;\\n            }\\n        }\\n    }\\n\\n    return [L, p, success];\\n}\\n\\n\\nfunction modifiedCholeskySolve(L, p, b) {\\n    const n = L.length;\\n\\n    let U = transpose(L);\\n    let xp = new Array(n).fill(0);\\n    for (let i = 0; i &lt; n; i++) {\\n        xp[i] = b[p[i]];\\n    }\\n\\n    \\n    let x = lowerTriSolve(L, xp);\\n\\n    \\n    xp = upperTriSolve(U, x);\\n\\n    for (let i = 0; i &lt; n; i++) {\\n        x[p[i]] = xp[i];\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction lowerTriSolve(L, b) {\\n    const floatEps = 1.0e-14;\\n    const n = L.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = 0; j &lt; n - 1; j++) {\\n        if (Math.abs(L[j][j]) &gt; floatEps) {\\n            x[j] /= L[j][j];\\n            for (let i = j + 1; i &lt; n; i++) {\\n                x[i] -= x[j] * L[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(L[n - 1][n - 1]) &gt; floatEps) {\\n            x[n - 1] /= L[n - 1][n - 1];\\n        } else {\\n            x[n - 1] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction upperTriSolve(U, b) {\\n    const floatEps = 1.0e-14;\\n    const n = U.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = n - 1; j &gt; 0; j--) {\\n        if (Math.abs(U[j][j]) &gt; floatEps) {\\n            x[j] /= U[j][j];\\n            for (let i = 0; i &lt; j; i++) {\\n                x[i] -= x[j] * U[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(U[0][0]) &gt; floatEps) {\\n            x[0] /= U[0][0];\\n        } else {\\n            x[0] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nclass NegativeBinomialDistribution extends DiscreteUnivariateDistribution {\\n  constructor(parametrization = &#x27;alpha-beta&#x27;, fixedParam = undefined) {\\n    super(parametrization);\\n\\n    \\n    this.name = &#x27;NegativeBinomial&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    if (this.parametrization === &#x27;alpha-beta&#x27;) {\\n      this.paramNames = [&#x27;\\u03b1&#x27;, &#x27;\\u03b2&#x27;];\\n      this.paramMin = [0.0, 0.0];\\n      this.paramMax = [Infinity, Infinity];\\n      if (fixedParam === undefined) this.fixedParams = [&#x27;\\u03b1&#x27;];\\n      else this.fixedParams = [fixedParam];\\n    } else if (this.parametrization === &#x27;mu-phi&#x27;) {\\n      this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03c6&#x27;];\\n      this.paramMin = [0.0, 0.0];\\n      this.paramMax = [Infinity, Infinity];\\n      if (fixedParam === undefined) this.fixedParams = [&#x27;\\u03c6&#x27;];\\n      else this.fixedParams = [fixedParam];\\n    } else if (this.parametrization === &#x27;alpha-p&#x27;) {\\n      this.paramNames = [&#x27;\\u03b1&#x27;, &#x27;p&#x27;];\\n      this.paramMin = [0.0, 0.0];\\n      this.paramMax = [Infinity, 1.0];\\n      if (fixedParam === undefined) this.fixedParams = [&#x27;\\u03b1&#x27;];\\n      else this.fixedParams = [fixedParam];\\n    } else if (this.parametrization === &#x27;r-b&#x27;) {\\n      this.paramNames = [&#x27;r&#x27;, &#x27;b&#x27;];\\n      this.paramMin = [0.0, 0.0];\\n      this.paramMax = [Infinity, Infinity];\\n      if (fixedParam === undefined) this.fixedParams = [&#x27;r&#x27;];\\n      else this.fixedParams = [fixedParam];\\n    } else { \\n      this.paramNames = [&#x27;unnamedParam1&#x27;, &#x27;unnamedParam2&#x27;];\\n      this.paramMin = [0.0, 0.0];\\n      this.paramMax = [Infinity, Infinity];\\n      if (fixedParam === undefined) this.fixedParams = [&#x27;unnamedParam1&#x27;];\\n      else this.fixedParams = [fixedParam];\\n    }\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  convertParams(params, from = this.parametrization, to = &#x27;alpha-beta&#x27;) {\\n    if (from === to) return params;\\n    else if (to === &#x27;alpha-beta&#x27;) return this.convertParamsToAlphaBeta(params, from);\\n    else if (from === &#x27;alpha-beta&#x27;) return this.convertParamsFromAlphaBeta(params, to);\\n    else return this.convertParamsFromAlphaBeta(this.convertParamsToAlphaBeta(params, from), to);\\n  }\\n\\n  convertParamsToAlphaBeta(params, from = this.parametrization) {\\n    \\n    let alpha, beta;\\n\\n    if (from === &#x27;mu-phi&#x27;) {\\n      let [mu, phi] = params.slice(0, 2);\\n      alpha = phi;\\n      beta = alpha / mu;\\n    } else if (from === &#x27;alpha-p&#x27;) {\\n      let [a, p] = params.slice(0, 2);\\n      alpha = a;\\n      beta = p / (1 - p);\\n    } else if (from === &#x27;r-b&#x27;) {\\n      let [r, b] = params.slice(0, 2);\\n      alpha = r;\\n      beta = 1 / b;\\n    } else if (from === &#x27;alpha-beta&#x27;) {\\n      [alpha, beta] = params.slice(0, 2);\\n    } else {\\n      throw new Error(&#x27;Invalid parametrization for converting. Allowed values are alpha-beta, mu-phi, alpha-p, and r-b.&#x27;);\\n    }\\n\\n    return [alpha, beta];\\n  }\\n\\n  convertParamsFromAlphaBeta(params, to = this.parametrization) {\\n    \\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    let output;\\n    if (to === &#x27;mu-phi&#x27;) {\\n      let mu = alpha / beta;\\n      let phi = alpha;\\n      output = [mu, phi];\\n    } else if (to === &#x27;alpha-p&#x27;) {\\n      let a = alpha;\\n      let p = beta / (1 + beta);\\n      output = [a, p];\\n    } else if (to === &#x27;r-b&#x27;) {\\n      let r = alpha;\\n      let b = 1 / beta;\\n      output = [r, b];\\n    } else if (to === &#x27;alpha-beta&#x27;) {\\n      output = [alpha, beta];\\n    } else {\\n      throw new Error(&#x27;Invalid parametrization for converting. Allowed values are alpha-beta, mu-phi, alpha-p, and r-b.&#x27;);\\n    }\\n\\n    return output;\\n  }\\n\\n  pmfSingleValue(y, params, parametrization = this.parametrization) {\\n    if (y &lt; 0) return NaN;\\n\\n    \\n    let [alpha, beta] = this.convertParamsToAlphaBeta(params, parametrization);\\n\\n    if (alpha &lt;= 0 || beta &lt;= 0) return NaN;\\n\\n    return Math.exp(lngamma(y + alpha)\\n                    - lngamma(alpha)\\n                    - lnfactorial(y)\\n                    + alpha * Math.log(beta / (1 + beta))\\n                    - y * Math.log(1 + beta));\\n  }\\n\\n  cdfSingleValue(y, params, parametrization = this.parametrization) {\\n    let [alpha, beta] = this.convertParamsToAlphaBeta(params, parametrization);\\n\\n    if (alpha === 0 || beta === Infinity) return 1.0;\\n    if (alpha === Infinity) return y === Infinity ? 1.0 : 0.0; \\n\\n    if (y &lt;= 0) return 0.0;\\n    if (y === Infinity) return 1.0;\\n\\n    return regularizedIncompleteBeta(beta / (1 + beta), alpha, y + 1);\\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    let [x1, x2] = super.ppf([0.001, 0.999], this.convertParamsToAlphaBeta(params, parametrization));\\n\\n    \\n    if (x1 &lt; (x2 - x1) / 10.0) x1 = -1.0;\\n\\n    return [x1, x2];\\n  }\\n\\n  \\n  quantileSet(x, p, extraParams) {\\n    if (this.fixedParams.length != 1) {\\n      throw new Error(&#x27;Must have exactly one fixed parameter.&#x27;)\\n    }\\n\\n    let x1 = x[0];\\n    let p1 = p[0];\\n    let otherParam = extraParams[0];\\n\\n    if (!Number.isInteger(x1)) {\\n      throw new Error(this.varName + &#x27; must be integer.&#x27;)\\n    }\\n    if (x1 &lt; 0 ) {\\n      throw new Error(&#x27;Must have &#x27; + this.varName + &#x27; &gt; 0.&#x27;)\\n    }\\n\\n    const rootFun = (xi, x1, p1) =&gt; {\\n      if (this.fixedParamsInds[0] === 0) {\\n        return p1 - this.cdfSingleValue(x1, [otherParam, xi / (1 - xi)], this.parametrization);\\n      } else {\\n        return p1 - this.cdfSingleValue(x1, [xi / (1 - xi), otherParam], this.parametrization);        \\n      }\\n    }\\n\\n    let xiOpt = brentSolve(rootFun, 0.0, 1.0, [x1, p1]);\\n    let optimSuccess = xiOpt != null;\\n    \\n    return [[xiOpt / (1 - xiOpt)], optimSuccess];\\n  }\\n\\n  quantileSetBoth(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    if (!Number.isInteger(x1) || !Number.isInteger(x2)) {\\n      throw new Error(this.varName + &#x27; must be integer.&#x27;)\\n    }\\n    if (x1 &lt; 0 || x2 &lt; 0) {\\n      throw new Error(&#x27;Must have &#x27; + this.varName + &#x27; &gt; 0.&#x27;)\\n    }\\n\\n    const quantileRootFun = (params, x1, p1, x2, p2) =&gt; {\\n      let mu = Math.exp(params[0]);\\n      let phi = Math.exp(params[1]);\\n\\n      let r1 = this.cdfSingleValue(x1, [mu, phi], &#x27;mu-phi&#x27;) - p1;\\n      let r2 = this.cdfSingleValue(x2, [mu, phi], &#x27;mu-phi&#x27;) - p2;\\n\\n      return [r1, r2];\\n    };\\n\\n    \\n    let meanp = (p1 + p2) / 2;\\n    let muGuess;\\n    if (Math.abs(meanp - 0.5) &lt; 0.2) {\\n      let meanx = (x1 + x2) / 2;\\n      muGuess = meanx;\\n    }\\n    else {\\n      muGuess = 1.0;\\n    }\\n\\n    let args = [x1, p1, x2, p2];\\n    let guess = [Math.log(muGuess), 1.0];\\n    let [logParams, optimSuccess] = findRootTrustRegion(quantileRootFun, guess, args=args);\\n\\n    let paramsOpt;\\n    if (optimSuccess) {\\n      let muOpt = Math.exp(logParams[0]);\\n      let phiOpt = Math.exp(logParams[1]);\\n\\n      \\n      if (phiOpt &gt; 1) {\\n\\n        \\n        const muGivenPhi = (phi, x, p) =&gt; {\\n          dist = new NegativeBinomialDistribution(&#x27;mu-phi&#x27;);\\n\\n          \\n          const rootFun = (xi, phi, x, p) =&gt; { \\n            if (xi === 1) return p;\\n            if (xi === 0) return p - 1;\\n            return p - this.cdfSingleValue(x, [xi / (1 - xi), phi], &#x27;mu-phi&#x27;);\\n          }\\n\\n          let xiOpt = brentSolve(rootFun, 0.0, 1.0, [phi, x, p]);\\n          let optimSuccess = xiOpt != null;\\n          \\n          return [xiOpt / (1 - xiOpt), optimSuccess];\\n        }\\n\\n        const hitQuantiles = (phi, x1, p1, x2, p2) =&gt; {\\n          let [muAdj, rootFindSuccess] = muGivenPhi(phi, x2, p2);\\n\\n          if (rootFindSuccess) {\\n            let [q1, q2] = this.ppf([p1, p2], [muAdj, phi], &#x27;mu-phi&#x27;);\\n\\n            if (q1 === x1 &amp;&amp; q2 === x2) return 1;\\n            else return -1;\\n          } else {\\n            return -1;\\n          }\\n        } \\n\\n        if (hitQuantiles(1.0) === 1) {\\n          phiOpt = 1.0;\\n          let [muAdj, rootFindSuccess] = muGivenPhi(phiOpt, x2, p2);\\n          muOpt = muAdj;\\n        }\\n        else {\\n          let phiAdj = bisectionSolve(hitQuantiles, 1.0, phiOpt, [x1, p1, x2, p2]);\\n          if (phiAdj != null) {\\n            phiOpt = phiAdj;\\n            let [muAdj, rootFindSuccess] = muGivenPhi(phiOpt, x2, p2);\\n            muOpt = muAdj;\\n          }\\n        }\\n      }\\n\\n      paramsOpt = this.convertParams([muOpt, phiOpt], &#x27;mu-phi&#x27;, this.parametrization);\\n    } else { \\n      let pois = new PoissonDistribution();\\n      let [paramsPois, optimSuccessPois] = pois.quantileSet([x2], [p2]);\\n\\n      if (optimSuccessPois) {\\n        let poisQuants = pois.ppf([p1, p2], paramsPois);\\n        if (poisQuants[0] === x1 &amp;&amp; poisQuants[1] === x2) {\\n          let errText;\\n          if (this.parametrization == &#x27;alpha-beta&#x27;|| this.parametrization == &#x27;alpha-p&#x27;) {\\n            errText = &#x27;Use Poisson (\\u03b1 \\u2192 \\u221e limit) with \\u03bb = &#x27; + paramsPois[0].toPrecision(4);\\n          }\\n          else if (this.parametrization == &#x27;mu-phi&#x27;) {\\n            errText = &#x27;Use Poisson (\\u03c6 \\u2192 \\u221e limit) with \\u03bb = &#x27; + paramsPois[0].toPrecision(4);\\n          }\\n          else if (this.parametrization == &#x27;r-b&#x27;) {\\n            errText = &#x27;Use Poisson (r \\u2192 \\u221e limit) with \\u03bb = &#x27; + paramsPois[0].toPrecision(4);\\n          }\\n          throw new Error(errText);\\n        }\\n        \\n      }\\n      paramsOpt = [];\\n    }\\n\\n    return [paramsOpt, optimSuccess];\\n  }\\n}\\n\\n\\n\\nvar dist = new NegativeBinomialDistribution();\\n\\n\\n\\nlet params = paramsFromSliders(sliders); \\n\\n\\nlet [x1, x2] = dist.defaultXRange(params);\\n\\n\\ntriggerCallbacks.active = false;\\n\\n\\np_p.x_range.start = x1;\\np_p.x_range.end = x2;\\n\\nupdateData(source_p, source_c, p_p, sliders, discrete);\\n\\n\\nsetYRanges(p_p, p_c, source_p);  \\n\\ntriggerCallbacks.active = true;\\n"}}]]]},"x_range":{"id":"p4681"},"y_range":{"type":"object","name":"Range1d","id":"p4682"},"x_scale":{"type":"object","name":"LinearScale","id":"p4667"},"y_scale":{"type":"object","name":"LinearScale","id":"p4668"},"title":{"type":"object","name":"Title","id":"p4660","attributes":{"text":" "}},"renderers":[{"type":"object","name":"GlyphRenderer","id":"p4695","attributes":{"level":"overlay","data_source":{"id":"p4686"},"view":{"type":"object","name":"CDSView","id":"p4696","attributes":{"filter":{"type":"object","name":"AllIndices","id":"p4697"}}},"glyph":{"type":"object","name":"Line","id":"p4692","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_width":2}},"nonselection_glyph":{"type":"object","name":"Line","id":"p4693","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_alpha":0.1,"line_width":2}},"muted_glyph":{"type":"object","name":"Line","id":"p4694","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_c"},"line_color":"#1f77b4","line_alpha":0.2,"line_width":2}}}}],"toolbar":{"type":"object","name":"Toolbar","id":"p4666","attributes":{"tools":[{"type":"object","name":"ResetTool","id":"p4679"},{"type":"object","name":"SaveTool","id":"p4680"}]}},"toolbar_location":null,"left":[{"type":"object","name":"LinearAxis","id":"p4674","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p4675","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p4676"},"axis_label":"CDF","axis_label_text_font_style":"normal","major_label_policy":{"type":"object","name":"AllLabels","id":"p4677"}}}],"below":[{"type":"object","name":"LinearAxis","id":"p4669","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p4670","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p4671"},"axis_label":"y","major_label_policy":{"type":"object","name":"AllLabels","id":"p4672"}}}],"center":[{"type":"object","name":"Grid","id":"p4673","attributes":{"axis":{"id":"p4669"}}},{"type":"object","name":"Grid","id":"p4678","attributes":{"dimension":1,"axis":{"id":"p4674"}}}],"frame_width":300,"frame_height":175,"background_fill_alpha":0,"border_fill_alpha":0}}],["source_p",{"id":"p4683"}],["source_c",{"id":"p4686"}],["discrete",true],["n",400],["sliders",[{"id":"p4717"},{"id":"p4719"}]],["xBoxes",[{"id":"p4724"}]],["pBoxes",[{"id":"p4725"}]],["quantileSetterSwitch",{"id":"p4727"}],["quantileSetterDiv",{"id":"p4726"}],["triggerCallbacks",{"id":"p4728"}],["startBoxes",[{"id":"p4720"},{"id":"p4721"}]],["endBoxes",[{"id":"p4722"},{"id":"p4723"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p\\\\&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass DiscreteUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pmfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pmf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pmfSingleValue(x, params, parametrization),\\n      x,\\n      params);\\n  }\\n\\n  cdfSingleValue(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    \\n    let cumsum = 0.0;\\n    let summand = 0.0;\\n    for (let n = this.xMin(params, parametrization); n &lt;= x; n++) {\\n        summand = this.pmfSingleValue(n, params, parametrization);\\n        if (!isNaN(summand)) cumsum += summand;\\n    }\\n\\n    return cumsum;\\n  }\\n\\n  cdfForPlotting(xStart, xEnd, params, parametrization = this.parametrization) {\\n\\n    params = this.scalarToArrayParams(params);\\n\\n    \\n    let cumsum;\\n    let y_c;\\n    let prob;\\n    if (Number.isInteger(xStart)) {\\n      \\n      cumsum = this.cdfSingleValue(Math.floor(xStart) - 1, params, parametrization);\\n\\n      if (Number.isInteger(xEnd)) {\\n        y_c = [cumsum];\\n        for (let x = xStart; x &lt; xEnd; x++) {\\n          prob = this.pmfSingleValue(x, params, parametrization);\\n          if (!isNaN(prob)) cumsum += prob;\\n          y_c.push(cumsum, cumsum);\\n        }\\n        prob = this.pmfSingleValue(xEnd, params, parametrization);\\n        if (!isNaN(prob)) cumsum += prob;\\n        y_c.push(cumsum);\\n      }\\n      else {\\n        y_c = [cumsum];\\n        for (let x = xStart; x &lt;= Math.floor(xEnd); x++) {\\n          prob = this.pmfSingleValue(x, params, parametrization);\\n          if (!isNaN(prob)) cumsum += prob;\\n          y_c.push(cumsum, cumsum);\\n        }\\n      }\\n    }\\n    else {\\n      \\n      cumsum = this.cdfSingleValue(Math.floor(xStart), params, parametrization);\\n\\n      if (Number.isInteger(xEnd)) {\\n        y_c = [cumsum, cumsum];\\n        for (let x = Math.ceil(xStart); x &lt; xEnd; x++) {\\n          prob = this.pmfSingleValue(x, params, parametrization);\\n          if (!isNaN(prob)) cumsum += prob;\\n          y_c.push(cumsum, cumsum);\\n        }\\n        prob = this.pmfSingleValue(xEnd, params, parametrization);\\n        if (!isNaN(prob)) cumsum += prob;\\n        y_c.push(cumsum);        \\n      }\\n      else {\\n        y_c = [cumsum, cumsum];\\n        for (let x = Math.ceil(xStart); x &lt;= xEnd; x++) {\\n          prob = this.pmfSingleValue(x, params, parametrization);\\n          if (!isNaN(prob)) cumsum += prob;\\n          y_c.push(cumsum, cumsum);\\n        }\\n      }    \\n    }\\n\\n    return y_c;\\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) throw new Error(&#x27;p must be between 0 and 1.&#x27;)\\n\\n    \\n    if (p == 0) return xMin(params, parametrization);\\n\\n    \\n    if (p == 1) return xMax(params, parametrization);\\n\\n    params = this.scalarToArrayParams(params);\\n\\n    \\n    let n = this.xMin(params, parametrization);\\n    let cumsum = this.pmfSingleValue(n, params, parametrization);\\n\\n    let iters = 0;\\n    let summand = 0.0;\\n    let xMaxForTheseParams = this.xMax(params, parametrization);\\n    while (cumsum &lt; p &amp;&amp; !isclose(cumsum, p) &amp;&amp; !isNaN(summand) &amp;&amp; n &lt; xMaxForTheseParams) {\\n      n += 1;\\n      summand = this.pmfSingleValue(n, params, parametrization);\\n\\n      if (!isNaN(summand)) cumsum += summand;\\n\\n      iters += 1;\\n    }\\n\\n    return n;\\n  }\\n\\n}\\n\\nclass BinomialDistribution extends DiscreteUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Binomial&#x27;;\\n\\n    \\n    this.varName = &#x27;n&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;N&#x27;, &#x27;\\u03b8&#x27;];\\n\\n    \\n    this.paramMin = [0, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, 1.0];\\n\\n    \\n    this.fixedParams = [&#x27;N&#x27;];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0;\\n  }\\n\\n  xMax(params) {\\n    return params[0];\\n  }\\n\\n  pmfSingleValue(n, params) {\\n    let [N, theta] = params.slice(0, 2);\\n\\n    if (n &gt; N || n &lt; 0) return NaN;\\n\\n    if (theta == 0) {\\n      if (n == 0) return 1.0;\\n      return 0.0;\\n    }\\n\\n    if (theta == 1) {\\n      if (n == N) return 1.0;\\n      return 0.0;\\n    }\\n\\n    return Math.exp(lnchoice(N, n) +\\n      n * Math.log(theta) +\\n      (N - n) * Math.log(1 - theta));\\n  }\\n\\n  cdfSingleValue(n, params) {\\n    let [N, theta] = params.slice(0, 2);\\n\\n    if (n &lt; 0) return 0.0;\\n    if (n &gt;= N) return 1.0;\\n    return regularizedIncompleteBeta(1.0 - theta, N - n, n + 1);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let [N, theta] = params.slice(0, 2);\\n    \\n    return super.ppfSingleValue(p, params, 0, N, N);\\n  }\\n\\n  defaultXRange(params) {\\n    let [N, theta] = params.slice(0, 2);\\n\\n    if (N &lt; 50) {\\n      return [-1, N + 1];\\n    } else {\\n      return this.ppf([0.001, 0.999], params);\\n    }\\n  }\\n\\n  quantileSet(x, p, extraParams) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n    let N = extraParams[0];\\n\\n    if (!Number.isInteger(x1)) {\\n      throw new Error(this.varName + &#x27; must be integer.&#x27;)\\n    }\\n    if (x1 &lt; 0) {\\n      throw new Error(&#x27;Must have &#x27; + this.varName + &#x27; &gt; 0.&#x27;)\\n    }\\n    if (x1 &gt;= N) {\\n      throw new Error(&#x27;Must have &#x27; + this.varName + &#x27; &lt; N.&#x27;)\\n    }\\n\\n    \\n    let rootFun = (theta, N) =&gt; p1 - this.cdfSingleValue(x1, [N, theta]);\\n\\n    let thetaOpt = brentSolve(rootFun, 0.0, 1.0, [N]);\\n    let optimSuccess = thetaOpt != null;\\n    \\n    return [[thetaOpt], optimSuccess];\\n  }\\n}\\n\\nclass PoissonDistribution extends DiscreteUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Poisson&#x27;;\\n\\n    \\n    this.varName = &#x27;n&#x27;;  \\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bb&#x27;];\\n\\n    \\n    this.paramMin = [0.0];\\n\\n    \\n    this.paramMax = [Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pmfSingleValue(n, params) {\\n    let lam = params[0];\\n\\n    if (lam &lt; 0) {\\n      return NaN;\\n    } else if (lam == 0) {\\n      if (n == 0) return 1.0;\\n      return 0.0;\\n    }\\n\\n    return Math.exp(n * Math.log(lam) - lnfactorial(n) - lam);\\n  }\\n\\n  cdfSingleValue(n, params) {\\n    if (n &lt; 0) return 0.0;\\n    if (n === Infinity) return 1.0;\\n\\n    let lam = params[0];\\n\\n    if (lam === 0) return 1.0;\\n\\n    return gammaincU(lam, n + 1, true);\\n  }\\n\\n  defaultXRange(params) {\\n    return super.ppf([0.001, 0.999], params)\\n  }\\n\\n  quantileSet(x, p) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n\\n    if (!Number.isInteger(x1)) {\\n      throw new Error(this.varName + &#x27; must be integer.&#x27;)\\n    }\\n    if (x1 &lt; 0) {\\n      throw new Error(&#x27;Must have &#x27; + this.varName + &#x27; \\u2265 0.&#x27;)\\n    }\\n\\n    \\n    if (x1 === 0 &amp;&amp; p1 === 1) return [[0.0], true];\\n\\n    \\n    const rootFun = (xi) =&gt; {\\n      if (xi === 1) return p1;\\n      return p1 - this.cdfSingleValue(x1, [xi / (1 - xi)]);\\n    }\\n\\n    let xiOpt = brentSolve(rootFun, 0.0, 1.0);\\n    let optimSuccess = xiOpt != null;\\n    \\n    return [[xiOpt / (1 - xiOpt)], optimSuccess];\\n  }\\n\\n}\\n\\nfunction regularizedIncompleteBeta(x, a, b) {\\n    \\n    \\n    if (x &lt; 0 || x &gt; 1) {\\n        throw new RangeError(&#x27;First argument must be between 0 and 1.&#x27;);\\n    }\\n\\n    \\n    else if (a === 1 &amp;&amp; b === 1) return x;\\n    else if (x === 0) return 0;\\n    else if (x === 1) return 1;\\n    else if (a === 0) return 1;\\n    else if (b === 0) return 0;\\n\\n    else {\\n        var bt = Math.exp(lngamma(a + b) - lngamma(a) - lngamma(b) + a * Math.log(x) + b * log1p(-x));\\n\\n        \\n        if (x &lt; (a + 1) / (a + b + 2)) return bt * betacf(x, a, b) / a;\\n\\n        \\n        else return 1 - bt * betacf(1 - x, b, a) / b;\\n    }\\n}\\n\\n\\nfunction lngamma(z) {\\n\\n    if(z &lt; 0) return Number(&#x27;0/0&#x27;);\\n\\n    if (z &lt; 0.5) return Math.log(Math.PI) - Math.log(Math.sin(Math.PI * z)) - lngamma(1-z);\\n\\n    var p = [676.5203681218851,\\n             -1259.1392167224028,\\n             771.32342877765313,\\n             -176.61502916214059,\\n             12.507343278686905,\\n             -0.13857109526572012,\\n             9.9843695780195716e-6,\\n             1.5056327351493116e-7];\\n\\n    z -= 1.0;\\n    var Ag = 0.99999999999980993;\\n    for (var i = 0; i &lt; p.length; i++) {\\n        Ag += p[i] / (z + i + 1);\\n    }\\n    var t = z + p.length - 0.5;\\n\\n    return 0.5 * Math.log(2*Math.PI) + (z + 0.5)*Math.log(t) - t + Math.log(Ag);\\n}\\n\\n\\nfunction lnfactorial(n) {\\n  if (n &gt; 254) { \\n    let x = n + 1;\\n    return (x - 0.5) * Math.log(x) - x + 0.5 * Math.log(2 * Math.PI) + 1.0 / (12.0 * x);\\n  }\\n  else { \\n    const lnfact = [0.000000000000000,\\n                    0.000000000000000,\\n                    0.693147180559945,\\n                    1.791759469228055,\\n                    3.178053830347946,\\n                    4.787491742782046,\\n                    6.579251212010101,\\n                    8.525161361065415,\\n                    10.604602902745251,\\n                    12.801827480081469,\\n                    15.104412573075516,\\n                    17.502307845873887,\\n                    19.987214495661885,\\n                    22.552163853123421,\\n                    25.191221182738683,\\n                    27.899271383840894,\\n                    30.671860106080675,\\n                    33.505073450136891,\\n                    36.395445208033053,\\n                    39.339884187199495,\\n                    42.335616460753485,\\n                    45.380138898476908,\\n                    48.471181351835227,\\n                    51.606675567764377,\\n                    54.784729398112319,\\n                    58.003605222980518,\\n                    61.261701761002001,\\n                    64.557538627006323,\\n                    67.889743137181526,\\n                    71.257038967168000,\\n                    74.658236348830158,\\n                    78.092223553315307,\\n                    81.557959456115029,\\n                    85.054467017581516,\\n                    88.580827542197682,\\n                    92.136175603687079,\\n                    95.719694542143202,\\n                    99.330612454787428,\\n                    102.968198614513810,\\n                    106.631760260643450,\\n                    110.320639714757390,\\n                    114.034211781461690,\\n                    117.771881399745060,\\n                    121.533081515438640,\\n                    125.317271149356880,\\n                    129.123933639127240,\\n                    132.952575035616290,\\n                    136.802722637326350,\\n                    140.673923648234250,\\n                    144.565743946344900,\\n                    148.477766951773020,\\n                    152.409592584497350,\\n                    156.360836303078800,\\n                    160.331128216630930,\\n                    164.320112263195170,\\n                    168.327445448427650,\\n                    172.352797139162820,\\n                    176.395848406997370,\\n                    180.456291417543780,\\n                    184.533828861449510,\\n                    188.628173423671600,\\n                    192.739047287844900,\\n                    196.866181672889980,\\n                    201.009316399281570,\\n                    205.168199482641200,\\n                    209.342586752536820,\\n                    213.532241494563270,\\n                    217.736934113954250,\\n                    221.956441819130360,\\n                    226.190548323727570,\\n                    230.439043565776930,\\n                    234.701723442818260,\\n                    238.978389561834350,\\n                    243.268849002982730,\\n                    247.572914096186910,\\n                    251.890402209723190,\\n                    256.221135550009480,\\n                    260.564940971863220,\\n                    264.921649798552780,\\n                    269.291097651019810,\\n                    273.673124285693690,\\n                    278.067573440366120,\\n                    282.474292687630400,\\n                    286.893133295426990,\\n                    291.323950094270290,\\n                    295.766601350760600,\\n                    300.220948647014100,\\n                    304.686856765668720,\\n                    309.164193580146900,\\n                    313.652829949878990,\\n                    318.152639620209300,\\n                    322.663499126726210,\\n                    327.185287703775200,\\n                    331.717887196928470,\\n                    336.261181979198450,\\n                    340.815058870798960,\\n                    345.379407062266860,\\n                    349.954118040770250,\\n                    354.539085519440790,\\n                    359.134205369575340,\\n                    363.739375555563470,\\n                    368.354496072404690,\\n                    372.979468885689020,\\n                    377.614197873918670,\\n                    382.258588773060010,\\n                    386.912549123217560,\\n                    391.575988217329610,\\n                    396.248817051791490,\\n                    400.930948278915760,\\n                    405.622296161144900,\\n                    410.322776526937280,\\n                    415.032306728249580,\\n                    419.750805599544780,\\n                    424.478193418257090,\\n                    429.214391866651570,\\n                    433.959323995014870,\\n                    438.712914186121170,\\n                    443.475088120918940,\\n                    448.245772745384610,\\n                    453.024896238496130,\\n                    457.812387981278110,\\n                    462.608178526874890,\\n                    467.412199571608080,\\n                    472.224383926980520,\\n                    477.044665492585580,\\n                    481.872979229887900,\\n                    486.709261136839360,\\n                    491.553448223298010,\\n                    496.405478487217580,\\n                    501.265290891579240,\\n                    506.132825342034830,\\n                    511.008022665236070,\\n                    515.890824587822520,\\n                    520.781173716044240,\\n                    525.679013515995050,\\n                    530.584288294433580,\\n                    535.496943180169520,\\n                    540.416924105997740,\\n                    545.344177791154950,\\n                    550.278651724285620,\\n                    555.220294146894960,\\n                    560.169054037273100,\\n                    565.124881094874350,\\n                    570.087725725134190,\\n                    575.057539024710200,\\n                    580.034272767130800,\\n                    585.017879388839220,\\n                    590.008311975617860,\\n                    595.005524249382010,\\n                    600.009470555327430,\\n                    605.020105849423770,\\n                    610.037385686238740,\\n                    615.061266207084940,\\n                    620.091704128477430,\\n                    625.128656730891070,\\n                    630.172081847810200,\\n                    635.221937855059760,\\n                    640.278183660408100,\\n                    645.340778693435030,\\n                    650.409682895655240,\\n                    655.484856710889060,\\n                    660.566261075873510,\\n                    665.653857411105950,\\n                    670.747607611912710,\\n                    675.847474039736880,\\n                    680.953419513637530,\\n                    686.065407301994010,\\n                    691.183401114410800,\\n                    696.307365093814040,\\n                    701.437263808737160,\\n                    706.573062245787470,\\n                    711.714725802289990,\\n                    716.862220279103440,\\n                    722.015511873601330,\\n                    727.174567172815840,\\n                    732.339353146739310,\\n                    737.509837141777440,\\n                    742.685986874351220,\\n                    747.867770424643370,\\n                    753.055156230484160,\\n                    758.248113081374300,\\n                    763.446610112640200,\\n                    768.650616799717000,\\n                    773.860102952558460,\\n                    779.075038710167410,\\n                    784.295394535245690,\\n                    789.521141208958970,\\n                    794.752249825813460,\\n                    799.988691788643450,\\n                    805.230438803703120,\\n                    810.477462875863580,\\n                    815.729736303910160,\\n                    820.987231675937890,\\n                    826.249921864842800,\\n                    831.517780023906310,\\n                    836.790779582469900,\\n                    842.068894241700490,\\n                    847.352097970438420,\\n                    852.640365001133090,\\n                    857.933669825857460,\\n                    863.231987192405430,\\n                    868.535292100464630,\\n                    873.843559797865740,\\n                    879.156765776907600,\\n                    884.474885770751830,\\n                    889.797895749890240,\\n                    895.125771918679900,\\n                    900.458490711945270,\\n                    905.796028791646340,\\n                    911.138363043611210,\\n                    916.485470574328820,\\n                    921.837328707804890,\\n                    927.193914982476710,\\n                    932.555207148186240,\\n                    937.921183163208070,\\n                    943.291821191335660,\\n                    948.667099599019820,\\n                    954.046996952560450,\\n                    959.431492015349480,\\n                    964.820563745165940,\\n                    970.214191291518320,\\n                    975.612353993036210,\\n                    981.015031374908400,\\n                    986.422203146368590,\\n                    991.833849198223450,\\n                    997.249949600427840,\\n                    1002.670484599700300,\\n                    1008.095434617181700,\\n                    1013.524780246136200,\\n                    1018.958502249690200,\\n                    1024.396581558613400,\\n                    1029.838999269135500,\\n                    1035.285736640801600,\\n                    1040.736775094367400,\\n                    1046.192096209724900,\\n                    1051.651681723869200,\\n                    1057.115513528895000,\\n                    1062.583573670030100,\\n                    1068.055844343701400,\\n                    1073.532307895632800,\\n                    1079.012946818975000,\\n                    1084.497743752465600,\\n                    1089.986681478622400,\\n                    1095.479742921962700,\\n                    1100.976911147256000,\\n                    1106.478169357800900,\\n                    1111.983500893733000,\\n                    1117.492889230361000,\\n                    1123.006317976526100,\\n                    1128.523770872990800,\\n                    1134.045231790853000,\\n                    1139.570684729984800,\\n                    1145.100113817496100,\\n                    1150.633503306223700,\\n                    1156.170837573242400];\\n    return lnfact[n];\\n  }\\n}\\n\\n\\nfunction findRootTrustRegion(\\n\\t\\tf, \\n\\t\\tx0, \\n\\t\\targs=[],\\n\\t\\tjac=jacCentralDiff,\\n\\t\\ttol=0.000000001, \\n\\t\\tmaxIters=10000, \\n\\t\\tdeltaBar=1000.0, \\n\\t\\teta=0.125, \\n\\t\\tminDelta=1e-12\\n  ) {\\n\\t\\n\\tlet x = deepCopy(x0);\\n\\n\\t\\n\\tlet delta = 0.99 * deltaBar;\\n\\n\\t\\n\\tlet r = f(x, ...args);\\n\\n\\t\\n\\tlet J = jac(f, x, args);\\n\\n\\t\\n\\tlet JTJ = mmMult(transpose(J), J);\\n\\n\\t\\n\\tlet JTr = mvMult(transpose(J), r);\\n\\n\\t\\n\\tlet normJTr = norm(JTr);\\n\\n\\tlet iters = 0;\\n\\twhile (iters &lt; maxIters &amp;&amp; checkTol(r, tol) &amp;&amp; delta &gt;= minDelta) {\\n\\t\\t\\n\\t\\tlet p = doglegStep(JTJ, JTr, normJTr, delta);\\n\\n\\t\\t\\n\\t\\tlet newr = f(vectorAdd(x, p), ...args);\\n\\t\\tlet rho = computeRho(r, newr, J, p);\\n\\n\\t\\t\\n\\t\\tif  (rho &lt; 0.25) {\\n\\t\\t\\tdelta = norm(p) / 4.0;\\n\\t\\t} else if (rho &gt; 0.75 &amp;&amp; Math.abs(norm(p) - delta) &lt; 1e-12) {\\n\\t\\t\\t\\tdelta = Math.min(2 * delta, deltaBar);\\n\\t\\t}\\n\\n\\t\\t\\n\\t\\tif (rho &gt; eta) {\\n\\t\\t\\tx = vectorAdd(x, p);\\n\\n\\t\\t\\tr = newr;\\n\\t\\t\\tJ = jac(f, x, args);\\n\\t\\t\\tJTJ = mmMult(transpose(J), J);\\n\\t\\t\\tJTr = mvMult(transpose(J), r);\\n\\t\\t\\tnormJTr = norm(JTr);\\n\\t\\t}\\n\\n\\t\\titers += 1;\\n\\t}\\n\\n\\tlet success = !checkTol(r, tol);\\n\\n\\treturn [x, success];\\n\\n}\\n\\n\\nfunction bisectionSolve(f, lower, upper, args=[], tol=1e-8, maxIter=1000) {\\n\\t\\n  if (f(lower, ...args) * f(upper, ...args) &gt;= 0) return null;\\n\\n  let mid = lower;\\n  for (let i = 0; i &lt; maxIter; i++) {\\n    mid = (lower + upper) / 2;\\n    let fMid = f(mid, ...args);\\n\\n    if (fMid === 0 || (upper - lower) / 2 &lt; tol) return mid;\\n\\n    if (fMid * f(lower, ...args) &gt; 0) lower = mid;\\n    else upper = mid;\\n  }\\n\\n  return mid;\\n}\\n\\n\\nfunction brentSolve(f, lower, upper, args=[], tol=1e-8, maxIter=1000) {\\n\\tlet a = lower;\\n\\tlet b = upper;\\n  let fa = f(a, ...args);\\n  let fb = f(b, ...args);\\n\\n  \\n  if (Math.abs(fa) &lt; tol) return a;\\n  if (Math.abs(fb) &lt; tol) return b;\\n\\n  \\n  if (fa * fb &gt;= 0) {\\n  \\treturn null;\\n\\t}\\n\\n  \\n  let c = a;\\n  let fc = fa;\\n\\n\\tlet iter = 0;\\n  while (iter++ &lt; maxIter) {\\n  \\tlet prevStep = b - a;\\n\\n    \\n    if (Math.abs(fc) &lt; Math.abs(fb)) {      \\n    \\t[a, b, c] = [b, c, b];\\n    \\t[fa, fb, fc] = [fb, fc, fb];\\n    }\\n\\n    \\n    let newStep = (c - b) / 2.0;\\n\\n    \\n    let tolAdj = 1e-15 * Math.abs(b) + tol / 2;\\n\\n    \\n  \\tif (Math.abs(newStep) &lt;= tolAdj || fb === 0 ) {\\n    \\t\\treturn b;\\n  \\t}\\n\\n    \\n    if (Math.abs(prevStep) &gt; tolAdj &amp;&amp; Math.abs(fa) &gt; Math.abs(fb)) {\\n    \\tlet p;\\n    \\tlet q;\\n    \\tlet t1;\\n    \\tlet t2;\\n    \\tlet cb = c - b;\\n    \\tif (a === c) { \\n    \\t\\tt1 = fb / fa;\\n    \\t\\tp = cb * t1;\\n    \\t\\tq = 1.0 - t1;\\n    \\t}\\n    \\telse { \\n    \\t\\tq = fa / fc;\\n    \\t\\tt1 = fb / fc;\\n    \\t\\tt2 = fb / fa;\\n    \\t\\tp = t2 * (cb * q * (q - t1) - (b - a) * (t1 - 1.0));\\n    \\t\\tq = (q - 1.0) * (t1 - 1.0) * (t2 - 1.0);\\n    \\t}\\n\\n    \\t\\n    \\tif (p &gt; 0) q = -q;\\n    \\telse p = -p;\\n\\n    \\t\\n    \\tif (p &lt; (0.75 * cb * q - Math.abs(tolAdj * q) / 2.0) \\n    \\t\\t&amp;&amp; p &lt; Math.abs(prevStep * q / 2.0)) { \\n\\t        newStep = p / q;\\n      \\t}\\n    }\\n\\n    if (Math.abs(newStep) &lt; tolAdj) {\\n      newStep = (newStep &gt; 0) ? tolAdj : -tolAdj;\\n    }\\n\\n    \\n    a = b;\\n    fa = fb;\\n\\n    \\n    b += newStep;\\n    fb = f(b, ...args);\\n\\n\\t\\n    if ((fb &gt; 0 &amp;&amp; fc &gt; 0) || (fb &lt; 0 &amp;&amp; fc &lt; 0)) {\\n      c = a; \\n      fc = fa;\\n    }\\n  }\\n\\n  \\n  return null;\\n}\\n\\n\\nfunction lnchoice(n, k) {\\n    return lnfactorial(n) - lnfactorial(n-k) - lnfactorial(k);\\n}\\n\\n\\nfunction log1p(x) {\\n  \\n  \\n  if (x &lt;= -1.0) {\\n    throw new RangeError(&#x27;Argument must be greater than -1.0&#x27;);\\n  }\\n\\n  \\n  else if (Math.abs(x) &gt; 1e-4) {\\n    return Math.log(1.0 + x);\\n  }\\n\\n  else {\\n    return (-0.5*x + 1.0)*x;\\n  }\\n}\\n\\n\\nfunction betacf(x, a, b) {\\n    \\n    \\n    var fpmin = 1e-30,\\n        m = 1,\\n        m2, aa, c, d, del, h, qab, qam, qap;\\n    \\n    qab = a + b;\\n    qap = a + 1;\\n    qam = a - 1;\\n    c = 1;\\n    d = 1 - qab * x / qap;\\n    if (Math.abs(d) &lt; fpmin) d = fpmin;\\n    d = 1 / d;\\n    h = d;\\n    for (; m &lt;= 100; m++) {\\n        m2 = 2 * m;\\n        aa = m * (b - m) * x / ((qam + m2) * (a + m2));\\n        \\n        d = 1 + aa * d;\\n        if (Math.abs(d) &lt; fpmin) d = fpmin;\\n        c = 1 + aa / c;\\n        if (Math.abs(c) &lt; fpmin) c = fpmin;\\n        d = 1 / d;\\n        h *= d * c;\\n        aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));\\n        \\n        d = 1 + aa * d;\\n        if (Math.abs(d) &lt; fpmin) d = fpmin;\\n        c = 1 + aa / c;\\n        if (Math.abs(c) &lt; fpmin) c = fpmin;\\n        d = 1 / d;\\n        del = d * c;\\n        h *= del;\\n        if (Math.abs(del - 1.0) &lt; 3e-7) break;\\n    }\\n    return h;\\n}\\n\\n\\nfunction isclose(x, y, rtol = 1.0e-7, atol = 1.0e-8) {\\n  return Math.abs(x - y) &lt;= (atol + rtol * Math.abs(y));\\n}\\n\\n\\nfunction gammaincU(x, s, regularized) {\\n\\n  var EPSILON = 1e-12;\\n\\n  if (x &lt;= 1.1 || x &lt;= s) {\\n    if (regularized !== false) {\\n      return 1 - gammaincL(x, s, regularized);\\n    } else {\\n      return Math.exp(lngamma(s)) - gammaincL(x, s, regularized);\\n    }\\n  }\\n\\n  var f = 1 + x - s,\\n    C = f,\\n    D = 0,\\n    i = 1,\\n    a, b, chg;\\n  for (i = 1; i &lt; 10000; i++) {\\n    a = i * (s - i);\\n    b = (i&lt;&lt;1) + 1 + x - s;\\n    D = b + a * D;\\n    C = b + a / C;\\n    D = 1 / D;\\n    chg = C * D;\\n    f *= chg;\\n    if (Math.abs(chg - 1) &lt; EPSILON) {\\n      break;\\n    }\\n  }\\n  if (regularized !== false) {\\n    return Math.exp(s * Math.log(x) - x - lngamma(s) - Math.log(f));\\n  } else {\\n    return Math.exp(s * Math.log(x) - x - Math.log(f));\\n  }\\n}\\n\\n\\nfunction transpose(A) {\\n    return A[0].map((_, colIndex) =&gt; A.map(row =&gt; row[colIndex]));\\n}\\n\\n\\nfunction mvMult(A, v) {\\n  return A.map(Arow =&gt; dot(Arow, v));\\n}\\n\\n\\nfunction mmMult(A, B) {\\n  let mA = A.length;\\n  let nA = A[0].length;\\n  let mB = B.length;\\n  let nB = B[0].length;\\n\\n  if (nA !== mB) {\\n      throw new Error(&#x27;Matrix dimension mismatch.&#x27;);\\n  }\\n\\n  let result = zeros(mA, nB);\\n\\n  for (let i = 0; i &lt; mA; i++) {\\n    for (let j = 0; j &lt; nB; j++) {\\n      for (let k = 0; k &lt; nA; k++) {\\n        result[i][j] += A[i][k] * B[k][j];\\n      }\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction vectorAdd() {\\n  let m = arguments.length;\\n  let n = arguments[0].length;\\n \\n  let result = new Array(n).fill(0.0);\\n \\n  for (let i = 0; i &lt; n; i++) {\\n    for (let j = 0; j &lt; m; j++) {\\n        result[i] += arguments[j][i];\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction norm(v) {\\n  return Math.sqrt(dot(v, v));\\n}\\n\\n\\nfunction deepCopy(x) {\\n  return JSON.parse(JSON.stringify(x));\\n}\\n\\n\\nfunction computeRho(r, newr, J, p) {\\n\\tlet r2 = norm(r) ** 2;\\n\\tlet num = r2 - norm(newr)**2;\\n\\tlet denom = r2 - norm(vectorAdd(r, mvMult(J, p))) ** 2;\\n\\n\\treturn num / denom;\\n}\\n\\n\\nfunction checkTol(r, tol) {\\n\\t\\n\\tconst n = r.length;\\n\\tfor (let i = 0; i &lt; n; i++) {\\n\\t\\tif (tol &lt; Math.abs(r[i])) return true;\\n\\t}\\n\\n\\treturn false;\\n}\\n\\n\\nfunction doglegStep(JTJ, JTr, normJTr, delta) {\\n\\t\\n\\tlet [pJ, posDef] = solvePosDef(JTJ, JTr);\\n\\tpJ = svMult(-1.0, pJ);\\n\\n\\t\\n\\tif (posDef &amp;&amp; norm(pJ) &lt;= delta) {\\n\\t\\treturn pJ;\\n\\t}\\n\\n\\t\\n\\tlet tau = Math.min(1, normJTr**3 / delta / quadForm(JTJ, JTr));\\n\\tlet pC = svMult(-tau * delta / normJTr, JTr);\\n\\n\\tlet pCnorm = norm(pC);\\n\\tif (!posDef || Math.abs(pCnorm - delta) &lt;= 1e-12) {\\n\\t\\treturn pC;\\n\\t}\\n\\n\\t\\n\\tlet pJ2 = norm(pJ) ** 2;\\n\\tlet pC2 = pCnorm**2;\\n\\tlet pJpC = dot(pJ, pC);\\n\\tlet a = pJ2 + pC2 - 2.0 * pJpC;\\n\\tlet b = 2.0 * (pJpC - pC2);\\n\\tlet c = pC2 - delta**2;\\n\\tlet q = -0.5 * (b + Math.sign(b) * Math.sqrt(b**2 - 4.0 * a * c));\\n\\n\\t\\n\\tlet beta;\\n\\tif (Math.abs(b) &lt; 1e-12) beta = Math.sqrt(-c / a);\\n\\telse if (b &lt; 0.0) beta = q / a;\\n\\telse beta = c / q;\\n\\n\\t\\n\\tif (0.0 &lt;= beta &amp;&amp; beta &lt;= 1) {\\n\\t\\treturn vectorAdd(pC, svMult(beta, vectorAdd(pJ, svMult(-1.0, pC))));\\n\\t} else { \\n\\t\\treturn pC;\\n\\t}\\n\\n}\\n\\n\\nfunction jacCentralDiff(f, x, args=[], eps=4.7e-6) {\\n\\t\\n\\tlet xPlus = deepCopy(x);\\n\\tlet xMinus = deepCopy(x);\\n\\n\\t\\n\\tlet fOfx = f(x, ...args);\\n\\tlet m = fOfx.length;\\n\\n\\t\\n\\tlet n = x.length;\\n\\n\\t\\n\\tlet J = zeros(m, n);\\n\\n\\t\\n\\tlet fOfxPlus;\\n\\tlet fOfxMinus;\\n\\n\\tfor (let j = 0; j &lt; n; j++) {\\n\\t\\txPlus[j] += eps;\\n\\t\\txMinus[j] -= eps;\\n\\t\\tfOfxPlus = f(xPlus, ...args);\\n\\t\\tfOfxMinus = f(xMinus, ...args);\\n\\t\\txPlus[j] -= eps;\\n\\t\\txMinus[j] += eps;\\n\\n\\t\\tfor (let i = 0; i &lt; m; i++) {\\n\\t\\t\\tJ[i][j] = (fOfxPlus[i] - fOfxMinus[i]) / 2.0 / eps;\\n\\t\\t}\\n\\t}\\n\\n\\treturn J;\\n}\\n\\n\\nfunction gammaincL(x, s, regularized) {\\n\\n  var EPSILON = 1e-12;\\n\\n  if (x === 0) {\\n    return 0;\\n  }\\n  if (x &lt; 0 || s &lt;= 0) {\\n    return NaN;\\n  }\\n\\n  if (x &gt; 1.1 &amp;&amp; x &gt; s) {\\n    if (regularized !== false) {\\n      return 1 - gammaincU(x, s, regularized);\\n    } else {\\n      return Math.exp(lngamma(s)) - gammaincU(x, s, regularized);\\n    }\\n  }\\n\\n  var ft,\\n    r = s,\\n    c = 1,\\n    pws = 1;\\n\\n  if (regularized !== false) {\\n    ft = s * Math.log(x) - x - lngamma(s);\\n  } else {\\n    ft = s * Math.log(x) - x;\\n  }\\n  ft = Math.exp(ft);\\n  do {\\n    r += 1;\\n    c *= x/r;\\n    pws += c;\\n  } while (c / pws &gt; EPSILON);\\n\\n  return pws * ft / s;\\n}\\n\\n\\nfunction dot(v1, v2) {\\n  const n = v1.length;\\n  let result = 0.0;\\n  for (let i = 0; i &lt; n; i++) result += v1[i] * v2[i];\\n\\n  return result;\\n}\\n\\n\\nfunction zeros(...dims) {\\n  let A = [];\\n\\n  \\n  for (let i = dims.length - 1; i &gt;= 0; i--) {\\n    let size = dims[i];\\n    if (i === dims.length - 1) {\\n      \\n      A = new Array(size).fill(0.0);\\n    } else {\\n      \\n      A = new Array(size).fill().map(() =&gt; deepCopy(A));\\n    }\\n  }\\n\\n  return A;\\n}\\n\\n\\nfunction svMult(a, v) {\\n  return v.map(x =&gt; a * x);\\n}\\n\\n\\nfunction quadForm(A, x) {\\n   return dot(x, mvMult(A, x)); \\n}\\n\\n\\nfunction solvePosDef(A, b) {\\n  let [L, p, success] = modifiedCholesky(A);\\n\\n  if (!success) {\\n    return [zeros(b.length), success];\\n  }\\n\\n  return [modifiedCholeskySolve(L, p, b), success];\\n}\\n\\n\\nfunction modifiedCholesky(A) {\\n    const floatEps = 1.0e-14;\\n    const n = A.length;\\n\\n    \\n    let L = deepCopy(A); \\n    let p = arange(0, n);\\n\\n    \\n    let success = true;\\n\\n    let xi = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        for (let j = 0; j &lt; i; j++) {\\n            let temp = Math.abs(L[i][j]);\\n            xi = Math.max(xi, temp);\\n        }\\n    }\\n\\n    let eta = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        let temp = Math.abs(L[i][i]);\\n        eta = Math.max(eta, temp);\\n    }\\n\\n    let beta;\\n    if (n &gt; 1) {\\n        beta = Math.sqrt(Math.max(eta, xi / Math.sqrt(n * n - 1)));\\n    } else {\\n        beta = Math.sqrt(eta);\\n    }\\n    beta = Math.max(beta, floatEps);\\n\\n    for (let k = 0; k &lt; n; k++) {\\n        \\n        let muVal = L[k][k];\\n        let mu = k;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            let temp = L[i][i];\\n            if (muVal &lt; temp) {\\n                mu = i;\\n                muVal = temp;\\n            }\\n        }\\n\\n        \\n        let iTemp = p[mu];\\n        p[mu] = p[k];\\n        p[k] = iTemp;\\n\\n        for (let i = 0; i &lt; k; i++) {\\n            let temp = L[k][i];\\n            L[k][i] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        let temp = L[k][k];\\n        L[k][k] = L[mu][mu];\\n        L[mu][mu] = temp;\\n        for (let i = k + 1; i &lt; mu; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        for (let i = mu + 1; i &lt; n; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[i][mu];\\n            L[i][mu] = temp;\\n        }\\n\\n        \\n        let cSum = 0;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            cSum = Math.max(cSum, Math.abs(L[i][k]));\\n        }\\n        cSum /= beta;\\n        cSum = cSum * cSum;\\n\\n        \\n        if (L[k][k] &lt; 0) {\\n            success = false;\\n        }\\n\\n        temp = Math.abs(L[k][k]);\\n        temp = Math.max(temp, floatEps * eta);\\n        temp = Math.max(temp, cSum);\\n        L[k][k] = Math.sqrt(temp);\\n\\n        \\n        for (let i = k + 1; i &lt; n; i++) {\\n            L[i][k] /= L[k][k];\\n        }\\n\\n        \\n        for (let j = k + 1; j &lt; n; j++) {\\n            for (let i = j; i &lt; n; i++) {\\n                L[i][j] -= L[i][k] * L[j][k];\\n            }\\n        }\\n\\n        \\n        for (let i = 0; i &lt; n - 1; i++) {\\n            for (let j = i + 1; j &lt; n; j++) {\\n                L[i][j] = 0.0;\\n            }\\n        }\\n    }\\n\\n    return [L, p, success];\\n}\\n\\n\\nfunction modifiedCholeskySolve(L, p, b) {\\n    const n = L.length;\\n\\n    let U = transpose(L);\\n    let xp = new Array(n).fill(0);\\n    for (let i = 0; i &lt; n; i++) {\\n        xp[i] = b[p[i]];\\n    }\\n\\n    \\n    let x = lowerTriSolve(L, xp);\\n\\n    \\n    xp = upperTriSolve(U, x);\\n\\n    for (let i = 0; i &lt; n; i++) {\\n        x[p[i]] = xp[i];\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction lowerTriSolve(L, b) {\\n    const floatEps = 1.0e-14;\\n    const n = L.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = 0; j &lt; n - 1; j++) {\\n        if (Math.abs(L[j][j]) &gt; floatEps) {\\n            x[j] /= L[j][j];\\n            for (let i = j + 1; i &lt; n; i++) {\\n                x[i] -= x[j] * L[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(L[n - 1][n - 1]) &gt; floatEps) {\\n            x[n - 1] /= L[n - 1][n - 1];\\n        } else {\\n            x[n - 1] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction upperTriSolve(U, b) {\\n    const floatEps = 1.0e-14;\\n    const n = U.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = n - 1; j &gt; 0; j--) {\\n        if (Math.abs(U[j][j]) &gt; floatEps) {\\n            x[j] /= U[j][j];\\n            for (let i = 0; i &lt; j; i++) {\\n                x[i] -= x[j] * U[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(U[0][0]) &gt; floatEps) {\\n            x[0] /= U[0][0];\\n        } else {\\n            x[0] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nclass NegativeBinomialDistribution extends DiscreteUnivariateDistribution {\\n  constructor(parametrization = &#x27;alpha-beta&#x27;, fixedParam = undefined) {\\n    super(parametrization);\\n\\n    \\n    this.name = &#x27;NegativeBinomial&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    if (this.parametrization === &#x27;alpha-beta&#x27;) {\\n      this.paramNames = [&#x27;\\u03b1&#x27;, &#x27;\\u03b2&#x27;];\\n      this.paramMin = [0.0, 0.0];\\n      this.paramMax = [Infinity, Infinity];\\n      if (fixedParam === undefined) this.fixedParams = [&#x27;\\u03b1&#x27;];\\n      else this.fixedParams = [fixedParam];\\n    } else if (this.parametrization === &#x27;mu-phi&#x27;) {\\n      this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03c6&#x27;];\\n      this.paramMin = [0.0, 0.0];\\n      this.paramMax = [Infinity, Infinity];\\n      if (fixedParam === undefined) this.fixedParams = [&#x27;\\u03c6&#x27;];\\n      else this.fixedParams = [fixedParam];\\n    } else if (this.parametrization === &#x27;alpha-p&#x27;) {\\n      this.paramNames = [&#x27;\\u03b1&#x27;, &#x27;p&#x27;];\\n      this.paramMin = [0.0, 0.0];\\n      this.paramMax = [Infinity, 1.0];\\n      if (fixedParam === undefined) this.fixedParams = [&#x27;\\u03b1&#x27;];\\n      else this.fixedParams = [fixedParam];\\n    } else if (this.parametrization === &#x27;r-b&#x27;) {\\n      this.paramNames = [&#x27;r&#x27;, &#x27;b&#x27;];\\n      this.paramMin = [0.0, 0.0];\\n      this.paramMax = [Infinity, Infinity];\\n      if (fixedParam === undefined) this.fixedParams = [&#x27;r&#x27;];\\n      else this.fixedParams = [fixedParam];\\n    } else { \\n      this.paramNames = [&#x27;unnamedParam1&#x27;, &#x27;unnamedParam2&#x27;];\\n      this.paramMin = [0.0, 0.0];\\n      this.paramMax = [Infinity, Infinity];\\n      if (fixedParam === undefined) this.fixedParams = [&#x27;unnamedParam1&#x27;];\\n      else this.fixedParams = [fixedParam];\\n    }\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  convertParams(params, from = this.parametrization, to = &#x27;alpha-beta&#x27;) {\\n    if (from === to) return params;\\n    else if (to === &#x27;alpha-beta&#x27;) return this.convertParamsToAlphaBeta(params, from);\\n    else if (from === &#x27;alpha-beta&#x27;) return this.convertParamsFromAlphaBeta(params, to);\\n    else return this.convertParamsFromAlphaBeta(this.convertParamsToAlphaBeta(params, from), to);\\n  }\\n\\n  convertParamsToAlphaBeta(params, from = this.parametrization) {\\n    \\n    let alpha, beta;\\n\\n    if (from === &#x27;mu-phi&#x27;) {\\n      let [mu, phi] = params.slice(0, 2);\\n      alpha = phi;\\n      beta = alpha / mu;\\n    } else if (from === &#x27;alpha-p&#x27;) {\\n      let [a, p] = params.slice(0, 2);\\n      alpha = a;\\n      beta = p / (1 - p);\\n    } else if (from === &#x27;r-b&#x27;) {\\n      let [r, b] = params.slice(0, 2);\\n      alpha = r;\\n      beta = 1 / b;\\n    } else if (from === &#x27;alpha-beta&#x27;) {\\n      [alpha, beta] = params.slice(0, 2);\\n    } else {\\n      throw new Error(&#x27;Invalid parametrization for converting. Allowed values are alpha-beta, mu-phi, alpha-p, and r-b.&#x27;);\\n    }\\n\\n    return [alpha, beta];\\n  }\\n\\n  convertParamsFromAlphaBeta(params, to = this.parametrization) {\\n    \\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    let output;\\n    if (to === &#x27;mu-phi&#x27;) {\\n      let mu = alpha / beta;\\n      let phi = alpha;\\n      output = [mu, phi];\\n    } else if (to === &#x27;alpha-p&#x27;) {\\n      let a = alpha;\\n      let p = beta / (1 + beta);\\n      output = [a, p];\\n    } else if (to === &#x27;r-b&#x27;) {\\n      let r = alpha;\\n      let b = 1 / beta;\\n      output = [r, b];\\n    } else if (to === &#x27;alpha-beta&#x27;) {\\n      output = [alpha, beta];\\n    } else {\\n      throw new Error(&#x27;Invalid parametrization for converting. Allowed values are alpha-beta, mu-phi, alpha-p, and r-b.&#x27;);\\n    }\\n\\n    return output;\\n  }\\n\\n  pmfSingleValue(y, params, parametrization = this.parametrization) {\\n    if (y &lt; 0) return NaN;\\n\\n    \\n    let [alpha, beta] = this.convertParamsToAlphaBeta(params, parametrization);\\n\\n    if (alpha &lt;= 0 || beta &lt;= 0) return NaN;\\n\\n    return Math.exp(lngamma(y + alpha)\\n                    - lngamma(alpha)\\n                    - lnfactorial(y)\\n                    + alpha * Math.log(beta / (1 + beta))\\n                    - y * Math.log(1 + beta));\\n  }\\n\\n  cdfSingleValue(y, params, parametrization = this.parametrization) {\\n    let [alpha, beta] = this.convertParamsToAlphaBeta(params, parametrization);\\n\\n    if (alpha === 0 || beta === Infinity) return 1.0;\\n    if (alpha === Infinity) return y === Infinity ? 1.0 : 0.0; \\n\\n    if (y &lt;= 0) return 0.0;\\n    if (y === Infinity) return 1.0;\\n\\n    return regularizedIncompleteBeta(beta / (1 + beta), alpha, y + 1);\\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    let [x1, x2] = super.ppf([0.001, 0.999], this.convertParamsToAlphaBeta(params, parametrization));\\n\\n    \\n    if (x1 &lt; (x2 - x1) / 10.0) x1 = -1.0;\\n\\n    return [x1, x2];\\n  }\\n\\n  \\n  quantileSet(x, p, extraParams) {\\n    if (this.fixedParams.length != 1) {\\n      throw new Error(&#x27;Must have exactly one fixed parameter.&#x27;)\\n    }\\n\\n    let x1 = x[0];\\n    let p1 = p[0];\\n    let otherParam = extraParams[0];\\n\\n    if (!Number.isInteger(x1)) {\\n      throw new Error(this.varName + &#x27; must be integer.&#x27;)\\n    }\\n    if (x1 &lt; 0 ) {\\n      throw new Error(&#x27;Must have &#x27; + this.varName + &#x27; &gt; 0.&#x27;)\\n    }\\n\\n    const rootFun = (xi, x1, p1) =&gt; {\\n      if (this.fixedParamsInds[0] === 0) {\\n        return p1 - this.cdfSingleValue(x1, [otherParam, xi / (1 - xi)], this.parametrization);\\n      } else {\\n        return p1 - this.cdfSingleValue(x1, [xi / (1 - xi), otherParam], this.parametrization);        \\n      }\\n    }\\n\\n    let xiOpt = brentSolve(rootFun, 0.0, 1.0, [x1, p1]);\\n    let optimSuccess = xiOpt != null;\\n    \\n    return [[xiOpt / (1 - xiOpt)], optimSuccess];\\n  }\\n\\n  quantileSetBoth(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    if (!Number.isInteger(x1) || !Number.isInteger(x2)) {\\n      throw new Error(this.varName + &#x27; must be integer.&#x27;)\\n    }\\n    if (x1 &lt; 0 || x2 &lt; 0) {\\n      throw new Error(&#x27;Must have &#x27; + this.varName + &#x27; &gt; 0.&#x27;)\\n    }\\n\\n    const quantileRootFun = (params, x1, p1, x2, p2) =&gt; {\\n      let mu = Math.exp(params[0]);\\n      let phi = Math.exp(params[1]);\\n\\n      let r1 = this.cdfSingleValue(x1, [mu, phi], &#x27;mu-phi&#x27;) - p1;\\n      let r2 = this.cdfSingleValue(x2, [mu, phi], &#x27;mu-phi&#x27;) - p2;\\n\\n      return [r1, r2];\\n    };\\n\\n    \\n    let meanp = (p1 + p2) / 2;\\n    let muGuess;\\n    if (Math.abs(meanp - 0.5) &lt; 0.2) {\\n      let meanx = (x1 + x2) / 2;\\n      muGuess = meanx;\\n    }\\n    else {\\n      muGuess = 1.0;\\n    }\\n\\n    let args = [x1, p1, x2, p2];\\n    let guess = [Math.log(muGuess), 1.0];\\n    let [logParams, optimSuccess] = findRootTrustRegion(quantileRootFun, guess, args=args);\\n\\n    let paramsOpt;\\n    if (optimSuccess) {\\n      let muOpt = Math.exp(logParams[0]);\\n      let phiOpt = Math.exp(logParams[1]);\\n\\n      \\n      if (phiOpt &gt; 1) {\\n\\n        \\n        const muGivenPhi = (phi, x, p) =&gt; {\\n          dist = new NegativeBinomialDistribution(&#x27;mu-phi&#x27;);\\n\\n          \\n          const rootFun = (xi, phi, x, p) =&gt; { \\n            if (xi === 1) return p;\\n            if (xi === 0) return p - 1;\\n            return p - this.cdfSingleValue(x, [xi / (1 - xi), phi], &#x27;mu-phi&#x27;);\\n          }\\n\\n          let xiOpt = brentSolve(rootFun, 0.0, 1.0, [phi, x, p]);\\n          let optimSuccess = xiOpt != null;\\n          \\n          return [xiOpt / (1 - xiOpt), optimSuccess];\\n        }\\n\\n        const hitQuantiles = (phi, x1, p1, x2, p2) =&gt; {\\n          let [muAdj, rootFindSuccess] = muGivenPhi(phi, x2, p2);\\n\\n          if (rootFindSuccess) {\\n            let [q1, q2] = this.ppf([p1, p2], [muAdj, phi], &#x27;mu-phi&#x27;);\\n\\n            if (q1 === x1 &amp;&amp; q2 === x2) return 1;\\n            else return -1;\\n          } else {\\n            return -1;\\n          }\\n        } \\n\\n        if (hitQuantiles(1.0) === 1) {\\n          phiOpt = 1.0;\\n          let [muAdj, rootFindSuccess] = muGivenPhi(phiOpt, x2, p2);\\n          muOpt = muAdj;\\n        }\\n        else {\\n          let phiAdj = bisectionSolve(hitQuantiles, 1.0, phiOpt, [x1, p1, x2, p2]);\\n          if (phiAdj != null) {\\n            phiOpt = phiAdj;\\n            let [muAdj, rootFindSuccess] = muGivenPhi(phiOpt, x2, p2);\\n            muOpt = muAdj;\\n          }\\n        }\\n      }\\n\\n      paramsOpt = this.convertParams([muOpt, phiOpt], &#x27;mu-phi&#x27;, this.parametrization);\\n    } else { \\n      let pois = new PoissonDistribution();\\n      let [paramsPois, optimSuccessPois] = pois.quantileSet([x2], [p2]);\\n\\n      if (optimSuccessPois) {\\n        let poisQuants = pois.ppf([p1, p2], paramsPois);\\n        if (poisQuants[0] === x1 &amp;&amp; poisQuants[1] === x2) {\\n          let errText;\\n          if (this.parametrization == &#x27;alpha-beta&#x27;|| this.parametrization == &#x27;alpha-p&#x27;) {\\n            errText = &#x27;Use Poisson (\\u03b1 \\u2192 \\u221e limit) with \\u03bb = &#x27; + paramsPois[0].toPrecision(4);\\n          }\\n          else if (this.parametrization == &#x27;mu-phi&#x27;) {\\n            errText = &#x27;Use Poisson (\\u03c6 \\u2192 \\u221e limit) with \\u03bb = &#x27; + paramsPois[0].toPrecision(4);\\n          }\\n          else if (this.parametrization == &#x27;r-b&#x27;) {\\n            errText = &#x27;Use Poisson (r \\u2192 \\u221e limit) with \\u03bb = &#x27; + paramsPois[0].toPrecision(4);\\n          }\\n          throw new Error(errText);\\n        }\\n        \\n      }\\n      paramsOpt = [];\\n    }\\n\\n    return [paramsOpt, optimSuccess];\\n  }\\n}\\n\\n\\n\\nvar dist = new NegativeBinomialDistribution();\\n\\n\\nif (triggerCallbacks.active) {\\n  updateData(source_p, source_c, p_p, sliders, discrete);\\n}"}}]],["change:end",[{"id":"p4730"}]]]},"end":50}},"y_range":{"type":"object","name":"DataRange1d","id":"p4635","attributes":{"start":0.0}},"x_scale":{"type":"object","name":"LinearScale","id":"p4643"},"y_scale":{"type":"object","name":"LinearScale","id":"p4644"},"title":{"type":"object","name":"Title","id":"p4636","attributes":{"text":"Negative Binomial"}},"renderers":[{"type":"object","name":"GlyphRenderer","id":"p4704","attributes":{"level":"overlay","data_source":{"id":"p4683"},"view":{"type":"object","name":"CDSView","id":"p4705","attributes":{"filter":{"type":"object","name":"AllIndices","id":"p4706"}}},"glyph":{"type":"object","name":"Scatter","id":"p4701","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"size":{"type":"value","value":5},"line_color":{"type":"value","value":"#1f77b4"},"fill_color":{"type":"value","value":"#1f77b4"}}},"nonselection_glyph":{"type":"object","name":"Scatter","id":"p4702","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"size":{"type":"value","value":5},"line_color":{"type":"value","value":"#1f77b4"},"line_alpha":{"type":"value","value":0.1},"fill_color":{"type":"value","value":"#1f77b4"},"fill_alpha":{"type":"value","value":0.1},"hatch_alpha":{"type":"value","value":0.1}}},"muted_glyph":{"type":"object","name":"Scatter","id":"p4703","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y_p"},"size":{"type":"value","value":5},"line_color":{"type":"value","value":"#1f77b4"},"line_alpha":{"type":"value","value":0.2},"fill_color":{"type":"value","value":"#1f77b4"},"fill_alpha":{"type":"value","value":0.2},"hatch_alpha":{"type":"value","value":0.2}}}}},{"type":"object","name":"GlyphRenderer","id":"p4713","attributes":{"level":"overlay","data_source":{"id":"p4683"},"view":{"type":"object","name":"CDSView","id":"p4714","attributes":{"filter":{"type":"object","name":"AllIndices","id":"p4715"}}},"glyph":{"type":"object","name":"Segment","id":"p4710","attributes":{"x0":{"type":"field","field":"x"},"y0":{"type":"value","value":0},"x1":{"type":"field","field":"x"},"y1":{"type":"field","field":"y_p"},"line_color":{"type":"value","value":"#1f77b4"},"line_width":{"type":"value","value":2}}},"nonselection_glyph":{"type":"object","name":"Segment","id":"p4711","attributes":{"x0":{"type":"field","field":"x"},"y0":{"type":"value","value":0},"x1":{"type":"field","field":"x"},"y1":{"type":"field","field":"y_p"},"line_color":{"type":"value","value":"#1f77b4"},"line_alpha":{"type":"value","value":0.1},"line_width":{"type":"value","value":2}}},"muted_glyph":{"type":"object","name":"Segment","id":"p4712","attributes":{"x0":{"type":"field","field":"x"},"y0":{"type":"value","value":0},"x1":{"type":"field","field":"x"},"y1":{"type":"field","field":"y_p"},"line_color":{"type":"value","value":"#1f77b4"},"line_alpha":{"type":"value","value":0.2},"line_width":{"type":"value","value":2}}}}}],"toolbar":{"type":"object","name":"Toolbar","id":"p4642","attributes":{"tools":[{"type":"object","name":"ResetTool","id":"p4655"},{"type":"object","name":"SaveTool","id":"p4656"}]}},"toolbar_location":null,"left":[{"type":"object","name":"LinearAxis","id":"p4650","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p4651","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p4652"},"axis_label":"PMF","axis_label_text_font_style":"normal","major_label_policy":{"type":"object","name":"AllLabels","id":"p4653"}}}],"below":[{"type":"object","name":"LinearAxis","id":"p4645","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p4646","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p4647"},"axis_label":"y","major_label_policy":{"type":"object","name":"AllLabels","id":"p4648"}}}],"center":[{"type":"object","name":"Grid","id":"p4649","attributes":{"axis":{"id":"p4645"}}},{"type":"object","name":"Grid","id":"p4654","attributes":{"dimension":1,"axis":{"id":"p4650"}}}],"frame_width":300,"frame_height":175,"background_fill_alpha":0,"border_fill_alpha":0}}],["p_c",{"id":"p4657"}],["source_p",{"id":"p4683"}],["source_c",{"id":"p4686"}],["discrete",true],["n",400],["sliders",[{"id":"p4717"},{"id":"p4719"}]],["xBoxes",[{"id":"p4724"}]],["pBoxes",[{"id":"p4725"}]],["quantileSetterSwitch",{"id":"p4727"}],["quantileSetterDiv",{"id":"p4726"}],["triggerCallbacks",{"id":"p4728"}],["startBoxes",[{"id":"p4720"},{"id":"p4721"}]],["endBoxes",[{"id":"p4722"},{"id":"p4723"}]]]},"code":"\\nfunction updateData(source_p, source_c, p_p, sliders, discrete) {\\n  if (discrete) {\\n    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n  else {\\n    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);\\n  }\\n}\\n\\n\\nfunction updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {\\n  if (!quantileSetterSwitch.active) {\\n    let params = paramsFromSliders(sliders);\\n\\n    for (let i = 0; i &lt; xBoxes.length; i++) {\\n      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);\\n    }\\n  }\\n}\\n\\n\\nfunction quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {\\n  \\n  triggerCallbacks.active = false;\\n\\n  \\n  let inputOk;\\n  try {\\n    var x = paramsFromBoxes(xBoxes);\\n    var p = paramsFromBoxes(pBoxes);\\n\\n    \\n    var params = paramsFromSliders(sliders);\\n\\n    \\n    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);\\n  } catch (e) {\\n    quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    inputOk = false;\\n  }\\n\\n  if (inputOk) {\\n    \\n    let extraParams = [];\\n    for (let i = 0; i &lt; dist.paramNames.length; i++) {\\n      if (dist.fixedParamsInds.includes(i)) {\\n        extraParams.push(params[i]);\\n      }\\n    }\\n\\n    \\n    let errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Failed to find parameters to match quantiles.&lt;/p&gt;&#x27;;\\n\\n    \\n    let optimParams, optimSuccess;\\n    try {\\n      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);\\n    } catch(e) {\\n      optimSuccess = false;\\n      errText = &#x27;&lt;p style=\\"color:tomato;\\"&gt;&#x27; + e.message; + &#x27;&lt;/p&gt;&#x27;;\\n    }\\n\\n    let text;\\n    if (optimSuccess) {\\n      \\n      text = &#x27;&lt;p&gt;&#x27;;\\n      for (let i = 0; i &lt; optimParams.length - 1; i++) {\\n        text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;, &#x27;;\\n      }\\n      let i = optimParams.length - 1;\\n      text += dist.paramNames[dist.activeParamsInds[i]] + &#x27; = &#x27; + optimParams[i].toPrecision(4) + &#x27;&lt;/p&gt;&#x27;;\\n    } else{\\n      text = errText;\\n    }\\n\\n    quantileSetterDiv.text = text;\\n\\n    if (optimSuccess) {\\n      \\n      let params = [];\\n      let aInd = 0;\\n      for (let i = 0; i &lt; sliders.length; i++) {\\n        if (dist.activeParamsInds.includes(i)) {\\n          params.push(optimParams[aInd]);\\n\\n          \\n          sliders[i].value = optimParams[aInd];\\n\\n          aInd += 1;\\n        } else { \\n          params.push(sliders[i].value);\\n        }\\n      }\\n\\n      \\n      for (let i = 0; i &lt; optimParams.length; i++ ) {\\n        if (sliders[dist.activeParamsInds[i]].start &gt; optimParams[i] || sliders[dist.activeParamsInds[i]].end &lt; optimParams[i]) {\\n          \\n          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] &lt; 0) {\\n            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;\\n            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);\\n          } else {\\n            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);\\n            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);\\n          }\\n        }\\n        \\n        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);\\n        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);\\n      }\\n\\n      \\n      let [x1, x2] = dist.defaultXRange(params);\\n\\n      p_p.x_range.start = x1;\\n      p_p.x_range.end = x2;\\n\\n      \\n      updateData(source_p, source_c, p_p, sliders, discrete);\\n\\n      \\n      setYRanges(p_p, p_c, source_p);  \\n    }\\n  }\\n\\n  \\n  triggerCallbacks.active = true;  \\n}\\n\\n\\nfunction updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let x_p = source_p.data[&#x27;x&#x27;];\\n  let y_p = source_p.data[&#x27;y_p&#x27;];\\n  let x_c = source_c.data[&#x27;x&#x27;];\\n  let y_c = source_c.data[&#x27;y_c&#x27;];\\n  let xRangeMin = xRange.start;\\n  let xRangeMax = xRange.end;\\n\\n  \\n  x_p = linspace(xRangeMin, xRangeMax, n);\\n  x_c = x_p;\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  let pdf = dist.pdf(x_p, params);\\n\\n  \\n  pdf = pdf.map(val =&gt; (val === Infinity || val === -Infinity) ? NaN : val);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = pdf;\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdf(x_c, params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {\\n  \\n  let xRangeMin = Math.ceil(xRange.start);\\n  let xRangeMax = Math.floor(xRange.end);\\n\\n  \\n  let x_p = arange(xRangeMin, xRangeMax + 1);\\n\\n  \\n  let x_c;\\n  if (Number.isInteger(xRange.start)) {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = x_p.flatMap(x =&gt; [x, x]);\\n    }\\n    else {\\n      x_c = [...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }\\n  }\\n  else {\\n    if (Number.isInteger(xRange.end)) {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x])];\\n    }\\n    else {\\n      x_c = [xRange.start, ...x_p.flatMap(x =&gt; [x, x]), xRange.end];\\n    }    \\n  }\\n\\n  \\n  source_p.data[&#x27;x&#x27;] = x_p;\\n  source_c.data[&#x27;x&#x27;] = x_c;\\n\\n  \\n  let params = paramsFromSliders(sliders);\\n\\n  \\n  source_p.data[&#x27;y_p&#x27;] = dist.pmf(x_p, params);\\n  source_c.data[&#x27;y_c&#x27;] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);\\n\\n  source_p.change.emit();\\n  source_c.change.emit();\\n}\\n\\n\\nfunction linspace(start, stop, n) {\\n  let x = new Array(n);\\n  let step = (stop - start) / (n - 1);\\n  for (let i = 0; i &lt; n; i++) {\\n    x[i] = start + i * step;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromSliders(sliders) {\\n  let params = [];\\n  for (let slider of sliders) {\\n    params.push(slider.value);\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction paramsFromBoxes(boxes) {\\n  let params = [];\\n  for (let box of boxes) {\\n    if (isNaN(box.value)) {\\n      throw new Error(box.value + &#x27; is not a valid number.&#x27;);\\n    }\\n    params.push(Number(box.value));\\n  }\\n\\n  return params;\\n}\\n\\n\\nfunction setYRanges(p_p, p_c, source_p) {\\n    p_c.y_range.start = 0.0;\\n    p_c.y_range.end = 1.0;        \\n\\n    let pdfMax = source_p.data[&#x27;y_p&#x27;];\\n    p_p.y_range.start = 0.0;\\n    p_p.y_range.end = 1.04 * pdfMax;\\n\\n}\\n\\n\\nfunction checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {\\n  for (let i = 0; i &lt; x.length; i++) {\\n    if (p[i] &lt;= 0 || p[i] &gt;= 1) {\\n      quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n      return false; \\n    }\\n\\n    if (x[i] &lt; xMin || x[i] &gt; xMax) {\\n      let qStr = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have &#x27; + xMin.toString() + &#x27; \\u2264 yy \\u2264 &#x27; + xMax.toString() + &#x27;.&lt;/p\\\\&gt;&#x27;;\\n      quantileSetterDiv.text = qStr.replace(/yy/g, varName);\\n      return false;\\n    }\\n  }\\n\\n\\n  if (p.length === 2) {\\n    if (p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower quantile must be less than upper quantile.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Lower yy must be less than upper yy.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;        \\n    }\\n  }\\n\\n  if (p.length === 3) {\\n    if (p[2] &lt;= 0 || p[2] &gt;= 1 || p[1] &lt;= 0 || p[1] &gt;= 1) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Must have 0 &lt; quantile &lt; 1.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (p[0] &gt;= p[1] || p[1] &gt;= p[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;Quantiles must be ordered lower, middle, upper.&lt;/p\\\\&gt;&#x27;;\\n        return false;\\n    }\\n\\n    if (x[0] &gt;= x[1] || x[1] &gt;= x[2]) {\\n        quantileSetterDiv.text = &#x27;&lt;p style=\\"color:tomato;\\"&gt;yy values must be ordered, lower, middle, upper.&lt;/p\\\\&gt;&#x27;.replace(/yy/g, varName);\\n        return false;\\n    }\\n  }\\n\\n    return true;\\n}\\n\\n\\nclass UnivariateDistribution {\\n  constructor(parametrization) {\\n    \\n    this.name = &#x27;&#x27;;\\n\\n    \\n    this.varName = &#x27;&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.p1Value = Infinity;\\n\\n    \\n    this.parametrization = parametrization\\n\\n    \\n    this.paramNames = [];\\n\\n    \\n    this.locationParam = undefined;\\n    this.locatonParamIndex = undefined;\\n\\n    \\n    this.paramMin = [];\\n\\n    \\n    this.paramMax = [];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    this.epsilon = 1.0e-8;\\n  }\\n\\n  generateLocationParamIndex() {\\n    if (this.locationParam === undefined) {\\n      this.locationParamInd = undefined;\\n    } else {\\n      this.locationParamInd = this.paramNames.indexOf(this.locationParam);\\n    }\\n  }\\n\\n  generateActiveFixedInds() {\\n    \\n    this.activeParamsInds = [];\\n    this.fixedParamsInds = []\\n    for (let i = 0; i &lt; this.paramNames.length; i++) {\\n      if (this.fixedParams.includes(this.paramNames[i])) {\\n        this.fixedParamsInds.push(i);\\n      } else {\\n        this.activeParamsInds.push(i);\\n      }\\n    }\\n  }\\n\\n  xMin(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  xMax(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  cdfSingleValue({x, params, parametrization = this.parametrization}) {\\n    \\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  quantileSet(x, p, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n\\n  cdf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.cdfSingleValue(x, params, parametrization),\\n      x,\\n      params\\n    );\\n  }\\n\\n  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) return NaN;\\n    return this.ppfSingleValue(p, params, parametrization);\\n  }\\n\\n  ppf(p, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (p, params) =&gt; this.ppfSingleValueWithCheck(p, params, parametrization),\\n      p,\\n      params\\n    );\\n  }\\n\\n  resetXRange(params, p, parametrization = this.parametrization) {\\n    if (p === undefined) {\\n      return this.defaultXRange(params, parametrization);\\n    } else if (this.checkResetp(p)) {\\n      return this.ppf(p, params, parametrization);\\n    }\\n  }\\n\\n  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {\\n    if (x instanceof Array) {\\n      let xLen = x.length;\\n\\n      let res = [];\\n      for (let i = 0; i &lt; xLen; i++) {\\n        res.push(func(x[i], params, parametrization));\\n      }\\n\\n      return res;\\n    } else {\\n      return func(x, params, parametrization);\\n    }\\n  }\\n\\n  scalarToArrayParams(params) {\\n    return params instanceof Array ? params : [params]\\n  }\\n}\\n\\nclass DiscreteUnivariateDistribution extends UnivariateDistribution {\\n  constructor(parametrization) {\\n    super(parametrization);\\n  }\\n\\n  pmfSingleValue(x, params, parametrization = this.parametrization) {\\n    \\n  }\\n\\n  pmf(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    return this.scalarOrArrayCompute(\\n      (x, params) =&gt; this.pmfSingleValue(x, params, parametrization),\\n      x,\\n      params);\\n  }\\n\\n  cdfSingleValue(x, params, parametrization = this.parametrization) {\\n    params = this.scalarToArrayParams(params);\\n\\n    \\n    let cumsum = 0.0;\\n    let summand = 0.0;\\n    for (let n = this.xMin(params, parametrization); n &lt;= x; n++) {\\n        summand = this.pmfSingleValue(n, params, parametrization);\\n        if (!isNaN(summand)) cumsum += summand;\\n    }\\n\\n    return cumsum;\\n  }\\n\\n  cdfForPlotting(xStart, xEnd, params, parametrization = this.parametrization) {\\n\\n    params = this.scalarToArrayParams(params);\\n\\n    \\n    let cumsum;\\n    let y_c;\\n    let prob;\\n    if (Number.isInteger(xStart)) {\\n      \\n      cumsum = this.cdfSingleValue(Math.floor(xStart) - 1, params, parametrization);\\n\\n      if (Number.isInteger(xEnd)) {\\n        y_c = [cumsum];\\n        for (let x = xStart; x &lt; xEnd; x++) {\\n          prob = this.pmfSingleValue(x, params, parametrization);\\n          if (!isNaN(prob)) cumsum += prob;\\n          y_c.push(cumsum, cumsum);\\n        }\\n        prob = this.pmfSingleValue(xEnd, params, parametrization);\\n        if (!isNaN(prob)) cumsum += prob;\\n        y_c.push(cumsum);\\n      }\\n      else {\\n        y_c = [cumsum];\\n        for (let x = xStart; x &lt;= Math.floor(xEnd); x++) {\\n          prob = this.pmfSingleValue(x, params, parametrization);\\n          if (!isNaN(prob)) cumsum += prob;\\n          y_c.push(cumsum, cumsum);\\n        }\\n      }\\n    }\\n    else {\\n      \\n      cumsum = this.cdfSingleValue(Math.floor(xStart), params, parametrization);\\n\\n      if (Number.isInteger(xEnd)) {\\n        y_c = [cumsum, cumsum];\\n        for (let x = Math.ceil(xStart); x &lt; xEnd; x++) {\\n          prob = this.pmfSingleValue(x, params, parametrization);\\n          if (!isNaN(prob)) cumsum += prob;\\n          y_c.push(cumsum, cumsum);\\n        }\\n        prob = this.pmfSingleValue(xEnd, params, parametrization);\\n        if (!isNaN(prob)) cumsum += prob;\\n        y_c.push(cumsum);        \\n      }\\n      else {\\n        y_c = [cumsum, cumsum];\\n        for (let x = Math.ceil(xStart); x &lt;= xEnd; x++) {\\n          prob = this.pmfSingleValue(x, params, parametrization);\\n          if (!isNaN(prob)) cumsum += prob;\\n          y_c.push(cumsum, cumsum);\\n        }\\n      }    \\n    }\\n\\n    return y_c;\\n  }\\n\\n  ppfSingleValue(p, params, parametrization = this.parametrization) {\\n    if (p &lt; 0 || p &gt; 1) throw new Error(&#x27;p must be between 0 and 1.&#x27;)\\n\\n    \\n    if (p == 0) return xMin(params, parametrization);\\n\\n    \\n    if (p == 1) return xMax(params, parametrization);\\n\\n    params = this.scalarToArrayParams(params);\\n\\n    \\n    let n = this.xMin(params, parametrization);\\n    let cumsum = this.pmfSingleValue(n, params, parametrization);\\n\\n    let iters = 0;\\n    let summand = 0.0;\\n    let xMaxForTheseParams = this.xMax(params, parametrization);\\n    while (cumsum &lt; p &amp;&amp; !isclose(cumsum, p) &amp;&amp; !isNaN(summand) &amp;&amp; n &lt; xMaxForTheseParams) {\\n      n += 1;\\n      summand = this.pmfSingleValue(n, params, parametrization);\\n\\n      if (!isNaN(summand)) cumsum += summand;\\n\\n      iters += 1;\\n    }\\n\\n    return n;\\n  }\\n\\n}\\n\\nclass BinomialDistribution extends DiscreteUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Binomial&#x27;;\\n\\n    \\n    this.varName = &#x27;n&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;N&#x27;, &#x27;\\u03b8&#x27;];\\n\\n    \\n    this.paramMin = [0, 0.0];\\n\\n    \\n    this.paramMax = [Infinity, 1.0];\\n\\n    \\n    this.fixedParams = [&#x27;N&#x27;];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0;\\n  }\\n\\n  xMax(params) {\\n    return params[0];\\n  }\\n\\n  pmfSingleValue(n, params) {\\n    let [N, theta] = params.slice(0, 2);\\n\\n    if (n &gt; N || n &lt; 0) return NaN;\\n\\n    if (theta == 0) {\\n      if (n == 0) return 1.0;\\n      return 0.0;\\n    }\\n\\n    if (theta == 1) {\\n      if (n == N) return 1.0;\\n      return 0.0;\\n    }\\n\\n    return Math.exp(lnchoice(N, n) +\\n      n * Math.log(theta) +\\n      (N - n) * Math.log(1 - theta));\\n  }\\n\\n  cdfSingleValue(n, params) {\\n    let [N, theta] = params.slice(0, 2);\\n\\n    if (n &lt; 0) return 0.0;\\n    if (n &gt;= N) return 1.0;\\n    return regularizedIncompleteBeta(1.0 - theta, N - n, n + 1);\\n  }\\n\\n  ppfSingleValue(p, params) {\\n    let [N, theta] = params.slice(0, 2);\\n    \\n    return super.ppfSingleValue(p, params, 0, N, N);\\n  }\\n\\n  defaultXRange(params) {\\n    let [N, theta] = params.slice(0, 2);\\n\\n    if (N &lt; 50) {\\n      return [-1, N + 1];\\n    } else {\\n      return this.ppf([0.001, 0.999], params);\\n    }\\n  }\\n\\n  quantileSet(x, p, extraParams) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n    let N = extraParams[0];\\n\\n    if (!Number.isInteger(x1)) {\\n      throw new Error(this.varName + &#x27; must be integer.&#x27;)\\n    }\\n    if (x1 &lt; 0) {\\n      throw new Error(&#x27;Must have &#x27; + this.varName + &#x27; &gt; 0.&#x27;)\\n    }\\n    if (x1 &gt;= N) {\\n      throw new Error(&#x27;Must have &#x27; + this.varName + &#x27; &lt; N.&#x27;)\\n    }\\n\\n    \\n    let rootFun = (theta, N) =&gt; p1 - this.cdfSingleValue(x1, [N, theta]);\\n\\n    let thetaOpt = brentSolve(rootFun, 0.0, 1.0, [N]);\\n    let optimSuccess = thetaOpt != null;\\n    \\n    return [[thetaOpt], optimSuccess];\\n  }\\n}\\n\\nclass PoissonDistribution extends DiscreteUnivariateDistribution {\\n  constructor() {\\n    super();\\n\\n    \\n    this.name = &#x27;Poisson&#x27;;\\n\\n    \\n    this.varName = &#x27;n&#x27;;  \\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    this.paramNames = [&#x27;\\u03bb&#x27;];\\n\\n    \\n    this.paramMin = [0.0];\\n\\n    \\n    this.paramMax = [Infinity];\\n\\n    \\n    this.fixedParams = [];\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  pmfSingleValue(n, params) {\\n    let lam = params[0];\\n\\n    if (lam &lt; 0) {\\n      return NaN;\\n    } else if (lam == 0) {\\n      if (n == 0) return 1.0;\\n      return 0.0;\\n    }\\n\\n    return Math.exp(n * Math.log(lam) - lnfactorial(n) - lam);\\n  }\\n\\n  cdfSingleValue(n, params) {\\n    if (n &lt; 0) return 0.0;\\n    if (n === Infinity) return 1.0;\\n\\n    let lam = params[0];\\n\\n    if (lam === 0) return 1.0;\\n\\n    return gammaincU(lam, n + 1, true);\\n  }\\n\\n  defaultXRange(params) {\\n    return super.ppf([0.001, 0.999], params)\\n  }\\n\\n  quantileSet(x, p) {\\n    let x1 = x[0];\\n    let p1 = p[0];\\n\\n    if (!Number.isInteger(x1)) {\\n      throw new Error(this.varName + &#x27; must be integer.&#x27;)\\n    }\\n    if (x1 &lt; 0) {\\n      throw new Error(&#x27;Must have &#x27; + this.varName + &#x27; \\u2265 0.&#x27;)\\n    }\\n\\n    \\n    if (x1 === 0 &amp;&amp; p1 === 1) return [[0.0], true];\\n\\n    \\n    const rootFun = (xi) =&gt; {\\n      if (xi === 1) return p1;\\n      return p1 - this.cdfSingleValue(x1, [xi / (1 - xi)]);\\n    }\\n\\n    let xiOpt = brentSolve(rootFun, 0.0, 1.0);\\n    let optimSuccess = xiOpt != null;\\n    \\n    return [[xiOpt / (1 - xiOpt)], optimSuccess];\\n  }\\n\\n}\\n\\nfunction regularizedIncompleteBeta(x, a, b) {\\n    \\n    \\n    if (x &lt; 0 || x &gt; 1) {\\n        throw new RangeError(&#x27;First argument must be between 0 and 1.&#x27;);\\n    }\\n\\n    \\n    else if (a === 1 &amp;&amp; b === 1) return x;\\n    else if (x === 0) return 0;\\n    else if (x === 1) return 1;\\n    else if (a === 0) return 1;\\n    else if (b === 0) return 0;\\n\\n    else {\\n        var bt = Math.exp(lngamma(a + b) - lngamma(a) - lngamma(b) + a * Math.log(x) + b * log1p(-x));\\n\\n        \\n        if (x &lt; (a + 1) / (a + b + 2)) return bt * betacf(x, a, b) / a;\\n\\n        \\n        else return 1 - bt * betacf(1 - x, b, a) / b;\\n    }\\n}\\n\\n\\nfunction lngamma(z) {\\n\\n    if(z &lt; 0) return Number(&#x27;0/0&#x27;);\\n\\n    if (z &lt; 0.5) return Math.log(Math.PI) - Math.log(Math.sin(Math.PI * z)) - lngamma(1-z);\\n\\n    var p = [676.5203681218851,\\n             -1259.1392167224028,\\n             771.32342877765313,\\n             -176.61502916214059,\\n             12.507343278686905,\\n             -0.13857109526572012,\\n             9.9843695780195716e-6,\\n             1.5056327351493116e-7];\\n\\n    z -= 1.0;\\n    var Ag = 0.99999999999980993;\\n    for (var i = 0; i &lt; p.length; i++) {\\n        Ag += p[i] / (z + i + 1);\\n    }\\n    var t = z + p.length - 0.5;\\n\\n    return 0.5 * Math.log(2*Math.PI) + (z + 0.5)*Math.log(t) - t + Math.log(Ag);\\n}\\n\\n\\nfunction lnfactorial(n) {\\n  if (n &gt; 254) { \\n    let x = n + 1;\\n    return (x - 0.5) * Math.log(x) - x + 0.5 * Math.log(2 * Math.PI) + 1.0 / (12.0 * x);\\n  }\\n  else { \\n    const lnfact = [0.000000000000000,\\n                    0.000000000000000,\\n                    0.693147180559945,\\n                    1.791759469228055,\\n                    3.178053830347946,\\n                    4.787491742782046,\\n                    6.579251212010101,\\n                    8.525161361065415,\\n                    10.604602902745251,\\n                    12.801827480081469,\\n                    15.104412573075516,\\n                    17.502307845873887,\\n                    19.987214495661885,\\n                    22.552163853123421,\\n                    25.191221182738683,\\n                    27.899271383840894,\\n                    30.671860106080675,\\n                    33.505073450136891,\\n                    36.395445208033053,\\n                    39.339884187199495,\\n                    42.335616460753485,\\n                    45.380138898476908,\\n                    48.471181351835227,\\n                    51.606675567764377,\\n                    54.784729398112319,\\n                    58.003605222980518,\\n                    61.261701761002001,\\n                    64.557538627006323,\\n                    67.889743137181526,\\n                    71.257038967168000,\\n                    74.658236348830158,\\n                    78.092223553315307,\\n                    81.557959456115029,\\n                    85.054467017581516,\\n                    88.580827542197682,\\n                    92.136175603687079,\\n                    95.719694542143202,\\n                    99.330612454787428,\\n                    102.968198614513810,\\n                    106.631760260643450,\\n                    110.320639714757390,\\n                    114.034211781461690,\\n                    117.771881399745060,\\n                    121.533081515438640,\\n                    125.317271149356880,\\n                    129.123933639127240,\\n                    132.952575035616290,\\n                    136.802722637326350,\\n                    140.673923648234250,\\n                    144.565743946344900,\\n                    148.477766951773020,\\n                    152.409592584497350,\\n                    156.360836303078800,\\n                    160.331128216630930,\\n                    164.320112263195170,\\n                    168.327445448427650,\\n                    172.352797139162820,\\n                    176.395848406997370,\\n                    180.456291417543780,\\n                    184.533828861449510,\\n                    188.628173423671600,\\n                    192.739047287844900,\\n                    196.866181672889980,\\n                    201.009316399281570,\\n                    205.168199482641200,\\n                    209.342586752536820,\\n                    213.532241494563270,\\n                    217.736934113954250,\\n                    221.956441819130360,\\n                    226.190548323727570,\\n                    230.439043565776930,\\n                    234.701723442818260,\\n                    238.978389561834350,\\n                    243.268849002982730,\\n                    247.572914096186910,\\n                    251.890402209723190,\\n                    256.221135550009480,\\n                    260.564940971863220,\\n                    264.921649798552780,\\n                    269.291097651019810,\\n                    273.673124285693690,\\n                    278.067573440366120,\\n                    282.474292687630400,\\n                    286.893133295426990,\\n                    291.323950094270290,\\n                    295.766601350760600,\\n                    300.220948647014100,\\n                    304.686856765668720,\\n                    309.164193580146900,\\n                    313.652829949878990,\\n                    318.152639620209300,\\n                    322.663499126726210,\\n                    327.185287703775200,\\n                    331.717887196928470,\\n                    336.261181979198450,\\n                    340.815058870798960,\\n                    345.379407062266860,\\n                    349.954118040770250,\\n                    354.539085519440790,\\n                    359.134205369575340,\\n                    363.739375555563470,\\n                    368.354496072404690,\\n                    372.979468885689020,\\n                    377.614197873918670,\\n                    382.258588773060010,\\n                    386.912549123217560,\\n                    391.575988217329610,\\n                    396.248817051791490,\\n                    400.930948278915760,\\n                    405.622296161144900,\\n                    410.322776526937280,\\n                    415.032306728249580,\\n                    419.750805599544780,\\n                    424.478193418257090,\\n                    429.214391866651570,\\n                    433.959323995014870,\\n                    438.712914186121170,\\n                    443.475088120918940,\\n                    448.245772745384610,\\n                    453.024896238496130,\\n                    457.812387981278110,\\n                    462.608178526874890,\\n                    467.412199571608080,\\n                    472.224383926980520,\\n                    477.044665492585580,\\n                    481.872979229887900,\\n                    486.709261136839360,\\n                    491.553448223298010,\\n                    496.405478487217580,\\n                    501.265290891579240,\\n                    506.132825342034830,\\n                    511.008022665236070,\\n                    515.890824587822520,\\n                    520.781173716044240,\\n                    525.679013515995050,\\n                    530.584288294433580,\\n                    535.496943180169520,\\n                    540.416924105997740,\\n                    545.344177791154950,\\n                    550.278651724285620,\\n                    555.220294146894960,\\n                    560.169054037273100,\\n                    565.124881094874350,\\n                    570.087725725134190,\\n                    575.057539024710200,\\n                    580.034272767130800,\\n                    585.017879388839220,\\n                    590.008311975617860,\\n                    595.005524249382010,\\n                    600.009470555327430,\\n                    605.020105849423770,\\n                    610.037385686238740,\\n                    615.061266207084940,\\n                    620.091704128477430,\\n                    625.128656730891070,\\n                    630.172081847810200,\\n                    635.221937855059760,\\n                    640.278183660408100,\\n                    645.340778693435030,\\n                    650.409682895655240,\\n                    655.484856710889060,\\n                    660.566261075873510,\\n                    665.653857411105950,\\n                    670.747607611912710,\\n                    675.847474039736880,\\n                    680.953419513637530,\\n                    686.065407301994010,\\n                    691.183401114410800,\\n                    696.307365093814040,\\n                    701.437263808737160,\\n                    706.573062245787470,\\n                    711.714725802289990,\\n                    716.862220279103440,\\n                    722.015511873601330,\\n                    727.174567172815840,\\n                    732.339353146739310,\\n                    737.509837141777440,\\n                    742.685986874351220,\\n                    747.867770424643370,\\n                    753.055156230484160,\\n                    758.248113081374300,\\n                    763.446610112640200,\\n                    768.650616799717000,\\n                    773.860102952558460,\\n                    779.075038710167410,\\n                    784.295394535245690,\\n                    789.521141208958970,\\n                    794.752249825813460,\\n                    799.988691788643450,\\n                    805.230438803703120,\\n                    810.477462875863580,\\n                    815.729736303910160,\\n                    820.987231675937890,\\n                    826.249921864842800,\\n                    831.517780023906310,\\n                    836.790779582469900,\\n                    842.068894241700490,\\n                    847.352097970438420,\\n                    852.640365001133090,\\n                    857.933669825857460,\\n                    863.231987192405430,\\n                    868.535292100464630,\\n                    873.843559797865740,\\n                    879.156765776907600,\\n                    884.474885770751830,\\n                    889.797895749890240,\\n                    895.125771918679900,\\n                    900.458490711945270,\\n                    905.796028791646340,\\n                    911.138363043611210,\\n                    916.485470574328820,\\n                    921.837328707804890,\\n                    927.193914982476710,\\n                    932.555207148186240,\\n                    937.921183163208070,\\n                    943.291821191335660,\\n                    948.667099599019820,\\n                    954.046996952560450,\\n                    959.431492015349480,\\n                    964.820563745165940,\\n                    970.214191291518320,\\n                    975.612353993036210,\\n                    981.015031374908400,\\n                    986.422203146368590,\\n                    991.833849198223450,\\n                    997.249949600427840,\\n                    1002.670484599700300,\\n                    1008.095434617181700,\\n                    1013.524780246136200,\\n                    1018.958502249690200,\\n                    1024.396581558613400,\\n                    1029.838999269135500,\\n                    1035.285736640801600,\\n                    1040.736775094367400,\\n                    1046.192096209724900,\\n                    1051.651681723869200,\\n                    1057.115513528895000,\\n                    1062.583573670030100,\\n                    1068.055844343701400,\\n                    1073.532307895632800,\\n                    1079.012946818975000,\\n                    1084.497743752465600,\\n                    1089.986681478622400,\\n                    1095.479742921962700,\\n                    1100.976911147256000,\\n                    1106.478169357800900,\\n                    1111.983500893733000,\\n                    1117.492889230361000,\\n                    1123.006317976526100,\\n                    1128.523770872990800,\\n                    1134.045231790853000,\\n                    1139.570684729984800,\\n                    1145.100113817496100,\\n                    1150.633503306223700,\\n                    1156.170837573242400];\\n    return lnfact[n];\\n  }\\n}\\n\\n\\nfunction findRootTrustRegion(\\n\\t\\tf, \\n\\t\\tx0, \\n\\t\\targs=[],\\n\\t\\tjac=jacCentralDiff,\\n\\t\\ttol=0.000000001, \\n\\t\\tmaxIters=10000, \\n\\t\\tdeltaBar=1000.0, \\n\\t\\teta=0.125, \\n\\t\\tminDelta=1e-12\\n  ) {\\n\\t\\n\\tlet x = deepCopy(x0);\\n\\n\\t\\n\\tlet delta = 0.99 * deltaBar;\\n\\n\\t\\n\\tlet r = f(x, ...args);\\n\\n\\t\\n\\tlet J = jac(f, x, args);\\n\\n\\t\\n\\tlet JTJ = mmMult(transpose(J), J);\\n\\n\\t\\n\\tlet JTr = mvMult(transpose(J), r);\\n\\n\\t\\n\\tlet normJTr = norm(JTr);\\n\\n\\tlet iters = 0;\\n\\twhile (iters &lt; maxIters &amp;&amp; checkTol(r, tol) &amp;&amp; delta &gt;= minDelta) {\\n\\t\\t\\n\\t\\tlet p = doglegStep(JTJ, JTr, normJTr, delta);\\n\\n\\t\\t\\n\\t\\tlet newr = f(vectorAdd(x, p), ...args);\\n\\t\\tlet rho = computeRho(r, newr, J, p);\\n\\n\\t\\t\\n\\t\\tif  (rho &lt; 0.25) {\\n\\t\\t\\tdelta = norm(p) / 4.0;\\n\\t\\t} else if (rho &gt; 0.75 &amp;&amp; Math.abs(norm(p) - delta) &lt; 1e-12) {\\n\\t\\t\\t\\tdelta = Math.min(2 * delta, deltaBar);\\n\\t\\t}\\n\\n\\t\\t\\n\\t\\tif (rho &gt; eta) {\\n\\t\\t\\tx = vectorAdd(x, p);\\n\\n\\t\\t\\tr = newr;\\n\\t\\t\\tJ = jac(f, x, args);\\n\\t\\t\\tJTJ = mmMult(transpose(J), J);\\n\\t\\t\\tJTr = mvMult(transpose(J), r);\\n\\t\\t\\tnormJTr = norm(JTr);\\n\\t\\t}\\n\\n\\t\\titers += 1;\\n\\t}\\n\\n\\tlet success = !checkTol(r, tol);\\n\\n\\treturn [x, success];\\n\\n}\\n\\n\\nfunction bisectionSolve(f, lower, upper, args=[], tol=1e-8, maxIter=1000) {\\n\\t\\n  if (f(lower, ...args) * f(upper, ...args) &gt;= 0) return null;\\n\\n  let mid = lower;\\n  for (let i = 0; i &lt; maxIter; i++) {\\n    mid = (lower + upper) / 2;\\n    let fMid = f(mid, ...args);\\n\\n    if (fMid === 0 || (upper - lower) / 2 &lt; tol) return mid;\\n\\n    if (fMid * f(lower, ...args) &gt; 0) lower = mid;\\n    else upper = mid;\\n  }\\n\\n  return mid;\\n}\\n\\n\\nfunction brentSolve(f, lower, upper, args=[], tol=1e-8, maxIter=1000) {\\n\\tlet a = lower;\\n\\tlet b = upper;\\n  let fa = f(a, ...args);\\n  let fb = f(b, ...args);\\n\\n  \\n  if (Math.abs(fa) &lt; tol) return a;\\n  if (Math.abs(fb) &lt; tol) return b;\\n\\n  \\n  if (fa * fb &gt;= 0) {\\n  \\treturn null;\\n\\t}\\n\\n  \\n  let c = a;\\n  let fc = fa;\\n\\n\\tlet iter = 0;\\n  while (iter++ &lt; maxIter) {\\n  \\tlet prevStep = b - a;\\n\\n    \\n    if (Math.abs(fc) &lt; Math.abs(fb)) {      \\n    \\t[a, b, c] = [b, c, b];\\n    \\t[fa, fb, fc] = [fb, fc, fb];\\n    }\\n\\n    \\n    let newStep = (c - b) / 2.0;\\n\\n    \\n    let tolAdj = 1e-15 * Math.abs(b) + tol / 2;\\n\\n    \\n  \\tif (Math.abs(newStep) &lt;= tolAdj || fb === 0 ) {\\n    \\t\\treturn b;\\n  \\t}\\n\\n    \\n    if (Math.abs(prevStep) &gt; tolAdj &amp;&amp; Math.abs(fa) &gt; Math.abs(fb)) {\\n    \\tlet p;\\n    \\tlet q;\\n    \\tlet t1;\\n    \\tlet t2;\\n    \\tlet cb = c - b;\\n    \\tif (a === c) { \\n    \\t\\tt1 = fb / fa;\\n    \\t\\tp = cb * t1;\\n    \\t\\tq = 1.0 - t1;\\n    \\t}\\n    \\telse { \\n    \\t\\tq = fa / fc;\\n    \\t\\tt1 = fb / fc;\\n    \\t\\tt2 = fb / fa;\\n    \\t\\tp = t2 * (cb * q * (q - t1) - (b - a) * (t1 - 1.0));\\n    \\t\\tq = (q - 1.0) * (t1 - 1.0) * (t2 - 1.0);\\n    \\t}\\n\\n    \\t\\n    \\tif (p &gt; 0) q = -q;\\n    \\telse p = -p;\\n\\n    \\t\\n    \\tif (p &lt; (0.75 * cb * q - Math.abs(tolAdj * q) / 2.0) \\n    \\t\\t&amp;&amp; p &lt; Math.abs(prevStep * q / 2.0)) { \\n\\t        newStep = p / q;\\n      \\t}\\n    }\\n\\n    if (Math.abs(newStep) &lt; tolAdj) {\\n      newStep = (newStep &gt; 0) ? tolAdj : -tolAdj;\\n    }\\n\\n    \\n    a = b;\\n    fa = fb;\\n\\n    \\n    b += newStep;\\n    fb = f(b, ...args);\\n\\n\\t\\n    if ((fb &gt; 0 &amp;&amp; fc &gt; 0) || (fb &lt; 0 &amp;&amp; fc &lt; 0)) {\\n      c = a; \\n      fc = fa;\\n    }\\n  }\\n\\n  \\n  return null;\\n}\\n\\n\\nfunction lnchoice(n, k) {\\n    return lnfactorial(n) - lnfactorial(n-k) - lnfactorial(k);\\n}\\n\\n\\nfunction log1p(x) {\\n  \\n  \\n  if (x &lt;= -1.0) {\\n    throw new RangeError(&#x27;Argument must be greater than -1.0&#x27;);\\n  }\\n\\n  \\n  else if (Math.abs(x) &gt; 1e-4) {\\n    return Math.log(1.0 + x);\\n  }\\n\\n  else {\\n    return (-0.5*x + 1.0)*x;\\n  }\\n}\\n\\n\\nfunction betacf(x, a, b) {\\n    \\n    \\n    var fpmin = 1e-30,\\n        m = 1,\\n        m2, aa, c, d, del, h, qab, qam, qap;\\n    \\n    qab = a + b;\\n    qap = a + 1;\\n    qam = a - 1;\\n    c = 1;\\n    d = 1 - qab * x / qap;\\n    if (Math.abs(d) &lt; fpmin) d = fpmin;\\n    d = 1 / d;\\n    h = d;\\n    for (; m &lt;= 100; m++) {\\n        m2 = 2 * m;\\n        aa = m * (b - m) * x / ((qam + m2) * (a + m2));\\n        \\n        d = 1 + aa * d;\\n        if (Math.abs(d) &lt; fpmin) d = fpmin;\\n        c = 1 + aa / c;\\n        if (Math.abs(c) &lt; fpmin) c = fpmin;\\n        d = 1 / d;\\n        h *= d * c;\\n        aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));\\n        \\n        d = 1 + aa * d;\\n        if (Math.abs(d) &lt; fpmin) d = fpmin;\\n        c = 1 + aa / c;\\n        if (Math.abs(c) &lt; fpmin) c = fpmin;\\n        d = 1 / d;\\n        del = d * c;\\n        h *= del;\\n        if (Math.abs(del - 1.0) &lt; 3e-7) break;\\n    }\\n    return h;\\n}\\n\\n\\nfunction isclose(x, y, rtol = 1.0e-7, atol = 1.0e-8) {\\n  return Math.abs(x - y) &lt;= (atol + rtol * Math.abs(y));\\n}\\n\\n\\nfunction gammaincU(x, s, regularized) {\\n\\n  var EPSILON = 1e-12;\\n\\n  if (x &lt;= 1.1 || x &lt;= s) {\\n    if (regularized !== false) {\\n      return 1 - gammaincL(x, s, regularized);\\n    } else {\\n      return Math.exp(lngamma(s)) - gammaincL(x, s, regularized);\\n    }\\n  }\\n\\n  var f = 1 + x - s,\\n    C = f,\\n    D = 0,\\n    i = 1,\\n    a, b, chg;\\n  for (i = 1; i &lt; 10000; i++) {\\n    a = i * (s - i);\\n    b = (i&lt;&lt;1) + 1 + x - s;\\n    D = b + a * D;\\n    C = b + a / C;\\n    D = 1 / D;\\n    chg = C * D;\\n    f *= chg;\\n    if (Math.abs(chg - 1) &lt; EPSILON) {\\n      break;\\n    }\\n  }\\n  if (regularized !== false) {\\n    return Math.exp(s * Math.log(x) - x - lngamma(s) - Math.log(f));\\n  } else {\\n    return Math.exp(s * Math.log(x) - x - Math.log(f));\\n  }\\n}\\n\\n\\nfunction transpose(A) {\\n    return A[0].map((_, colIndex) =&gt; A.map(row =&gt; row[colIndex]));\\n}\\n\\n\\nfunction mvMult(A, v) {\\n  return A.map(Arow =&gt; dot(Arow, v));\\n}\\n\\n\\nfunction mmMult(A, B) {\\n  let mA = A.length;\\n  let nA = A[0].length;\\n  let mB = B.length;\\n  let nB = B[0].length;\\n\\n  if (nA !== mB) {\\n      throw new Error(&#x27;Matrix dimension mismatch.&#x27;);\\n  }\\n\\n  let result = zeros(mA, nB);\\n\\n  for (let i = 0; i &lt; mA; i++) {\\n    for (let j = 0; j &lt; nB; j++) {\\n      for (let k = 0; k &lt; nA; k++) {\\n        result[i][j] += A[i][k] * B[k][j];\\n      }\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction vectorAdd() {\\n  let m = arguments.length;\\n  let n = arguments[0].length;\\n \\n  let result = new Array(n).fill(0.0);\\n \\n  for (let i = 0; i &lt; n; i++) {\\n    for (let j = 0; j &lt; m; j++) {\\n        result[i] += arguments[j][i];\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n\\nfunction norm(v) {\\n  return Math.sqrt(dot(v, v));\\n}\\n\\n\\nfunction deepCopy(x) {\\n  return JSON.parse(JSON.stringify(x));\\n}\\n\\n\\nfunction computeRho(r, newr, J, p) {\\n\\tlet r2 = norm(r) ** 2;\\n\\tlet num = r2 - norm(newr)**2;\\n\\tlet denom = r2 - norm(vectorAdd(r, mvMult(J, p))) ** 2;\\n\\n\\treturn num / denom;\\n}\\n\\n\\nfunction checkTol(r, tol) {\\n\\t\\n\\tconst n = r.length;\\n\\tfor (let i = 0; i &lt; n; i++) {\\n\\t\\tif (tol &lt; Math.abs(r[i])) return true;\\n\\t}\\n\\n\\treturn false;\\n}\\n\\n\\nfunction doglegStep(JTJ, JTr, normJTr, delta) {\\n\\t\\n\\tlet [pJ, posDef] = solvePosDef(JTJ, JTr);\\n\\tpJ = svMult(-1.0, pJ);\\n\\n\\t\\n\\tif (posDef &amp;&amp; norm(pJ) &lt;= delta) {\\n\\t\\treturn pJ;\\n\\t}\\n\\n\\t\\n\\tlet tau = Math.min(1, normJTr**3 / delta / quadForm(JTJ, JTr));\\n\\tlet pC = svMult(-tau * delta / normJTr, JTr);\\n\\n\\tlet pCnorm = norm(pC);\\n\\tif (!posDef || Math.abs(pCnorm - delta) &lt;= 1e-12) {\\n\\t\\treturn pC;\\n\\t}\\n\\n\\t\\n\\tlet pJ2 = norm(pJ) ** 2;\\n\\tlet pC2 = pCnorm**2;\\n\\tlet pJpC = dot(pJ, pC);\\n\\tlet a = pJ2 + pC2 - 2.0 * pJpC;\\n\\tlet b = 2.0 * (pJpC - pC2);\\n\\tlet c = pC2 - delta**2;\\n\\tlet q = -0.5 * (b + Math.sign(b) * Math.sqrt(b**2 - 4.0 * a * c));\\n\\n\\t\\n\\tlet beta;\\n\\tif (Math.abs(b) &lt; 1e-12) beta = Math.sqrt(-c / a);\\n\\telse if (b &lt; 0.0) beta = q / a;\\n\\telse beta = c / q;\\n\\n\\t\\n\\tif (0.0 &lt;= beta &amp;&amp; beta &lt;= 1) {\\n\\t\\treturn vectorAdd(pC, svMult(beta, vectorAdd(pJ, svMult(-1.0, pC))));\\n\\t} else { \\n\\t\\treturn pC;\\n\\t}\\n\\n}\\n\\n\\nfunction jacCentralDiff(f, x, args=[], eps=4.7e-6) {\\n\\t\\n\\tlet xPlus = deepCopy(x);\\n\\tlet xMinus = deepCopy(x);\\n\\n\\t\\n\\tlet fOfx = f(x, ...args);\\n\\tlet m = fOfx.length;\\n\\n\\t\\n\\tlet n = x.length;\\n\\n\\t\\n\\tlet J = zeros(m, n);\\n\\n\\t\\n\\tlet fOfxPlus;\\n\\tlet fOfxMinus;\\n\\n\\tfor (let j = 0; j &lt; n; j++) {\\n\\t\\txPlus[j] += eps;\\n\\t\\txMinus[j] -= eps;\\n\\t\\tfOfxPlus = f(xPlus, ...args);\\n\\t\\tfOfxMinus = f(xMinus, ...args);\\n\\t\\txPlus[j] -= eps;\\n\\t\\txMinus[j] += eps;\\n\\n\\t\\tfor (let i = 0; i &lt; m; i++) {\\n\\t\\t\\tJ[i][j] = (fOfxPlus[i] - fOfxMinus[i]) / 2.0 / eps;\\n\\t\\t}\\n\\t}\\n\\n\\treturn J;\\n}\\n\\n\\nfunction gammaincL(x, s, regularized) {\\n\\n  var EPSILON = 1e-12;\\n\\n  if (x === 0) {\\n    return 0;\\n  }\\n  if (x &lt; 0 || s &lt;= 0) {\\n    return NaN;\\n  }\\n\\n  if (x &gt; 1.1 &amp;&amp; x &gt; s) {\\n    if (regularized !== false) {\\n      return 1 - gammaincU(x, s, regularized);\\n    } else {\\n      return Math.exp(lngamma(s)) - gammaincU(x, s, regularized);\\n    }\\n  }\\n\\n  var ft,\\n    r = s,\\n    c = 1,\\n    pws = 1;\\n\\n  if (regularized !== false) {\\n    ft = s * Math.log(x) - x - lngamma(s);\\n  } else {\\n    ft = s * Math.log(x) - x;\\n  }\\n  ft = Math.exp(ft);\\n  do {\\n    r += 1;\\n    c *= x/r;\\n    pws += c;\\n  } while (c / pws &gt; EPSILON);\\n\\n  return pws * ft / s;\\n}\\n\\n\\nfunction dot(v1, v2) {\\n  const n = v1.length;\\n  let result = 0.0;\\n  for (let i = 0; i &lt; n; i++) result += v1[i] * v2[i];\\n\\n  return result;\\n}\\n\\n\\nfunction zeros(...dims) {\\n  let A = [];\\n\\n  \\n  for (let i = dims.length - 1; i &gt;= 0; i--) {\\n    let size = dims[i];\\n    if (i === dims.length - 1) {\\n      \\n      A = new Array(size).fill(0.0);\\n    } else {\\n      \\n      A = new Array(size).fill().map(() =&gt; deepCopy(A));\\n    }\\n  }\\n\\n  return A;\\n}\\n\\n\\nfunction svMult(a, v) {\\n  return v.map(x =&gt; a * x);\\n}\\n\\n\\nfunction quadForm(A, x) {\\n   return dot(x, mvMult(A, x)); \\n}\\n\\n\\nfunction solvePosDef(A, b) {\\n  let [L, p, success] = modifiedCholesky(A);\\n\\n  if (!success) {\\n    return [zeros(b.length), success];\\n  }\\n\\n  return [modifiedCholeskySolve(L, p, b), success];\\n}\\n\\n\\nfunction modifiedCholesky(A) {\\n    const floatEps = 1.0e-14;\\n    const n = A.length;\\n\\n    \\n    let L = deepCopy(A); \\n    let p = arange(0, n);\\n\\n    \\n    let success = true;\\n\\n    let xi = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        for (let j = 0; j &lt; i; j++) {\\n            let temp = Math.abs(L[i][j]);\\n            xi = Math.max(xi, temp);\\n        }\\n    }\\n\\n    let eta = 0;\\n    for (let i = 0; i &lt; n; i++) {\\n        let temp = Math.abs(L[i][i]);\\n        eta = Math.max(eta, temp);\\n    }\\n\\n    let beta;\\n    if (n &gt; 1) {\\n        beta = Math.sqrt(Math.max(eta, xi / Math.sqrt(n * n - 1)));\\n    } else {\\n        beta = Math.sqrt(eta);\\n    }\\n    beta = Math.max(beta, floatEps);\\n\\n    for (let k = 0; k &lt; n; k++) {\\n        \\n        let muVal = L[k][k];\\n        let mu = k;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            let temp = L[i][i];\\n            if (muVal &lt; temp) {\\n                mu = i;\\n                muVal = temp;\\n            }\\n        }\\n\\n        \\n        let iTemp = p[mu];\\n        p[mu] = p[k];\\n        p[k] = iTemp;\\n\\n        for (let i = 0; i &lt; k; i++) {\\n            let temp = L[k][i];\\n            L[k][i] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        let temp = L[k][k];\\n        L[k][k] = L[mu][mu];\\n        L[mu][mu] = temp;\\n        for (let i = k + 1; i &lt; mu; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[mu][i];\\n            L[mu][i] = temp;\\n        }\\n\\n        for (let i = mu + 1; i &lt; n; i++) {\\n            let temp = L[i][k];\\n            L[i][k] = L[i][mu];\\n            L[i][mu] = temp;\\n        }\\n\\n        \\n        let cSum = 0;\\n        for (let i = k + 1; i &lt; n; i++) {\\n            cSum = Math.max(cSum, Math.abs(L[i][k]));\\n        }\\n        cSum /= beta;\\n        cSum = cSum * cSum;\\n\\n        \\n        if (L[k][k] &lt; 0) {\\n            success = false;\\n        }\\n\\n        temp = Math.abs(L[k][k]);\\n        temp = Math.max(temp, floatEps * eta);\\n        temp = Math.max(temp, cSum);\\n        L[k][k] = Math.sqrt(temp);\\n\\n        \\n        for (let i = k + 1; i &lt; n; i++) {\\n            L[i][k] /= L[k][k];\\n        }\\n\\n        \\n        for (let j = k + 1; j &lt; n; j++) {\\n            for (let i = j; i &lt; n; i++) {\\n                L[i][j] -= L[i][k] * L[j][k];\\n            }\\n        }\\n\\n        \\n        for (let i = 0; i &lt; n - 1; i++) {\\n            for (let j = i + 1; j &lt; n; j++) {\\n                L[i][j] = 0.0;\\n            }\\n        }\\n    }\\n\\n    return [L, p, success];\\n}\\n\\n\\nfunction modifiedCholeskySolve(L, p, b) {\\n    const n = L.length;\\n\\n    let U = transpose(L);\\n    let xp = new Array(n).fill(0);\\n    for (let i = 0; i &lt; n; i++) {\\n        xp[i] = b[p[i]];\\n    }\\n\\n    \\n    let x = lowerTriSolve(L, xp);\\n\\n    \\n    xp = upperTriSolve(U, x);\\n\\n    for (let i = 0; i &lt; n; i++) {\\n        x[p[i]] = xp[i];\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction arange(start, stop) {\\n  let x = new Array(stop - start);\\n  for (let i = 0; i &lt; stop - start; i++) {\\n    x[i] = start + i;\\n  }\\n\\n  return x;\\n}\\n\\n\\nfunction lowerTriSolve(L, b) {\\n    const floatEps = 1.0e-14;\\n    const n = L.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = 0; j &lt; n - 1; j++) {\\n        if (Math.abs(L[j][j]) &gt; floatEps) {\\n            x[j] /= L[j][j];\\n            for (let i = j + 1; i &lt; n; i++) {\\n                x[i] -= x[j] * L[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(L[n - 1][n - 1]) &gt; floatEps) {\\n            x[n - 1] /= L[n - 1][n - 1];\\n        } else {\\n            x[n - 1] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nfunction upperTriSolve(U, b) {\\n    const floatEps = 1.0e-14;\\n    const n = U.length;\\n\\n    \\n    let x = Array.from(b);\\n\\n    \\n    for (let j = n - 1; j &gt; 0; j--) {\\n        if (Math.abs(U[j][j]) &gt; floatEps) {\\n            x[j] /= U[j][j];\\n            for (let i = 0; i &lt; j; i++) {\\n                x[i] -= x[j] * U[i][j];\\n            }\\n        } else {\\n            x[j] = 0.0;\\n        }\\n    }\\n\\n    if (n &gt; 0) {\\n        if (Math.abs(U[0][0]) &gt; floatEps) {\\n            x[0] /= U[0][0];\\n        } else {\\n            x[0] = 0.0;\\n        }\\n    }\\n\\n    return x;\\n}\\n\\n\\nclass NegativeBinomialDistribution extends DiscreteUnivariateDistribution {\\n  constructor(parametrization = &#x27;alpha-beta&#x27;, fixedParam = undefined) {\\n    super(parametrization);\\n\\n    \\n    this.name = &#x27;NegativeBinomial&#x27;;\\n\\n    \\n    this.varName = &#x27;y&#x27;;\\n\\n    \\n    this.hardMin = 0;\\n    this.hardMax = Infinity;\\n\\n    \\n    if (this.parametrization === &#x27;alpha-beta&#x27;) {\\n      this.paramNames = [&#x27;\\u03b1&#x27;, &#x27;\\u03b2&#x27;];\\n      this.paramMin = [0.0, 0.0];\\n      this.paramMax = [Infinity, Infinity];\\n      if (fixedParam === undefined) this.fixedParams = [&#x27;\\u03b1&#x27;];\\n      else this.fixedParams = [fixedParam];\\n    } else if (this.parametrization === &#x27;mu-phi&#x27;) {\\n      this.paramNames = [&#x27;\\u03bc&#x27;, &#x27;\\u03c6&#x27;];\\n      this.paramMin = [0.0, 0.0];\\n      this.paramMax = [Infinity, Infinity];\\n      if (fixedParam === undefined) this.fixedParams = [&#x27;\\u03c6&#x27;];\\n      else this.fixedParams = [fixedParam];\\n    } else if (this.parametrization === &#x27;alpha-p&#x27;) {\\n      this.paramNames = [&#x27;\\u03b1&#x27;, &#x27;p&#x27;];\\n      this.paramMin = [0.0, 0.0];\\n      this.paramMax = [Infinity, 1.0];\\n      if (fixedParam === undefined) this.fixedParams = [&#x27;\\u03b1&#x27;];\\n      else this.fixedParams = [fixedParam];\\n    } else if (this.parametrization === &#x27;r-b&#x27;) {\\n      this.paramNames = [&#x27;r&#x27;, &#x27;b&#x27;];\\n      this.paramMin = [0.0, 0.0];\\n      this.paramMax = [Infinity, Infinity];\\n      if (fixedParam === undefined) this.fixedParams = [&#x27;r&#x27;];\\n      else this.fixedParams = [fixedParam];\\n    } else { \\n      this.paramNames = [&#x27;unnamedParam1&#x27;, &#x27;unnamedParam2&#x27;];\\n      this.paramMin = [0.0, 0.0];\\n      this.paramMax = [Infinity, Infinity];\\n      if (fixedParam === undefined) this.fixedParams = [&#x27;unnamedParam1&#x27;];\\n      else this.fixedParams = [fixedParam];\\n    }\\n\\n    \\n    super.generateActiveFixedInds()\\n  }\\n\\n  xMin(params) {\\n    return 0;\\n  }\\n\\n  xMax(params) {\\n    return Infinity;\\n  }\\n\\n  convertParams(params, from = this.parametrization, to = &#x27;alpha-beta&#x27;) {\\n    if (from === to) return params;\\n    else if (to === &#x27;alpha-beta&#x27;) return this.convertParamsToAlphaBeta(params, from);\\n    else if (from === &#x27;alpha-beta&#x27;) return this.convertParamsFromAlphaBeta(params, to);\\n    else return this.convertParamsFromAlphaBeta(this.convertParamsToAlphaBeta(params, from), to);\\n  }\\n\\n  convertParamsToAlphaBeta(params, from = this.parametrization) {\\n    \\n    let alpha, beta;\\n\\n    if (from === &#x27;mu-phi&#x27;) {\\n      let [mu, phi] = params.slice(0, 2);\\n      alpha = phi;\\n      beta = alpha / mu;\\n    } else if (from === &#x27;alpha-p&#x27;) {\\n      let [a, p] = params.slice(0, 2);\\n      alpha = a;\\n      beta = p / (1 - p);\\n    } else if (from === &#x27;r-b&#x27;) {\\n      let [r, b] = params.slice(0, 2);\\n      alpha = r;\\n      beta = 1 / b;\\n    } else if (from === &#x27;alpha-beta&#x27;) {\\n      [alpha, beta] = params.slice(0, 2);\\n    } else {\\n      throw new Error(&#x27;Invalid parametrization for converting. Allowed values are alpha-beta, mu-phi, alpha-p, and r-b.&#x27;);\\n    }\\n\\n    return [alpha, beta];\\n  }\\n\\n  convertParamsFromAlphaBeta(params, to = this.parametrization) {\\n    \\n    let [alpha, beta] = params.slice(0, 2);\\n\\n    let output;\\n    if (to === &#x27;mu-phi&#x27;) {\\n      let mu = alpha / beta;\\n      let phi = alpha;\\n      output = [mu, phi];\\n    } else if (to === &#x27;alpha-p&#x27;) {\\n      let a = alpha;\\n      let p = beta / (1 + beta);\\n      output = [a, p];\\n    } else if (to === &#x27;r-b&#x27;) {\\n      let r = alpha;\\n      let b = 1 / beta;\\n      output = [r, b];\\n    } else if (to === &#x27;alpha-beta&#x27;) {\\n      output = [alpha, beta];\\n    } else {\\n      throw new Error(&#x27;Invalid parametrization for converting. Allowed values are alpha-beta, mu-phi, alpha-p, and r-b.&#x27;);\\n    }\\n\\n    return output;\\n  }\\n\\n  pmfSingleValue(y, params, parametrization = this.parametrization) {\\n    if (y &lt; 0) return NaN;\\n\\n    \\n    let [alpha, beta] = this.convertParamsToAlphaBeta(params, parametrization);\\n\\n    if (alpha &lt;= 0 || beta &lt;= 0) return NaN;\\n\\n    return Math.exp(lngamma(y + alpha)\\n                    - lngamma(alpha)\\n                    - lnfactorial(y)\\n                    + alpha * Math.log(beta / (1 + beta))\\n                    - y * Math.log(1 + beta));\\n  }\\n\\n  cdfSingleValue(y, params, parametrization = this.parametrization) {\\n    let [alpha, beta] = this.convertParamsToAlphaBeta(params, parametrization);\\n\\n    if (alpha === 0 || beta === Infinity) return 1.0;\\n    if (alpha === Infinity) return y === Infinity ? 1.0 : 0.0; \\n\\n    if (y &lt;= 0) return 0.0;\\n    if (y === Infinity) return 1.0;\\n\\n    return regularizedIncompleteBeta(beta / (1 + beta), alpha, y + 1);\\n  }\\n\\n  defaultXRange(params, parametrization = this.parametrization) {\\n    let [x1, x2] = super.ppf([0.001, 0.999], this.convertParamsToAlphaBeta(params, parametrization));\\n\\n    \\n    if (x1 &lt; (x2 - x1) / 10.0) x1 = -1.0;\\n\\n    return [x1, x2];\\n  }\\n\\n  \\n  quantileSet(x, p, extraParams) {\\n    if (this.fixedParams.length != 1) {\\n      throw new Error(&#x27;Must have exactly one fixed parameter.&#x27;)\\n    }\\n\\n    let x1 = x[0];\\n    let p1 = p[0];\\n    let otherParam = extraParams[0];\\n\\n    if (!Number.isInteger(x1)) {\\n      throw new Error(this.varName + &#x27; must be integer.&#x27;)\\n    }\\n    if (x1 &lt; 0 ) {\\n      throw new Error(&#x27;Must have &#x27; + this.varName + &#x27; &gt; 0.&#x27;)\\n    }\\n\\n    const rootFun = (xi, x1, p1) =&gt; {\\n      if (this.fixedParamsInds[0] === 0) {\\n        return p1 - this.cdfSingleValue(x1, [otherParam, xi / (1 - xi)], this.parametrization);\\n      } else {\\n        return p1 - this.cdfSingleValue(x1, [xi / (1 - xi), otherParam], this.parametrization);        \\n      }\\n    }\\n\\n    let xiOpt = brentSolve(rootFun, 0.0, 1.0, [x1, p1]);\\n    let optimSuccess = xiOpt != null;\\n    \\n    return [[xiOpt / (1 - xiOpt)], optimSuccess];\\n  }\\n\\n  quantileSetBoth(x, p) {\\n    let [x1, x2] = x.slice(0, 2);\\n    let [p1, p2] = p.slice(0, 2);\\n\\n    if (!Number.isInteger(x1) || !Number.isInteger(x2)) {\\n      throw new Error(this.varName + &#x27; must be integer.&#x27;)\\n    }\\n    if (x1 &lt; 0 || x2 &lt; 0) {\\n      throw new Error(&#x27;Must have &#x27; + this.varName + &#x27; &gt; 0.&#x27;)\\n    }\\n\\n    const quantileRootFun = (params, x1, p1, x2, p2) =&gt; {\\n      let mu = Math.exp(params[0]);\\n      let phi = Math.exp(params[1]);\\n\\n      let r1 = this.cdfSingleValue(x1, [mu, phi], &#x27;mu-phi&#x27;) - p1;\\n      let r2 = this.cdfSingleValue(x2, [mu, phi], &#x27;mu-phi&#x27;) - p2;\\n\\n      return [r1, r2];\\n    };\\n\\n    \\n    let meanp = (p1 + p2) / 2;\\n    let muGuess;\\n    if (Math.abs(meanp - 0.5) &lt; 0.2) {\\n      let meanx = (x1 + x2) / 2;\\n      muGuess = meanx;\\n    }\\n    else {\\n      muGuess = 1.0;\\n    }\\n\\n    let args = [x1, p1, x2, p2];\\n    let guess = [Math.log(muGuess), 1.0];\\n    let [logParams, optimSuccess] = findRootTrustRegion(quantileRootFun, guess, args=args);\\n\\n    let paramsOpt;\\n    if (optimSuccess) {\\n      let muOpt = Math.exp(logParams[0]);\\n      let phiOpt = Math.exp(logParams[1]);\\n\\n      \\n      if (phiOpt &gt; 1) {\\n\\n        \\n        const muGivenPhi = (phi, x, p) =&gt; {\\n          dist = new NegativeBinomialDistribution(&#x27;mu-phi&#x27;);\\n\\n          \\n          const rootFun = (xi, phi, x, p) =&gt; { \\n            if (xi === 1) return p;\\n            if (xi === 0) return p - 1;\\n            return p - this.cdfSingleValue(x, [xi / (1 - xi), phi], &#x27;mu-phi&#x27;);\\n          }\\n\\n          let xiOpt = brentSolve(rootFun, 0.0, 1.0, [phi, x, p]);\\n          let optimSuccess = xiOpt != null;\\n          \\n          return [xiOpt / (1 - xiOpt), optimSuccess];\\n        }\\n\\n        const hitQuantiles = (phi, x1, p1, x2, p2) =&gt; {\\n          let [muAdj, rootFindSuccess] = muGivenPhi(phi, x2, p2);\\n\\n          if (rootFindSuccess) {\\n            let [q1, q2] = this.ppf([p1, p2], [muAdj, phi], &#x27;mu-phi&#x27;);\\n\\n            if (q1 === x1 &amp;&amp; q2 === x2) return 1;\\n            else return -1;\\n          } else {\\n            return -1;\\n          }\\n        } \\n\\n        if (hitQuantiles(1.0) === 1) {\\n          phiOpt = 1.0;\\n          let [muAdj, rootFindSuccess] = muGivenPhi(phiOpt, x2, p2);\\n          muOpt = muAdj;\\n        }\\n        else {\\n          let phiAdj = bisectionSolve(hitQuantiles, 1.0, phiOpt, [x1, p1, x2, p2]);\\n          if (phiAdj != null) {\\n            phiOpt = phiAdj;\\n            let [muAdj, rootFindSuccess] = muGivenPhi(phiOpt, x2, p2);\\n            muOpt = muAdj;\\n          }\\n        }\\n      }\\n\\n      paramsOpt = this.convertParams([muOpt, phiOpt], &#x27;mu-phi&#x27;, this.parametrization);\\n    } else { \\n      let pois = new PoissonDistribution();\\n      let [paramsPois, optimSuccessPois] = pois.quantileSet([x2], [p2]);\\n\\n      if (optimSuccessPois) {\\n        let poisQuants = pois.ppf([p1, p2], paramsPois);\\n        if (poisQuants[0] === x1 &amp;&amp; poisQuants[1] === x2) {\\n          let errText;\\n          if (this.parametrization == &#x27;alpha-beta&#x27;|| this.parametrization == &#x27;alpha-p&#x27;) {\\n            errText = &#x27;Use Poisson (\\u03b1 \\u2192 \\u221e limit) with \\u03bb = &#x27; + paramsPois[0].toPrecision(4);\\n          }\\n          else if (this.parametrization == &#x27;mu-phi&#x27;) {\\n            errText = &#x27;Use Poisson (\\u03c6 \\u2192 \\u221e limit) with \\u03bb = &#x27; + paramsPois[0].toPrecision(4);\\n          }\\n          else if (this.parametrization == &#x27;r-b&#x27;) {\\n            errText = &#x27;Use Poisson (r \\u2192 \\u221e limit) with \\u03bb = &#x27; + paramsPois[0].toPrecision(4);\\n          }\\n          throw new Error(errText);\\n        }\\n        \\n      }\\n      paramsOpt = [];\\n    }\\n\\n    return [paramsOpt, optimSuccess];\\n  }\\n}\\n\\n\\n\\nvar dist = new NegativeBinomialDistribution();\\n\\n\\n\\nif (cb_obj.active) {\\n  for (let i = 0; i &lt; sliders.length; i++) {\\n    if (!dist.fixedParamsInds.includes(i)) {\\n      sliders[i].title = dist.paramNames[i] + &#x27; (computed)&#x27;;\\n      sliders[i].disabled = true;\\n    }\\n  }\\n  for (let xBox of xBoxes) {\\n    xBox.disabled = false;\\n  }\\n  for (let pBox of pBoxes) {\\n    pBox.disabled = false;\\n  }\\n} else {\\n  for (let i = 0; i &lt; sliders.length; i++) {\\n    if (!dist.fixedParamsInds.includes(i)) {\\n      sliders[i].title = dist.paramNames[i];\\n      sliders[i].disabled = false;\\n    }\\n  }\\n  for (let xBox of xBoxes) {\\n    xBox.disabled = true;\\n  }\\n  for (let pBox of pBoxes) {\\n    pBox.disabled = true;\\n  }\\n  quantileSetterDiv.text = &#x27;&#x27;;\\n}"}}]]]}}}]}},{"type":"object","name":"Spacer","id":"p4769","attributes":{"width":10}},{"id":"p4726"}]}},{"type":"object","name":"Spacer","id":"p4771","attributes":{"height":10}},{"type":"object","name":"Row","id":"p4773","attributes":{"children":[{"type":"object","name":"Column","id":"p4761","attributes":{"children":[{"type":"object","name":"Row","id":"p4759","attributes":{"children":[{"type":"object","name":"Column","id":"p4752","attributes":{"children":[{"type":"object","name":"Spacer","id":"p4751","attributes":{"height":4}},{"id":"p4720"}]}},{"id":"p4717"},{"type":"object","name":"Column","id":"p4754","attributes":{"children":[{"type":"object","name":"Spacer","id":"p4753","attributes":{"height":4}},{"id":"p4722"}]}}]}},{"type":"object","name":"Row","id":"p4760","attributes":{"children":[{"type":"object","name":"Column","id":"p4756","attributes":{"children":[{"type":"object","name":"Spacer","id":"p4755","attributes":{"height":4}},{"id":"p4721"}]}},{"id":"p4719"},{"type":"object","name":"Column","id":"p4758","attributes":{"children":[{"type":"object","name":"Spacer","id":"p4757","attributes":{"height":4}},{"id":"p4723"}]}}]}}]}},{"type":"object","name":"Spacer","id":"p4772","attributes":{"width":20}},{"type":"object","name":"Column","id":"p4750","attributes":{"children":[{"type":"object","name":"Row","id":"p4749","attributes":{"children":[{"type":"object","name":"Spacer","id":"p4741","attributes":{"width":20}},{"type":"object","name":"Column","id":"p4744","attributes":{"children":[{"type":"object","name":"Spacer","id":"p4742","attributes":{"height":7}},{"type":"object","name":"Div","id":"p4743","attributes":{"text":"&lt;p&gt;&lt;b&gt;y: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p4724"},{"type":"object","name":"Spacer","id":"p4745","attributes":{"width":16}},{"type":"object","name":"Column","id":"p4748","attributes":{"children":[{"type":"object","name":"Spacer","id":"p4746","attributes":{"height":7}},{"type":"object","name":"Div","id":"p4747","attributes":{"text":"&lt;p&gt;&lt;b&gt;quantile: &lt;/b&gt;&lt;/p&gt;"}}]}},{"id":"p4725"}]}}]}}]}},{"type":"object","name":"Spacer","id":"p4774","attributes":{"height":10}},{"type":"object","name":"GridPlot","id":"p4766","attributes":{"rows":null,"cols":null,"toolbar":{"type":"object","name":"Toolbar","id":"p4765","attributes":{"tools":[{"type":"object","name":"ToolProxy","id":"p4763","attributes":{"tools":[{"id":"p4679"},{"id":"p4655"},{"id":"p4679"},{"id":"p4655"}]}},{"type":"object","name":"SaveTool","id":"p4764"}]}},"toolbar_location":"right","children":[[{"id":"p4633"},0,0],[{"type":"object","name":"Spacer","id":"p4762","attributes":{"width":30}},0,1],[{"id":"p4657"},0,2]]}}]}}]}}';
                  const render_items = [{"docid":"a03891bc-f212-4e55-bbc7-ea844acaeb52","roots":{"p4775":"dae8ba92-eeab-44bb-b44d-4d5feef7e632"},"root_ids":["p4775"]}];
                  root.Bokeh.embed.embed_items(docs_json, render_items);
                  }
                  if (root.Bokeh !== undefined) {
                    embed_document(root);
                  } else {
                    let attempts = 0;
                    const timer = setInterval(function(root) {
                      if (root.Bokeh !== undefined) {
                        clearInterval(timer);
                        embed_document(root);
                      } else {
                        attempts++;
                        if (attempts > 100) {
                          clearInterval(timer);
                          console.log("Bokeh: ERROR: Unable to run BokehJS code because BokehJS library is missing");
                        }
                      }
                    }, 10, root)
                  }
                })(window);
              });
            };
            if (document.readyState != "loading") fn();
            else document.addEventListener("DOMContentLoaded", fn);
          })();
        },
    function(Bokeh) {
        }
      ];
    
      function run_inline_js() {
        for (let i = 0; i < inline_js.length; i++) {
          inline_js[i].call(root, root.Bokeh);
        }
      }
    
      if (root._bokeh_is_loading === 0) {
        console.debug("Bokeh: BokehJS loaded, going straight to plotting");
        run_inline_js();
      } else {
        load_libs(css_urls, js_urls, function() {
          console.debug("Bokeh: BokehJS plotting callback run at", now());
          run_inline_js();
        });
      }
    }(window));
  };
  if (document.readyState != "loading") fn();
  else document.addEventListener("DOMContentLoaded", fn);
})();